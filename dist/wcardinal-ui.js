/*
 Winter Cardinal UI v0.21.0
 Copyright (C) 2019 Toshiba Corporation
 SPDX-License-Identifier: Apache-2.0

 Material Design icons by Google
 Apache license version 2.0.
*/
(function (pixi_js) {
    'use strict';

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDeserializers = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeType;
    (function (EShapeType) {
        EShapeType[EShapeType["CIRCLE"] = 0] = "CIRCLE";
        EShapeType[EShapeType["RECTANGLE"] = 1] = "RECTANGLE";
        EShapeType[EShapeType["RECTANGLE_ROUNDED"] = 2] = "RECTANGLE_ROUNDED";
        EShapeType[EShapeType["TRIANGLE"] = 3] = "TRIANGLE";
        EShapeType[EShapeType["TRIANGLE_ROUNDED"] = 4] = "TRIANGLE_ROUNDED";
        EShapeType[EShapeType["LINE"] = 5] = "LINE";
        EShapeType[EShapeType["IMAGE"] = 6] = "IMAGE";
        EShapeType[EShapeType["IMAGE_SDF"] = 7] = "IMAGE_SDF";
        EShapeType[EShapeType["GROUP"] = 8] = "GROUP";
        EShapeType[EShapeType["BAR"] = 9] = "BAR";
        EShapeType[EShapeType["LABEL"] = 10] = "LABEL";
        EShapeType[EShapeType["NULL"] = 11] = "NULL";
        EShapeType[EShapeType["GROUP_SHADOWED"] = 12] = "GROUP_SHADOWED";
        EShapeType[EShapeType["LINE_OF_CIRCLES"] = 13] = "LINE_OF_CIRCLES";
        EShapeType[EShapeType["LINE_OF_RECTANGLES"] = 14] = "LINE_OF_RECTANGLES";
        EShapeType[EShapeType["LINE_OF_RECTANGLE_ROUNDEDS"] = 15] = "LINE_OF_RECTANGLE_ROUNDEDS";
        EShapeType[EShapeType["LINE_OF_TRIANGLES"] = 16] = "LINE_OF_TRIANGLES";
        EShapeType[EShapeType["LINE_OF_TRIANGLE_ROUNDEDS"] = 17] = "LINE_OF_TRIANGLE_ROUNDEDS";
        EShapeType[EShapeType["EXTENSION"] = 1000] = "EXTENSION";
    })(EShapeType || (EShapeType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeUploadeds = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsStyle;
    (function (EShapePointsStyle) {
        EShapePointsStyle[EShapePointsStyle["NONE"] = 0] = "NONE";
        EShapePointsStyle[EShapePointsStyle["CLOSED"] = 1] = "CLOSED";
        EShapePointsStyle[EShapePointsStyle["NON_EXPANDING_WIDTH"] = 2] = "NON_EXPANDING_WIDTH";
        EShapePointsStyle[EShapePointsStyle["NON_SHRINKING_WIDTH"] = 4] = "NON_SHRINKING_WIDTH";
        EShapePointsStyle[EShapePointsStyle["NON_SCALING_DOT_AND_DASH"] = 8] = "NON_SCALING_DOT_AND_DASH";
        EShapePointsStyle[EShapePointsStyle["DOTTED"] = 16] = "DOTTED";
        EShapePointsStyle[EShapePointsStyle["DOTTED_DENSELY"] = 32] = "DOTTED_DENSELY";
        EShapePointsStyle[EShapePointsStyle["DOTTED_LOOSELY"] = 64] = "DOTTED_LOOSELY";
        EShapePointsStyle[EShapePointsStyle["DASHED"] = 128] = "DASHED";
        EShapePointsStyle[EShapePointsStyle["DASHED_DENSELY"] = 256] = "DASHED_DENSELY";
        EShapePointsStyle[EShapePointsStyle["DASHED_LOOSELY"] = 512] = "DASHED_LOOSELY";
        EShapePointsStyle[EShapePointsStyle["DOTTED_MASK"] = 112] = "DOTTED_MASK";
        EShapePointsStyle[EShapePointsStyle["DASHED_MASK"] = 896] = "DASHED_MASK";
        EShapePointsStyle[EShapePointsStyle["NON_SOLID_MASK"] = 1008] = "NON_SOLID_MASK";
    })(EShapePointsStyle || (EShapePointsStyle = {}));

    var toDash = function (length, strokeWidth, style, result) {
        result.set(2 * length, 0);
        if (style & EShapePointsStyle.NON_SOLID_MASK) {
            if (style & EShapePointsStyle.DOTTED) {
                result.set(strokeWidth, strokeWidth);
            }
            else if (style & EShapePointsStyle.DOTTED_DENSELY) {
                result.set(strokeWidth, strokeWidth * 0.5);
            }
            else if (style & EShapePointsStyle.DOTTED_LOOSELY) {
                result.set(strokeWidth, strokeWidth * 2);
            }
            else if (style & EShapePointsStyle.DASHED) {
                result.set(strokeWidth * 2, strokeWidth);
            }
            else if (style & EShapePointsStyle.DASHED_DENSELY) {
                result.set(strokeWidth * 2, strokeWidth * 0.5);
            }
            else if (style & EShapePointsStyle.DASHED_LOOSELY) {
                result.set(strokeWidth * 2, strokeWidth * 2);
            }
        }
        return result;
    };

    var toScaleInvariant = function (style) {
        var nonExpandingWidth = (style & EShapePointsStyle.NON_EXPANDING_WIDTH ? 1 : 0);
        var nonShrinkingWidth = (style & EShapePointsStyle.NON_SHRINKING_WIDTH ? 2 : 0);
        var nonScalingDotAndDash = (style & EShapePointsStyle.NON_SCALING_DOT_AND_DASH ? 4 : 0);
        if (style & EShapePointsStyle.NON_SOLID_MASK) {
            return nonExpandingWidth | nonShrinkingWidth | nonScalingDotAndDash;
        }
        else {
            return nonExpandingWidth | nonShrinkingWidth;
        }
    };

    var BAR_VERTEX_COUNT = 4;
    var BAR_INDEX_COUNT = 2;
    var BAR_FMIN = 0.00001;
    var BAR_WORK_POINT = new pixi_js.Point();
    var buildBarClipping = function (clippings, voffset) {
        var ic = voffset * 3;
        clippings[ic + 0] = 1;
        clippings[ic + 1] = 0;
        clippings[ic + 2] = 3;
        clippings[ic + 3] = 0;
        clippings[ic + 4] = 1;
        clippings[ic + 5] = 5;
        clippings[ic + 6] = 1;
        clippings[ic + 7] = 0;
        clippings[ic + 8] = 3;
        clippings[ic + 9] = 0;
        clippings[ic + 10] = 1;
        clippings[ic + 11] = 5;
    };
    var buildBarIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3;
        indices[ii + 0] = voffset + 0;
        indices[ii + 1] = voffset + 2;
        indices[ii + 2] = voffset + 1;
        indices[ii + 3] = voffset + 1;
        indices[ii + 4] = voffset + 2;
        indices[ii + 5] = voffset + 3;
    };
    var buildBarVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, pointValues, pointsStyle, pointsSize, strokeWidth, internalTransform) {
        // First point
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var tx = internalTransform.tx;
        var ty = internalTransform.ty;
        var pv0 = pointValues[0];
        var pv1 = pointValues[1];
        var p1x = a * pv0 + c * pv1 + tx;
        var p1y = b * pv0 + d * pv1 + ty;
        // Last point
        var pv2 = pointValues[2];
        var pv3 = pointValues[3];
        var p2x = a * pv2 + c * pv3 + tx;
        var p2y = b * pv2 + d * pv3 + ty;
        // Normal
        var dx = p2x - p1x;
        var dy = p2y - p1y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        var l = distance;
        if (0 <= pointsSize && BAR_FMIN < distance) {
            var ratio = pointsSize / distance;
            dx *= ratio;
            dy *= ratio;
            p2x = p1x + dx;
            p2y = p1y + dy;
            l = pointsSize;
        }
        // Other points
        var p0x = p1x - dx;
        var p0y = p1y - dy;
        var p3x = p2x + dx;
        var p3y = p2y + dy;
        //
        var scaleInvariant = toScaleInvariant(pointsStyle);
        var iv = voffset << 1;
        var icf = voffset << 2;
        var is = voffset * 6;
        vertices[iv + 0] = p1x;
        vertices[iv + 1] = p1y;
        vertices[iv + 2] = p1x;
        vertices[iv + 3] = p1y;
        steps[is + 0] = strokeWidth;
        steps[is + 1] = scaleInvariant;
        steps[is + 2] = p0x;
        steps[is + 3] = p0y;
        steps[is + 4] = p2x;
        steps[is + 5] = p2y;
        steps[is + 6] = strokeWidth;
        steps[is + 7] = scaleInvariant;
        steps[is + 8] = p0x;
        steps[is + 9] = p0y;
        steps[is + 10] = p2x;
        steps[is + 11] = p2y;
        colorFills[icf + 0] = 0.0;
        colorFills[icf + 4] = 0.0;
        vertices[iv + 4] = p2x;
        vertices[iv + 5] = p2y;
        vertices[iv + 6] = p2x;
        vertices[iv + 7] = p2y;
        steps[is + 12] = strokeWidth;
        steps[is + 13] = scaleInvariant;
        steps[is + 14] = p1x;
        steps[is + 15] = p1y;
        steps[is + 16] = p3x;
        steps[is + 17] = p3y;
        steps[is + 18] = strokeWidth;
        steps[is + 19] = scaleInvariant;
        steps[is + 20] = p1x;
        steps[is + 21] = p1y;
        steps[is + 22] = p3x;
        steps[is + 23] = p3y;
        colorFills[icf + 8] = l;
        colorFills[icf + 12] = l;
        // Total length
        var dash = toDash(l, strokeWidth, pointsStyle, BAR_WORK_POINT);
        var dash0 = dash.x;
        var dash1 = dash.y;
        colorFills[icf + 1] = dash0;
        colorFills[icf + 2] = dash1;
        colorFills[icf + 3] = l;
        colorFills[icf + 5] = dash0;
        colorFills[icf + 6] = dash1;
        colorFills[icf + 7] = l;
        colorFills[icf + 9] = dash0;
        colorFills[icf + 10] = dash1;
        colorFills[icf + 11] = l;
        colorFills[icf + 13] = dash0;
        colorFills[icf + 14] = dash1;
        colorFills[icf + 15] = l;
    };
    var buildBarUv = function (uvs, voffset, textureUvs) {
        var iuv = voffset << 1;
        uvs[iuv + 0] = textureUvs.x0;
        uvs[iuv + 1] = textureUvs.y0;
        uvs[iuv + 2] = textureUvs.x3;
        uvs[iuv + 3] = textureUvs.y3;
        uvs[iuv + 4] = textureUvs.x1;
        uvs[iuv + 5] = textureUvs.y1;
        uvs[iuv + 6] = textureUvs.x2;
        uvs[iuv + 7] = textureUvs.y2;
    };

    var UtilCharacterIterator = /** @class */ (function () {
        function UtilCharacterIterator() {
            this._target = "";
            this._position = 0;
        }
        Object.defineProperty(UtilCharacterIterator.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this._position = position;
            },
            enumerable: true,
            configurable: true
        });
        UtilCharacterIterator.prototype.init = function (target) {
            this._target = target;
            this._position = 0;
        };
        UtilCharacterIterator.prototype.hasNext = function () {
            return this._position < this._target.length;
        };
        UtilCharacterIterator.prototype.findNextBreak = function (target, istart) {
            var iend = target.length;
            for (var i = istart; i < iend; ++i) {
                var code = target.charCodeAt(i);
                if (!this.isLowSurrogate(code) && !this.isVariationSelector(code)) {
                    return i;
                }
            }
            return iend;
        };
        UtilCharacterIterator.prototype.isHighSurrogate = function (code) {
            return (0xd800 <= code && code <= 0xdbff);
        };
        UtilCharacterIterator.prototype.isLowSurrogate = function (code) {
            return (0xdc00 <= code && code <= 0xdfff);
        };
        UtilCharacterIterator.prototype.isVariationSelector = function (code) {
            return (0xfe00 <= code && code <= 0xfe0f);
        };
        UtilCharacterIterator.prototype.next = function () {
            var target = this._target;
            var position = this._position;
            var nextBreak = this.findNextBreak(target, position + 1);
            var result = target.substring(position, nextBreak);
            this._position = nextBreak;
            return result;
        };
        /**
         * Advances the position if the next character is not equal to
         * the given `except`.
         *
         * @param except
         * @return true if the position is advanced
         */
        UtilCharacterIterator.prototype.advance = function (except) {
            var target = this._target;
            var position = this._position;
            var nextBreak = this.findNextBreak(target, position + 1);
            if (target.substring(position, nextBreak) !== except) {
                this._position = nextBreak;
                return true;
            }
            return false;
        };
        UtilCharacterIterator.from = function (target) {
            if (UtilCharacterIterator._instance == null) {
                UtilCharacterIterator._instance = new UtilCharacterIterator();
            }
            var instance = UtilCharacterIterator._instance;
            instance.init(target);
            return instance;
        };
        UtilCharacterIterator._instance = null;
        return UtilCharacterIterator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextWeight;
    (function (EShapeTextWeight) {
        EShapeTextWeight[EShapeTextWeight["NORMAL"] = 0] = "NORMAL";
        EShapeTextWeight[EShapeTextWeight["BOLD"] = 1] = "BOLD";
    })(EShapeTextWeight || (EShapeTextWeight = {}));
    var EShapeTextStyle;
    (function (EShapeTextStyle) {
        EShapeTextStyle[EShapeTextStyle["NORMAL"] = 0] = "NORMAL";
        EShapeTextStyle[EShapeTextStyle["ITALIC"] = 1] = "ITALIC";
    })(EShapeTextStyle || (EShapeTextStyle = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignHorizontal;
    (function (EShapeTextAlignHorizontal) {
        EShapeTextAlignHorizontal[EShapeTextAlignHorizontal["LEFT"] = 0] = "LEFT";
        EShapeTextAlignHorizontal[EShapeTextAlignHorizontal["CENTER"] = 1] = "CENTER";
        EShapeTextAlignHorizontal[EShapeTextAlignHorizontal["RIGHT"] = 2] = "RIGHT";
        EShapeTextAlignHorizontal[EShapeTextAlignHorizontal["OUTSIDE_LEFT"] = 3] = "OUTSIDE_LEFT";
        EShapeTextAlignHorizontal[EShapeTextAlignHorizontal["OUTSIDE_RIGHT"] = 4] = "OUTSIDE_RIGHT";
    })(EShapeTextAlignHorizontal || (EShapeTextAlignHorizontal = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignVertical;
    (function (EShapeTextAlignVertical) {
        EShapeTextAlignVertical[EShapeTextAlignVertical["TOP"] = 0] = "TOP";
        EShapeTextAlignVertical[EShapeTextAlignVertical["MIDDLE"] = 1] = "MIDDLE";
        EShapeTextAlignVertical[EShapeTextAlignVertical["BOTTOM"] = 2] = "BOTTOM";
        EShapeTextAlignVertical[EShapeTextAlignVertical["OUTSIDE_TOP"] = 3] = "OUTSIDE_TOP";
        EShapeTextAlignVertical[EShapeTextAlignVertical["OUTSIDE_BOTTOM"] = 4] = "OUTSIDE_BOTTOM";
    })(EShapeTextAlignVertical || (EShapeTextAlignVertical = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextDirection;
    (function (EShapeTextDirection) {
        EShapeTextDirection[EShapeTextDirection["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
        EShapeTextDirection[EShapeTextDirection["TOP_TO_BOTTOM"] = 1] = "TOP_TO_BOTTOM";
        EShapeTextDirection[EShapeTextDirection["BOTTOM_TO_TOP"] = 2] = "BOTTOM_TO_TOP";
    })(EShapeTextDirection || (EShapeTextDirection = {}));

    var toLength = function (p0x, p0y, p1x, p1y) {
        var dx01 = p1x - p0x;
        var dy01 = p1y - p0y;
        return Math.sqrt(dx01 * dx01 + dy01 * dy01);
    };

    var TEXT_VERTEX_COUNT = 4;
    var TEXT_INDEX_COUNT = 2;
    var TEXT_SDF_WINDOW = 12;
    var TEXT_FMIN = 0.00001;
    var TEXT_WORK_POINT = new pixi_js.Point();
    var toTextBufferCount = function (shape) {
        return Math.ceil(shape.text.value.length / 12) * 12;
    };
    var buildTextClipping = function (clippings, voffset, vcount) {
        for (var i = voffset * 3, imax = i + vcount * 3; i < imax; i += 3) {
            clippings[i + 0] = 0;
            clippings[i + 1] = 0;
            clippings[i + 2] = 2;
        }
    };
    var buildTextIndex = function (indices, voffset, ioffset, icount) {
        for (var i = 0, ii = ioffset * 3, imax = (icount >> 1); i < imax; i += 1, ii += 6) {
            var j = voffset + (i << 2);
            indices[ii + 0] = j + 0;
            indices[ii + 1] = j + 1;
            indices[ii + 2] = j + 3;
            indices[ii + 3] = j + 1;
            indices[ii + 4] = j + 2;
            indices[ii + 5] = j + 3;
        }
    };
    var buildTextStep = function (steps, voffset, vcount, textAtlas, textSize, textOutlineWidth, textWeight, antialiasWeight) {
        if (textAtlas != null) {
            var scaleBase = (0.4 / TEXT_SDF_WINDOW) * antialiasWeight;
            var scale = scaleBase * (textAtlas.font.size / textSize);
            var outlineWidth = textOutlineWidth * 0.4;
            var weight = (textWeight === EShapeTextWeight.NORMAL ? 0.0 : 0.05);
            for (var i = voffset * 6, imax = i + vcount * 6; i < imax; i += 6) {
                steps[i + 0] = scale;
                steps[i + 1] = outlineWidth;
                steps[i + 2] = weight;
                steps[i + 3] = TEXT_FMIN;
                steps[i + 4] = TEXT_FMIN;
                steps[i + 5] = TEXT_FMIN;
            }
        }
        else {
            for (var i = voffset * 6, imax = i + vcount * 6; i < imax; i += 6) {
                steps[i + 0] = 0;
                steps[i + 1] = 0;
                steps[i + 2] = TEXT_FMIN;
                steps[i + 3] = TEXT_FMIN;
                steps[i + 4] = TEXT_FMIN;
                steps[i + 5] = TEXT_FMIN;
            }
        }
    };
    var getTextBBox = function (halign, valign, hoffset, voffset, hpadding, vpadding, width, height, x0, y0, x1, y1, x2, y2, x3, y3, hnx, hny, vnx, vny, result) {
        switch (halign) {
            case EShapeTextAlignHorizontal.LEFT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x0
                            + hnx * (hoffset + hpadding)
                            + vnx * (voffset + vpadding);
                        result.y = y0
                            + hny * (hoffset + hpadding)
                            + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x = 0.5 * (x0 + x3)
                            + hnx * (hoffset + hpadding)
                            + vnx * (voffset - 0.5 * height);
                        result.y = 0.5 * (y0 + y3)
                            + hny * (hoffset + hpadding)
                            + vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x = x3
                            + hnx * (hoffset + hpadding)
                            + vnx * (voffset - vpadding - height);
                        result.y = y3
                            + hny * (hoffset + hpadding)
                            + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x = x0
                            + hnx * (hoffset + hpadding)
                            + vnx * (voffset - vpadding - height);
                        result.y = y0
                            + hny * (hoffset + hpadding)
                            + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x3
                            + hnx * (hoffset + hpadding)
                            + vnx * (voffset + vpadding);
                        result.y = y3
                            + hny * (hoffset + hpadding)
                            + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.CENTER:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = 0.5 * (x0 + x1)
                            + hnx * (hoffset - 0.5 * width)
                            + vnx * (voffset + vpadding);
                        result.y = 0.5 * (y0 + y1)
                            + hny * (hoffset - 0.5 * width)
                            + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x = 0.5 * (x0 + x2)
                            + hnx * (hoffset - 0.5 * width)
                            + vnx * (voffset - 0.5 * height);
                        result.y = 0.5 * (y0 + y2)
                            + hny * (hoffset - 0.5 * width)
                            + vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x = 0.5 * (x3 + x2)
                            + hnx * (hoffset - 0.5 * width)
                            + vnx * (voffset - vpadding - height);
                        result.y = 0.5 * (y3 + y2)
                            + hny * (hoffset - 0.5 * width)
                            + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x = 0.5 * (x0 + x1)
                            + hnx * (hoffset - 0.5 * width)
                            + vnx * (voffset - vpadding - height);
                        result.y = 0.5 * (y0 + y1)
                            + hny * (hoffset - 0.5 * width)
                            + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = 0.5 * (x3 + x2)
                            + hnx * (hoffset - 0.5 * width)
                            + vnx * (voffset + vpadding);
                        result.y = 0.5 * (y3 + y2)
                            + hny * (hoffset - 0.5 * width)
                            + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.RIGHT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x1
                            + hnx * (hoffset - hpadding - width)
                            + vnx * (voffset + vpadding);
                        result.y = y1
                            + hny * (hoffset - hpadding - width)
                            + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x = 0.5 * (x1 + x2)
                            + hnx * (hoffset - hpadding - width)
                            + vnx * (voffset - 0.5 * height);
                        result.y = 0.5 * (y1 + y2)
                            + hny * (hoffset - hpadding - width)
                            + vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x = x2
                            + hnx * (hoffset - hpadding - width)
                            + vnx * (voffset - vpadding - height);
                        result.y = y2
                            + hny * (hoffset - hpadding - width)
                            + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x = x1
                            + hnx * (hoffset - hpadding - width)
                            + vnx * (voffset - vpadding - height);
                        result.y = y1
                            + hny * (hoffset - hpadding - width)
                            + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x2
                            + hnx * (hoffset - hpadding - width)
                            + vnx * (voffset + vpadding);
                        result.y = y2
                            + hny * (hoffset - hpadding - width)
                            + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x0
                            + hnx * (hoffset - hpadding - width)
                            + vnx * (voffset + vpadding);
                        result.y = y0
                            + hny * (hoffset - hpadding - width)
                            + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x = 0.5 * (x0 + x3)
                            + hnx * (hoffset - hpadding - width)
                            + vnx * (voffset - 0.5 * height);
                        result.y = 0.5 * (y0 + y3)
                            + hny * (hoffset - hpadding - width)
                            + vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x = x3
                            + hnx * (hoffset - hpadding - width)
                            + vnx * (voffset - vpadding - height);
                        result.y = y3
                            + hny * (hoffset - hpadding - width)
                            + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x = x0
                            + hnx * (hoffset - hpadding - width)
                            + vnx * (voffset - vpadding - height);
                        result.y = y0
                            + hny * (hoffset - hpadding - width)
                            + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x3
                            + hnx * (hoffset - hpadding - width)
                            + vnx * (voffset + vpadding);
                        result.y = y3
                            + hny * (hoffset - hpadding - width)
                            + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x1
                            + hnx * (hoffset + hpadding)
                            + vnx * (voffset + vpadding);
                        result.y = y1
                            + hny * (hoffset + hpadding)
                            + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x = 0.5 * (x1 + x2)
                            + hnx * (hoffset + hpadding)
                            + vnx * (voffset - 0.5 * height);
                        result.y = 0.5 * (y1 + y2)
                            + hny * (hoffset + hpadding)
                            + vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x = x2
                            + hnx * (hoffset + hpadding)
                            + vnx * (voffset - vpadding - height);
                        result.y = y2
                            + hny * (hoffset + hpadding)
                            + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x = x1
                            + hnx * (hoffset + hpadding)
                            + vnx * (voffset - vpadding - height);
                        result.y = y1
                            + hny * (hoffset + hpadding)
                            + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x2
                            + hnx * (hoffset + hpadding)
                            + vnx * (voffset + vpadding);
                        result.y = y2
                            + hny * (hoffset + hpadding)
                            + vny * (voffset + vpadding);
                        break;
                }
                break;
        }
    };
    var toNormalized = function (dx, dy, defx, defy, result) {
        var d = dx * dx + dy * dy;
        if (TEXT_FMIN < d) {
            var l = Math.sqrt(d);
            var li = 1 / l;
            result.set(dx * li, dy * li);
            return l;
        }
        else {
            result.set(defx, defy);
            return 0;
        }
    };
    var rotateAlignHorizontalRight = function (align) {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
        }
    };
    var rotateAlignVerticalRight = function (align) {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
        }
    };
    var rotateAlignHorizontalLeft = function (align) {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
        }
    };
    var rotateAlignVerticalLeft = function (align) {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
        }
    };
    var buildTextVertex = function (vertices, uvs, voffset, vcount, originX, originY, sizeX, sizeY, textAtlas, textSize, textValue, textStyle, textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textSpacingHorizontal, textSpacingVertical, textDirection, textPaddingHorizontal, textPaddingVertical, textClipping, textWorld, textureUvs, internalTransform) {
        // Calculate the transformed positions
        //
        //  0               1
        // |---------------|
        // |               |
        // |3              |2
        // |---------------|
        //
        var sx = sizeX * 0.5;
        var sy = sizeY * 0.5;
        var work = TEXT_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX + sx, originY - sy);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        work.set(originX + sx, originY + sy);
        internalTransform.apply(work, work);
        var x2 = work.x;
        var y2 = work.y;
        var x3 = x0 + (x2 - x1);
        var y3 = y0 + (y2 - y1);
        // Horizontal normal
        var hl = toLength(x0, y0, x1, y1);
        toNormalized(internalTransform.a, internalTransform.b, 1, 0, work);
        var hnx = work.x;
        var hny = work.y;
        // Vertical normal
        var vl = toLength(x0, y0, x3, y3);
        toNormalized(internalTransform.c, internalTransform.d, 0, 1, work);
        var vnx = work.x;
        var vny = work.y;
        // Calculate the width / height
        var width = 0;
        var height = 0;
        var heightChar = 0;
        var lineHeight = Math.max(0, textSize + textSpacingVertical);
        var lineWidth = 0;
        var textAtlasCharacters = textAtlas.characters;
        var iterator = UtilCharacterIterator.from(textValue);
        var advancePrevious = 0;
        while (iterator.hasNext()) {
            var character = iterator.next();
            if (character !== "\n") {
                if (0 < advancePrevious) {
                    lineWidth += Math.max(0, advancePrevious + textSpacingHorizontal);
                }
                var data = textAtlasCharacters[character];
                if (data) {
                    advancePrevious = data.advance;
                    heightChar = data.height;
                }
                else {
                    advancePrevious = 0;
                }
            }
            else {
                lineWidth += advancePrevious;
                advancePrevious = 0;
                width = Math.max(width, lineWidth);
                lineWidth = 0;
                height += lineHeight;
            }
        }
        var scale = textSize / textAtlas.font.size;
        lineWidth += advancePrevious;
        width = Math.max(width, lineWidth) * scale;
        lineWidth = 0;
        heightChar *= scale;
        height += textSize;
        //
        var tx0 = 0;
        var ty0 = 0;
        var lineWidthMaximum = NaN;
        switch (textDirection) {
            case EShapeTextDirection.LEFT_TO_RIGHT:
                getTextBBox(textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textPaddingHorizontal, textPaddingVertical, width, height, x0, y0, x1, y1, x2, y2, x3, y3, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping) {
                    switch (textAlignHorizontal) {
                        case EShapeTextAlignHorizontal.LEFT:
                        case EShapeTextAlignHorizontal.CENTER:
                        case EShapeTextAlignHorizontal.RIGHT:
                            switch (textAlignVertical) {
                                case EShapeTextAlignVertical.TOP:
                                case EShapeTextAlignVertical.MIDDLE:
                                case EShapeTextAlignVertical.BOTTOM:
                                    lineWidthMaximum = hl - textPaddingHorizontal * 2;
                                    break;
                            }
                            break;
                    }
                }
                break;
            case EShapeTextDirection.TOP_TO_BOTTOM:
                // Swap normals
                work.set(vnx, vny);
                vnx = -hnx;
                vny = -hny;
                hnx = work.x;
                hny = work.y;
                // Get text bbox
                getTextBBox(rotateAlignVerticalRight(textAlignVertical), rotateAlignHorizontalRight(textAlignHorizontal), textOffsetVertical, textOffsetHorizontal, textPaddingVertical, textPaddingHorizontal, width, height, x1, y1, x2, y2, x3, y3, x0, y0, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping) {
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.TOP:
                        case EShapeTextAlignVertical.MIDDLE:
                        case EShapeTextAlignVertical.BOTTOM:
                            switch (textAlignHorizontal) {
                                case EShapeTextAlignHorizontal.LEFT:
                                case EShapeTextAlignHorizontal.CENTER:
                                case EShapeTextAlignHorizontal.RIGHT:
                                    lineWidthMaximum = vl - textPaddingVertical * 2;
                                    break;
                            }
                            break;
                    }
                }
                break;
            case EShapeTextDirection.BOTTOM_TO_TOP:
                // Swap normals
                work.set(vnx, vny);
                vnx = hnx;
                vny = hny;
                hnx = -work.x;
                hny = -work.y;
                // Get text bbox
                getTextBBox(rotateAlignVerticalLeft(textAlignVertical), rotateAlignHorizontalLeft(textAlignHorizontal), textOffsetVertical, textOffsetHorizontal, textPaddingVertical, textPaddingHorizontal, width, height, x3, y3, x0, y0, x1, y1, x2, y2, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping) {
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.TOP:
                        case EShapeTextAlignVertical.MIDDLE:
                        case EShapeTextAlignVertical.BOTTOM:
                            switch (textAlignHorizontal) {
                                case EShapeTextAlignHorizontal.LEFT:
                                case EShapeTextAlignHorizontal.CENTER:
                                case EShapeTextAlignHorizontal.RIGHT:
                                    lineWidthMaximum = vl - textPaddingVertical * 2;
                                    break;
                            }
                            break;
                    }
                }
                break;
        }
        //
        if (lineWidthMaximum < width) {
            var dwidth = (width - lineWidthMaximum) * 0.5;
            textWorld[0] = tx0 + hnx * dwidth;
            textWorld[1] = ty0 + hny * dwidth;
            textWorld[2] = hnx;
            textWorld[3] = hny;
            textWorld[4] = vnx;
            textWorld[5] = vny;
            textWorld[6] = lineWidthMaximum;
            textWorld[7] = height;
        }
        else {
            textWorld[0] = tx0;
            textWorld[1] = ty0;
            textWorld[2] = hnx;
            textWorld[3] = hny;
            textWorld[4] = vnx;
            textWorld[5] = vny;
            textWorld[6] = width;
            textWorld[7] = height;
        }
        // Texture
        var uvx0 = textureUvs.x0;
        var uvx1 = textureUvs.x1;
        var uvx3 = textureUvs.x3;
        var uvy0 = textureUvs.y0;
        var uvy1 = textureUvs.y1;
        var uvy3 = textureUvs.y3;
        var duvx01 = (uvx1 - uvx0);
        var duvy01 = (uvy1 - uvy0);
        var duvx03 = (uvx3 - uvx0);
        var duvy03 = (uvy3 - uvy0);
        // Vertices & UVs
        var lhx = lineHeight * vnx;
        var lhy = lineHeight * vny;
        var snx = scale * hnx;
        var sny = scale * hny;
        var offsetY = (heightChar - textSize) * 0.5;
        var oyx = offsetY * vnx;
        var oyy = offsetY * vny;
        var offsetItalic = (textStyle === EShapeTextStyle.NORMAL ? 0 : textSize * 0.25);
        var bx0 = tx0 - oyx + offsetItalic * snx;
        var by0 = ty0 - oyy + offsetItalic * sny;
        var bx3 = tx0 + oyx + textSize * vnx;
        var by3 = ty0 + oyy + textSize * vny;
        var cx0 = bx0;
        var cy0 = by0;
        var cx3 = bx3;
        var cy3 = by3;
        lineWidth = 0;
        advancePrevious = 0;
        iterator.position = 0;
        var lineCount = 0;
        var iv = voffset * 2;
        for (; iterator.hasNext(); iv += 8) {
            var character = iterator.next();
            if (character !== "\n") {
                var lineWidthPrevious = lineWidth;
                if (0 < advancePrevious) {
                    lineWidth += Math.max(0, advancePrevious + textSpacingHorizontal);
                }
                var ax = lineWidth * snx;
                var ay = lineWidth * sny;
                cx0 = bx0 + ax;
                cy0 = by0 + ay;
                cx3 = bx3 + ax;
                cy3 = by3 + ay;
                var data = textAtlasCharacters[character];
                lineCount += 1;
                if (data) {
                    var advance = data.advance;
                    if (lineWidthMaximum < (lineWidth + advance) * scale) {
                        var dots = textAtlasCharacters["..."];
                        if (dots) {
                            if (1 < lineCount && lineWidthMaximum < (lineWidth + dots.advance) * scale) {
                                lineWidth = lineWidthPrevious;
                                iv -= 8;
                                lineCount -= 1;
                                var bx = lineWidth * snx;
                                var by = lineWidth * sny;
                                cx0 = bx0 + bx;
                                cy0 = by0 + by;
                                cx3 = bx3 + bx;
                                cy3 = by3 + by;
                            }
                            advancePrevious = dots.advance;
                            writeCharacter(vertices, uvs, iv, dots, textAtlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0);
                            for (iv += 8; true; iv += 8) {
                                if (iterator.hasNext() && iterator.advance("\n")) {
                                    writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                                    lineCount += 1;
                                }
                                else {
                                    iv -= 8;
                                    break;
                                }
                            }
                        }
                        else {
                            advancePrevious = advance;
                            writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                        }
                    }
                    else {
                        advancePrevious = advance;
                        writeCharacter(vertices, uvs, iv, data, textAtlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0);
                    }
                }
                else {
                    advancePrevious = 0;
                    writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                }
            }
            else {
                lineWidth += advancePrevious;
                advancePrevious = 0;
                bx0 += lhx;
                by0 += lhy;
                bx3 += lhx;
                by3 += lhy;
                cx0 = bx0;
                cy0 = by0;
                cx3 = bx3;
                cy3 = by3;
                writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                adjustTextAlignment(vertices, hnx, hny, lineCount, iv, width - lineWidth * scale, textDirection, textAlignHorizontal, textAlignVertical);
                lineWidth = 0;
                lineCount = 0;
            }
        }
        lineWidth += advancePrevious;
        adjustTextAlignment(vertices, hnx, hny, lineCount, iv, width - lineWidth * scale, textDirection, textAlignHorizontal, textAlignVertical);
        for (var ivmax = (voffset + vcount) * 2; iv < ivmax; iv += 2) {
            vertices[iv + 0] = tx0;
            vertices[iv + 1] = ty0;
            uvs[iv + 0] = uvx0;
            uvs[iv + 1] = uvy0;
        }
    };
    var writeCharacterEmpty = function (vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3) {
        vertices[iv + 0] = cx0;
        vertices[iv + 1] = cy0;
        vertices[iv + 2] = cx0;
        vertices[iv + 3] = cy0;
        vertices[iv + 4] = cx3;
        vertices[iv + 5] = cy3;
        vertices[iv + 6] = cx3;
        vertices[iv + 7] = cy3;
        uvs[iv + 0] = uvx0;
        uvs[iv + 1] = uvy0;
        uvs[iv + 2] = uvx0;
        uvs[iv + 3] = uvy0;
        uvs[iv + 4] = uvx3;
        uvs[iv + 5] = uvy3;
        uvs[iv + 6] = uvx3;
        uvs[iv + 7] = uvy3;
    };
    var writeCharacter = function (vertices, uvs, iv, data, atlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0) {
        // Vertices
        var dataOffsetX = data.x - data.origin.x;
        var dataWidth = data.width;
        var dx0 = dataOffsetX * snx;
        var dy0 = dataOffsetX * sny;
        var dx1 = (dataOffsetX + dataWidth) * snx;
        var dy1 = (dataOffsetX + dataWidth) * sny;
        vertices[iv + 0] = cx0 + dx0;
        vertices[iv + 1] = cy0 + dy0;
        vertices[iv + 2] = cx0 + dx1;
        vertices[iv + 3] = cy0 + dy1;
        vertices[iv + 4] = cx3 + dx1;
        vertices[iv + 5] = cy3 + dy1;
        vertices[iv + 6] = cx3 + dx0;
        vertices[iv + 7] = cy3 + dy0;
        // UVs
        var px0 = data.x / atlas.width;
        var py0 = data.y / atlas.height;
        var px1 = (data.x + data.width) / atlas.width;
        var py1 = (data.y + data.height) / atlas.height;
        var dux0 = duvx01 * px0;
        var duy0 = duvy01 * px0;
        var dux1 = duvx01 * px1;
        var duy1 = duvy01 * px1;
        var dvx0 = duvx03 * py0;
        var dvy0 = duvy03 * py0;
        var dvx1 = duvx03 * py1;
        var dvy1 = duvy03 * py1;
        uvs[iv + 0] = uvx0 + dux0 + dvx0;
        uvs[iv + 1] = uvy0 + duy0 + dvy0;
        uvs[iv + 2] = uvx0 + dux1 + dvx0;
        uvs[iv + 3] = uvy0 + duy1 + dvy0;
        uvs[iv + 4] = uvx0 + dux1 + dvx1;
        uvs[iv + 5] = uvy0 + duy1 + dvy1;
        uvs[iv + 6] = uvx0 + dux0 + dvx1;
        uvs[iv + 7] = uvy0 + duy0 + dvy1;
    };
    var moveText = function (vertices, vertexIndex, textCount, dx, dy) {
        for (var i = 0, iv = vertexIndex - 8 * textCount; i < textCount; i += 1, iv += 8) {
            vertices[iv + 0] += dx;
            vertices[iv + 1] += dy;
            vertices[iv + 2] += dx;
            vertices[iv + 3] += dy;
            vertices[iv + 4] += dx;
            vertices[iv + 5] += dy;
            vertices[iv + 6] += dx;
            vertices[iv + 7] += dy;
        }
    };
    var moveTextHalf = function (vertices, vertexIndex, textCount, offset, nx, ny) {
        offset *= 0.5;
        moveText(vertices, vertexIndex, textCount, offset * nx, offset * ny);
    };
    var moveTextFull = function (vertices, vertexIndex, textCount, offset, nx, ny) {
        moveText(vertices, vertexIndex, textCount, offset * nx, offset * ny);
    };
    var adjustTextAlignment = function (vertices, nx, ny, lineCount, vertexIndex, offset, textDirection, textAlignHorizontal, textAlignVertical) {
        if (TEXT_FMIN < offset) {
            switch (textDirection) {
                case EShapeTextDirection.LEFT_TO_RIGHT:
                    switch (textAlignHorizontal) {
                        case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                        case EShapeTextAlignHorizontal.LEFT:
                            // DO NOTHING
                            break;
                        case EShapeTextAlignHorizontal.CENTER:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                        case EShapeTextAlignHorizontal.RIGHT:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                    }
                    break;
                case EShapeTextDirection.TOP_TO_BOTTOM:
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        case EShapeTextAlignVertical.TOP:
                            // DO NOTHING
                            break;
                        case EShapeTextAlignVertical.MIDDLE:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.OUTSIDE_TOP:
                        case EShapeTextAlignVertical.BOTTOM:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                    }
                    break;
                case EShapeTextDirection.BOTTOM_TO_TOP:
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        case EShapeTextAlignVertical.TOP:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.MIDDLE:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.OUTSIDE_TOP:
                        case EShapeTextAlignVertical.BOTTOM:
                            // DO NOTHING
                            break;
                    }
                    break;
            }
        }
    };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBarPosition;
    (function (EShapeBarPosition) {
        EShapeBarPosition[EShapeBarPosition["TOP"] = 0] = "TOP";
        EShapeBarPosition[EShapeBarPosition["LEFT"] = 1] = "LEFT";
        EShapeBarPosition[EShapeBarPosition["RIGHT"] = 2] = "RIGHT";
        EShapeBarPosition[EShapeBarPosition["BOTTOM"] = 3] = "BOTTOM";
    })(EShapeBarPosition || (EShapeBarPosition = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBarPoints = /** @class */ (function () {
        function EShapeBarPoints(parent, position, size, style) {
            this._parent = parent;
            this._id = 0;
            this._values = [0, 0, 0, 0];
            this._segments = [];
            this._style = style;
            this._size = size;
            this._position = position;
            this._updatedSize = NaN;
            this._updatedParentSizeX = NaN;
            this._updatedParentSizeY = NaN;
            this._updatedPosition = NaN;
        }
        EShapeBarPoints.prototype.getComputedSize = function (size, position, sizeX, sizeY) {
            if (0 <= size) {
                return size;
            }
            else {
                switch (position) {
                    case EShapeBarPosition.TOP:
                    case EShapeBarPosition.BOTTOM:
                        return Math.abs(sizeY);
                    case EShapeBarPosition.RIGHT:
                    case EShapeBarPosition.LEFT:
                        return Math.abs(sizeX);
                }
                return 0;
            }
        };
        EShapeBarPoints.prototype.update = function () {
            var parentSize = this._parent.size;
            var parentSizeX = parentSize.x;
            var parentSizeY = parentSize.y;
            var position = this._position;
            var size = this._size;
            if (this._updatedSize !== size || this._updatedParentSizeX !== parentSizeX ||
                this._updatedParentSizeY !== parentSizeY || this._updatedPosition !== position) {
                this._id += 1;
                this._updatedSize = size;
                this._updatedParentSizeX = parentSizeX;
                this._updatedParentSizeY = parentSizeY;
                this._updatedPosition = position;
                var psxh = parentSizeX * 0.5;
                var psyh = parentSizeY * 0.5;
                var computedSize = this.getComputedSize(size, position, parentSizeX, parentSizeY);
                var values = this._values;
                switch (position) {
                    case EShapeBarPosition.TOP:
                        values[0] = 0;
                        values[1] = -psyh;
                        values[2] = 0;
                        values[3] = -psyh + computedSize;
                        break;
                    case EShapeBarPosition.RIGHT:
                        values[0] = psxh;
                        values[1] = 0;
                        values[2] = psxh - computedSize;
                        values[3] = 0;
                        break;
                    case EShapeBarPosition.BOTTOM:
                        values[0] = 0;
                        values[1] = psyh;
                        values[2] = 0;
                        values[3] = psyh - computedSize;
                        break;
                    case EShapeBarPosition.LEFT:
                        values[0] = -psxh;
                        values[1] = 0;
                        values[2] = -psxh + computedSize;
                        values[3] = 0;
                        break;
                }
            }
        };
        Object.defineProperty(EShapeBarPoints.prototype, "length", {
            get: function () {
                return 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "id", {
            get: function () {
                this.update();
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "values", {
            get: function () {
                this.update();
                return this._values;
            },
            set: function (values) {
                // SUPPOSED NOT TO BE CALLED
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            set: function (segments) {
                // SUPPOSED NOT TO BE CALLED
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                this.moveTo(undefined, size, undefined);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this.moveTo(position, undefined, undefined);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                this.moveTo(undefined, undefined, style);
            },
            enumerable: true,
            configurable: true
        });
        EShapeBarPoints.prototype.copy = function (source) {
            if (source instanceof EShapeBarPoints) {
                return this.moveTo(source.position, source.size, source.style);
            }
            else {
                return this.moveTo(undefined, undefined, source.style);
            }
        };
        EShapeBarPoints.prototype.set = function (newValues, newSegments, newStyle) {
            var newPosition;
            var newSize;
            if (newValues != null) {
                var x0 = newValues[0];
                if (x0 === 0) {
                    var y0 = newValues[1];
                    newPosition = (y0 <= 0 ? EShapeBarPosition.TOP : EShapeBarPosition.BOTTOM);
                    newSize = Math.abs(newValues[3] - y0);
                }
                else {
                    newPosition = (x0 <= 0 ? EShapeBarPosition.LEFT : EShapeBarPosition.RIGHT);
                    newSize = Math.abs(newValues[2] - x0);
                }
            }
            return this.moveTo(newPosition, newSize, newStyle);
        };
        EShapeBarPoints.prototype.moveTo = function (position, size, style) {
            var isChanged = false;
            if (style != null && this._style !== style) {
                this._style = style;
                isChanged = true;
            }
            if (position != null && this._position !== position) {
                this._position = position;
                isChanged = true;
            }
            if (size != null && this._size !== size) {
                this._size = size;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeBarPoints.prototype.clone = function (parent) {
            return new EShapeBarPoints(parent, this._position, this._size, this._style);
        };
        EShapeBarPoints.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeBarPoints.prototype.serialize = function (manager) {
            return manager.add("[" + this._position + "," + this._size + "," + this._style + "]");
        };
        EShapeBarPoints.prototype.deserialize = function (resourceId, manager) {
            if (0 <= resourceId && resourceId < manager.resources.length) {
                var resource = manager.resources[resourceId];
                var parsed = JSON.parse(resource);
                this.moveTo(parsed[0], parsed[1], parsed[2]);
            }
        };
        EShapeBarPoints.prototype.calcHitPointAbs = function (x, y, ax, ay, threshold, range, tester, result) {
            var length = this.length;
            if (2 <= length) {
                var values = this._values;
                var v0x = values[0];
                var v0y = values[1];
                var v1x = values[2];
                var v1y = values[3];
                if (tester(x, y, v0x, v0y, v1x, v1y, 0, threshold, result)) {
                    return true;
                }
            }
            return false;
        };
        return EShapeBarPoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DApplications = /** @class */ (function () {
        function DApplications() {
        }
        DApplications.add = function (instance) {
            var instances = DApplications.INSTANCES;
            instances.push(instance);
        };
        DApplications.first = function () {
            var instances = DApplications.INSTANCES;
            if (0 < instances.length) {
                return instances[0];
            }
            throw new Error("No application found.");
        };
        DApplications.last = function () {
            var instances = DApplications.INSTANCES;
            if (0 < instances.length) {
                return instances[instances.length - 1];
            }
            throw new Error("No application found.");
        };
        DApplications.get = function (index) {
            var instances = DApplications.INSTANCES;
            if (0 <= index && index < instances.length) {
                return instances[index];
            }
            return null;
        };
        DApplications.indexOf = function (instance) {
            return DApplications.INSTANCES.indexOf(instance);
        };
        DApplications.size = function () {
            return DApplications.INSTANCES.length;
        };
        DApplications.toStage = function (target) {
            var stage = target;
            while (stage.parent) {
                stage = stage.parent;
            }
            if (("application" in stage) && ("layer" in stage)) {
                return stage;
            }
            return null;
        };
        DApplications.find = function (target) {
            var stage = this.toStage(target);
            if (stage) {
                return stage.layer.application;
            }
            return null;
        };
        DApplications.getLayerBase = function (target) {
            var stage = this.toStage(target);
            if (stage) {
                return stage.layer.application.getLayerBase();
            }
            return null;
        };
        DApplications.getLayerOverlay = function (target) {
            var stage = this.toStage(target);
            if (stage) {
                return stage.layer.application.getLayerOverlay();
            }
            return null;
        };
        DApplications.getLayer = function (target) {
            var stage = this.toStage(target);
            if (stage) {
                return stage.layer;
            }
            return null;
        };
        DApplications.update = function (target) {
            if (target) {
                var stage = this.toStage(target);
                if (stage) {
                    stage.layer.update();
                }
            }
            else {
                var instances = DApplications.INSTANCES;
                for (var i = 0, imax = instances.length; i < imax; ++i) {
                    instances[i].update();
                }
            }
        };
        DApplications.render = function (target) {
            if (target) {
                var stage = this.toStage(target);
                if (stage) {
                    stage.layer.render();
                }
            }
            else {
                var instances = DApplications.INSTANCES;
                for (var i = 0, imax = instances.length; i < imax; ++i) {
                    instances[i].render();
                }
            }
        };
        DApplications.INSTANCES = [];
        return DApplications;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseState;
    (function (DBaseState) {
        DBaseState[DBaseState["NONE"] = 0] = "NONE";
        DBaseState[DBaseState["HOVERED"] = 1] = "HOVERED";
        DBaseState[DBaseState["ACTIVE"] = 2] = "ACTIVE";
        DBaseState[DBaseState["ACTIVE_IN"] = 4] = "ACTIVE_IN";
        DBaseState[DBaseState["FOCUSED"] = 8] = "FOCUSED";
        DBaseState[DBaseState["FOCUSED_IN"] = 16] = "FOCUSED_IN";
        DBaseState[DBaseState["UNFOCUSABLE"] = 32] = "UNFOCUSABLE";
        DBaseState[DBaseState["FOCUS_ROOT"] = 64] = "FOCUS_ROOT";
        DBaseState[DBaseState["READ_ONLY"] = 128] = "READ_ONLY";
        DBaseState[DBaseState["DISABLED"] = 256] = "DISABLED";
        DBaseState[DBaseState["DRAGGING"] = 512] = "DRAGGING";
        DBaseState[DBaseState["PRESSED"] = 1024] = "PRESSED";
        DBaseState[DBaseState["INVALID"] = 2048] = "INVALID";
        DBaseState[DBaseState["SUCCEEDED"] = 4096] = "SUCCEEDED";
        DBaseState[DBaseState["FAILED"] = 8192] = "FAILED";
        DBaseState[DBaseState["CUSTOM"] = 1048576] = "CUSTOM";
    })(DBaseState || (DBaseState = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAction = /** @class */ (function () {
        function EShapeAction() {
            this.values = [];
        }
        EShapeAction.prototype.add = function (value, index) {
            var values = this.values;
            if (index != null) {
                values.splice(index, 0, value);
            }
            else {
                values.push(value);
            }
        };
        EShapeAction.prototype.addAll = function (values) {
            var sources = values;
            var destinations = this.values;
            for (var i = 0, imax = sources.length; i < imax; ++i) {
                destinations.push(sources[i]);
            }
        };
        EShapeAction.prototype.indexOf = function (target) {
            var values = this.values;
            // Instance-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value.isEquals(target)) {
                    return i;
                }
            }
            return -1;
        };
        EShapeAction.prototype.get = function (index) {
            var result = this.values[index];
            if (result != null) {
                return result;
            }
            return null;
        };
        EShapeAction.prototype.set = function (index, value) {
            this.values[index] = value;
        };
        EShapeAction.prototype.remove = function (index) {
            this.values.splice(index, 1);
        };
        EShapeAction.prototype.clear = function () {
            this.values.length = 0;
        };
        EShapeAction.prototype.size = function () {
            return this.values.length;
        };
        EShapeAction.prototype.swap = function (indexA, indexB) {
            var values = this.values;
            var tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
        };
        EShapeAction.prototype.serialize = function (manager) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                result.push(values[i].serialize(manager));
            }
            return result;
        };
        return EShapeAction;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCopyPart;
    (function (EShapeCopyPart) {
        EShapeCopyPart[EShapeCopyPart["NONE"] = 0] = "NONE";
        EShapeCopyPart[EShapeCopyPart["TRANSFORM"] = 1] = "TRANSFORM";
        EShapeCopyPart[EShapeCopyPart["SIZE"] = 2] = "SIZE";
        EShapeCopyPart[EShapeCopyPart["STYLE"] = 4] = "STYLE";
        EShapeCopyPart[EShapeCopyPart["ACTION"] = 8] = "ACTION";
        EShapeCopyPart[EShapeCopyPart["POINTS"] = 16] = "POINTS";
        EShapeCopyPart[EShapeCopyPart["STATE"] = 32] = "STATE";
        EShapeCopyPart[EShapeCopyPart["ALL"] = 63] = "ALL";
    })(EShapeCopyPart || (EShapeCopyPart = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isString = function (target) {
        return (typeof target === "string") ||
            (Object.prototype.toString.call(target) === "[object String]");
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var setShortcutKeyAndWhich = function (shortcut) {
        var key = shortcut.key;
        if (key.length <= 1) {
            if (shortcut.shift) {
                shortcut.key = key.toUpperCase();
            }
            var code = key.charCodeAt(0);
            if (97 <= code && code <= 122) {
                // a ... z
                shortcut.which = code - 32;
            }
            else {
                shortcut.which = code;
            }
        }
        else {
            switch (key) {
                case "Enter":
                    shortcut.which = 13;
                    break;
                case "Space":
                    shortcut.key = " ";
                    shortcut.which = 32;
                    break;
                case "Escape":
                    shortcut.which = 27;
                    break;
                case "F1":
                    shortcut.which = 112;
                    break;
                case "F2":
                    shortcut.which = 113;
                    break;
                case "F3":
                    shortcut.which = 114;
                    break;
                case "F4":
                    shortcut.which = 115;
                    break;
                case "F5":
                    shortcut.which = 116;
                    break;
                case "F6":
                    shortcut.which = 117;
                    break;
                case "F7":
                    shortcut.which = 118;
                    break;
                case "F8":
                    shortcut.which = 119;
                    break;
                case "F9":
                    shortcut.which = 120;
                    break;
                case "F10":
                    shortcut.which = 121;
                    break;
                case "F11":
                    shortcut.which = 122;
                    break;
                case "F12":
                    shortcut.which = 123;
                    break;
                case "CapsLock":
                    if (shortcut.shift) {
                        shortcut.which = 20;
                    }
                    else {
                        shortcut.which = 240;
                    }
                    break;
                case "ArrowUp":
                    shortcut.which = 38;
                    break;
                case "ArrowDown":
                    shortcut.which = 40;
                    break;
                case "ArrowLeft":
                    shortcut.which = 37;
                    break;
                case "ArrowRight":
                    shortcut.which = 39;
                    break;
                case "Insert":
                    shortcut.which = 45;
                    break;
                case "Delete":
                    shortcut.which = 46;
                    break;
                case "PageUp":
                    shortcut.which = 33;
                    break;
                case "PageDown":
                    shortcut.which = 34;
                    break;
                case "Backspace":
                    shortcut.which = 8;
                    break;
                case ";":
                    shortcut.which = 187;
                    break;
                case "Pause":
                    shortcut.which = 19;
                    break;
                case "ScrollLock":
                    shortcut.which = 145;
                    break;
                case "Tab":
                    shortcut.which = 9;
                    break;
            }
        }
        return shortcut;
    };
    var UtilKeyboardEvent = /** @class */ (function () {
        function UtilKeyboardEvent() {
        }
        UtilKeyboardEvent.isActivateKey = function (e) {
            return (e.key === "Space" || e.key === "Enter" || e.which === 32 || e.which === 13);
        };
        UtilKeyboardEvent.isArrowUpKey = function (e) {
            return (e.key === "ArrowUp" || e.which === 38);
        };
        UtilKeyboardEvent.isArrowDownKey = function (e) {
            return (e.key === "ArrowDown" || e.which === 40);
        };
        UtilKeyboardEvent.isArrowLeftKey = function (e) {
            return (e.key === "ArrowLeft" || e.which === 37);
        };
        UtilKeyboardEvent.isArrowRightKey = function (e) {
            return (e.key === "ArrowRight" || e.which === 39);
        };
        UtilKeyboardEvent.isCancelKey = function (e) {
            return (e.key === "Esc" || e.which === 27);
        };
        UtilKeyboardEvent.isFocusKey = function (e) {
            return (e.key === "Tab" || e.which === 9);
        };
        UtilKeyboardEvent.isUndoKey = function (e) {
            return (e.ctrlKey && (e.key === "z" || e.which === 90));
        };
        UtilKeyboardEvent.isRedoKey = function (e) {
            return (e.ctrlKey && (e.key === "y" || e.which === 89));
        };
        UtilKeyboardEvent.isSaveKey = function (e) {
            return (e.ctrlKey && !e.shiftKey && (e.key === "s" || e.which === 83));
        };
        UtilKeyboardEvent.isSaveAsKey = function (e) {
            return (e.ctrlKey && e.shiftKey && (e.key === "S" || e.which === 83));
        };
        UtilKeyboardEvent.isDeleteKey = function (e) {
            return (e.key === "Delete" || e.which === 46);
        };
        UtilKeyboardEvent.isSelectAllKey = function (e) {
            return (e.ctrlKey && !e.shiftKey && (e.key === "a" || e.which === 65));
        };
        UtilKeyboardEvent.isOkKey = function (e) {
            return (e.key === "Enter" || e.which === 13);
        };
        UtilKeyboardEvent.getFocusDirection = function (e) {
            return (e.shiftKey !== true);
        };
        UtilKeyboardEvent.toShortcut = function (expressionOrShortcut) {
            if (!isString(expressionOrShortcut)) {
                return expressionOrShortcut;
            }
            else {
                var expression = expressionOrShortcut;
                var arrowIndex = expression.indexOf("->");
                var keyExpression = void 0;
                var event_1;
                if (0 <= arrowIndex) {
                    keyExpression = expression.substring(0, arrowIndex).trim();
                    event_1 = expression.substring(arrowIndex + 2).trim();
                }
                else {
                    keyExpression = expression.trim();
                }
                var keys = keyExpression.toLowerCase().split("+");
                var alt = 0 <= keys.indexOf("alt");
                var ctrl = 0 <= keys.indexOf("ctrl");
                var shift = 0 <= keys.indexOf("shift");
                var key = keys[keys.length - 1];
                return setShortcutKeyAndWhich({
                    alt: alt,
                    ctrl: ctrl,
                    shift: shift,
                    key: key,
                    which: 0,
                    event: event_1
                });
            }
        };
        UtilKeyboardEvent.toString = function (shortcut) {
            var parts = [];
            if (shortcut.ctrl) {
                parts.push("Ctrl");
            }
            if (shortcut.shift) {
                parts.push("Shift");
            }
            if (shortcut.alt) {
                parts.push("Alt");
            }
            parts.push(shortcut.key.toUpperCase());
            return parts.join("+");
        };
        UtilKeyboardEvent.on = function (target, expressionOrShortcut, handler) {
            var shortcut = this.toShortcut(expressionOrShortcut);
            document.body.addEventListener("keydown", function (e) {
                if (e.altKey === shortcut.alt && e.ctrlKey === shortcut.ctrl &&
                    e.shiftKey === shortcut.shift &&
                    (e.key === shortcut.key || e.which === shortcut.which)) {
                    if (target.isActionable()) {
                        if (shortcut.event != null) {
                            target.emit(shortcut.event);
                        }
                        else if (handler != null) {
                            handler(e);
                        }
                    }
                    e.preventDefault();
                }
            });
        };
        return UtilKeyboardEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRuntimeReset;
    (function (EShapeRuntimeReset) {
        EShapeRuntimeReset[EShapeRuntimeReset["NONE"] = 0] = "NONE";
        EShapeRuntimeReset[EShapeRuntimeReset["POSITION_X"] = 1] = "POSITION_X";
        EShapeRuntimeReset[EShapeRuntimeReset["POSITION_Y"] = 2] = "POSITION_Y";
        EShapeRuntimeReset[EShapeRuntimeReset["POSITION"] = 3] = "POSITION";
        EShapeRuntimeReset[EShapeRuntimeReset["ROTATION"] = 4] = "ROTATION";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR_FILL"] = 8] = "COLOR_FILL";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR_STROKE"] = 16] = "COLOR_STROKE";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR_FILL_AND_STROKE"] = 24] = "COLOR_FILL_AND_STROKE";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR_TEXT"] = 32] = "COLOR_TEXT";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR_TEXT_OUTLINE"] = 64] = "COLOR_TEXT_OUTLINE";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR"] = 120] = "COLOR";
        EShapeRuntimeReset[EShapeRuntimeReset["VISIBILITY"] = 128] = "VISIBILITY";
        EShapeRuntimeReset[EShapeRuntimeReset["HEIGHT"] = 256] = "HEIGHT";
        EShapeRuntimeReset[EShapeRuntimeReset["WIDTH"] = 512] = "WIDTH";
        EShapeRuntimeReset[EShapeRuntimeReset["SIZE"] = 768] = "SIZE";
        EShapeRuntimeReset[EShapeRuntimeReset["TEXT"] = 1024] = "TEXT";
        EShapeRuntimeReset[EShapeRuntimeReset["CURSOR"] = 2048] = "CURSOR";
    })(EShapeRuntimeReset || (EShapeRuntimeReset = {}));
    var EShapeRuntimeState;
    (function (EShapeRuntimeState) {
        EShapeRuntimeState[EShapeRuntimeState["NONE"] = 0] = "NONE";
        EShapeRuntimeState[EShapeRuntimeState["CHANGED"] = 1] = "CHANGED";
        EShapeRuntimeState[EShapeRuntimeState["CLICKED"] = 2] = "CLICKED";
        EShapeRuntimeState[EShapeRuntimeState["DOWN"] = 4] = "DOWN";
        EShapeRuntimeState[EShapeRuntimeState["UP"] = 8] = "UP";
        EShapeRuntimeState[EShapeRuntimeState["PRESSED"] = 16] = "PRESSED";
        EShapeRuntimeState[EShapeRuntimeState["PERSISTENT"] = 16] = "PERSISTENT";
    })(EShapeRuntimeState || (EShapeRuntimeState = {}));
    var EShapeRuntime = /** @class */ (function () {
        function EShapeRuntime(shape) {
            var transform = shape.transform;
            var position = transform.position;
            this.x = position.x;
            this.y = position.y;
            this.size = new pixi_js.Point(shape.size.x, shape.size.y);
            this.rotation = transform.rotation;
            this.actions = [];
            this.fill = shape.fill.toObject();
            this.stroke = shape.stroke.toObject();
            this.text = shape.text.toObject();
            this.cursor = shape.cursor;
            this.reset = EShapeRuntimeReset.NONE;
            this.written = EShapeRuntimeReset.NONE;
            this.effect = NaN;
            this.state = EShapeRuntimeState.NONE;
            this.interactive = false;
        }
        EShapeRuntime.prototype.onPointerClick = function (shape, e) {
            if (!shape.disabled) {
                if (!(this.state & EShapeRuntimeState.CLICKED)) {
                    this.state |= EShapeRuntimeState.CHANGED | EShapeRuntimeState.CLICKED;
                    DApplications.update(shape);
                }
            }
        };
        EShapeRuntime.prototype.onPointerDblClick = function (shape, e) {
            return false;
        };
        EShapeRuntime.prototype.onPointerOver = function (shape, e) {
            shape.hovered = true;
        };
        EShapeRuntime.prototype.onPointerOut = function (shape, e) {
            shape.hovered = false;
        };
        EShapeRuntime.prototype.onPointerDown = function (shape, e) {
            var layer = DApplications.getLayer(shape);
            if (!(this.state & EShapeRuntimeState.DOWN)) {
                this.state |= EShapeRuntimeState.CHANGED | EShapeRuntimeState.DOWN | EShapeRuntimeState.PRESSED;
                if (layer) {
                    layer.update();
                }
            }
            if (layer) {
                var focusController = layer.getFocusController();
                focusController.setFocused(focusController.findFocusableParent(shape), true, true);
            }
        };
        EShapeRuntime.prototype.onPointerUp = function (shape, e) {
            if (!(this.state & EShapeRuntimeState.UP)) {
                this.state |= EShapeRuntimeState.CHANGED | EShapeRuntimeState.UP;
                this.state &= ~EShapeRuntimeState.PRESSED;
                DApplications.update(shape);
            }
        };
        EShapeRuntime.prototype.onPointerMove = function (shape, e) {
            //
        };
        EShapeRuntime.prototype.onKeyDown = function (shape, e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onPointerDown(shape);
            }
            return false;
        };
        EShapeRuntime.prototype.onKeyUp = function (shape, e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onPointerUp(shape);
                this.onPointerClick(shape);
            }
            return false;
        };
        EShapeRuntime.prototype.onStateChange = function (shape, newState, oldState) {
            this.state |= EShapeRuntimeState.CHANGED;
            DApplications.update(shape);
        };
        EShapeRuntime.prototype.update = function (shape, time) {
            var tag = shape.tag;
            var isEffectTimeUp = (this.effect <= time);
            if (tag.isChanged || (this.state & EShapeRuntimeState.CHANGED) || isEffectTimeUp) {
                if (isEffectTimeUp) {
                    this.effect = NaN;
                }
                shape.disallowUploadedUpdate();
                this.onUpdate(shape, time);
                shape.allowUploadedUpdate();
                this.state &= EShapeRuntimeState.PERSISTENT;
                tag.isChanged = false;
            }
        };
        EShapeRuntime.prototype.onUpdate = function (shape, time) {
            if (0 < this.actions.length) {
                this.executeActions(shape, time);
                this.resetUnwrittenProperties(shape);
            }
        };
        EShapeRuntime.prototype.executeActions = function (shape, time) {
            this.written = EShapeRuntimeReset.NONE;
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].execute(shape, this, time);
            }
        };
        EShapeRuntime.prototype.resetUnwrittenProperties = function (shape) {
            var target = (~this.written) & this.reset;
            if (target !== EShapeRuntimeReset.NONE) {
                if (target & EShapeRuntimeReset.POSITION_X) {
                    shape.transform.position.x = this.x;
                }
                if (target & EShapeRuntimeReset.POSITION_Y) {
                    shape.transform.position.y = this.y;
                }
                if (target & EShapeRuntimeReset.VISIBILITY) {
                    shape.visible = true;
                }
                if (target & EShapeRuntimeReset.COLOR_FILL) {
                    var fill = this.fill;
                    shape.fill.set(undefined, fill.color, fill.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_STROKE) {
                    var stroke = this.stroke;
                    shape.stroke.set(undefined, stroke.color, stroke.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_TEXT) {
                    var text = this.text;
                    shape.text.set(undefined, text.color, text.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                    var outline = this.text.outline;
                    shape.text.outline.set(undefined, outline.color, outline.alpha);
                }
                if (target & EShapeRuntimeReset.HEIGHT) {
                    shape.size.y = this.size.y;
                }
                if (target & EShapeRuntimeReset.WIDTH) {
                    shape.size.x = this.size.x;
                }
                if (target & EShapeRuntimeReset.ROTATION) {
                    shape.transform.rotation = this.rotation;
                }
                if (target & EShapeRuntimeReset.TEXT) {
                    shape.text.value = this.text.value;
                }
                if (target & EShapeRuntimeReset.CURSOR) {
                    shape.cursor = this.cursor;
                }
            }
        };
        return EShapeRuntime;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTransformImpl = /** @class */ (function (_super) {
        __extends(EShapeTransformImpl, _super);
        function EShapeTransformImpl(parent) {
            var _this = _super.call(this) || this;
            _this.internalTransform = new pixi_js.Matrix();
            _this._parent = parent;
            return _this;
        }
        EShapeTransformImpl.prototype.onChange = function () {
            _super.prototype.onChange.call(this);
            this._parent.onTransformChange();
        };
        EShapeTransformImpl.prototype.updateSkew = function () {
            _super.prototype.updateSkew.call(this);
            this._parent.onTransformChange();
        };
        EShapeTransformImpl.prototype.getLocalIdCurrent = function () {
            return this._currentLocalID;
        };
        EShapeTransformImpl.prototype.getLocalId = function () {
            return this._localID;
        };
        EShapeTransformImpl.prototype.getParentId = function () {
            return this._parentID;
        };
        EShapeTransformImpl.prototype.getWorldId = function () {
            return this._worldID;
        };
        EShapeTransformImpl.prototype.updateTransform = function (parentTransform) {
            var oldLocalId = this._currentLocalID;
            var oldWorldId = this._worldID;
            _super.prototype.updateTransform.call(this, parentTransform);
            var newLocalId = this._currentLocalID;
            var newWorldId = this._worldID;
            if (oldLocalId !== newLocalId) {
                var localTransform = this.localTransform;
                var internalTransform = this.internalTransform;
                localTransform.copyTo(internalTransform);
                if (parentTransform instanceof EShapeTransformImpl) {
                    internalTransform.prepend(parentTransform.internalTransform);
                }
            }
            else if (oldWorldId !== newWorldId) {
                var localTransform = this.localTransform;
                var internalTransform = this.internalTransform;
                if (parentTransform instanceof EShapeTransformImpl) {
                    localTransform.copyTo(internalTransform).prepend(parentTransform.internalTransform);
                    this._currentLocalID += 1;
                    this._localID = this._currentLocalID;
                }
            }
        };
        return EShapeTransformImpl;
    }(pixi_js.Transform));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toPadded = function (str, length, c) {
        var strLength = str.length;
        if (length < strLength) {
            return str;
        }
        var padding = "";
        for (var i = 0, imax = length - strLength; i < imax; ++i) {
            padding += c;
        }
        return padding + str;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilRgb = /** @class */ (function () {
        function UtilRgb() {
        }
        UtilRgb.toCode = function (color) {
            return toPadded(color.toString(16).toUpperCase(), 6, "0");
        };
        UtilRgb.fromCode = function (code) {
            var trimmed = code.trim().toLowerCase();
            if (trimmed.length === 6) {
                var color = Number("0x" + trimmed);
                if (color === color) {
                    return color;
                }
            }
            return null;
        };
        UtilRgb.fromRgb = function (r, g, b) {
            return ((r * 0xff) << 16) + ((g * 0xff) << 8) + ((b * 0xff) | 0);
        };
        UtilRgb.blend = function (colorA, colorB, t) {
            var ar = ((colorA >> 16) & 0xff);
            var ag = ((colorA >> 8) & 0xff);
            var ab = ((colorA | 0) & 0xff);
            var br = ((colorB >> 16) & 0xff);
            var bg = ((colorB >> 8) & 0xff);
            var bb = ((colorB | 0) & 0xff);
            var w1 = Math.max(0, Math.min(1, t));
            var w0 = 1 - w1;
            var cr = Math.max(0, Math.min(0xff, ar * w0 + br * w1));
            var cg = Math.max(0, Math.min(0xff, ag * w0 + bg * w1));
            var cb = Math.max(0, Math.min(0xff, ab * w0 + bb * w1));
            return (cr << 16) + (cg << 8) + (cb | 0);
        };
        UtilRgb.brighten = function (color, amount) {
            return this.blend(color, 0xffffff, amount);
        };
        UtilRgb.darken = function (color, amount) {
            return this.blend(color, 0x000000, amount);
        };
        return UtilRgb;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGradients = /** @class */ (function () {
        function EShapeGradients() {
        }
        EShapeGradients.serializeGradient = function (gradient) {
            var points = gradient.points;
            var result = "[" + gradient.direction;
            for (var i = 0, imax = points.length, j = 1; i < imax; i += 1, j += 3) {
                var point = points[i];
                result += "," + point.color + "," + point.alpha + "," + point.position;
            }
            result += "]";
            return result;
        };
        EShapeGradients.parseGradient = function (target) {
            try {
                return JSON.parse(target);
            }
            catch (e) {
                return null;
            }
        };
        EShapeGradients.deserializeGradient = function (target) {
            var parsed = this.parseGradient(target);
            if (parsed == null || parsed.length < 7) {
                return undefined;
            }
            else {
                var direction = parsed[0];
                var points = [];
                for (var i = 1, imax = parsed.length; i < imax; i += 3) {
                    points.push({
                        color: parsed[i + 0],
                        alpha: parsed[i + 1],
                        position: parsed[i + 2]
                    });
                }
                return {
                    points: points,
                    direction: direction
                };
            }
        };
        EShapeGradients.toGradientId = function (gradient, manager) {
            if (gradient != null) {
                if (gradient.serialized == null) {
                    gradient.serialized = this.serializeGradient(gradient);
                }
                return manager.add(gradient.serialized);
            }
            return -1;
        };
        EShapeGradients.toGradientImageUrl = function (gradient) {
            var direction = gradient.direction;
            var points = gradient.points;
            var stops = "";
            for (var i = 0, imax = points.length; i < imax; ++i) {
                var point = points[i];
                var color = UtilRgb.toCode(point.color);
                var alpha = point.alpha;
                var offset = point.position * 100;
                stops += "<stop offset=\"" + offset + "%\" stop-color=\"#" + color + "\" stop-opacity=\"" + alpha + "\" />";
            }
            var radian = direction * Math.PI / 180;
            var dx = 0.5 * Math.cos(radian);
            var dy = -0.5 * Math.sin(radian);
            var url = "data:image/svg+xml;base64," + btoa("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">" +
                "<defs>" +
                ("<linearGradient id=\"o2glkm3aeu2oio\" x1=\"" + (0.5 - dx) + "\" x2=\"" + (0.5 + dx) + "\" y1=\"" + (0.5 - dy) + "\" y2=\"" + (0.5 + dy) + "\">") +
                stops +
                "</linearGradient>" +
                "</defs>" +
                "<rect x=\"0\" y=\"0\" width=\"32\" height=\"32\" stroke=\"none\" fill=\"url(#o2glkm3aeu2oio)\" />" +
                "</svg>");
            return url;
        };
        return EShapeGradients;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBase = /** @class */ (function (_super) {
        __extends(EShapeBase, _super);
        function EShapeBase(type) {
            var _this = _super.call(this) || this;
            _this.id = "";
            _this.type = type;
            _this.transform = _this.newTransform();
            _this._onTransformChangeLock = 0;
            _this._isOnTransformChanged = false;
            _this.action = new EShapeAction();
            _this._visible = true;
            _this._uploadedUpdateLock = 0;
            _this._isUploadedUpdated = false;
            _this._isUploadedUpdatedRecursively = false;
            _this._boundsTransformId = NaN;
            _this._boundsInternalTransformId = NaN;
            _this._boundsLocalTransformId = NaN;
            _this._state = _this._stateLocal = DBaseState.UNFOCUSABLE;
            _this.interactive = false;
            //
            _this.parent = null;
            _this.children = [];
            //
            _this.selected = false;
            _this.index = 0;
            _this.reference = 0;
            return _this;
        }
        EShapeBase.prototype.newTransform = function () {
            return new EShapeTransformImpl(this);
        };
        EShapeBase.prototype.onSizeChange = function () {
            this._boundsTransformId = NaN;
            this._boundsInternalTransformId = NaN;
            this._boundsLocalTransformId = NaN;
            this.onTransformChange_();
            this.updateUploaded();
        };
        EShapeBase.prototype.onTransformChange = function () {
            this.onTransformChange_();
            this.updateUploadedRecursively();
        };
        EShapeBase.prototype.onTransformChange_ = function () {
            if (this._onTransformChangeLock === 0) {
                var parent_1 = this.parent;
                if (parent_1 != null) {
                    parent_1.onChildTransformChange();
                }
            }
            else {
                this._isOnTransformChanged = true;
            }
        };
        EShapeBase.prototype.disallowOnTransformChange = function () {
            this._onTransformChangeLock += 1;
            if (this._onTransformChangeLock === 1) {
                this._isOnTransformChanged = false;
            }
        };
        EShapeBase.prototype.allowOnTransformChange = function (invokeOnTransformChange) {
            this._onTransformChangeLock -= 1;
            if (this._onTransformChangeLock === 0) {
                if (this._isOnTransformChanged) {
                    this._isOnTransformChanged = false;
                    if (invokeOnTransformChange) {
                        this.onTransformChange();
                    }
                }
            }
        };
        EShapeBase.prototype.onChildTransformChange = function () {
            //
        };
        EShapeBase.prototype.disallowUploadedUpdate = function () {
            this._uploadedUpdateLock += 1;
            if (this._uploadedUpdateLock === 1) {
                this._isUploadedUpdated = false;
                this._isUploadedUpdatedRecursively = false;
            }
        };
        EShapeBase.prototype.allowUploadedUpdate = function () {
            this._uploadedUpdateLock -= 1;
            if (this._uploadedUpdateLock === 0) {
                if (this._isUploadedUpdatedRecursively) {
                    this._isUploadedUpdatedRecursively = false;
                    this._isUploadedUpdated = false;
                    this.updateUploadedRecursively();
                }
                else if (this._isUploadedUpdated) {
                    this._isUploadedUpdated = false;
                    this.updateUploaded();
                }
            }
        };
        EShapeBase.prototype.updateUploadedRecursively = function () {
            if (this._uploadedUpdateLock === 0) {
                this.updateUploaded();
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].updateUploadedRecursively();
                }
            }
            else {
                this._isUploadedUpdatedRecursively = true;
            }
        };
        EShapeBase.prototype.updateUploaded = function () {
            if (this._uploadedUpdateLock === 0) {
                var uploaded = this.uploaded;
                if (uploaded != null) {
                    uploaded.update(this);
                }
            }
            else {
                this._isUploadedUpdated = true;
            }
        };
        Object.defineProperty(EShapeBase.prototype, "root", {
            //
            get: function () {
                var root = this;
                while (root.parent instanceof EShapeBase) {
                    root = root.parent;
                }
                return root;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "visible", {
            //
            get: function () {
                var parent = this.parent;
                if (parent instanceof EShapeBase) {
                    return parent.visible && this._visible;
                }
                else {
                    return this._visible;
                }
            },
            set: function (visible) {
                if (this._visible !== visible) {
                    this._visible = visible;
                    this.updateUploadedRecursively();
                }
            },
            enumerable: true,
            configurable: true
        });
        //
        EShapeBase.prototype.toDirty = function () {
            var parent = this.parent;
            if (parent != null) {
                parent.toDirty();
            }
        };
        // Hierarchy
        EShapeBase.prototype.attach = function (parent, at) {
            this.detach();
            this.parent = parent;
            var children = parent.children;
            if (at != null && 0 <= at && at < children.length) {
                children.splice(at, 0, this);
            }
            else {
                children.push(this);
            }
            this.uploaded = undefined;
            parent.onChildTransformChange();
            parent.toDirty();
            return this;
        };
        EShapeBase.prototype.detach = function () {
            var parent = this.parent;
            if (parent != null) {
                this.parent = null;
                this.uploaded = undefined;
                var children = parent.children;
                var index = children.indexOf(this);
                if (0 <= index) {
                    children.splice(index, 1);
                    parent.onChildTransformChange();
                    parent.toDirty();
                }
            }
            return this;
        };
        // Transform
        EShapeBase.prototype.updateTransform = function () {
            var parent = this.parent;
            if (parent) {
                if (parent.parent) {
                    parent.updateTransform();
                }
                this.transform.updateTransform(parent.transform);
            }
            else {
                this.transform.updateTransform(pixi_js.Transform.IDENTITY);
            }
        };
        // Serialization
        EShapeBase.prototype.serializeChildren = function (manager) {
            var children = this.children;
            var childrenSerialized = [];
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                childrenSerialized.push(child.serialize(manager));
            }
            return childrenSerialized;
        };
        EShapeBase.prototype.serializeImage = function (manager) {
            var image = this.image;
            return (image != null ? manager.add(image.src) : -1);
        };
        EShapeBase.prototype.serializeGradient = function (manager) {
            return EShapeGradients.toGradientId(this.gradient, manager);
        };
        EShapeBase.prototype.serialize = function (manager) {
            var transform = this.transform;
            var position = transform.position;
            var pivot = transform.pivot;
            var size = this.size;
            var shortcut = this.shortcut;
            var shortcutId = (shortcut != null ? manager.add(shortcut) : -1);
            var title = this.title;
            var titleId = (title != null ? manager.add(title) : -1);
            return [
                this.type,
                manager.add(this.id),
                position.x,
                position.y,
                size.x,
                size.y,
                transform.rotation,
                transform.skew.x,
                this.fill.serialize(manager),
                this.stroke.serialize(manager),
                manager.add(this.cursor.trim()),
                this.text.serialize(manager),
                this.tag.serialize(manager),
                this.radius,
                this.corner,
                -1,
                -1,
                this.action.serialize(manager),
                this.serializeImage(manager),
                this.serializeGradient(manager),
                this.serializeChildren(manager),
                pivot.x,
                pivot.y,
                (this.interactive ? 1 : 0) | (this.unfocusable ? 2 : 0),
                shortcutId,
                titleId
            ];
        };
        // Hit test
        EShapeBase.prototype.toLocalRect = function (point, result) {
            var x = point.x;
            var y = point.y;
            var size = this.size;
            var sx = 0.5 * size.x;
            var sy = 0.5 * size.y;
            var pivot = this.transform.pivot;
            var dx = x - pivot.x;
            var dy = y - pivot.y;
            var stroke = this.stroke;
            var s = stroke.width * stroke.align;
            if (0 <= sx) {
                if (0 <= sy) {
                    result.x = +dx;
                    result.y = +dy;
                    result.width = +sx + s;
                    result.height = +sy + s;
                }
                else {
                    result.x = +dx;
                    result.y = -dy;
                    result.width = +sx + s;
                    result.height = -sy + s;
                }
            }
            else {
                if (0 <= sy) {
                    result.x = -dx;
                    result.y = +dy;
                    result.width = -sx + s;
                    result.height = +sy + s;
                }
                else {
                    result.x = -dx;
                    result.y = -dy;
                    result.width = -sx + s;
                    result.height = -sy + s;
                }
            }
            return result;
        };
        EShapeBase.prototype.contains = function (point) {
            var rect = this.toLocalRect(point, EShapeBase.WORK_RECT);
            if (this.containsAbs(rect.x, rect.y, rect.width, rect.height)) {
                return this;
            }
            var x = point.x;
            var y = point.y;
            return this.containsText(x, y, point) || this.containsChildren(x, y, point);
        };
        EShapeBase.prototype.containsText = function (x, y, work) {
            var text = this.text;
            var textAtlas = text.atlas;
            if (textAtlas != null) {
                var textWorld = text.world;
                if (textWorld != null) {
                    work.set(x, y);
                    this.transform.internalTransform.apply(work, work);
                    var tx = work.x - textWorld[0];
                    var ty = work.y - textWorld[1];
                    var th = textWorld[2] * tx + textWorld[3] * ty;
                    var tv = textWorld[4] * tx + textWorld[5] * ty;
                    if (0 <= th && th <= textWorld[6] && 0 <= tv && tv <= textWorld[7]) {
                        return this;
                    }
                }
            }
            return null;
        };
        EShapeBase.prototype.containsChildren = function (x, y, work) {
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                work.set(x, y);
                child.updateTransform();
                child.transform.localTransform.applyInverse(work, work);
                var childResult = child.contains(work);
                if (childResult != null) {
                    if (this.shadowed) {
                        return this;
                    }
                    else {
                        return childResult;
                    }
                }
            }
            return null;
        };
        EShapeBase.prototype.containsBBox = function (point) {
            var rect = this.toLocalRect(point, EShapeBase.WORK_RECT);
            return this.containsAbsBBox(rect.x, rect.y, rect.width, rect.height);
        };
        EShapeBase.prototype.containsAbs = function (x, y, ax, ay) {
            return this.containsAbsBBox(x, y, ax, ay);
        };
        EShapeBase.prototype.containsAbsBBox = function (x, y, ax, ay) {
            return (-ax <= x && x <= +ax && -ay <= y && y <= +ay);
        };
        EShapeBase.prototype.select = function (point) {
            return false;
        };
        //
        EShapeBase.prototype.toGlobal = function (position, result, skipUpdate) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            result.copyFrom(position);
            this.transform.worldTransform.apply(result, result);
            return result;
        };
        EShapeBase.prototype.toLocal = function (position, from, result, skipUpdate) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            if (result === undefined) {
                result = new pixi_js.Point();
            }
            result.copyFrom(position);
            this.transform.worldTransform.applyInverse(result, result);
            return result;
        };
        EShapeBase.prototype.getBounds = function (work, skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var bounds = this._bounds = (this._bounds || new pixi_js.Rectangle());
            var worldId = this.transform.getWorldId();
            if (worldId !== this._boundsTransformId) {
                this._boundsTransformId = worldId;
                this.getBounds_(this.transform.worldTransform, work, bounds);
            }
            result.copyFrom(bounds);
            return result;
        };
        EShapeBase.prototype.getBoundsInternal = function (work, skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var boundsInternal = this._boundsInternal = (this._boundsInternal || new pixi_js.Rectangle());
            var currentLocalId = this.transform.getLocalIdCurrent();
            if (currentLocalId !== this._boundsInternalTransformId) {
                this._boundsInternalTransformId = currentLocalId;
                this.getBounds_(this.transform.internalTransform, work, boundsInternal);
            }
            result.copyFrom(boundsInternal);
            return result;
        };
        EShapeBase.prototype.getBoundsLocal = function (work, skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var boundsLocal = this._boundsLocal = (this._boundsLocal || new pixi_js.Rectangle());
            var currentLocalId = this.transform.getLocalIdCurrent();
            if (currentLocalId !== this._boundsLocalTransformId) {
                this._boundsLocalTransformId = currentLocalId;
                this.getBounds_(this.transform.localTransform, work, boundsLocal);
            }
            result.copyFrom(boundsLocal);
            return result;
        };
        EShapeBase.prototype.getBoundsSize = function () {
            return this.size;
        };
        EShapeBase.prototype.getBounds_ = function (transform, work, result) {
            var pivot = this.transform.pivot;
            var px = pivot.x;
            var py = pivot.y;
            var size = this.getBoundsSize();
            var sx = 0.5 * size.x;
            var sy = 0.5 * size.y;
            var a = transform.a;
            var b = transform.b;
            var c = transform.c;
            var d = transform.d;
            var x = -sx + px;
            var y = -sy + py;
            var x0 = a * x + c * y;
            var y0 = b * x + d * y;
            x = +sx + px;
            y = -sy + py;
            var x1 = a * x + c * y;
            var y1 = b * x + d * y;
            x = -sx + px;
            y = +sy + py;
            var x2 = a * x + c * y;
            var y2 = b * x + d * y;
            x = +sx + px;
            y = +sy + py;
            var x3 = a * x + c * y;
            var y3 = b * x + d * y;
            var xmin = Math.min(x0, x1, x2, x3);
            var ymin = Math.min(y0, y1, y2, y3);
            var xmax = Math.max(x0, x1, x2, x3);
            var ymax = Math.max(y0, y1, y2, y3);
            result.x = xmin + transform.tx;
            result.y = ymin + transform.ty;
            result.width = xmax - xmin;
            result.height = ymax - ymin;
            return result;
        };
        //
        EShapeBase.prototype.destroy = function () {
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
        };
        //
        EShapeBase.prototype.updateState = function () {
            var parent = this.parent;
            var stateLocal = this._stateLocal;
            var newState = (parent instanceof EShapeBase ?
                this.mergeState(stateLocal, parent.getState()) :
                stateLocal);
            var oldState = this._state;
            if (oldState !== newState) {
                this._state = newState;
                this.onStateChange(newState, oldState);
            }
        };
        EShapeBase.prototype.mergeState = function (stateLocal, stateParent) {
            return stateLocal | (stateParent & DBaseState.DISABLED) |
                (stateParent & (DBaseState.FOCUSED | DBaseState.FOCUSED_IN) ? DBaseState.FOCUSED_IN : DBaseState.NONE);
        };
        EShapeBase.prototype.onStateChange = function (newState, oldState) {
            var runtime = this.runtime;
            if (runtime != null) {
                runtime.onStateChange(this, newState, oldState);
            }
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof EShapeBase) {
                    child.onParentStateChange(newState, oldState);
                }
            }
        };
        EShapeBase.prototype.onParentStateChange = function (newStateParent, oldStateParent) {
            var newState = this.mergeState(this._stateLocal, newStateParent);
            var oldState = this._state;
            if (oldState !== newState) {
                this._state = newState;
                this.onStateChange(newState, oldState);
            }
        };
        EShapeBase.prototype.getState = function () {
            return this._state;
        };
        EShapeBase.prototype.setState = function (state, isOn) {
            if ((!!(this._stateLocal & state)) !== isOn) {
                if (isOn) {
                    this._stateLocal |= state;
                }
                else {
                    this._stateLocal &= ~state;
                }
                this.updateState();
            }
            return this;
        };
        EShapeBase.prototype.hasState = function (state) {
            return !!(this._state & state);
        };
        EShapeBase.prototype.focus = function () {
            this.focused = true;
            return this;
        };
        EShapeBase.prototype.blur = function () {
            this.focused = false;
            return this;
        };
        Object.defineProperty(EShapeBase.prototype, "hovered", {
            get: function () {
                return this.hasState(DBaseState.HOVERED);
            },
            set: function (isHovered) {
                this.setState(DBaseState.HOVERED, isHovered);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "active", {
            get: function () {
                return this.hasState(DBaseState.ACTIVE);
            },
            set: function (isActive) {
                this.setState(DBaseState.ACTIVE, isActive);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "readonly", {
            get: function () {
                return this.hasState(DBaseState.READ_ONLY);
            },
            set: function (isReadOnly) {
                this.setState(DBaseState.READ_ONLY, isReadOnly);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "enabled", {
            get: function () {
                return !this.hasState(DBaseState.DISABLED);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "disabled", {
            get: function () {
                return this.hasState(DBaseState.DISABLED);
            },
            set: function (isDisabled) {
                this.setState(DBaseState.DISABLED, isDisabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "dragging", {
            get: function () {
                return this.hasState(DBaseState.DRAGGING);
            },
            set: function (isDragging) {
                this.setState(DBaseState.DRAGGING, isDragging);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "focused", {
            get: function () {
                return this.hasState(DBaseState.FOCUSED);
            },
            set: function (focused) {
                if (this.focused !== focused) {
                    var layer = DApplications.getLayer(this);
                    if (layer) {
                        layer.getFocusController().setFocused(this, focused, false);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "focusedin", {
            get: function () {
                return this.hasState(DBaseState.FOCUSED | DBaseState.FOCUSED_IN);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "unfocusable", {
            get: function () {
                return this.hasState(DBaseState.UNFOCUSABLE);
            },
            set: function (unforcusable) {
                this.setState(DBaseState.UNFOCUSABLE, unforcusable);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "clicked", {
            get: function () {
                var runtime = this.runtime;
                return !!(runtime && (runtime.state & EShapeRuntimeState.CLICKED));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "pressed", {
            get: function () {
                var runtime = this.runtime;
                return !!(runtime && (runtime.state & EShapeRuntimeState.PRESSED));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "down", {
            get: function () {
                var runtime = this.runtime;
                return !!(runtime && (runtime.state & EShapeRuntimeState.DOWN));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "up", {
            get: function () {
                var runtime = this.runtime;
                return !!(runtime && (runtime.state & EShapeRuntimeState.UP));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "shadowed", {
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        EShapeBase.prototype.onDblClick = function (e) {
            var runtime = this.runtime;
            if (runtime != null) {
                return runtime.onPointerDblClick(this);
            }
            return false;
        };
        EShapeBase.prototype.onShortcut = function (e) {
            var runtime = this.runtime;
            if (runtime != null) {
                return runtime.onPointerClick(this);
            }
        };
        EShapeBase.prototype.onKeyDown = function (e) {
            var runtime = this.runtime;
            if (runtime != null) {
                return runtime.onKeyDown(this, e);
            }
            return false;
        };
        EShapeBase.prototype.onKeyUp = function (e) {
            var runtime = this.runtime;
            if (runtime != null) {
                return runtime.onKeyUp(this, e);
            }
            return false;
        };
        //
        EShapeBase.prototype.update = function (time) {
            var runtime = this.runtime;
            if (runtime != null) {
                runtime.update(this, time);
            }
        };
        EShapeBase.prototype.updateRecursively = function (time) {
            this.update(time);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].update(time);
            }
        };
        EShapeBase.prototype.copy = function (source, part) {
            if (part === void 0) { part = EShapeCopyPart.ALL; }
            this.id = source.id;
            if ((part & EShapeCopyPart.TRANSFORM) !== 0) {
                var transform = this.transform;
                var sourceTransform = source.transform;
                transform.position.copyFrom(sourceTransform.position);
                transform.rotation = sourceTransform.rotation;
                transform.skew.copyFrom(sourceTransform.skew);
                transform.pivot.copyFrom(sourceTransform.pivot);
                transform.scale.copyFrom(sourceTransform.scale);
            }
            if ((part & EShapeCopyPart.SIZE) !== 0) {
                this.size.copyFrom(source.size);
            }
            if ((part & EShapeCopyPart.STYLE) !== 0) {
                this.fill.copy(source.fill);
                this.stroke.copy(source.stroke);
                this.tag.copy(source.tag);
                this.text.copy(source.text);
                this.radius = source.radius;
                this.corner = source.corner;
                if (this.image == null) {
                    this.image = source.image;
                }
            }
            if ((part & EShapeCopyPart.ACTION) !== 0) {
                this.action.addAll(source.action.values);
                this.interactive = source.interactive;
                this.cursor = source.cursor;
                this.shortcut = source.shortcut;
            }
            if ((part & EShapeCopyPart.POINTS) !== 0) {
                var sourcePoints = source.points;
                if (sourcePoints != null) {
                    var points = this.points;
                    if (points != null) {
                        points.copy(sourcePoints);
                    }
                    else {
                        this.points = sourcePoints.clone(this);
                    }
                }
            }
            if ((part & EShapeCopyPart.STATE) !== 0) {
                this.setState(source.getState(), true);
            }
            return this;
        };
        EShapeBase.WORK_RECT = new pixi_js.Rectangle();
        return EShapeBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCorner;
    (function (EShapeCorner) {
        EShapeCorner[EShapeCorner["NONE"] = 0] = "NONE";
        EShapeCorner[EShapeCorner["TOP_LEFT"] = 1] = "TOP_LEFT";
        EShapeCorner[EShapeCorner["TOP_RIGHT"] = 2] = "TOP_RIGHT";
        EShapeCorner[EShapeCorner["BOTTOM_LEFT"] = 4] = "BOTTOM_LEFT";
        EShapeCorner[EShapeCorner["BOTTOM_RIGHT"] = 8] = "BOTTOM_RIGHT";
        EShapeCorner[EShapeCorner["TOP"] = 3] = "TOP";
        EShapeCorner[EShapeCorner["BOTTOM"] = 12] = "BOTTOM";
        EShapeCorner[EShapeCorner["LEFT"] = 5] = "LEFT";
        EShapeCorner[EShapeCorner["RIGHT"] = 10] = "RIGHT";
        EShapeCorner[EShapeCorner["ALL"] = 15] = "ALL";
    })(EShapeCorner || (EShapeCorner = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeStrokeSide;
    (function (EShapeStrokeSide) {
        EShapeStrokeSide[EShapeStrokeSide["NONE"] = 0] = "NONE";
        EShapeStrokeSide[EShapeStrokeSide["TOP"] = 1] = "TOP";
        EShapeStrokeSide[EShapeStrokeSide["RIGHT"] = 2] = "RIGHT";
        EShapeStrokeSide[EShapeStrokeSide["BOTTOM"] = 4] = "BOTTOM";
        EShapeStrokeSide[EShapeStrokeSide["LEFT"] = 8] = "LEFT";
        EShapeStrokeSide[EShapeStrokeSide["TOP_OR_LEFT"] = 9] = "TOP_OR_LEFT";
        EShapeStrokeSide[EShapeStrokeSide["TOP_OR_RIGHT"] = 3] = "TOP_OR_RIGHT";
        EShapeStrokeSide[EShapeStrokeSide["BOTTOM_OR_LEFT"] = 12] = "BOTTOM_OR_LEFT";
        EShapeStrokeSide[EShapeStrokeSide["BOTTOM_OR_RIGHT"] = 6] = "BOTTOM_OR_RIGHT";
        EShapeStrokeSide[EShapeStrokeSide["ALL"] = 15] = "ALL";
    })(EShapeStrokeSide || (EShapeStrokeSide = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDefaults = /** @class */ (function () {
        function EShapeDefaults() {
        }
        EShapeDefaults.IS_EDIT_MODE = false;
        EShapeDefaults.FILL_COLOR = 0xffffff;
        EShapeDefaults.FILL_ALPHA = 0.5;
        EShapeDefaults.STROKE_COLOR = 0x4f4f4f;
        EShapeDefaults.STROKE_COLOR_DARK = 0x4f4f4f;
        EShapeDefaults.STROKE_COLOR_LIGHT = 0xd0d0d0;
        EShapeDefaults.STROKE_ALPHA = 1;
        EShapeDefaults.STROKE_WIDTH = 2;
        EShapeDefaults.STROKE_ALIGN = 0;
        EShapeDefaults.STROKE_SIDE = EShapeStrokeSide.ALL;
        EShapeDefaults.TEXT_VALUE = "";
        EShapeDefaults.TEXT_FAMILY = "auto";
        EShapeDefaults.TEXT_SIZE = 14;
        EShapeDefaults.CURSOR = "";
        EShapeDefaults.RADIUS = 0.25;
        EShapeDefaults.SIZE_X = 100;
        EShapeDefaults.SIZE_Y = 100;
        EShapeDefaults.HIGHLIGHT_COLOR = 0x1e87f0;
        return EShapeDefaults;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeFillImpl = /** @class */ (function () {
        function EShapeFillImpl(parent, enable, color, alpha) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
        }
        Object.defineProperty(EShapeFillImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeFillImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeFillImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeFillImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha);
            }
        };
        EShapeFillImpl.prototype.set = function (enable, color, alpha) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeFillImpl.prototype.clone = function () {
            return new EShapeFillImpl(this._parent, this._enable, this._color, this._alpha);
        };
        EShapeFillImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha
            };
        };
        EShapeFillImpl.prototype.serialize = function (manager) {
            var stringified = "[" + (this._enable ? 1 : 0) + "," + this._color + "," + this._alpha + "]";
            return manager.add(stringified);
        };
        EShapeFillImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.fills.get(target);
                if (parsed != null) {
                    this.set(parsed[0] !== 0, parsed[1], parsed[2]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.fills.set(target, deserialized);
                    this.set(deserialized[0] !== 0, deserialized[1], deserialized[2]);
                }
            }
        };
        return EShapeFillImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeStrokeImpl = /** @class */ (function () {
        function EShapeStrokeImpl(parent, enable, color, alpha, width, align, side) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
            this._width = width;
            this._align = align;
            this._side = side;
        }
        Object.defineProperty(EShapeStrokeImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "side", {
            get: function () {
                return this._side;
            },
            set: function (side) {
                if (this._side !== side) {
                    this._side = side;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeStrokeImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha, target.width, target.align, target.side);
            }
        };
        EShapeStrokeImpl.prototype.set = function (enable, color, alpha, width, align, side) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (width !== undefined && this._width !== width) {
                this._width = width;
                isChanged = true;
            }
            if (align !== undefined && this._align !== align) {
                this._align = align;
                isChanged = true;
            }
            if (side !== undefined && this._side !== side) {
                this._side = side;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeStrokeImpl.prototype.clone = function () {
            return new EShapeStrokeImpl(this._parent, this._enable, this._color, this._alpha, this._width, this._align, this._side);
        };
        EShapeStrokeImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha,
                width: this._width,
                align: this._align,
                side: this._side
            };
        };
        EShapeStrokeImpl.prototype.serialize = function (manager) {
            var enable = this._enable ? 1 : 0;
            var serialized = "[" + enable + "," + this._color + "," + this._alpha + "," + this._width + "," + this._align + "," + this._side + "]";
            return manager.add(serialized);
        };
        EShapeStrokeImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.strokes.get(target);
                if (parsed != null) {
                    this.set(parsed[0] !== 0, parsed[1], parsed[2], parsed[3], parsed[4], parsed[5]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.strokes.set(target, deserialized);
                    this.set(deserialized[0] !== 0, deserialized[1], deserialized[2], deserialized[3], deserialized[4], deserialized[5]);
                }
            }
        };
        return EShapeStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTagValueOrder;
    (function (EShapeTagValueOrder) {
        EShapeTagValueOrder[EShapeTagValueOrder["ASCENDING"] = 0] = "ASCENDING";
        EShapeTagValueOrder[EShapeTagValueOrder["DESCENDING"] = 1] = "DESCENDING";
    })(EShapeTagValueOrder || (EShapeTagValueOrder = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTagValueRangeType;
    (function (EShapeTagValueRangeType) {
        EShapeTagValueRangeType[EShapeTagValueRangeType["NONE"] = 0] = "NONE";
        EShapeTagValueRangeType[EShapeTagValueRangeType["FROM"] = 1] = "FROM";
        EShapeTagValueRangeType[EShapeTagValueRangeType["TO"] = 2] = "TO";
        EShapeTagValueRangeType[EShapeTagValueRangeType["FROM_TO"] = 3] = "FROM_TO";
    })(EShapeTagValueRangeType || (EShapeTagValueRangeType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTagValueRangeImpl = /** @class */ (function () {
        function EShapeTagValueRangeImpl() {
            this._type = EShapeTagValueRangeType.NONE;
            this._from = 0;
            this._to = 1;
        }
        Object.defineProperty(EShapeTagValueRangeImpl.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (type) {
                if (this._type !== type) {
                    this._type = type;
                    var parent_1 = this.parent;
                    if (parent_1 != null) {
                        parent_1.isChanged = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueRangeImpl.prototype, "from", {
            get: function () {
                return this._from;
            },
            set: function (from) {
                if (this._from !== from) {
                    this._from = from;
                    var parent_2 = this.parent;
                    if (parent_2 != null) {
                        parent_2.isChanged = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueRangeImpl.prototype, "to", {
            get: function () {
                return this._to;
            },
            set: function (to) {
                if (this._to !== to) {
                    this._to = to;
                    var parent_3 = this.parent;
                    if (parent_3 != null) {
                        parent_3.isChanged = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeTagValueRangeImpl.prototype.set = function (from, to) {
            var result = false;
            if (from !== undefined && to !== undefined) {
                if (from !== null && to !== null) {
                    var type = (this._type | EShapeTagValueRangeType.FROM) | EShapeTagValueRangeType.TO;
                    if (this._type !== type || this._from !== from || this._to !== to) {
                        this._type = type;
                        this._from = from;
                        this._to = to;
                        result = true;
                    }
                }
                else if (from !== null) {
                    var type = (this._type | EShapeTagValueRangeType.FROM) & (~EShapeTagValueRangeType.TO);
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._from = from;
                        result = true;
                    }
                }
                else if (to !== null) {
                    var type = (this._type | EShapeTagValueRangeType.TO) & (~EShapeTagValueRangeType.FROM);
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._to = to;
                        result = true;
                    }
                }
                else {
                    var type = this._type & (~(EShapeTagValueRangeType.TO | EShapeTagValueRangeType.FROM));
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            else if (from !== undefined) {
                if (from !== null) {
                    var type = this._type | EShapeTagValueRangeType.FROM;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._from = from;
                        result = true;
                    }
                }
                else {
                    var type = this._type & (~EShapeTagValueRangeType.FROM);
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            else if (to !== undefined) {
                if (to !== null) {
                    var type = this._type | EShapeTagValueRangeType.TO;
                    if (this._type !== type || this._to !== to) {
                        this._type = type;
                        this._to = to;
                        result = true;
                    }
                }
                else {
                    var type = this._type & (~EShapeTagValueRangeType.TO);
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            if (result) {
                var parent_4 = this.parent;
                if (parent_4 != null) {
                    parent_4.isChanged = true;
                }
            }
            return result;
        };
        EShapeTagValueRangeImpl.prototype.normalize = function (value) {
            var type = this._type;
            var from = this._from;
            var to = this._to;
            switch (type) {
                case EShapeTagValueRangeType.FROM_TO:
                    return (value - from) / (to - from);
                case EShapeTagValueRangeType.FROM:
                    return value - from;
                case EShapeTagValueRangeType.TO:
                    return to - value;
                case EShapeTagValueRangeType.NONE:
                default:
                    return value;
            }
        };
        EShapeTagValueRangeImpl.prototype.isEquals = function (target) {
            return (this._type === target.type &&
                this._from === target.from &&
                this._to === target.to);
        };
        EShapeTagValueRangeImpl.prototype.copy = function (target) {
            return this.copy_(target.type, target.from, target.to);
        };
        EShapeTagValueRangeImpl.prototype.copy_ = function (type, from, to) {
            var isChanged = false;
            if (this._type !== type) {
                this._type = type;
                isChanged = true;
            }
            if (this._from !== from) {
                this._from = from;
                isChanged = true;
            }
            if (this._to !== to) {
                this._to = to;
                isChanged = true;
            }
            if (isChanged) {
                var parent_5 = this.parent;
                if (parent_5 != null) {
                    parent_5.isChanged = true;
                }
            }
            return this;
        };
        EShapeTagValueRangeImpl.prototype.toObject = function () {
            return {
                type: this.type,
                from: this.from,
                to: this.to
            };
        };
        EShapeTagValueRangeImpl.prototype.serialize = function (manager) {
            var serialized = "[" + this._type + "," + this._from + "," + this._to + "]";
            return manager.add(serialized);
        };
        EShapeTagValueRangeImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.ranges.get(target);
                if (parsed != null) {
                    this.copy_(parsed[0], parsed[1], parsed[2]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.ranges.set(target, deserialized);
                    this.copy_(deserialized[0], deserialized[1], deserialized[2]);
                }
            }
        };
        return EShapeTagValueRangeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var INDEX_COMPARATOR = function (a, b) {
        return a - b;
    };
    var EShapeTagValueImpl = /** @class */ (function () {
        function EShapeTagValueImpl() {
            this.id = "";
            this.initial = "";
            this.format = "";
            this.range = new EShapeTagValueRangeImpl();
            this._value = 0;
            this._time = 0;
            this._capacity = 0;
            this._order = EShapeTagValueOrder.ASCENDING;
        }
        Object.defineProperty(EShapeTagValueImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            set: function (parent) {
                if (this._parent !== parent) {
                    this._parent = parent;
                    this.range.parent = parent;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (newValue) {
                var formatter = this.formatter;
                if (formatter != null) {
                    newValue = formatter(newValue);
                }
                var capacity = this._capacity;
                if (capacity <= 0) {
                    if (this._value !== newValue) {
                        this._value = newValue;
                        var parent_1 = this.parent;
                        if (parent_1 != null) {
                            parent_1.isChanged = true;
                        }
                    }
                }
                else {
                    var values = this._values;
                    if (values == null) {
                        values = [];
                        this._values = values;
                    }
                    // Update the value
                    this._value = newValue;
                    // Update the values
                    var order = this._order;
                    if (order === EShapeTagValueOrder.ASCENDING) {
                        values.push(newValue);
                    }
                    else {
                        values.unshift(newValue);
                    }
                    // Remove the unnecessary values
                    var count = values.length - capacity;
                    if (0 < count) {
                        if (order === EShapeTagValueOrder.ASCENDING) {
                            for (var i = 0; i < count; ++i) {
                                values.shift();
                            }
                        }
                        else {
                            values.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    var parent_2 = this.parent;
                    if (parent_2 != null) {
                        parent_2.isChanged = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "nvalue", {
            get: function () {
                return this.range.normalize(this._value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "values", {
            get: function () {
                var result = this._values;
                if (result == null) {
                    result = [];
                    this._values = result;
                }
                return result;
            },
            set: function (newValues) {
                if (0 < newValues.length) {
                    var capacity = this._capacity;
                    if (capacity <= 0) {
                        var newValue = newValues[newValues.length - 1];
                        var formatter = this.formatter;
                        if (formatter != null) {
                            newValue = formatter(newValue);
                        }
                        if (this._value !== newValue) {
                            this._value = newValue;
                            var parent_3 = this.parent;
                            if (parent_3 != null) {
                                parent_3.isChanged = true;
                            }
                        }
                    }
                    else {
                        var values = this._values;
                        if (values == null) {
                            values = [];
                            this._values = values;
                        }
                        var order = this._order;
                        var formatter = this.formatter;
                        if (formatter != null) {
                            // Update the value
                            this._value = formatter(newValues[newValues.length - 1]);
                            // Update the values
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0, imax = newValues.length; i < imax; ++i) {
                                    values.push(formatter(newValues[i]));
                                }
                            }
                            else {
                                for (var i = 0, imax = newValues.length; i < imax; ++i) {
                                    values.unshift(formatter(newValues[i]));
                                }
                            }
                        }
                        else {
                            // Update the value
                            this._value = newValues[newValues.length - 1];
                            // Update the values
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0, imax = newValues.length; i < imax; ++i) {
                                    values.push(newValues[i]);
                                }
                            }
                            else {
                                for (var i = 0, imax = newValues.length; i < imax; ++i) {
                                    values.unshift(newValues[i]);
                                }
                            }
                        }
                        // Remove the unnecessary values
                        var count = values.length - capacity;
                        if (0 < count) {
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    values.shift();
                                }
                            }
                            else {
                                values.length = capacity;
                            }
                        }
                        // Tell the parent it's changed
                        var parent_4 = this.parent;
                        if (parent_4 != null) {
                            parent_4.isChanged = true;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "time", {
            get: function () {
                return this._time;
            },
            set: function (newTime) {
                var capacity = this._capacity;
                if (capacity <= 0) {
                    if (this._time !== newTime) {
                        this._time = newTime;
                        var parent_5 = this.parent;
                        if (parent_5 != null) {
                            parent_5.isChanged = true;
                        }
                    }
                }
                else {
                    // Update the times
                    var times = this._times;
                    if (times == null) {
                        times = [];
                        this._times = times;
                    }
                    // Update the time
                    this._time = newTime;
                    // Update the times
                    var order = this._order;
                    if (order === EShapeTagValueOrder.ASCENDING) {
                        times.push(newTime);
                    }
                    else {
                        times.unshift(newTime);
                    }
                    // Remove the unnecessary times
                    var count = times.length - capacity;
                    if (0 < count) {
                        if (order === EShapeTagValueOrder.ASCENDING) {
                            for (var i = 0; i < count; ++i) {
                                times.shift();
                            }
                        }
                        else {
                            times.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    var parent_6 = this.parent;
                    if (parent_6 != null) {
                        parent_6.isChanged = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "times", {
            get: function () {
                var result = this._times;
                if (result == null) {
                    result = [];
                    this._times = result;
                }
                return result;
            },
            set: function (newTimes) {
                if (0 < newTimes.length) {
                    var capacity = this._capacity;
                    if (capacity <= 0) {
                        var newTime = newTimes[newTimes.length - 1];
                        if (this._time !== newTime) {
                            this._time = newTime;
                            var parent_7 = this.parent;
                            if (parent_7 != null) {
                                parent_7.isChanged = true;
                            }
                        }
                    }
                    else {
                        // Update the times
                        var times = this._times;
                        if (times == null) {
                            times = [];
                            this._times = times;
                        }
                        // Update the value
                        this._time = newTimes[newTimes.length - 1];
                        //
                        var order = this._order;
                        if (order === EShapeTagValueOrder.ASCENDING) {
                            for (var i = 0, imax = newTimes.length; i < imax; ++i) {
                                times.push(newTimes[i]);
                            }
                        }
                        else {
                            for (var i = 0, imax = newTimes.length; i < imax; ++i) {
                                times.unshift(newTimes[i]);
                            }
                        }
                        //
                        var count = times.length - capacity;
                        if (0 < count) {
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    times.shift();
                                }
                            }
                            else {
                                times.length = capacity;
                            }
                        }
                        // Tell the parent it's changed
                        var parent_8 = this.parent;
                        if (parent_8 != null) {
                            parent_8.isChanged = true;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "capacity", {
            get: function () {
                return this._capacity;
            },
            set: function (capacity) {
                if (this._capacity < capacity) {
                    this._capacity = capacity;
                }
                else if (capacity < this._capacity) {
                    this._capacity = capacity;
                    var isChanged = false;
                    // Values
                    var order = this._order;
                    var values = this._values;
                    if (values != null) {
                        var count = values.length - capacity;
                        if (0 < count) {
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    values.shift();
                                }
                            }
                            else {
                                values.length = capacity;
                            }
                            isChanged = true;
                        }
                    }
                    // Times
                    var times = this._times;
                    if (times != null) {
                        var count = times.length - capacity;
                        if (0 < count) {
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    times.shift();
                                }
                            }
                            else {
                                times.length = capacity;
                            }
                            isChanged = true;
                        }
                    }
                    if (isChanged) {
                        var parent_9 = this.parent;
                        if (parent_9 != null) {
                            parent_9.isChanged = true;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (order) {
                this._order = order;
            },
            enumerable: true,
            configurable: true
        });
        EShapeTagValueImpl.prototype.remove = function (index) {
            var isChanged = false;
            // Values
            var values = this._values;
            if (values != null) {
                if (0 <= index && index < values.length) {
                    values.splice(index, 1);
                    isChanged = true;
                }
            }
            // Times
            var times = this._times;
            if (times != null) {
                if (0 <= index && index < times.length) {
                    times.splice(index, 1);
                    isChanged = true;
                }
            }
            if (isChanged) {
                var parent_10 = this.parent;
                if (parent_10 != null) {
                    parent_10.isChanged = true;
                }
            }
        };
        EShapeTagValueImpl.prototype.removeAll = function (indices) {
            var isChanged = false;
            var values = this._values;
            var times = this._times;
            var sorted = indices.slice(0).sort(INDEX_COMPARATOR);
            if (values != null) {
                if (times != null) {
                    for (var i = sorted.length - 1; 0 <= i; --i) {
                        var index = sorted[i];
                        if (0 <= index) {
                            if (index < values.length) {
                                values.splice(index, 1);
                                isChanged = true;
                            }
                            if (index < times.length) {
                                times.splice(index, 1);
                                isChanged = true;
                            }
                        }
                    }
                }
                else {
                    for (var i = sorted.length - 1; 0 <= i; --i) {
                        var index = sorted[i];
                        if (0 <= index && index < values.length) {
                            values.splice(index, 1);
                            isChanged = true;
                        }
                    }
                }
            }
            else {
                if (times != null) {
                    for (var i = sorted.length - 1; 0 <= i; --i) {
                        var index = sorted[i];
                        if (0 <= index && index < times.length) {
                            times.splice(index, 1);
                            isChanged = true;
                        }
                    }
                }
            }
            if (isChanged) {
                var parent_11 = this.parent;
                if (parent_11 != null) {
                    parent_11.isChanged = true;
                }
            }
        };
        EShapeTagValueImpl.prototype.clear = function () {
            var isChanged = false;
            // Values
            var values = this._values;
            if (values != null) {
                values.length = 0;
                isChanged = true;
            }
            // Times
            var times = this._times;
            if (times != null) {
                times.length = 0;
                isChanged = true;
            }
            // Change flag
            if (isChanged) {
                var parent_12 = this.parent;
                if (parent_12 != null) {
                    parent_12.isChanged = true;
                }
            }
        };
        /**
         * This method does not copy the `#values` and `#times` for the performance.
         *
         * @param target a copy target
         */
        EShapeTagValueImpl.prototype.copy = function (target) {
            this.id = target.id;
            this.initial = target.initial;
            this.format = target.format;
            this.formatter = target.formatter;
            this.range.copy(target.range);
            this._value = target.value;
            this._time = target.time;
            this._capacity = target.capacity;
            return this;
        };
        EShapeTagValueImpl.prototype.serialize = function (manager) {
            var idSerialized = manager.add(this.id);
            var initialSerialized = manager.add(this.initial);
            var formatSerialized = manager.add(this.format.trim());
            var rangeSerialized = this.range.serialize(manager);
            return manager.add("[" + idSerialized + "," + initialSerialized + "," + formatSerialized + "," + rangeSerialized + "," + this._capacity + "," + this._order + "]");
        };
        EShapeTagValueImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.tagValues.get(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.tagValues.set(target, parsed);
                }
                this.id = resources[parsed[0]] || "";
                this.initial = resources[parsed[1]] || "";
                this.format = resources[parsed[2]] || "";
                this.range.deserialize(parsed[3], manager);
                this._capacity = parsed[4];
                this._order = parsed[5];
            }
            return this;
        };
        return EShapeTagValueImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTagImpl = /** @class */ (function () {
        function EShapeTagImpl() {
            this._values = [];
            this.isChanged = true;
        }
        Object.defineProperty(EShapeTagImpl.prototype, "id", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].id;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        return inherited.id;
                    }
                }
                return "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "initial", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].initial;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        return inherited.initial;
                    }
                }
                return "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "format", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].format;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        return inherited.format;
                    }
                }
                return "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "range", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].range;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        return inherited.range;
                    }
                }
                return EShapeTagImpl.RANGE_DUMMY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "value", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].value;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        return inherited.value;
                    }
                }
                return 0;
            },
            set: function (value) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].value = value;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        inherited.value = value;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "nvalue", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].nvalue;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        return inherited.nvalue;
                    }
                }
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "time", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].time;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        return inherited.time;
                    }
                }
                return 0;
            },
            set: function (time) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].time = time;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        inherited.time = time;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "values", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].values;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        return inherited.values;
                    }
                }
                return EShapeTagImpl.EMPTY_ARRAY;
            },
            set: function (newValues) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].values = newValues;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        inherited.values = newValues;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "times", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].times;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        return inherited.times;
                    }
                }
                return EShapeTagImpl.EMPTY_ARRAY;
            },
            set: function (newTimes) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].times = newTimes;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        inherited.times = newTimes;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "capacity", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].capacity;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        return inherited.capacity;
                    }
                }
                return 0;
            },
            set: function (capacity) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].capacity = capacity;
                }
                else {
                    var inherited = this.inherited;
                    if (inherited != null) {
                        inherited.capacity = capacity;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeTagImpl.prototype.add = function (value, index) {
            var values = this._values;
            value.parent = this;
            if (index === undefined) {
                values.push(value);
            }
            else {
                values.splice(index, 0, value);
            }
        };
        EShapeTagImpl.prototype.set = function (index, value) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                var result = values[index];
                value.parent = this;
                values[index] = value;
                result.parent = undefined;
                return result;
            }
            return null;
        };
        EShapeTagImpl.prototype.remove = function (index) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                values.splice(index, 1)[0].parent = undefined;
            }
        };
        EShapeTagImpl.prototype.indexOf = function (target) {
            var values = this._values;
            // Instance-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value.id === target.id &&
                    value.initial === target.initial &&
                    value.formatter === target.formatter &&
                    value.range.isEquals(target.range)) {
                    return i;
                }
            }
            // ID-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value.id === target.id) {
                    return i;
                }
            }
            return -1;
        };
        EShapeTagImpl.prototype.get = function (index) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                return values[index];
            }
            return null;
        };
        EShapeTagImpl.prototype.size = function () {
            return this._values.length;
        };
        EShapeTagImpl.prototype.swap = function (indexA, indexB) {
            var values = this._values;
            var tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
        };
        EShapeTagImpl.prototype.copy = function (target) {
            var values = this._values;
            values.length = 0;
            for (var i = 0, imax = target.size(); i < imax; ++i) {
                var value = target.get(i);
                if (value != null) {
                    var newValue = new EShapeTagValueImpl().copy(value);
                    newValue.parent = this;
                    values.push(newValue);
                }
            }
            return this;
        };
        EShapeTagImpl.prototype.serialize = function (manager) {
            var values = this._values;
            if (values.length <= 0) {
                return manager.add("[]");
            }
            else {
                var serialized = "[" + values[0].serialize(manager);
                for (var i = 1, imax = values.length; i < imax; ++i) {
                    serialized += "," + values[i].serialize(manager);
                }
                serialized += "]";
                return manager.add(serialized);
            }
        };
        EShapeTagImpl.prototype.deserialize = function (target, manager) {
            if (0 <= target && target < manager.resources.length) {
                var deserialized = manager.tags.get(target);
                if (deserialized == null) {
                    deserialized = JSON.parse(manager.resources[target]);
                    manager.tags.set(target, deserialized);
                }
                var values = this._values;
                values.length = 0;
                for (var i = 0, imax = deserialized.length; i < imax; ++i) {
                    var index = deserialized[i];
                    var value = new EShapeTagValueImpl();
                    value.parent = this;
                    value.deserialize(index, manager);
                    values.push(value);
                }
            }
        };
        EShapeTagImpl.RANGE_DUMMY = new EShapeTagValueRangeImpl();
        EShapeTagImpl.EMPTY_ARRAY = [];
        return EShapeTagImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignImpl = /** @class */ (function () {
        function EShapeTextAlignImpl(parent, horizontal, vertical) {
            this._parent = parent;
            this._horizontal = horizontal;
            this._vertical = vertical;
        }
        Object.defineProperty(EShapeTextAlignImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextAlignImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeTextAlignImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.horizontal, target.vertical);
            }
        };
        EShapeTextAlignImpl.prototype.set = function (horizontal, vertical) {
            var isChanged = false;
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextAlignImpl.prototype.toObject = function () {
            return {
                horizontal: this._horizontal,
                vertical: this._vertical
            };
        };
        EShapeTextAlignImpl.prototype.serialize = function (manager) {
            return manager.add("[" + this._horizontal + "," + this._vertical + "]");
        };
        EShapeTextAlignImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.aligns.get(target);
                if (parsed != null) {
                    this.set(parsed[0], parsed[1]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.aligns.set(target, deserialized);
                    this.set(deserialized[0], deserialized[1]);
                }
            }
        };
        return EShapeTextAlignImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextOffsetImpl = /** @class */ (function () {
        function EShapeTextOffsetImpl(parent, horizontal, vertical) {
            this._parent = parent;
            this._horizontal = horizontal;
            this._vertical = vertical;
        }
        Object.defineProperty(EShapeTextOffsetImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextOffsetImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeTextOffsetImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.horizontal, target.vertical);
            }
        };
        EShapeTextOffsetImpl.prototype.set = function (horizontal, vertical) {
            var isChanged = false;
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextOffsetImpl.prototype.toObject = function () {
            return {
                horizontal: this._horizontal,
                vertical: this._vertical
            };
        };
        EShapeTextOffsetImpl.prototype.serialize = function (manager) {
            return manager.add("[" + this._horizontal + "," + this._vertical + "]");
        };
        EShapeTextOffsetImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.margins.get(target);
                if (parsed != null) {
                    this.set(parsed[0], parsed[1]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.margins.set(target, deserialized);
                    this.set(deserialized[0], deserialized[1]);
                }
            }
        };
        return EShapeTextOffsetImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextOutlineImpl = /** @class */ (function () {
        function EShapeTextOutlineImpl(parent, enable, color, alpha, width) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
            this._width = width;
        }
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeTextOutlineImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha, target.width);
            }
        };
        EShapeTextOutlineImpl.prototype.set = function (enable, color, alpha, width) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (width !== undefined && this._width !== width) {
                this._width = width;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextOutlineImpl.prototype.clone = function () {
            return new EShapeTextOutlineImpl(this._parent, this._enable, this._color, this._alpha, this._width);
        };
        EShapeTextOutlineImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha,
                width: this._width
            };
        };
        EShapeTextOutlineImpl.prototype.serialize = function (manager) {
            var serialized = "[" + (this._enable ? 1 : 0) + "," + this._color + "," + this._alpha + "," + this._width + "]";
            return manager.add(serialized);
        };
        EShapeTextOutlineImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.textOutlines.get(target);
                if (parsed != null) {
                    this.set(parsed[0] !== 0, parsed[1], parsed[2], parsed[3]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.textOutlines.set(target, deserialized);
                    this.set(deserialized[0] !== 0, deserialized[1], deserialized[2], deserialized[3]);
                }
            }
        };
        return EShapeTextOutlineImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextImpl = /** @class */ (function () {
        function EShapeTextImpl(parent, value, color, alpha, family, size) {
            this._parent = parent;
            this._enable = true;
            this._value = value;
            this._color = color;
            this._alpha = alpha;
            this._family = family;
            this._size = size;
            this._weight = EShapeTextWeight.NORMAL;
            this.align = new EShapeTextAlignImpl(parent, EShapeTextAlignHorizontal.CENTER, EShapeTextAlignVertical.MIDDLE);
            this.offset = new EShapeTextOffsetImpl(parent, 0, 0);
            this._style = EShapeTextStyle.NORMAL;
            this.spacing = new EShapeTextOffsetImpl(parent, 0, 0);
            this.outline = new EShapeTextOutlineImpl(parent, false, 0xffffff, 1.0, 0.5);
            this._direction = EShapeTextDirection.LEFT_TO_RIGHT;
            this.padding = new EShapeTextOffsetImpl(parent, 10, 10);
            this._clipping = false;
        }
        Object.defineProperty(EShapeTextImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                if (this._value !== value) {
                    this._value = value;
                    // Compatibility check
                    var parent_1 = this._parent;
                    var uploaded = parent_1.uploaded;
                    if (uploaded == null || !uploaded.isCompatible(parent_1)) {
                        this.atlas = undefined;
                        parent_1.toDirty();
                        return;
                    }
                    // Character code check
                    var atlas = this.atlas;
                    var characters = atlas && atlas.characters;
                    if (characters != null) {
                        for (var i = 0, imax = value.length; i < imax; ++i) {
                            var char = value[i];
                            if (!(char in characters)) {
                                this.atlas = undefined;
                                parent_1.toDirty();
                                return;
                            }
                        }
                    }
                    else {
                        this.atlas = undefined;
                        parent_1.toDirty();
                        return;
                    }
                    // Update uploaded
                    parent_1.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "family", {
            get: function () {
                return this._family;
            },
            set: function (family) {
                if (this._family !== family) {
                    this._family = family;
                    this._parent.toDirty();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                if (this._size !== size) {
                    this._size = size;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            set: function (weight) {
                if (this._weight !== weight) {
                    this._weight = weight;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                if (this._style !== style) {
                    this._style = style;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "direction", {
            get: function () {
                return this._direction;
            },
            set: function (direction) {
                if (this._direction !== direction) {
                    this._direction = direction;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "clipping", {
            get: function () {
                return this._clipping;
            },
            set: function (clipping) {
                if (this._clipping !== clipping) {
                    this._clipping = clipping;
                    this._parent.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeTextImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.value, target.color, target.alpha, target.family, target.size, target.weight, target.style, target.direction, target.clipping);
                this.align.copy(target.align);
                this.offset.copy(target.offset);
                this.outline.copy(target.outline);
                this.spacing.copy(target.spacing);
                this.padding.copy(target.padding);
            }
            return this;
        };
        EShapeTextImpl.prototype.set = function (value, color, alpha, family, size, weight, style, direction, clipping) {
            var isChangedDirty = false;
            var isChangedUploaded = false;
            if (value != null && this._value !== value) {
                this._value = value;
                isChangedDirty = true;
            }
            if (color != null && this._color !== color) {
                this._color = color;
                isChangedUploaded = true;
            }
            if (alpha != null && this._alpha !== alpha) {
                this._alpha = alpha;
                isChangedUploaded = true;
            }
            if (family != null && this._family !== family) {
                this._family = family;
                isChangedDirty = true;
            }
            if (size != null && this._size !== size) {
                this._size = size;
                isChangedUploaded = true;
            }
            if (weight != null && this._weight !== weight) {
                this._weight = weight;
                isChangedUploaded = true;
            }
            if (style != null && this._style !== style) {
                this._style = style;
                isChangedUploaded = true;
            }
            if (direction != null && this._direction !== direction) {
                this._direction = direction;
                isChangedUploaded = true;
            }
            if (clipping != null && this._clipping !== clipping) {
                this._clipping = clipping;
                isChangedUploaded = true;
            }
            if (isChangedDirty) {
                this._parent.toDirty();
            }
            else if (isChangedUploaded) {
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeTextImpl.prototype.toObject = function () {
            return {
                value: this._value,
                color: this._color,
                alpha: this._alpha,
                family: this._family,
                size: this._size,
                weight: this._weight,
                align: this.align.toObject(),
                offset: this.offset.toObject(),
                style: this._style,
                outline: this.outline.toObject(),
                direction: this._direction,
                spacing: this.spacing.toObject(),
                padding: this.padding.toObject(),
                clipping: this._clipping
            };
        };
        EShapeTextImpl.prototype.serialize = function (manager) {
            var alignSerialized = this.align.serialize(manager);
            var offsetSerialized = this.offset.serialize(manager);
            var outlineSerialized = this.outline.serialize(manager);
            var spacingSerialized = this.spacing.serialize(manager);
            var paddingSerialized = this.padding.serialize(manager);
            var serialized = "[" + manager.add(this._value) + "," + this._color + "," + this._alpha + "," +
                (manager.add(this._family) + "," + this._size + "," + this._weight + "," + alignSerialized + ",") +
                (offsetSerialized + "," + this._style + "," + outlineSerialized + "," + spacingSerialized + ",") +
                (this._direction + "," + paddingSerialized + "," + (this._clipping ? 1 : 0) + "]");
            return manager.add(serialized);
        };
        EShapeTextImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.texts.get(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.texts.set(target, parsed);
                }
                this.set(resources[parsed[0]] || "", parsed[1], parsed[2], resources[parsed[3]] || "auto", parsed[4], parsed[5], parsed[8], parsed[11], (parsed[13] !== 0));
                this.align.deserialize(parsed[6], manager);
                this.offset.deserialize(parsed[7], manager);
                this.outline.deserialize(parsed[9], manager);
                this.spacing.deserialize(parsed[10], manager);
                this.padding.deserialize(parsed[12], manager);
            }
        };
        return EShapeTextImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePrimitive = /** @class */ (function (_super) {
        __extends(EShapePrimitive, _super);
        function EShapePrimitive(type) {
            var _this = _super.call(this, type) || this;
            _this.size = _this.newSize();
            _this.fill = _this.newFill();
            _this.stroke = _this.newStroke();
            _this._radius = EShapeDefaults.RADIUS;
            _this._corner = EShapeCorner.ALL;
            _this.tag = new EShapeTagImpl();
            _this.text = _this.newText();
            _this.cursor = EShapeDefaults.CURSOR;
            return _this;
        }
        EShapePrimitive.prototype.newSize = function () {
            var _this = this;
            return new pixi_js.ObservablePoint(function () { _this.onSizeChange(); }, undefined, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
        };
        EShapePrimitive.prototype.newFill = function () {
            return new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, EShapeDefaults.FILL_ALPHA);
        };
        EShapePrimitive.prototype.newStroke = function () {
            return new EShapeStrokeImpl(this, true, EShapeDefaults.STROKE_COLOR, EShapeDefaults.STROKE_ALPHA, EShapeDefaults.STROKE_WIDTH, EShapeDefaults.STROKE_ALIGN, EShapeDefaults.STROKE_SIDE);
        };
        EShapePrimitive.prototype.newText = function () {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.STROKE_COLOR, EShapeDefaults.STROKE_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        };
        Object.defineProperty(EShapePrimitive.prototype, "corner", {
            get: function () {
                return this._corner;
            },
            set: function (corner) {
                if (this._corner !== corner) {
                    this._corner = corner;
                    this.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapePrimitive.prototype, "radius", {
            get: function () {
                return this._radius;
            },
            set: function (radius) {
                if (this._radius !== radius) {
                    this._radius = radius;
                    this.updateUploaded();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapePrimitive.prototype, "image", {
            get: function () {
                return this._image;
            },
            set: function (image) {
                if (this._image !== image) {
                    if (image != null) {
                        this._image = image;
                        this.imageSrc = image.src;
                    }
                    else {
                        this._image = undefined;
                        this.imageSrc = undefined;
                    }
                    var parent_1 = this.parent;
                    if (parent_1 != null) {
                        parent_1.toDirty();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        return EShapePrimitive;
    }(EShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineBase = /** @class */ (function (_super) {
        __extends(EShapeLineBase, _super);
        function EShapeLineBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineBase.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            result[15] = this.points.serialize(manager);
            return result;
        };
        EShapeLineBase.prototype.getPixelScale = function () {
            var container = this.root.parent;
            if (container != null && container.getPixelScale != null) {
                return container.getPixelScale();
            }
            return 1.0;
        };
        EShapeLineBase.prototype.getStrokeWidthScale = function (points) {
            var style = points.style;
            if (style & EShapePointsStyle.NON_EXPANDING_WIDTH) {
                if (style & EShapePointsStyle.NON_SHRINKING_WIDTH) {
                    return this.getPixelScale();
                }
                else {
                    return Math.min(1.0, this.getPixelScale());
                }
            }
            else {
                if (style & EShapePointsStyle.NON_SHRINKING_WIDTH) {
                    return Math.max(1.0, this.getPixelScale());
                }
                else {
                    return 1.0;
                }
            }
        };
        EShapeLineBase.prototype.toHitThreshold = function (toThreshold) {
            var stroke = this.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeScale = this.getStrokeWidthScale(this.points);
            return (toThreshold ?
                toThreshold(strokeWidth, strokeScale) :
                strokeWidth * strokeScale * 0.5);
        };
        EShapeLineBase.prototype.containsAbs = function (x, y, ax, ay) {
            var points = this.points;
            var threshold = this.toHitThreshold(null);
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return points.calcHitPointAbs(x, y, ax, ay, threshold, null, this.calcHitPointAbsHitTester, null);
            }
            return false;
        };
        EShapeLineBase.prototype.calcHitPoint = function (point, toHitThreshold, range, tester, result) {
            var points = this.points;
            var threshold = this.toHitThreshold(toHitThreshold);
            var rect = this.toLocalRect(point, EShapeBase.WORK_RECT);
            if (this.containsAbsBBox(rect.x, rect.y, rect.width + threshold, rect.height + threshold)) {
                return points.calcHitPointAbs(rect.x, rect.y, rect.width, rect.height, threshold, range, tester, result);
            }
            return false;
        };
        EShapeLineBase.prototype.calcHitPointAbsHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            // (x, y) = p0 + (p1 - p0) * t where 0 <= t <= 1
            // d0 := p1 - p0
            // d1 := v - p0
            // (p0.x + d0.x * t - x)^2 + (p0.y + d0.y * t - y)^2
            // (d0.x t - d1.x)^2 + (d0.y t - d1.y)^2
            // (d0.x^2 + d0.y^2) t^2 - 2 (d0.x * d1.x + d0.y * d1.y) t + (d1.x^2 + d1.y^2)
            // a := dot( d0, d0 )
            // b := dot( d0, d1 )
            // c := dot( d1, d1 )
            // a t^2 - 2 b t + c = a (t - b / a)^2 + c - b * b / a
            // t0 = b / a  min = c - b * b / a
            var d0x = p1x - p0x;
            var d0y = p1y - p0y;
            var d1x = x - p0x;
            var d1y = y - p0y;
            var a = d0x * d0x + d0y * d0y;
            var b = d0x * d1x + d0y * d1y;
            var c = d1x * d1x + d1y * d1y;
            if (0.0001 < a) {
                var t = Math.max(0, Math.min(1, b / a));
                var d = a * t * t - 2 * b * t + c;
                if (d < threshold * threshold) {
                    return true;
                }
            }
            return false;
        };
        EShapeLineBase.WORK_RANGE = [0, 0];
        return EShapeLineBase;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBar = /** @class */ (function (_super) {
        __extends(EShapeBar, _super);
        function EShapeBar(position, size, width, style) {
            var _this = _super.call(this, EShapeType.BAR) || this;
            _this.fill.enable = false;
            _this.stroke.set(true, undefined, undefined, width);
            _this.points = new EShapeBarPoints(_this, position, size, style);
            return _this;
        }
        EShapeBar.prototype.clone = function () {
            var points = this.points;
            return new EShapeBar(points.position, points.size, this.stroke.width, points.style).copy(this);
        };
        EShapeBar.prototype.containsAbsBBox = function (x, y, ax, ay) {
            var size = Math.max(0, this.points.size);
            return _super.prototype.containsAbsBBox.call(this, x, y, ax + size, ay + size);
        };
        return EShapeBar;
    }(EShapeLineBase));

    var buildColor = function (color, alpha, voffset, vcount, colors) {
        var r = ((color >> 16) & 0xFF) / 255.0 * alpha;
        var g = ((color >> 8) & 0xFF) / 255.0 * alpha;
        var b = ((color >> 0) & 0xFF) / 255.0 * alpha;
        var a = alpha;
        var ic = voffset << 2;
        for (var i = 0; i < vcount; ++i) {
            colors[ic + 0] = r;
            colors[ic + 1] = g;
            colors[ic + 2] = b;
            colors[ic + 3] = a;
            ic += 4;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeUploadedBase = /** @class */ (function () {
        function EShapeUploadedBase(buffer, voffset, ioffset, vcount, icount, antialiasWeight) {
            this.buffer = buffer;
            this.transformLocalId = -1;
            this.vertexOffset = voffset;
            this.vertexCount = vcount;
            this.indexOffset = ioffset;
            this.indexCount = icount;
            this.colorFill = NaN;
            this.alphaFill = -1;
            this.colorStroke = NaN;
            this.alphaStroke = -1;
            this.sizeX = NaN;
            this.sizeY = NaN;
            this.strokeWidth = NaN;
            this.strokeAlign = NaN;
            this.strokeSide = NaN;
            this.radius = NaN;
            this.corner = NaN;
            this.texture = null;
            this.textureTransformId = NaN;
            this.antialiasWeight = antialiasWeight;
        }
        EShapeUploadedBase.prototype.init = function (shape) {
            shape.uploaded = this;
            return this;
        };
        EShapeUploadedBase.prototype.isCompatible = function (shape) {
            return true;
        };
        EShapeUploadedBase.prototype.getBuffer = function () {
            return this.buffer;
        };
        EShapeUploadedBase.prototype.getVertexOffset = function () {
            return this.vertexOffset;
        };
        EShapeUploadedBase.prototype.getVertexCount = function () {
            return this.vertexCount;
        };
        EShapeUploadedBase.prototype.getIndexOffset = function () {
            return this.indexOffset;
        };
        EShapeUploadedBase.prototype.getIndexCount = function () {
            return this.indexCount;
        };
        EShapeUploadedBase.prototype.toTransformLocalId = function (shape) {
            shape.updateTransform();
            return shape.transform.getLocalId();
        };
        EShapeUploadedBase.prototype.toTexture = function (shape) {
            return shape.texture || pixi_js.Texture.WHITE;
        };
        EShapeUploadedBase.prototype.toTextureTransformId = function (texture) {
            var textureAny = texture;
            if (textureAny._uvs == null) {
                texture.updateUvs();
            }
            return textureAny._updateID;
        };
        EShapeUploadedBase.prototype.toTextureUvs = function (texture) {
            return texture._uvs;
        };
        EShapeUploadedBase.prototype.updateColorFill = function (buffer, shape, vertexCount) {
            var fill = shape.fill;
            var isEnabled = shape.visible && fill.enable;
            var color = fill.color;
            var alpha = (isEnabled ? fill.alpha : 0);
            if (color !== this.colorFill || alpha !== this.alphaFill) {
                this.colorFill = color;
                this.alphaFill = alpha;
                buffer.updateColorFills();
                buildColor(color, alpha, this.vertexOffset, vertexCount, buffer.colorFills);
            }
        };
        EShapeUploadedBase.prototype.updateColorStroke = function (buffer, shape, vertexCount) {
            var stroke = shape.stroke;
            var isEnabled = shape.visible && stroke.enable && 0 < stroke.width;
            var color = stroke.color;
            var alpha = (isEnabled ? stroke.alpha : 0);
            if (color !== this.colorStroke || alpha !== this.alphaStroke) {
                this.colorStroke = color;
                this.alphaStroke = alpha;
                buffer.updateColorStrokes();
                buildColor(color, alpha, this.vertexOffset, vertexCount, buffer.colorStrokes);
            }
        };
        EShapeUploadedBase.prototype.updateColorFillAndStroke = function (buffer, shape, vertexCount) {
            this.updateColorFill(buffer, shape, vertexCount);
            this.updateColorStroke(buffer, shape, vertexCount);
        };
        EShapeUploadedBase.prototype.buildUnit = function (builder) {
            var texture = this.texture || pixi_js.Texture.WHITE;
            var baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                var indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        };
        return EShapeUploadedBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextUploaded = /** @class */ (function (_super) {
        __extends(EShapeTextUploaded, _super);
        function EShapeTextUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) {
            var _this = _super.call(this, buffer, voffset, ioffset, vcount, icount, antialiasWeight) || this;
            _this.textSize = NaN;
            _this.textFamily = "auto";
            _this.textValue = "";
            _this.textTexture = null;
            _this.textTextureTransformId = NaN;
            _this.textColor = NaN;
            _this.textAlpha = NaN;
            _this.textWeight = NaN;
            _this.textStyle = NaN;
            _this.textAlignHorizontal = NaN;
            _this.textAlignVertical = NaN;
            _this.textOffsetHorizontal = NaN;
            _this.textOffsetVertical = NaN;
            _this.textOutlineWidth = NaN;
            _this.textOutlineColor = NaN;
            _this.textOutlineAlpha = NaN;
            _this.textSpacingHorizontal = NaN;
            _this.textSpacingVertical = NaN;
            _this.textDirection = NaN;
            _this.textPaddingHorizontal = NaN;
            _this.textPaddingVertical = NaN;
            _this.textClipping = false;
            _this.textVertexOffset = _this.vertexOffset + _this.vertexCount - tvcount;
            _this.textIndexOffset = _this.indexOffset + _this.indexCount - ticount;
            _this.textVertexCount = tvcount;
            _this.textIndexCount = ticount;
            return _this;
        }
        EShapeTextUploaded.prototype.initText = function () {
            var vcount = this.textVertexCount;
            if (0 < vcount) {
                // Clippings
                var buffer = this.buffer;
                var voffset = this.textVertexOffset;
                buffer.updateClippings();
                buildTextClipping(buffer.clippings, voffset, vcount);
                // Indices
                buffer.updateIndices();
                buildTextIndex(buffer.indices, voffset, this.textIndexOffset, this.textIndexCount);
            }
        };
        EShapeTextUploaded.prototype.isCompatible = function (shape) {
            if (_super.prototype.isCompatible.call(this, shape)) {
                return (toTextBufferCount(shape) * TEXT_VERTEX_COUNT === this.textVertexCount);
            }
            return false;
        };
        EShapeTextUploaded.prototype.updateText = function (buffer, shape) {
            var vcount = this.textVertexCount;
            if (0 < vcount) {
                var textAtlas = shape.text.atlas;
                if (textAtlas != null) {
                    this.updateTextVertex(buffer, shape, textAtlas);
                    this.updateTextColorFill(buffer, shape);
                    this.updateTextColorStroke(buffer, shape);
                    this.updateTextStep(buffer, shape);
                }
            }
        };
        EShapeTextUploaded.prototype.updateColor = function (buffer, shape) {
            var vertexCount = this.vertexCount - this.textVertexCount;
            this.updateColorFillAndStroke(buffer, shape, vertexCount);
        };
        EShapeTextUploaded.prototype.updateTextVertex = function (buffer, shape, textAtlas) {
            var text = shape.text;
            var textSize = text.size;
            var textFamily = text.family;
            var textValue = text.value;
            var textStyle = text.style;
            var textAlignHorizontal = text.align.horizontal;
            var textAlignVertical = text.align.vertical;
            var textOffsetHorizontal = text.offset.horizontal;
            var textOffsetVertical = text.offset.vertical;
            var textSpacingHorizontal = text.spacing.horizontal;
            var textSpacingVertical = text.spacing.vertical;
            var textDirection = text.direction;
            var textPaddingHorizontal = text.padding.horizontal;
            var textPaddingVertical = text.padding.vertical;
            var textClipping = text.clipping;
            var textTexture = text.texture || pixi_js.Texture.WHITE;
            var textTextureTransformId = this.toTextureTransformId(textTexture);
            var isCharChanged = (textValue !== this.textValue || textFamily !== this.textFamily);
            var isCharSizeChanged = (textSize !== this.textSize);
            var isCharStyleChanged = (textStyle !== this.textStyle);
            var isCharAlignChanged = (textAlignHorizontal !== this.textAlignHorizontal ||
                textAlignVertical !== this.textAlignVertical);
            var isCharOffsetChanged = (textOffsetHorizontal !== this.textOffsetHorizontal ||
                textOffsetVertical !== this.textOffsetVertical);
            var isCharSpacingChanged = (textSpacingHorizontal !== this.textSpacingHorizontal ||
                textSpacingVertical !== this.textSpacingVertical ||
                textPaddingHorizontal !== this.textPaddingHorizontal ||
                textPaddingVertical !== this.textPaddingVertical);
            var isCharDirectionChanged = (textDirection !== this.textDirection);
            var isClippingChanged = (this.textClipping !== textClipping);
            var isTextureChanged = (textTexture !== this.textTexture ||
                textTextureTransformId !== this.textTextureTransformId);
            if (isCharChanged || isCharSizeChanged || isCharStyleChanged ||
                isCharAlignChanged || isCharOffsetChanged || isCharSpacingChanged ||
                isCharDirectionChanged || isClippingChanged || isTextureChanged) {
                this.textSize = textSize;
                this.textFamily = textFamily;
                this.textValue = textValue;
                this.textStyle = textStyle;
                this.textAlignHorizontal = textAlignHorizontal;
                this.textAlignVertical = textAlignVertical;
                this.textOffsetHorizontal = textOffsetHorizontal;
                this.textOffsetVertical = textOffsetVertical;
                this.textSpacingHorizontal = textSpacingHorizontal;
                this.textSpacingVertical = textSpacingVertical;
                this.textDirection = textDirection;
                this.textPaddingHorizontal = textPaddingHorizontal;
                this.textPaddingVertical = textPaddingVertical;
                this.textClipping = textClipping;
                this.textTexture = textTexture;
                this.textTextureTransformId = textTextureTransformId;
                if (isCharSizeChanged) {
                    // Invalidate the text weight to update the text steps.
                    this.textWeight = NaN;
                }
                // Vertices & UVs
                buffer.updateVertices();
                buffer.updateUvs();
                var shapeSize = shape.size;
                var textWorld = text.world = text.world || new Float32Array(8);
                buildTextVertex(buffer.vertices, buffer.uvs, this.textVertexOffset, this.textVertexCount, 0, 0, shapeSize.x, shapeSize.y, textAtlas, textSize, textValue, textStyle, textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textSpacingHorizontal, textSpacingVertical, textDirection, textPaddingHorizontal, textPaddingVertical, textClipping, textWorld, this.toTextureUvs(textTexture), shape.transform.internalTransform);
            }
        };
        EShapeTextUploaded.prototype.updateTextColorFill = function (buffer, shape) {
            var text = shape.text;
            var color = text.color;
            var alpha = (shape.visible && text.enable ? text.alpha : 0);
            if (color !== this.textColor || alpha !== this.textAlpha) {
                this.textColor = color;
                this.textAlpha = alpha;
                buffer.updateColorFills();
                buildColor(color, alpha, this.textVertexOffset, this.textVertexCount, buffer.colorFills);
            }
        };
        EShapeTextUploaded.prototype.updateTextColorStroke = function (buffer, shape) {
            var text = shape.text;
            var outline = text.outline;
            var color = outline.color;
            var alpha = (shape.visible && text.enable ? outline.alpha : 0);
            if (color !== this.textOutlineColor || alpha !== this.textOutlineAlpha) {
                this.textOutlineColor = color;
                this.textOutlineAlpha = alpha;
                buffer.updateColorStrokes();
                buildColor(color, alpha, this.textVertexOffset, this.textVertexCount, buffer.colorStrokes);
            }
        };
        EShapeTextUploaded.prototype.updateTextStep = function (buffer, shape) {
            var text = shape.text;
            var textOutline = text.outline;
            var textOutlineWidth = (textOutline.enable ? textOutline.width : 0);
            var textWeight = text.weight;
            if (textWeight !== this.textWeight || textOutlineWidth !== this.textOutlineWidth) {
                this.textWeight = textWeight;
                this.textOutlineWidth = textOutlineWidth;
                buffer.updateSteps();
                buildTextStep(buffer.steps, this.textVertexOffset, this.textVertexCount, text.atlas, text.size, textOutlineWidth, textWeight, this.antialiasWeight);
            }
        };
        EShapeTextUploaded.prototype.buildUnit = function (builder) {
            _super.prototype.buildUnit.call(this, builder);
            if (0 < this.textVertexCount) {
                var textTexture = this.textTexture || pixi_js.Texture.WHITE;
                var textBaseTexture = textTexture.baseTexture;
                if (textBaseTexture !== builder.baseTexture) {
                    builder.baseTexture = textBaseTexture;
                    builder.push(textTexture, this.textIndexOffset);
                }
            }
        };
        return EShapeTextUploaded;
    }(EShapeUploadedBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBarUploaded = /** @class */ (function (_super) {
        __extends(EShapeBarUploaded, _super);
        function EShapeBarUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) {
            var _this = _super.call(this, buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) || this;
            _this.pointsId = NaN;
            _this.pointsStyle = EShapePointsStyle.NONE;
            return _this;
        }
        EShapeBarUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Clipping & indices
            var buffer = this.buffer;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            buffer.updateClippings();
            buffer.updateIndices();
            buildBarClipping(buffer.clippings, voffset);
            buildBarIndex(buffer.indices, voffset, ioffset);
            // Text
            this.initText();
            //
            this.update(shape);
            return this;
        };
        EShapeBarUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndColorFill(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeBarUploaded.prototype.updateVertexStepAndColorFill = function (buffer, shape) {
            if (shape instanceof EShapeBar) {
                var size = shape.size;
                var sizeX = size.x;
                var sizeY = size.y;
                var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
                var stroke = shape.stroke;
                var strokeWidth = (stroke.enable ? stroke.width : 0);
                var isStrokeWidthChanged = (strokeWidth !== this.strokeWidth);
                var transformLocalId = this.toTransformLocalId(shape);
                var isTransformChanged = (this.transformLocalId !== transformLocalId);
                var points = shape.points;
                var pointsId = points.id;
                var isPointsIdChanged = (pointsId !== this.pointsId);
                var pointsStyle = points.style;
                var isPointsStyleChanged = (pointsStyle !== this.pointsStyle);
                if (isSizeChanged || isTransformChanged || isStrokeWidthChanged || isPointsIdChanged || isPointsStyleChanged) {
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                    this.strokeWidth = strokeWidth;
                    this.transformLocalId = transformLocalId;
                    this.pointsId = pointsId;
                    this.pointsStyle = pointsStyle;
                    if (isSizeChanged || isTransformChanged) {
                        // Invalidate the text layout to update the text layout.
                        this.textSpacingHorizontal = NaN;
                    }
                    if (isPointsIdChanged) {
                        // Invalidate the texture transform ID to update the UVs
                        this.textureTransformId = NaN;
                    }
                    buffer.updateVertices();
                    buffer.updateSteps();
                    buffer.updateColorFills();
                    buildBarVertexStepAndColorFill(buffer.vertices, buffer.steps, buffer.colorFills, this.vertexOffset, points.values, pointsStyle, points.size, strokeWidth, shape.transform.internalTransform);
                }
            }
        };
        EShapeBarUploaded.prototype.updateColorFillAndStroke = function (buffer, shape, vertexCount) {
            this.updateColorStroke(buffer, shape, vertexCount);
        };
        EShapeBarUploaded.prototype.updateUv = function (buffer, shape) {
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buildBarUv(buffer.uvs, this.vertexOffset, this.toTextureUvs(texture));
            }
        };
        return EShapeBarUploaded;
    }(EShapeTextUploaded));

    var createBarUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = BAR_VERTEX_COUNT + tvcount;
        var icount = BAR_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeBarUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isArray = Array.isArray || (function (target) {
        return Object.prototype.toString.call(target) === "[object Array]";
    });

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isNumber = function (target) {
        return (typeof target === "number") ||
            (Object.prototype.toString.call(target) === "[object Number]");
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionBases = /** @class */ (function () {
        function EShapeActionBases() {
        }
        EShapeActionBases.toBaseFill = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_FILL ? shape : runtime).fill;
        };
        EShapeActionBases.toBaseStroke = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_STROKE ? shape : runtime).stroke;
        };
        EShapeActionBases.toBaseText = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_TEXT ? shape : runtime).text;
        };
        EShapeActionBases.toBaseTextOutline = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_TEXT_OUTLINE ? shape : runtime).text.outline;
        };
        return EShapeActionBases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isFunction = function (target) {
        return (typeof target) === "function";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackground = /** @class */ (function () {
        function DBaseBackground(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            if (options != null && options.background != null) {
                var background = options.background;
                this._color = background.color;
                this._alpha = background.alpha;
            }
        }
        DBaseBackground.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseBackground.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseBackground.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getBackgroundColor(state);
        };
        Object.defineProperty(DBaseBackground.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseBackground.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getBackgroundAlpha(state);
        };
        Object.defineProperty(DBaseBackground.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseBackground.prototype.onChange = function () {
            var callback = this._callback;
            if (callback != null) {
                callback();
            }
        };
        return DBaseBackground;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A border mask.
     * Borders on masked parts are not rendered.
     */
    var DBorderMask;
    (function (DBorderMask) {
        DBorderMask[DBorderMask["NONE"] = 0] = "NONE";
        DBorderMask[DBorderMask["TOP"] = 1] = "TOP";
        DBorderMask[DBorderMask["RIGHT"] = 2] = "RIGHT";
        DBorderMask[DBorderMask["BOTTOM"] = 4] = "BOTTOM";
        DBorderMask[DBorderMask["LEFT"] = 8] = "LEFT";
        DBorderMask[DBorderMask["TOP_RIGHT"] = 3] = "TOP_RIGHT";
        DBorderMask[DBorderMask["TOP_BOTTOM"] = 5] = "TOP_BOTTOM";
        DBorderMask[DBorderMask["TOP_LEFT"] = 9] = "TOP_LEFT";
        DBorderMask[DBorderMask["RIGHT_BOTTOM"] = 6] = "RIGHT_BOTTOM";
        DBorderMask[DBorderMask["RIGHT_LEFT"] = 10] = "RIGHT_LEFT";
        DBorderMask[DBorderMask["BOTTOM_LEFT"] = 12] = "BOTTOM_LEFT";
        DBorderMask[DBorderMask["NOT_TOP"] = 14] = "NOT_TOP";
        DBorderMask[DBorderMask["NOT_RIGHT"] = 13] = "NOT_RIGHT";
        DBorderMask[DBorderMask["NOT_BOTTOM"] = 11] = "NOT_BOTTOM";
        DBorderMask[DBorderMask["NOT_LEFT"] = 7] = "NOT_LEFT";
        DBorderMask[DBorderMask["ALL"] = 15] = "ALL";
    })(DBorderMask || (DBorderMask = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorder = /** @class */ (function () {
        function DBaseBorder(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            if (options != null && options.border != null) {
                var border = options.border;
                this._color = border.color;
                this._alpha = border.alpha;
                this._width = border.width;
                this._align = border.align;
                this._mask = (isString(border.mask) ? DBorderMask[border.mask] : border.mask);
            }
        }
        DBaseBorder.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseBorder.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseBorder.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getBorderColor(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseBorder.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getBorderAlpha(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseBorder.prototype.getWidth = function (state) {
            var width = this._width;
            if (width !== undefined) {
                if (isFunction(width)) {
                    var result = width(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return width;
                }
            }
            return this._theme.getBorderWidth(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseBorder.prototype.getAlign = function (state) {
            var align = this._align;
            if (align !== undefined) {
                if (isFunction(align)) {
                    var result = align(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return align;
                }
            }
            return this._theme.getBorderAlign(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseBorder.prototype.getMask = function (state) {
            var mask = this._mask;
            if (mask !== undefined) {
                if (isFunction(mask)) {
                    var result = mask(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return mask;
                }
            }
            return this._theme.getBorderMask(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseBorder.prototype.onChange = function () {
            var callback = this._callback;
            if (callback != null) {
                callback();
            }
        };
        return DBaseBorder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCornerMask;
    (function (DCornerMask) {
        DCornerMask[DCornerMask["NONE"] = 0] = "NONE";
        DCornerMask[DCornerMask["TOP_LEFT"] = 1] = "TOP_LEFT";
        DCornerMask[DCornerMask["TOP_RIGHT"] = 2] = "TOP_RIGHT";
        DCornerMask[DCornerMask["BOTTOM_LEFT"] = 4] = "BOTTOM_LEFT";
        DCornerMask[DCornerMask["BOTTOM_RIGHT"] = 8] = "BOTTOM_RIGHT";
        DCornerMask[DCornerMask["TOP"] = 3] = "TOP";
        DCornerMask[DCornerMask["BOTTOM"] = 12] = "BOTTOM";
        DCornerMask[DCornerMask["LEFT"] = 5] = "LEFT";
        DCornerMask[DCornerMask["RIGHT"] = 10] = "RIGHT";
        DCornerMask[DCornerMask["ALL"] = 15] = "ALL";
    })(DCornerMask || (DCornerMask = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseCorner = /** @class */ (function () {
        function DBaseCorner(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            if (options != null && options.corner != null) {
                var corner = options.corner;
                if (isNumber(corner)) {
                    this._radius = corner;
                    this._mask = undefined;
                }
                else {
                    this._radius = corner.radius;
                    this._mask = (isString(corner.mask) ? DCornerMask[corner.mask] : corner.mask);
                }
            }
        }
        DBaseCorner.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseCorner.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseCorner.prototype.getRadius = function () {
            var radius = this._radius;
            return (radius !== undefined ? radius : this._theme.getCornerRadius());
        };
        Object.defineProperty(DBaseCorner.prototype, "radius", {
            get: function () {
                return this._radius;
            },
            set: function (radius) {
                if (this._radius !== radius) {
                    this._radius = radius;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseCorner.prototype.getMask = function () {
            var mask = this._mask;
            return (mask !== undefined ? mask : this._theme.getCornerMask());
        };
        Object.defineProperty(DBaseCorner.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseCorner.prototype.set = function (radius, mask) {
            var isChanged = false;
            if (this._radius !== radius) {
                this._radius = radius;
                isChanged = true;
            }
            if (this._mask !== mask) {
                this._mask = mask;
                isChanged = true;
            }
            var callback = this._callback;
            if (isChanged && callback != null) {
                callback();
            }
        };
        return DBaseCorner;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * DBase interactivity.
     * Mouse / touch events are triggered only on interactive objects.
     */
    var DBaseInteractive;
    (function (DBaseInteractive) {
        /**
         * Not interactive.
         */
        DBaseInteractive[DBaseInteractive["NONE"] = 0] = "NONE";
        /**
         * Interactive.
         * However children are not interactive.
         */
        DBaseInteractive[DBaseInteractive["SELF"] = 1] = "SELF";
        /**
         * Not interactive.
         * However children are interactive.
         */
        DBaseInteractive[DBaseInteractive["CHILDREN"] = 2] = "CHILDREN";
        /**
         * Interactive.
         * Children are also interactive.
         */
        DBaseInteractive[DBaseInteractive["BOTH"] = 3] = "BOTH";
    })(DBaseInteractive || (DBaseInteractive = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOutline = /** @class */ (function () {
        function DBaseOutline(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            if (options != null && options.outline != null) {
                var outline = options.outline;
                this._color = outline.color;
                this._alpha = outline.alpha;
                this._width = outline.width;
                this._offset = outline.offset;
                this._align = outline.align;
                this._mask = (isString(outline.mask) ? DBorderMask[outline.mask] : outline.mask);
            }
        }
        DBaseOutline.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseOutline.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseOutline.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getOutlineColor(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseOutline.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getOutlineAlpha(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseOutline.prototype.getWidth = function (state) {
            var width = this._width;
            if (width !== undefined) {
                if (isFunction(width)) {
                    var result = width(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return width;
                }
            }
            return this._theme.getOutlineWidth(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseOutline.prototype.getOffset = function (state) {
            var offset = this._offset;
            if (offset !== undefined) {
                if (isFunction(offset)) {
                    var result = offset(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return offset;
                }
            }
            return this._theme.getOutlineOffset(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "offset", {
            get: function () {
                return this._offset;
            },
            set: function (offset) {
                if (this._offset !== offset) {
                    this._offset = offset;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseOutline.prototype.getAlign = function (state) {
            var align = this._align;
            if (align !== undefined) {
                if (isFunction(align)) {
                    var result = align(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return align;
                }
            }
            return this._theme.getOutlineAlign(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseOutline.prototype.getMask = function (state) {
            var mask = this._mask;
            if (mask !== undefined) {
                if (isFunction(mask)) {
                    var result = mask(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return mask;
                }
            }
            return this._theme.getOutlineMask(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        return DBaseOutline;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePadding = /** @class */ (function () {
        function DBasePadding(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            if (options != null && options.padding != null) {
                var padding = options.padding;
                if (isNumber(padding)) {
                    this._left = padding;
                    this._top = padding;
                    this._right = padding;
                    this._bottom = padding;
                }
                else {
                    this._left = padding.left;
                    this._top = padding.top;
                    this._right = padding.right;
                    this._bottom = padding.bottom;
                }
            }
        }
        DBasePadding.prototype.getTheme = function () {
            return this._theme;
        };
        DBasePadding.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBasePadding.prototype.getLeft = function () {
            var left = this._left;
            return left !== undefined ? left : this._theme.getPaddingLeft();
        };
        Object.defineProperty(DBasePadding.prototype, "left", {
            get: function () {
                return this._left;
            },
            set: function (left) {
                if (this._left !== left) {
                    this._left = left;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBasePadding.prototype.getTop = function () {
            var top = this._top;
            return top !== undefined ? top : this._theme.getPaddingTop();
        };
        Object.defineProperty(DBasePadding.prototype, "top", {
            get: function () {
                return this._top;
            },
            set: function (top) {
                if (this._top !== top) {
                    this._top = top;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBasePadding.prototype.getRight = function () {
            var right = this._right;
            return right !== undefined ? right : this._theme.getPaddingRight();
        };
        Object.defineProperty(DBasePadding.prototype, "right", {
            get: function () {
                return this._right;
            },
            set: function (right) {
                if (this._right !== right) {
                    this._right = right;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBasePadding.prototype.getBottom = function () {
            var bottom = this._bottom;
            return bottom !== undefined ? bottom : this._theme.getPaddingBottom();
        };
        Object.defineProperty(DBasePadding.prototype, "bottom", {
            get: function () {
                return this._bottom;
            },
            set: function (bottom) {
                if (this._bottom !== bottom) {
                    this._bottom = bottom;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBasePadding.prototype.set = function (top, right, bottom, left) {
            if (right == null) {
                this.top = top;
                this.right = top;
                this.bottom = top;
                this.left = top;
            }
            else if (bottom == null) {
                this.top = top;
                this.right = right;
                this.bottom = top;
                this.left = right;
            }
            else if (left == null) {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = right;
            }
            else {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = left;
            }
            if (this._callback != null) {
                this._callback();
            }
        };
        return DBasePadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePoint = /** @class */ (function () {
        function DBasePoint(point, cb, scope) {
            this._point = point;
            this.cb = cb;
        }
        Object.defineProperty(DBasePoint.prototype, "x", {
            get: function () {
                return this._point.x;
            },
            set: function (x) {
                var point = this._point;
                if (point.x !== x) {
                    point.x = x;
                    this.cb.call(this.scope);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBasePoint.prototype, "y", {
            get: function () {
                return this._point.y;
            },
            set: function (y) {
                var point = this._point;
                if (point.y !== y) {
                    point.y = y;
                    this.cb.call(this.scope);
                }
            },
            enumerable: true,
            configurable: true
        });
        DBasePoint.prototype.set = function (x, y) {
            var point = this._point;
            if (point.x !== x || point.y !== y) {
                point.set(x, y);
                this.cb.call(this.scope);
            }
            return this;
        };
        DBasePoint.prototype.copyFrom = function (target) {
            var point = this._point;
            if (point.x !== target.x || point.y !== target.y) {
                point.copyFrom(target);
                this.cb.call(this.scope);
            }
            return this;
        };
        DBasePoint.prototype.copyTo = function (target) {
            return target.copyFrom(this._point);
        };
        DBasePoint.prototype.copy = function () {
            return this.copyFrom(arguments[0]);
        };
        DBasePoint.prototype.clone = function (cb, scope) {
            cb = cb || this.cb;
            scope = scope || this.scope;
            return new DBasePoint(this._point, cb, scope);
        };
        DBasePoint.prototype.equals = function (p) {
            return this._point.equals(p);
        };
        return DBasePoint;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundMeshGeometry = /** @class */ (function (_super) {
        __extends(DBaseBackgroundMeshGeometry, _super);
        function DBaseBackgroundMeshGeometry(texture, width, height, borderSize, cornerMask) {
            var _this = _super.call(this, new Float32Array(56), new Float32Array(56), new Uint16Array(42)) || this;
            _this._width = width;
            _this._height = height;
            _this._texture = texture;
            _this._borderSize = borderSize;
            _this._cornerMask = cornerMask;
            _this._isDirty = true;
            _this._textureId = NaN;
            _this._vertexBuffer = _this.getBuffer("aVertexPosition");
            _this._vertices = _this._vertexBuffer.data;
            _this._uvBuffer = _this.getBuffer("aTextureCoord");
            _this._uvs = _this._uvBuffer.data;
            _this._indexBuffer = _this.getIndex();
            _this._indices = _this._indexBuffer.data;
            return _this;
        }
        Object.defineProperty(DBaseBackgroundMeshGeometry.prototype, "borderSize", {
            get: function () {
                return this._borderSize;
            },
            set: function (borderSize) {
                if (this._borderSize !== borderSize) {
                    this._borderSize = borderSize;
                    this._isDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMeshGeometry.prototype, "cornerMask", {
            get: function () {
                return this._cornerMask;
            },
            set: function (cornerMask) {
                if (this._cornerMask !== cornerMask) {
                    this._cornerMask = cornerMask;
                    this._isDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMeshGeometry.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._isDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMeshGeometry.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (height) {
                if (this._height !== height) {
                    this._height = height;
                    this._isDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMeshGeometry.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            set: function (texture) {
                if (this._texture !== texture) {
                    this._texture = texture;
                    this._isDirty = true;
                    this._textureId = NaN;
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseBackgroundMeshGeometry.prototype.getTextureId = function () {
            return this._texture._updateID;
        };
        DBaseBackgroundMeshGeometry.prototype.fillVertices = function (iv, array, x0, x1, y0, y1) {
            array[iv + 0] = x0;
            array[iv + 1] = y0;
            array[iv + 2] = x1;
            array[iv + 3] = y0;
            array[iv + 4] = x0;
            array[iv + 5] = y1;
            array[iv + 6] = x1;
            array[iv + 7] = y1;
        };
        DBaseBackgroundMeshGeometry.prototype.fillIndices = function (ii, indices, iv) {
            indices[ii + 0] = iv + 0;
            indices[ii + 1] = iv + 1;
            indices[ii + 2] = iv + 2;
            indices[ii + 3] = iv + 1;
            indices[ii + 4] = iv + 3;
            indices[ii + 5] = iv + 2;
        };
        DBaseBackgroundMeshGeometry.prototype.fillUvsCorner = function (iv, uvs, c, u0, u1, u2, u3, v0, v1, v2, v3) {
            if (c) {
                this.fillVertices(iv, uvs, u0, u1, v0, v1);
            }
            else {
                this.fillVertices(iv, uvs, u3, u2, v0, v1);
            }
        };
        DBaseBackgroundMeshGeometry.prototype.fillUvs = function (iv, uvs, u0, u1, v0, v1) {
            this.fillVertices(iv, uvs, u0, u1, v0, v1);
        };
        DBaseBackgroundMeshGeometry.prototype.update = function () {
            var texture = this.texture;
            if (!texture.valid) {
                return;
            }
            var textureId = this.getTextureId();
            if (this._isDirty || this._textureId !== textureId) {
                this._isDirty = false;
                this._textureId = textureId;
                var vertices = this._vertices;
                var uvs = this._uvs;
                var indices = this._indices;
                var width = this._width;
                var height = this._height;
                var borderSize = this._borderSize;
                var x0 = 0;
                var x1 = Math.min(width * 0.5, borderSize);
                var x2 = Math.max(width * 0.5, width - borderSize);
                var x3 = width;
                var y0 = 0;
                var y1 = Math.min(height * 0.5, borderSize);
                var y2 = Math.max(height * 0.5, height - borderSize);
                var y3 = height;
                var textureUvs = texture._uvs;
                var l = textureUvs.x0;
                var r = textureUvs.x1;
                var t = textureUvs.y0;
                var b = textureUvs.y3;
                var w = (r - l) * (borderSize / texture.width);
                var h = (b - t) * (borderSize / texture.height);
                var u0 = l;
                var u1 = l + w;
                var u2 = r - w;
                var u3 = r;
                var v0 = t;
                var v1 = t + h;
                var v2 = b - h;
                var v3 = b;
                var cornerMask = this._cornerMask;
                var ctl = !(cornerMask & DCornerMask.TOP_LEFT);
                var ctr = !(cornerMask & DCornerMask.TOP_RIGHT);
                var cbl = !(cornerMask & DCornerMask.BOTTOM_LEFT);
                var cbr = !(cornerMask & DCornerMask.BOTTOM_RIGHT);
                // Vertices & UVs
                var iv = 0;
                var ia = 0;
                var ii = 0;
                // Top left
                this.fillVertices(iv, vertices, x0, x1, y0, y1);
                this.fillUvsCorner(iv, uvs, ctl, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Top middle
                this.fillVertices(iv, vertices, x1, x2, y0, y1);
                this.fillUvs(iv, uvs, u1, u2, v0, v1);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Top right
                this.fillVertices(iv, vertices, x3, x2, y0, y1);
                this.fillUvsCorner(iv, uvs, ctr, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Middle
                this.fillVertices(iv, vertices, x0, x3, y1, y2);
                this.fillUvs(iv, uvs, u0, u3, v1, v2);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom left
                this.fillVertices(iv, vertices, x0, x1, y3, y2);
                this.fillUvsCorner(iv, uvs, cbl, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom middle
                this.fillVertices(iv, vertices, x1, x2, y2, y3);
                this.fillUvs(iv, uvs, u1, u2, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom right
                this.fillVertices(iv, vertices, x3, x2, y3, y2);
                this.fillUvsCorner(iv, uvs, cbr, u3, u2, u1, u0, v3, v2, v1, v0);
                this.fillIndices(ii, indices, ia);
                this._vertexBuffer.update();
                this._uvBuffer.update();
                this._indexBuffer.update();
            }
        };
        return DBaseBackgroundMeshGeometry;
    }(pixi_js.MeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundMesh = /** @class */ (function (_super) {
        __extends(DBaseBackgroundMesh, _super);
        function DBaseBackgroundMesh(texture, borderSize, cornerMask) {
            return _super.call(this, new DBaseBackgroundMeshGeometry(texture, 100, 100, borderSize, cornerMask), new pixi_js.MeshMaterial(texture)) || this;
        }
        Object.defineProperty(DBaseBackgroundMesh.prototype, "texture", {
            get: function () {
                return this.shader.texture;
            },
            set: function (texture) {
                if (this.shader.texture !== texture) {
                    this.shader.texture = texture;
                    this.geometry.texture = texture;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "width", {
            get: function () {
                return this.geometry.width;
            },
            set: function (width) {
                this.geometry.width = width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "height", {
            get: function () {
                return this.geometry.height;
            },
            set: function (height) {
                this.geometry.height = height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "borderSize", {
            get: function () {
                return this.geometry.cornerMask;
            },
            set: function (borderSize) {
                this.geometry.borderSize = borderSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "cornerMask", {
            get: function () {
                return this.geometry.cornerMask;
            },
            set: function (cornerMask) {
                this.geometry.cornerMask = cornerMask;
            },
            enumerable: true,
            configurable: true
        });
        DBaseBackgroundMesh.prototype._render = function (renderer) {
            this.geometry.update();
            _super.prototype._render.call(this, renderer);
        };
        DBaseBackgroundMesh.prototype.update = function () {
            this.geometry.update();
        };
        return DBaseBackgroundMesh;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderMeshGeometry = /** @class */ (function (_super) {
        __extends(DBaseBorderMeshGeometry, _super);
        function DBaseBorderMeshGeometry(texture, width, height, borderSize, borderMask, cornerMask) {
            var _this = _super.call(this, new Float32Array(64), new Float32Array(64), new Uint16Array(48)) || this;
            _this._width = width;
            _this._height = height;
            _this._texture = texture;
            _this._borderSize = borderSize;
            _this._borderMask = borderMask;
            _this._cornerMask = cornerMask;
            _this._isDirty = true;
            _this._textureId = NaN;
            _this._vertexBuffer = _this.getBuffer("aVertexPosition");
            _this._vertices = _this._vertexBuffer.data;
            _this._uvBuffer = _this.getBuffer("aTextureCoord");
            _this._uvs = _this._uvBuffer.data;
            _this._indexBuffer = _this.getIndex();
            _this._indices = _this._indexBuffer.data;
            return _this;
        }
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "borderMask", {
            get: function () {
                return this._borderMask;
            },
            set: function (borderMask) {
                if (this._borderMask !== borderMask) {
                    this._borderMask = borderMask;
                    this._isDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "cornerMask", {
            get: function () {
                return this._cornerMask;
            },
            set: function (cornerMask) {
                if (this._cornerMask !== cornerMask) {
                    this._cornerMask = cornerMask;
                    this._isDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "borderSize", {
            get: function () {
                return this._borderSize;
            },
            set: function (borderSize) {
                if (this._borderSize !== borderSize) {
                    this._borderSize = borderSize;
                    this._isDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._isDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (height) {
                if (this._height !== height) {
                    this._height = height;
                    this._isDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            set: function (texture) {
                if (this._texture !== texture) {
                    this._texture = texture;
                    this._isDirty = true;
                    this._textureId = NaN;
                }
            },
            enumerable: true,
            configurable: true
        });
        DBaseBorderMeshGeometry.prototype.fillVertices = function (iv, array, x0, x1, y0, y1) {
            array[iv + 0] = x0;
            array[iv + 1] = y0;
            array[iv + 2] = x1;
            array[iv + 3] = y0;
            array[iv + 4] = x0;
            array[iv + 5] = y1;
            array[iv + 6] = x1;
            array[iv + 7] = y1;
        };
        DBaseBorderMeshGeometry.prototype.fillIndices = function (ii, indices, iv) {
            indices[ii + 0] = iv + 0;
            indices[ii + 1] = iv + 1;
            indices[ii + 2] = iv + 2;
            indices[ii + 3] = iv + 1;
            indices[ii + 4] = iv + 3;
            indices[ii + 5] = iv + 2;
        };
        DBaseBorderMeshGeometry.prototype.fillUvsCorner = function (iv, uvs, b1, b2, c, u0, u1, u2, u3, v0, v1, v2, v3) {
            if (b1 || b2) {
                if (c) {
                    this.fillVertices(iv, uvs, u0, u1, v0, v1);
                }
                else if (b1 && b2) {
                    this.fillVertices(iv, uvs, u3, u2, v0, v1);
                }
                else if (b1) {
                    this.fillVertices(iv, uvs, u1, u2, v0, v1);
                }
                else {
                    this.fillVertices(iv, uvs, u0, u1, v1, v2);
                }
            }
            else {
                this.fillVertices(iv, uvs, u1, u1, v1, v1);
            }
        };
        DBaseBorderMeshGeometry.prototype.fillUvs = function (iv, uvs, b, u0, u1, v0, v1, uz, vz) {
            if (b) {
                this.fillVertices(iv, uvs, u0, u1, v0, v1);
            }
            else {
                this.fillVertices(iv, uvs, uz, uz, vz, vz);
            }
        };
        DBaseBorderMeshGeometry.prototype.update = function () {
            var texture = this._texture;
            if (!texture.valid) {
                return;
            }
            var textureId = texture._updateID;
            if (this._isDirty || this._textureId !== textureId) {
                this._isDirty = false;
                this._textureId = textureId;
                var vertices = this._vertices;
                var uvs = this._uvs;
                var indices = this._indices;
                var width = this._width;
                var height = this._height;
                var borderSize = this._borderSize;
                var x0 = 0;
                var x1 = Math.min(width * 0.5, borderSize);
                var x2 = Math.max(width * 0.5, width - borderSize);
                var x3 = width;
                var y0 = 0;
                var y1 = Math.min(height * 0.5, borderSize);
                var y2 = Math.max(height * 0.5, height - borderSize);
                var y3 = height;
                var textureUvs = texture._uvs;
                var l = textureUvs.x0;
                var r = textureUvs.x1;
                var t = textureUvs.y0;
                var b = textureUvs.y3;
                var w = (r - l) * (borderSize / texture.width);
                var h = (b - t) * (borderSize / texture.height);
                var u0 = l;
                var u1 = l + w;
                var u2 = r - w;
                var u3 = r;
                var v0 = t;
                var v1 = t + h;
                var v2 = b - h;
                var v3 = b;
                var borderMask = this._borderMask;
                var bt = !(borderMask & DBorderMask.TOP);
                var bb = !(borderMask & DBorderMask.BOTTOM);
                var bl = !(borderMask & DBorderMask.LEFT);
                var br = !(borderMask & DBorderMask.RIGHT);
                var cornerMask = this._cornerMask;
                var ctl = !(cornerMask & DCornerMask.TOP_LEFT);
                var ctr = !(cornerMask & DCornerMask.TOP_RIGHT);
                var cbl = !(cornerMask & DCornerMask.BOTTOM_LEFT);
                var cbr = !(cornerMask & DCornerMask.BOTTOM_RIGHT);
                // Vertices & UVs
                var iv = 0;
                var ia = 0;
                var ii = 0;
                // Top left
                this.fillVertices(iv, vertices, x0, x1, y0, y1);
                this.fillUvsCorner(iv, uvs, bt, bl, ctl, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Top middle
                this.fillVertices(iv, vertices, x1, x2, y0, y1);
                this.fillUvs(iv, uvs, bt, u1, u2, v0, v1, u1, v1);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Top right
                this.fillVertices(iv, vertices, x3, x2, y0, y1);
                this.fillUvsCorner(iv, uvs, bt, br, ctr, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Middle left
                this.fillVertices(iv, vertices, x0, x1, y1, y2);
                this.fillUvs(iv, uvs, bl, u0, u1, v1, v2, u1, v1);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Middle right
                this.fillVertices(iv, vertices, x2, x3, y1, y2);
                this.fillUvs(iv, uvs, br, u2, u3, v1, v2, u2, v2);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom left
                this.fillVertices(iv, vertices, x0, x1, y3, y2);
                this.fillUvsCorner(iv, uvs, bb, bl, cbl, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom middle
                this.fillVertices(iv, vertices, x1, x2, y2, y3);
                this.fillUvs(iv, uvs, bb, u1, u2, v2, v3, u2, v2);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom right
                this.fillVertices(iv, vertices, x3, x2, y3, y2);
                this.fillUvsCorner(iv, uvs, bb, br, cbr, u3, u2, u1, u0, v3, v2, v1, v0);
                this.fillIndices(ii, indices, ia);
                this._vertexBuffer.update();
                this._uvBuffer.update();
                this._indexBuffer.update();
            }
        };
        return DBaseBorderMeshGeometry;
    }(pixi_js.MeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderMesh = /** @class */ (function (_super) {
        __extends(DBaseBorderMesh, _super);
        function DBaseBorderMesh(texture, borderSize, borderMask, cornerMask) {
            return _super.call(this, new DBaseBorderMeshGeometry(texture, 100, 100, borderSize, borderMask, cornerMask), new pixi_js.MeshMaterial(texture)) || this;
        }
        Object.defineProperty(DBaseBorderMesh.prototype, "texture", {
            get: function () {
                return this.shader.texture;
            },
            set: function (texture) {
                if (this.shader.texture !== texture) {
                    this.shader.texture = texture;
                    this.geometry.texture = texture;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "width", {
            get: function () {
                return this.geometry.width;
            },
            set: function (width) {
                this.geometry.width = width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "height", {
            get: function () {
                return this.geometry.height;
            },
            set: function (height) {
                this.geometry.height = height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "borderSize", {
            get: function () {
                return this.geometry.borderSize;
            },
            set: function (borderSize) {
                this.geometry.borderSize = borderSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "borderMask", {
            get: function () {
                return this.geometry.borderMask;
            },
            set: function (borderMask) {
                this.geometry.borderMask = borderMask;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "cornerMask", {
            get: function () {
                return this.geometry.cornerMask;
            },
            set: function (cornerMask) {
                this.geometry.cornerMask = cornerMask;
            },
            enumerable: true,
            configurable: true
        });
        DBaseBorderMesh.prototype._render = function (renderer) {
            this.geometry.update();
            _super.prototype._render.call(this, renderer);
        };
        DBaseBorderMesh.prototype.update = function () {
            this.geometry.update();
        };
        return DBaseBorderMesh;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOutlineMesh = /** @class */ (function (_super) {
        __extends(DBaseOutlineMesh, _super);
        function DBaseOutlineMesh() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DBaseOutlineMesh;
    }(DBaseBorderMesh));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseReflowable = /** @class */ (function () {
        function DBaseReflowable(base) {
            var theme = base.theme;
            var corner = base.corner;
            var cornerRadius = corner.getRadius();
            var cornerHeight = cornerRadius + 1;
            var cornerMask = corner.getMask();
            var backgroundPlane = this._backgroundPlane = new DBaseBackgroundMesh(theme.getBackgroundTexture(cornerRadius), cornerHeight, cornerMask);
            base.appendRenderable(backgroundPlane, true);
            var state = base.state;
            var border = base.border;
            var borderWidth = border.getWidth(state);
            var borderMask = border.getMask(state);
            var borderPlane = this._borderPlane = new DBaseBorderMesh(theme.getBorderTexture(cornerRadius, borderWidth), cornerHeight, borderMask, cornerMask);
            base.appendRenderable(borderPlane, false);
            var outline = base.outline;
            var outlineWidth = outline.getWidth(state);
            var outlineMask = outline.getMask(state);
            var outlinePlane = this._outlinePlane = new DBaseOutlineMesh(theme.getBorderTexture(cornerRadius, outlineWidth), cornerHeight, outlineMask, cornerMask);
            base.appendRenderable(outlinePlane, false);
            this._lastBackgroundCornerRadius = cornerRadius;
            this._lastBorderCornerRadius = cornerRadius;
            this._lastBorderWidth = borderWidth;
            this._lastOutlineCornerRadius = cornerRadius;
            this._lastOutlineWidth = outlineWidth;
            base.addReflowable(this);
        }
        DBaseReflowable.prototype.onReflow = function (base, width, height) {
            var theme = base.theme;
            var state = base.state;
            var corner = base.corner;
            var cornerRadius = corner.getRadius();
            var cornerHeight = cornerRadius + 1;
            var cornerMask = corner.getMask();
            // Background
            var background = base.background;
            var backgroundPlane = this._backgroundPlane;
            var backgroundColor = background.getColor(state);
            if (backgroundColor != null) {
                var backgroundAlpha = background.getAlpha(state);
                if (0 < backgroundAlpha) {
                    if (this._lastBackgroundCornerRadius !== cornerRadius) {
                        this._lastBackgroundCornerRadius = cornerRadius;
                        backgroundPlane.texture = theme.getBackgroundTexture(cornerRadius);
                        backgroundPlane.borderSize = cornerHeight;
                    }
                    backgroundPlane.tint = backgroundColor;
                    backgroundPlane.alpha = backgroundAlpha;
                    backgroundPlane.width = width;
                    backgroundPlane.height = height;
                    backgroundPlane.cornerMask = cornerMask;
                    backgroundPlane.visible = true;
                }
                else {
                    backgroundPlane.visible = false;
                }
            }
            else {
                backgroundPlane.visible = false;
            }
            // Border
            var border = base.border;
            var borderPlane = this._borderPlane;
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                if (0 < borderAlpha) {
                    var borderWidth = border.getWidth(state);
                    if (this._lastBorderCornerRadius !== cornerRadius || this._lastBorderWidth !== borderWidth) {
                        this._lastBorderCornerRadius = cornerRadius;
                        this._lastBorderWidth = borderWidth;
                        borderPlane.texture = theme.getBorderTexture(cornerRadius, borderWidth);
                        borderPlane.borderSize = cornerHeight;
                    }
                    var borderAlign = border.getAlign(state);
                    var borderMask = border.getMask(state);
                    borderPlane.tint = borderColor;
                    borderPlane.alpha = borderAlpha;
                    var borderOffset = borderAlign * borderWidth;
                    borderPlane.x = -borderOffset;
                    borderPlane.y = -borderOffset;
                    borderPlane.width = width + borderOffset * 2;
                    borderPlane.height = height + borderOffset * 2;
                    borderPlane.borderMask = borderMask;
                    borderPlane.cornerMask = cornerMask;
                    borderPlane.visible = true;
                }
                else {
                    borderPlane.visible = false;
                }
            }
            else {
                borderPlane.visible = false;
            }
            // Outline
            var outline = base.outline;
            var outlinePlane = this._outlinePlane;
            var outlineColor = outline.getColor(state);
            if (outlineColor != null) {
                var outlineAlpha = outline.getAlpha(state);
                if (0 < outlineAlpha) {
                    var outlineWidth = outline.getWidth(state);
                    if (this._lastOutlineCornerRadius !== cornerRadius || this._lastOutlineWidth !== outlineWidth) {
                        this._lastOutlineCornerRadius = cornerRadius;
                        this._lastOutlineWidth = outlineWidth;
                        outlinePlane.texture = theme.getBorderTexture(cornerRadius, outlineWidth);
                        outlinePlane.borderSize = cornerHeight;
                    }
                    var outlineMask = outline.getMask(state);
                    var outlineOffset = outline.getOffset(state);
                    var outlineAlign = outline.getAlign(state);
                    outlinePlane.tint = outlineColor;
                    outlinePlane.alpha = outlineAlpha;
                    var outlineOffsetAccumulative = outlineOffset + outlineAlign * outlineWidth;
                    outlinePlane.x = -outlineOffsetAccumulative;
                    outlinePlane.y = -outlineOffsetAccumulative;
                    outlinePlane.width = width + outlineOffsetAccumulative * 2;
                    outlinePlane.height = height + outlineOffsetAccumulative * 2;
                    outlinePlane.borderMask = outlineMask;
                    outlinePlane.cornerMask = cornerMask;
                    outlinePlane.visible = true;
                }
                else {
                    outlinePlane.visible = false;
                }
            }
            else {
                outlinePlane.visible = false;
            }
        };
        return DBaseReflowable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseStates = /** @class */ (function () {
        function DBaseStates() {
        }
        DBaseStates.is = function (target, state) {
            return !!(target & state);
        };
        DBaseStates.isHovered = function (target) {
            return !!(target & DBaseState.HOVERED);
        };
        DBaseStates.isDragging = function (target) {
            return !!(target & DBaseState.DRAGGING);
        };
        DBaseStates.isFocused = function (target) {
            return !!(target & DBaseState.FOCUSED);
        };
        DBaseStates.isFocusedIn = function (target) {
            return !!(target & (DBaseState.FOCUSED | DBaseState.FOCUSED_IN));
        };
        DBaseStates.isActive = function (target) {
            return !!(target & DBaseState.ACTIVE);
        };
        DBaseStates.isActiveIn = function (target) {
            return !!(target & (DBaseState.ACTIVE | DBaseState.ACTIVE_IN));
        };
        DBaseStates.isNotActive = function (state) {
            return (!!(state & DBaseState.DISABLED)) || (!(state & DBaseState.ACTIVE));
        };
        DBaseStates.isPressed = function (target) {
            return !!(target & DBaseState.PRESSED);
        };
        DBaseStates.isDisabled = function (target) {
            return !!(target & DBaseState.DISABLED);
        };
        DBaseStates.isReadOnly = function (target) {
            return !!(target & DBaseState.READ_ONLY);
        };
        DBaseStates.isActionable = function (target) {
            return !(target & (DBaseState.DISABLED | DBaseState.READ_ONLY));
        };
        DBaseStates.isInvalid = function (target) {
            return !!(target & DBaseState.INVALID);
        };
        DBaseStates.isSucceeded = function (target) {
            return !!(target & DBaseState.SUCCEEDED);
        };
        DBaseStates.isFailed = function (target) {
            return !!(target & DBaseState.FAILED);
        };
        DBaseStates.bind = function (destination, destinationState, source, when) {
            destination.setState(destinationState, when(source.state));
            source.on("statechange", function (newSourceState) {
                destination.setState(destinationState, when(newSourceState));
            });
        };
        DBaseStates.disable = function (destination, source, when) {
            if (when === void 0) { when = DBaseStates.isNotActive; }
            DBaseStates.bind(destination, DBaseState.DISABLED, source, when);
        };
        return DBaseStates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutClearType;
    (function (DLayoutClearType) {
        DLayoutClearType[DLayoutClearType["NONE"] = 0] = "NONE";
        DLayoutClearType[DLayoutClearType["BEFORE"] = 1] = "BEFORE";
        DLayoutClearType[DLayoutClearType["AFTER"] = 2] = "AFTER";
        DLayoutClearType[DLayoutClearType["BOTH"] = 3] = "BOTH";
    })(DLayoutClearType || (DLayoutClearType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var NodeType;
    (function (NodeType) {
        // Parensesis
        NodeType[NodeType["OPEN"] = 0] = "OPEN";
        NodeType[NodeType["CLOSE"] = 1] = "CLOSE";
        NodeType[NodeType["PARENSESIS"] = 2] = "PARENSESIS";
        // Operations
        NodeType[NodeType["ADD_OR_PLUS"] = 3] = "ADD_OR_PLUS";
        NodeType[NodeType["SUB_OR_MINUS"] = 4] = "SUB_OR_MINUS";
        NodeType[NodeType["PLUS"] = 5] = "PLUS";
        NodeType[NodeType["MINUS"] = 6] = "MINUS";
        NodeType[NodeType["ADD"] = 7] = "ADD";
        NodeType[NodeType["SUB"] = 8] = "SUB";
        NodeType[NodeType["MUL"] = 9] = "MUL";
        NodeType[NodeType["DIV"] = 10] = "DIV";
        // Functions
        NodeType[NodeType["MIN"] = 11] = "MIN";
        NodeType[NodeType["MAX"] = 12] = "MAX";
        NodeType[NodeType["COMMA"] = 13] = "COMMA";
        // Literals
        NodeType[NodeType["PARENT"] = 14] = "PARENT";
        NodeType[NodeType["SELF"] = 15] = "SELF";
        NodeType[NodeType["PADDING"] = 16] = "PADDING";
        NodeType[NodeType["CURRENT"] = 17] = "CURRENT";
        NodeType[NodeType["NUMBER"] = 18] = "NUMBER";
    })(NodeType || (NodeType = {}));
    var TOKEN_MAPPING_OPERATOR = {
        "+": 3 /* ADD_OR_PLUS */,
        "-": 4 /* SUB_OR_MINUS */,
        "*": 9 /* MUL */,
        "/": 10 /* DIV */,
        "(": 0 /* OPEN */,
        ")": 1 /* CLOSE */,
        ",": 13 /* COMMA */,
        "min": 11 /* MIN */,
        "max": 12 /* MAX */
    };
    var TOKEN_MAPPING_LITERAL = {
        "%": 14 /* PARENT */,
        "s": 15 /* SELF */,
        "p": 16 /* PADDING */,
        "c": 17 /* CURRENT */
    };
    /**
     * Parser and evaluator of the scalar expressions like `100% - 50s`.
     *
     * Literals
     *
     * * x%: 0.01 * x * parent value
     * * xs: 0.01 * x * self value
     * * xp: 0.01 * x * padding value
     * * xc: 0.01 * x * current value
     *
     * Operators
     *
     * * `+`
     * * `-`
     * * `*`
     * * `/`
     * * `(` and `)`
     *
     * Functions
     *
     * * min( a, b, ... )
     * * max( a, b, ... )
     *
     * Examples
     *
     * * `90%`: 0.9 * parent value
     * * `50s`: 0.5 * self value
     * * `90% - 50s`: 0.9 * parent value - 0.5 * self value
     * * `90% - (50s + 100) * 2`: 0.9 * parent value - ( 0.5 * self value + 100 ) * 2
     */
    var DScalarExpression = /** @class */ (function () {
        function DScalarExpression(expression) {
            var nodes = this.toToken(expression);
            var i = 0;
            do {
                i = this.toParensesis(nodes, i);
            } while (i < nodes.length);
            this.toUnary(nodes);
            this.toArithmetic(nodes, 9 /* MUL */, 10 /* DIV */);
            this.toArithmetic(nodes, 7 /* ADD */, 8 /* SUB */);
            if (nodes.length === 1) {
                var node = nodes[0];
                if (!isNumber(node)) {
                    this._node = node;
                    return;
                }
            }
            throw new Error("Failed to parse '" + expression + "'");
        }
        DScalarExpression.prototype.toParensesis = function (nodes, ifrom) {
            var ito = nodes.length;
            for (var i = ifrom; i < ito; ++i) {
                var inode = nodes[i];
                if (inode === 0 /* OPEN */) {
                    var istart = i;
                    var nodeType = 2 /* PARENSESIS */;
                    if (0 < i) {
                        var nodeTypePrev = nodes[i - 1];
                        if (nodeTypePrev === 11 /* MIN */ || nodeTypePrev === 12 /* MAX */) {
                            istart -= 1;
                            nodeType = nodeTypePrev;
                        }
                    }
                    for (var j = i + 1; j < ito; ++j) {
                        var jnode = nodes[j];
                        if (jnode === 1 /* CLOSE */) {
                            nodes[istart] = [nodeType, this.toComma(nodes, i + 1, j)];
                            nodes.splice(istart + 1, j - istart);
                            return istart + 1;
                        }
                        else if (jnode === 0 /* OPEN */) {
                            j = this.toParensesis(nodes, j) - 1;
                            ito = nodes.length;
                        }
                    }
                    throw new Error("Malformed parensesis");
                }
            }
            return ito;
        };
        DScalarExpression.prototype.toCommaOf = function (nodes, ifrom, ito) {
            var l = ito - ifrom;
            if (l <= 0) {
                return [18 /* NUMBER */, 0];
            }
            else if (l <= 1) {
                return nodes[ifrom];
            }
            else {
                var operand = [];
                for (var j = ifrom; j < ito; ++j) {
                    operand.push(nodes[j]);
                }
                return [2 /* PARENSESIS */, operand];
            }
        };
        DScalarExpression.prototype.toComma = function (nodes, ifrom, ito) {
            var result = null;
            var iprev = ifrom;
            for (var i = ifrom; i < ito; ++i) {
                var node = nodes[i];
                if (node === 13 /* COMMA */) {
                    result = result || [];
                    result.push(this.toCommaOf(nodes, iprev, i));
                    iprev = i + 1;
                }
            }
            if (iprev < ito) {
                if (result == null) {
                    var operand = [];
                    for (var i = iprev; i < ito; ++i) {
                        operand.push(nodes[i]);
                    }
                    return operand;
                }
                else {
                    result.push(this.toCommaOf(nodes, iprev, ito));
                }
            }
            return result || [];
        };
        DScalarExpression.prototype.toUnaryNode = function (node) {
            if (!isNumber(node)) {
                if (node[0] === 2 /* PARENSESIS */ ||
                    node[0] === 11 /* MIN */ ||
                    node[0] === 12 /* MAX */) {
                    this.toUnary(node[1]);
                }
            }
        };
        DScalarExpression.prototype.toUnary = function (nodes) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (node === 3 /* ADD_OR_PLUS */ || node === 4 /* SUB_OR_MINUS */) {
                    if (i <= 0 || isNumber(nodes[i - 1])) {
                        if (i + 1 < imax && !isNumber(nodes[i + 1])) {
                            var operand = nodes.splice(i + 1, 1)[0];
                            var type = (node === 3 /* ADD_OR_PLUS */ ? 5 /* PLUS */ : 6 /* MINUS */);
                            nodes[i] = [type, operand];
                            imax = nodes.length;
                            this.toUnaryNode(operand);
                        }
                        else {
                            throw new Error("Malformed unary operator");
                        }
                    }
                    else {
                        var type = (node === 3 /* ADD_OR_PLUS */ ? 7 /* ADD */ : 8 /* SUB */);
                        nodes[i] = type;
                    }
                }
                else {
                    this.toUnaryNode(node);
                    imax = nodes.length;
                }
            }
        };
        DScalarExpression.prototype.toArithmeticNode = function (node, operatorA, operatorB) {
            if (!isNumber(node)) {
                if (node[0] === 2 /* PARENSESIS */ || node[0] === 11 /* MIN */ || node[0] === 12 /* MAX */) {
                    this.toArithmetic(node[1], operatorA, operatorB);
                }
                else if (node[0] === 5 /* PLUS */ || node[0] === 6 /* MINUS */) {
                    this.toArithmeticNode(node[1], operatorA, operatorB);
                }
                else if (node[0] === 7 /* ADD */ || node[0] === 8 /* SUB */ ||
                    node[0] === 9 /* MUL */ || node[0] === 10 /* DIV */) {
                    this.toArithmeticNode(node[1], operatorA, operatorB);
                    this.toArithmeticNode(node[2], operatorA, operatorB);
                }
            }
        };
        DScalarExpression.prototype.toArithmetic = function (nodes, operatorA, operatorB) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (node === operatorA || node === operatorB) {
                    if (0 < i && i + 1 < imax) {
                        var left = nodes[i - 1];
                        var right = nodes[i + 1];
                        if (!isNumber(left) && !isNumber(right)) {
                            nodes.splice(i, 2);
                            nodes[i - 1] = [node, left, right];
                            i -= 1;
                            imax = nodes.length;
                            this.toArithmeticNode(left, operatorA, operatorB);
                            this.toArithmeticNode(right, operatorA, operatorB);
                            continue;
                        }
                    }
                    throw new Error("Malformed operands for the operator " + node);
                }
                else {
                    this.toArithmeticNode(node, operatorA, operatorB);
                    imax = nodes.length;
                }
            }
        };
        DScalarExpression.prototype.toToken = function (expression) {
            var tokens = [];
            while (true) {
                var matched = DScalarExpression.TOKEN_REGEX.exec(expression);
                if (matched != null) {
                    var token = matched[0];
                    var tokenTypeOperator = TOKEN_MAPPING_OPERATOR[token];
                    if (tokenTypeOperator != null) {
                        tokens.push(tokenTypeOperator);
                    }
                    else {
                        var parsedToken = parseFloat(token);
                        if (parsedToken !== parsedToken) {
                            throw new Error("Unexpected token '" + token + "' at " + matched.index + " in '" + expression + "'");
                        }
                        var tokenTypeLiteral = TOKEN_MAPPING_LITERAL[token[token.length - 1]];
                        if (tokenTypeLiteral != null) {
                            tokens.push([tokenTypeLiteral, parsedToken * 0.01]);
                        }
                        else {
                            tokens.push([18 /* NUMBER */, parsedToken]);
                        }
                    }
                }
                else {
                    break;
                }
            }
            return tokens;
        };
        DScalarExpression.prototype.evaluate = function (node, parent, self, padding, current) {
            switch (node[0]) {
                case 2 /* PARENSESIS */:
                    var nodes = node[1];
                    return this.evaluate(nodes[nodes.length - 1], parent, self, padding, current);
                // Unary operators
                case 5 /* PLUS */:
                    return +this.evaluate(node[1], parent, self, padding, current);
                case 6 /* MINUS */:
                    return -this.evaluate(node[1], parent, self, padding, current);
                // Four arithmetic operators
                case 7 /* ADD */:
                    return this.evaluate(node[1], parent, self, padding, current) +
                        this.evaluate(node[2], parent, self, padding, current);
                case 8 /* SUB */:
                    return this.evaluate(node[1], parent, self, padding, current) -
                        this.evaluate(node[2], parent, self, padding, current);
                case 9 /* MUL */:
                    return this.evaluate(node[1], parent, self, padding, current) *
                        this.evaluate(node[2], parent, self, padding, current);
                case 10 /* DIV */:
                    return this.evaluate(node[1], parent, self, padding, current) /
                        this.evaluate(node[2], parent, self, padding, current);
                // Functions
                case 11 /* MIN */:
                    if (0 < node[1].length) {
                        var args = node[1];
                        var result = this.evaluate(args[0], parent, self, padding, current);
                        for (var i = 1, imax = args.length; i < imax; ++i) {
                            result = Math.min(result, this.evaluate(args[i], parent, self, padding, current));
                        }
                        return result;
                    }
                    return 0;
                case 12 /* MAX */:
                    if (0 < node[1].length) {
                        var args = node[1];
                        var result = this.evaluate(args[0], parent, self, padding, current);
                        for (var i = 1, imax = args.length; i < imax; ++i) {
                            result = Math.max(result, this.evaluate(args[i], parent, self, padding, current));
                        }
                        return result;
                    }
                    return 0;
                // Literals
                case 14 /* PARENT */:
                    return node[1] * parent;
                case 15 /* SELF */:
                    return node[1] * self;
                case 16 /* PADDING */:
                    return node[1] * padding;
                case 17 /* CURRENT */:
                    return node[1] * current;
                case 18 /* NUMBER */:
                    return node[1];
            }
            return 0;
        };
        DScalarExpression.prototype.calculate = function (parent, self, padding, current) {
            return this.evaluate(this._node, parent, self, padding, current);
        };
        DScalarExpression.TOKEN_REGEX = /(?:\+|-|\*|\/|\(|\)|min|max|,|(?:\d+(?:\.\d*)?[%psc]?))/g;
        return DScalarExpression;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var POSITION_CENTER = function (p, s) { return (p - s) * 0.5; };
    var POSITION_PADDING = function (p, s, d) { return d; };
    var SIZE_MAXIMIZED = function (p) { return p; };
    var SIZE_PADDING = function (p, s, d) { return p - d; };
    var DScalarFunctions = /** @class */ (function () {
        function DScalarFunctions() {
        }
        DScalarFunctions.position = function (coordinate) {
            if (coordinate == null || isNumber(coordinate)) {
                return null;
            }
            else if (isString(coordinate)) {
                switch (coordinate) {
                    case "center":
                    case "CENTER":
                        return POSITION_CENTER;
                    case "padding":
                    case "PADDING":
                        return POSITION_PADDING;
                }
                var scalarExpression_1 = new DScalarExpression(coordinate);
                return function (parent, self, padding, current) {
                    return scalarExpression_1.calculate(parent, self, padding, current);
                };
            }
            else if (isFunction(coordinate)) {
                return coordinate;
            }
            else {
                var scalar_1 = coordinate;
                return function (parent, self, padding, current) {
                    return scalar_1.calculate(parent, self, padding, current);
                };
            }
        };
        DScalarFunctions.size = function (coordinate) {
            if (coordinate == null || isNumber(coordinate)) {
                return null;
            }
            else if (isString(coordinate)) {
                switch (coordinate) {
                    case "100%":
                    case "maximized":
                    case "MAXIMIZED":
                        return SIZE_MAXIMIZED;
                    case "padding":
                    case "PADDING":
                        return SIZE_PADDING;
                }
                var scalarExpression_2 = new DScalarExpression(coordinate);
                return function (parent, self, padding, current) {
                    return scalarExpression_2.calculate(parent, self, padding, current);
                };
            }
            else if (isFunction(coordinate)) {
                return coordinate;
            }
            else {
                var scalar_2 = coordinate;
                return function (parent, self, padding, current) {
                    return scalar_2.calculate(parent, self, padding, current);
                };
            }
        };
        return DScalarFunctions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DThemes = /** @class */ (function () {
        function DThemes() {
        }
        DThemes.setDefaultThemeClass = function (theme) {
            this.DEFAULT_THEME_CLASS = theme;
        };
        DThemes.getDefaultThemeClass = function () {
            return this.DEFAULT_THEME_CLASS;
        };
        DThemes.getInstance = function () {
            if (this.INSTANCE == null) {
                var defaultThemeClass = this.getDefaultThemeClass();
                if (defaultThemeClass == null) {
                    throw new Error("No default theme class found");
                }
                this.INSTANCE = new defaultThemeClass();
            }
            return this.INSTANCE;
        };
        DThemes.setInstance = function (instance) {
            var result = this.INSTANCE;
            this.INSTANCE = instance;
            return result;
        };
        DThemes.DEFAULT_THEME_CLASS = null;
        DThemes.INSTANCE = null;
        return DThemes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilPointerEvent = /** @class */ (function () {
        function UtilPointerEvent() {
        }
        Object.defineProperty(UtilPointerEvent, "touchable", {
            get: function () {
                return ("ontouchstart" in document);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "tap", {
            get: function () {
                return "pointertap";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "down", {
            get: function () {
                return "pointerdown";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "enter", {
            get: function () {
                return "pointerenter";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "leave", {
            get: function () {
                return "pointerleave";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "move", {
            get: function () {
                return "pointermove";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "out", {
            get: function () {
                return "pointerout";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "over", {
            get: function () {
                return "pointerover";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "up", {
            get: function () {
                return "pointerup";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "cancel", {
            get: function () {
                return "pointercancel";
            },
            enumerable: true,
            configurable: true
        });
        UtilPointerEvent.toGlobal = function (e, interactionManager, result) {
            if ("touches" in e) {
                var touches = e.changedTouches;
                var touch = touches[touches.length - 1];
                if (touch != null) {
                    interactionManager.mapPositionToPoint(result, touch.clientX, touch.clientY);
                }
                else {
                    interactionManager.mapPositionToPoint(result, 0, 0);
                }
            }
            else {
                interactionManager.mapPositionToPoint(result, e.clientX, e.clientY);
            }
            return result;
        };
        UtilPointerEvent.onClick = function (target, handler) {
            var _this = this;
            if (!this.touchable) {
                target.on("click", handler);
            }
            else {
                var isDowned_1 = false;
                var downX_1 = 0;
                var downY_1 = 0;
                var interactionManagerBound_1 = null;
                var cleanup_1 = function () {
                    isDowned_1 = false;
                    if (interactionManagerBound_1) {
                        interactionManagerBound_1.off(up_1, onUp_1);
                        interactionManagerBound_1 = null;
                    }
                };
                var isValidDistance_1 = function (e) {
                    var global = e.data.global;
                    var dx = Math.abs(downX_1 - global.x);
                    var dy = Math.abs(downY_1 - global.y);
                    var threshold = _this.CLICK_DISTANCE_THRESHOLD;
                    return (dx <= threshold && dy <= threshold);
                };
                target.on("click", function (e) {
                    if (isDowned_1) {
                        cleanup_1();
                    }
                    handler(e);
                });
                var up_1 = this.up;
                var onUp_1 = function (e) {
                    if (isDowned_1) {
                        cleanup_1();
                        if (_this.contains(target, e.target)) {
                            if (isValidDistance_1(e)) {
                                handler(e);
                            }
                        }
                    }
                };
                target.on(this.down, function (e) {
                    if (isDowned_1) {
                        var global_1 = e.data.global;
                        downX_1 = global_1.x;
                        downY_1 = global_1.y;
                    }
                    else {
                        isDowned_1 = true;
                        var global_2 = e.data.global;
                        downX_1 = global_2.x;
                        downY_1 = global_2.y;
                        if (interactionManagerBound_1) {
                            interactionManagerBound_1.off(up_1, onUp_1);
                            interactionManagerBound_1 = null;
                        }
                        var layer = DApplications.getLayer(target);
                        if (layer) {
                            interactionManagerBound_1 = layer.renderer.plugins.interaction;
                            interactionManagerBound_1.once(up_1, onUp_1);
                        }
                    }
                });
            }
        };
        UtilPointerEvent.onLongClick = function (target, onClick, onLongClick) {
            var _this = this;
            if (!this.touchable) {
                target.on("click", onClick);
            }
            else {
                var isDowned_2 = false;
                var downX_2 = 0;
                var downY_2 = 0;
                var timeoutId_1 = null;
                var interactionManagerBound_2 = null;
                var cleanupTimeout_1 = function () {
                    if (timeoutId_1 != null) {
                        clearTimeout(timeoutId_1);
                        timeoutId_1 = null;
                    }
                };
                var cleanup_2 = function () {
                    isDowned_2 = false;
                    if (interactionManagerBound_2) {
                        interactionManagerBound_2.off(up_2, onUp_2);
                        interactionManagerBound_2.off(move_1, onMove_1);
                        interactionManagerBound_2 = null;
                    }
                    cleanupTimeout_1();
                };
                var isValidDistance_2 = function (e) {
                    var global = e.data.global;
                    var dx = Math.abs(downX_2 - global.x);
                    var dy = Math.abs(downY_2 - global.y);
                    var threshold = _this.CLICK_DISTANCE_THRESHOLD;
                    return (dx < threshold && dy < threshold);
                };
                target.on("click", function (e) {
                    if (isDowned_2) {
                        cleanup_2();
                    }
                    onClick(e);
                });
                var up_2 = this.up;
                var move_1 = this.move;
                var onUp_2 = function (e) {
                    if (isDowned_2) {
                        cleanup_2();
                        if (_this.contains(target, e.target)) {
                            if (isValidDistance_2(e)) {
                                onClick(e);
                            }
                        }
                    }
                };
                var onMove_1 = function (e) {
                    if (isDowned_2) {
                        if (_this.contains(target, e.target)) {
                            if (!isValidDistance_2(e)) {
                                cleanup_2();
                            }
                        }
                    }
                };
                target.on(this.down, function (e) {
                    if (!isDowned_2) {
                        isDowned_2 = true;
                        var global_3 = e.data.global;
                        downX_2 = global_3.x;
                        downY_2 = global_3.y;
                        cleanupTimeout_1();
                        var oe = e.data.originalEvent;
                        if ("touches" in oe) {
                            timeoutId_1 = window.setTimeout(function () {
                                if (isDowned_2) {
                                    cleanup_2();
                                    onLongClick(e);
                                }
                            }, _this.LONG_CLICK_THRESHOLD);
                        }
                        if (interactionManagerBound_2) {
                            interactionManagerBound_2.off(up_2, onUp_2);
                            interactionManagerBound_2.off(move_1, onMove_1);
                            interactionManagerBound_2 = null;
                        }
                        var layer = DApplications.getLayer(target);
                        if (layer) {
                            interactionManagerBound_2 = layer.renderer.plugins.interaction;
                            interactionManagerBound_2.once(up_2, onUp_2);
                            interactionManagerBound_2.on(move_1, onMove_1);
                        }
                    }
                });
            }
        };
        UtilPointerEvent.onDblClick = function (target, handler) {
            var _this = this;
            if (!this.touchable) {
                target.addEventListener("dblclick", handler);
            }
            else {
                var isDowned_3 = 0;
                var downX_3 = 0;
                var downY_3 = 0;
                var clickTime_1 = 0;
                target.addEventListener("dblclick", handler);
                target.addEventListener("touchend", function (e) {
                    if (isDowned_3 === 1 || isDowned_3 === 3) {
                        var touches = e.changedTouches;
                        var touch = touches[touches.length - 1];
                        if (touch != null) {
                            var dx = downX_3 - touch.clientX;
                            var dy = downY_3 - touch.clientY;
                            if (Math.abs(dx) + Math.abs(dy) < _this.CLICK_DISTANCE_THRESHOLD) {
                                isDowned_3 += 1;
                                if (isDowned_3 === 4) {
                                    isDowned_3 = 0;
                                    var elapsedTime = e.timeStamp - clickTime_1;
                                    if (elapsedTime < _this.DBLCLICK_INTERVAL_THRESHOLD) {
                                        handler(e);
                                    }
                                    else {
                                        clickTime_1 = e.timeStamp;
                                        isDowned_3 = 2;
                                    }
                                }
                                else {
                                    clickTime_1 = e.timeStamp;
                                }
                                return;
                            }
                        }
                    }
                    isDowned_3 = 0;
                });
                target.addEventListener("touchstart", function (e) {
                    if (isDowned_3 === 0) {
                        var touch = e.touches.item(e.touches.length - 1);
                        if (touch != null) {
                            isDowned_3 = 1;
                            downX_3 = touch.clientX;
                            downY_3 = touch.clientY;
                            return;
                        }
                    }
                    else if (isDowned_3 === 2) {
                        var touch = e.touches.item(e.touches.length - 1);
                        if (touch != null) {
                            isDowned_3 = 3;
                            downX_3 = touch.clientX;
                            downY_3 = touch.clientY;
                            return;
                        }
                    }
                    isDowned_3 = 0;
                });
            }
        };
        UtilPointerEvent.contains = function (target, targetOrChild) {
            var current = targetOrChild;
            while (current != null && current !== target) {
                current = current.parent;
            }
            return current === target;
        };
        UtilPointerEvent.CLICK_DISTANCE_THRESHOLD = 10;
        UtilPointerEvent.DBLCLICK_INTERVAL_THRESHOLD = 333;
        UtilPointerEvent.LONG_CLICK_THRESHOLD = 750;
        return UtilPointerEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toTheme = function (options) {
        if (options != null && options.theme != null) {
            var theme = options.theme;
            if (isString(theme)) {
                return DThemes.getInstance().get(theme);
            }
            else {
                return theme;
            }
        }
        return null;
    };
    var toShortcuts = function (options) {
        if (options != null && (options.shortcuts != null || options.shortcut != null)) {
            var result = [];
            if (options.shortcut != null) {
                result.push(UtilKeyboardEvent.toShortcut(options.shortcut));
            }
            if (options.shortcuts != null) {
                var shortcuts = options.shortcuts;
                for (var i = 0, imax = shortcuts.length; i < imax; ++i) {
                    UtilKeyboardEvent.toShortcut(shortcuts[i]);
                }
            }
            return result;
        }
        return undefined;
    };
    var AutoFlag;
    (function (AutoFlag) {
        AutoFlag[AutoFlag["NONE"] = 0] = "NONE";
        AutoFlag[AutoFlag["WIDTH"] = 1] = "WIDTH";
        AutoFlag[AutoFlag["HEIGHT"] = 2] = "HEIGHT";
    })(AutoFlag || (AutoFlag = {}));
    var DBase = /** @class */ (function (_super) {
        __extends(DBase, _super);
        function DBase(options) {
            var _this = _super.call(this) || this;
            // Transform
            var transform = _this.transform;
            _this._position = new DBasePoint(transform.position, function () {
                _this.onPositionChanged();
            });
            _this._scale = new DBasePoint(transform.scale, function () {
                _this.onScaleChanged();
            });
            _this._skew = new DBasePoint(transform.skew, function () {
                _this.onSkewChanged();
            });
            //
            _this._options = options;
            var scalarSet = _this._scalarSet = {};
            _this._autoFlags = 0 /* NONE */;
            _this._isDirty = true;
            _this._hasDirty = false;
            _this._isChildrenDirty = false;
            _this._shadow = null;
            _this._name = (options && options.name) || "";
            var theme = _this._theme = toTheme(options) || _this.getThemeDefault();
            _this._befores = [];
            _this._afters = [];
            _this._reflowables = [];
            _this._clearType = (options && options.clear != null ?
                (isString(options.clear) ? DLayoutClearType[options.clear] : options.clear) :
                theme.getClearType());
            _this._padding = new DBasePadding(theme, options, function () {
                _this.layout();
                _this.toChildrenDirty();
                DApplications.update(_this);
            });
            var toDirtyAndUpdate = function () {
                _this.toDirty();
                DApplications.update(_this);
            };
            _this._background = new DBaseBackground(theme, options, toDirtyAndUpdate);
            _this._border = new DBaseBorder(theme, options, toDirtyAndUpdate);
            _this._outline = new DBaseOutline(theme, options, toDirtyAndUpdate);
            _this._corner = new DBaseCorner(theme, options, toDirtyAndUpdate);
            _this.initReflowable();
            // X
            var position = transform.position;
            var x = (options && options.x != null ? options.x : theme.getX());
            if (isNumber(x)) {
                position.x = x;
            }
            else {
                position.x = 0;
                scalarSet.x = DScalarFunctions.position(x);
            }
            // Y
            var y = (options && options.y != null ? options.y : theme.getY());
            if (isNumber(y)) {
                position.y = y;
            }
            else {
                position.y = 0;
                scalarSet.y = DScalarFunctions.position(y);
            }
            // Width
            var width = (options && options.width != null ? options.width : theme.getWidth());
            if (isNumber(width)) {
                _this._width = width;
            }
            else if (width === "auto" || width === "AUTO") {
                _this._width = 100;
                _this.toWidthAuto();
            }
            else {
                _this._width = 100;
                scalarSet.width = DScalarFunctions.size(width);
            }
            // Height
            var height = (options && options.height != null ? options.height : theme.getHeight());
            if (isNumber(height)) {
                _this._height = height;
            }
            else if (height === "auto" || height === "AUTO") {
                _this._height = 100;
                _this.toHeightAuto();
            }
            else {
                _this._height = 100;
                scalarSet.height = DScalarFunctions.size(height);
            }
            // Visibility
            if (options && options.visible != null) {
                _this.visible = options.visible;
            }
            // State
            _this._state = DBaseState.NONE;
            _this._stateLocal = DBaseState.NONE;
            // Interactive
            var interactive = (options && options.interactive != null ?
                (isString(options.interactive) ? DBaseInteractive[options.interactive] : options.interactive) :
                theme.getInteractive());
            _this.interactive = ((interactive & DBaseInteractive.SELF) !== 0);
            _this.interactiveChildren = ((interactive & DBaseInteractive.CHILDREN) !== 0);
            // Events
            var on = options && options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            // Title
            _this._title = (options && options.title != null ? options.title : theme.getTitle());
            // Weight
            _this._weight = (options && options.weight != null ? options.weight : theme.getWeight());
            // Shadow
            _this._onShadowUpdateBound = function () {
                DApplications.update(_this);
            };
            var shadow = (options && options.shadow) || theme.getShadow();
            if (shadow) {
                if (isString(shadow)) {
                    switch (shadow) {
                        case "WEAK":
                            _this.shadow = theme.newShadowWeak();
                            break;
                        case "DEFAULT":
                            _this.shadow = theme.newShadow();
                            break;
                    }
                }
                else {
                    _this.shadow = shadow;
                }
            }
            // Event handlers
            _this.on(UtilPointerEvent.over, function (e) {
                _this.onOver(e);
            });
            _this.on(UtilPointerEvent.out, function (e) {
                _this.onOut(e);
            });
            _this.on(UtilPointerEvent.down, function (e) {
                _this.onDown(e);
            });
            _this.on(UtilPointerEvent.up, function (e) {
                _this.onUp(e);
            });
            // Children change detection
            _this.on("added", function () {
                _this.layout();
                if (_this.isDirty() || _this.hasDirty()) {
                    _this.toParentHasDirty();
                }
                if (_this._isChildrenDirty) {
                    _this.toParentChildrenDirty();
                }
                _this.updateState();
                DApplications.update(_this);
            });
            _this.on("removed", function () {
                _this.blur(true);
                _this.updateState();
                DApplications.update(_this);
            });
            // Shortcut
            var shortcuts = _this._shortcuts = toShortcuts(options);
            if (shortcuts != null) {
                var onShortcutBound = function (e) {
                    _this.onShortcut(e);
                };
                for (var i = 0, imax = shortcuts.length; i < imax; ++i) {
                    UtilKeyboardEvent.on(_this, shortcuts[i], onShortcutBound);
                }
            }
            // Cursor
            var cursor = options && options.cursor;
            if (cursor == null) {
                cursor = theme.getCursor();
            }
            if (cursor != null) {
                _this.cursor = cursor;
            }
            // Other initialization
            _this.init(options);
            // State Override
            if (options && options.state != null) {
                if (isString(options.state)) {
                    _this.setState(DBaseState[options.state], true);
                }
                else if (isNumber(options.state)) {
                    _this.setState(options.state, true);
                }
                else {
                    var states = options.state;
                    for (var i = 0, imax = states.length; i < imax; ++i) {
                        _this.setState(DBaseState[states[i]], true);
                    }
                }
            }
            // Parent
            if (options && options.parent != null) {
                options.parent.addChild(_this);
            }
            // Children
            if (options && options.children != null) {
                var children = options.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child != null) {
                        _this.addChild(child);
                    }
                }
            }
            // Done
            _this.emit("init", _this);
            return _this;
        }
        DBase.prototype.prependRenderable = function (renderable, phase) {
            renderable.parent = this;
            var list = (phase ? this._befores : this._afters);
            list.unshift(renderable);
        };
        DBase.prototype.appendRenderable = function (renderable, phase) {
            renderable.parent = this;
            var list = (phase ? this._befores : this._afters);
            list.push(renderable);
        };
        DBase.prototype.removeRenderable = function (renderable, phase) {
            renderable.parent = null;
            var list = (phase ? this._befores : this._afters);
            var index = list.indexOf(renderable);
            if (0 <= index) {
                list.splice(index, 1);
            }
        };
        DBase.prototype.addReflowable = function (reflowable) {
            this._reflowables.push(reflowable);
        };
        DBase.prototype.removeReflowable = function (reflowable) {
            var reflowables = this._reflowables;
            var index = reflowables.indexOf(reflowable);
            if (0 <= index) {
                reflowables.splice(index, 1);
            }
        };
        DBase.prototype.initReflowable = function () {
            new DBaseReflowable(this);
        };
        DBase.prototype.onChildrenChange = function () {
            this.toChildrenDirty();
            _super.prototype.onChildrenChange.call(this);
        };
        DBase.prototype.onShortcut = function (e) {
            // DO NOTHING
        };
        DBase.prototype.init = function (options) {
            // OTHER INITIALIZATIONS BEFORE `parent.addChild( this )`
        };
        Object.defineProperty(DBase.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            enumerable: true,
            configurable: true
        });
        DBase.prototype.onPositionChanged = function () {
            this.moveChildren();
            DApplications.update(this);
            this.emit("move", this);
        };
        DBase.prototype.resize = function (width, height) {
            var oldWidth = this._width;
            var oldHeight = this._height;
            var widthResized = oldWidth !== width;
            var heightResized = oldHeight !== height;
            if (widthResized) {
                this._width = width;
            }
            if (heightResized) {
                this._height = height;
            }
            var resized = widthResized || heightResized;
            if (resized) {
                this.onResize(width, height, oldWidth, oldHeight);
            }
            if (widthResized) {
                var scalarSet = this._scalarSet;
                if (scalarSet.x != null) {
                    var position = this.transform.position;
                    var parent_1 = this.getParentOfSize();
                    if (parent_1) {
                        this.x = scalarSet.x(parent_1.width, width, parent_1.padding.getLeft(), position.x);
                    }
                }
            }
            if (heightResized) {
                var scalarSet = this._scalarSet;
                if (scalarSet.y != null) {
                    var position = this.transform.position;
                    var parent_2 = this.getParentOfSize();
                    if (parent_2) {
                        this.y = scalarSet.y(parent_2.height, height, parent_2.padding.getTop(), position.y);
                    }
                }
            }
            return resized;
        };
        DBase.prototype.getClearType = function () {
            return this._clearType;
        };
        DBase.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            this.toDirty();
            this.toChildrenDirty();
            this.resizeChildren();
            DApplications.update(this);
            this.emit("resize", newWidth, newHeight, oldWidth, oldHeight, this);
        };
        DBase.prototype.onScaleChanged = function () {
            DApplications.update(this);
            this.emit("scale", this);
        };
        DBase.prototype.onSkewChanged = function () {
            DApplications.update(this);
            this.emit("skew", this);
        };
        Object.defineProperty(DBase.prototype, "type", {
            get: function () {
                return this.getType();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "name", {
            get: function () {
                return this._name;
            },
            set: function (name) {
                this._name = name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "x", {
            get: function () {
                return this._position.x;
            },
            set: function (x) {
                this._position.x = x;
            },
            enumerable: true,
            configurable: true
        });
        DBase.prototype.getX = function () {
            var scalarSet = this._scalarSet;
            if (scalarSet.x != null) {
                return scalarSet.x;
            }
            else {
                return this.x;
            }
        };
        DBase.prototype.setX = function (x) {
            if (isNumber(x)) {
                this.x = x;
            }
            else {
                var scalarSet = this._scalarSet;
                var scalar = DScalarFunctions.position(x);
                if (scalarSet.x !== scalar) {
                    scalarSet.x = scalar;
                    this.layout();
                }
            }
        };
        Object.defineProperty(DBase.prototype, "y", {
            get: function () {
                return this._position.y;
            },
            set: function (y) {
                this._position.y = y;
            },
            enumerable: true,
            configurable: true
        });
        DBase.prototype.getY = function () {
            var scalarSet = this._scalarSet;
            if (scalarSet.y != null) {
                return scalarSet.y;
            }
            else {
                return this.y;
            }
        };
        DBase.prototype.setY = function (y) {
            if (isNumber(y)) {
                this.y = y;
            }
            else {
                var scalarSet = this._scalarSet;
                var scalar = DScalarFunctions.position(y);
                if (scalarSet.y !== scalar) {
                    scalarSet.y = scalar;
                    this.layout();
                }
            }
        };
        Object.defineProperty(DBase.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                var oldWidth = this._width;
                if (oldWidth !== width) {
                    this._width = width;
                    var height = this._height;
                    this.onResize(width, height, oldWidth, height);
                    // Layout
                    var scalarSet = this._scalarSet;
                    if (scalarSet.x != null) {
                        var position = this.transform.position;
                        var parent_3 = this.getParentOfSize();
                        if (parent_3) {
                            this.x = scalarSet.x(parent_3.width, width, parent_3.padding.getLeft(), position.x);
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBase.prototype.toWidthAuto = function () {
            this._autoFlags |= 1 /* WIDTH */;
        };
        DBase.prototype.isWidthAuto = function () {
            return (this._autoFlags & 1 /* WIDTH */) !== 0;
        };
        DBase.prototype.getWidth = function () {
            var scalarSet = this._scalarSet;
            if (this.isWidthAuto()) {
                return "auto";
            }
            else if (scalarSet.width != null) {
                return scalarSet.width;
            }
            else {
                return this.width;
            }
        };
        DBase.prototype.setWidth = function (width) {
            if (isNumber(width)) {
                this.width = width;
            }
            else if (width === "auto" || width === "AUTO") {
                if (!this.isWidthAuto()) {
                    this.toWidthAuto();
                    this.toChildrenDirty();
                    DApplications.update(this);
                }
            }
            else {
                var scalarSet = this._scalarSet;
                var scalar = DScalarFunctions.size(width);
                if (scalarSet.width !== scalar) {
                    scalarSet.width = scalar;
                    this.layout();
                }
            }
        };
        Object.defineProperty(DBase.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (height) {
                var oldHeight = this._height;
                if (oldHeight !== height) {
                    this._height = height;
                    var width = this._width;
                    this.onResize(width, height, width, oldHeight);
                    // Layout
                    var scalarSet = this._scalarSet;
                    if (scalarSet.y != null) {
                        var position = this.transform.position;
                        var parent_4 = this.getParentOfSize();
                        if (parent_4) {
                            this.y = scalarSet.y(parent_4.height, height, parent_4.padding.getTop(), position.y);
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBase.prototype.toHeightAuto = function () {
            this._autoFlags |= 2 /* HEIGHT */;
        };
        DBase.prototype.isHeightAuto = function () {
            return (this._autoFlags & 2 /* HEIGHT */) !== 0;
        };
        DBase.prototype.getHeight = function () {
            var scalarSet = this._scalarSet;
            if (this.isHeightAuto()) {
                return "auto";
            }
            else if (scalarSet.height != null) {
                return scalarSet.height;
            }
            else {
                return this.height;
            }
        };
        DBase.prototype.setHeight = function (height) {
            if (isNumber(height)) {
                this.height = height;
            }
            else if (height === "auto" || height === "AUTO") {
                if (!this.isHeightAuto()) {
                    this.toHeightAuto();
                    this.toChildrenDirty();
                    DApplications.update(this);
                }
            }
            else {
                var scalarSet = this._scalarSet;
                var scalar = DScalarFunctions.size(height);
                if (scalarSet.height !== scalar) {
                    scalarSet.height = scalar;
                    this.layout();
                }
            }
        };
        Object.defineProperty(DBase.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "skew", {
            get: function () {
                return this._skew;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "corner", {
            get: function () {
                return this._corner;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "background", {
            get: function () {
                return this._background;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "border", {
            get: function () {
                return this._border;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "outline", {
            get: function () {
                return this._outline;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "unsafe", {
            get: function () {
                return this.transform;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "title", {
            get: function () {
                return this._title;
            },
            set: function (title) {
                if (this._title !== title) {
                    this._title = title;
                    if (this.isHovered()) {
                        this.applyTitle();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DBase.prototype.applyTitle = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.view.title = this._title;
            }
        };
        DBase.prototype.show = function () {
            if (!this.visible) {
                this.visible = true;
                this.toParentChildrenDirty();
                DApplications.update(this);
            }
            return this;
        };
        DBase.prototype.isShown = function () {
            return this.visible;
        };
        DBase.prototype.hide = function () {
            if (this.visible) {
                this.visible = false;
                this.toParentChildrenDirty();
                DApplications.update(this);
            }
            return this;
        };
        DBase.prototype.isHidden = function () {
            return !this.visible;
        };
        DBase.prototype.toDirty = function () {
            if (!this._isDirty) {
                this._isDirty = true;
                this.toParentHasDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toHasDirty = function () {
            if (!this._hasDirty) {
                this._hasDirty = true;
                this.toParentHasDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toParentHasDirty = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.toHasDirty();
            }
        };
        DBase.prototype.toChildrenDirty = function () {
            if (!this._isChildrenDirty) {
                this._isChildrenDirty = true;
                this.onChildrenDirty();
                this.toParentChildrenDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toParentChildrenDirty = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.toChildrenDirty();
            }
        };
        DBase.prototype.isChildrenDirty = function () {
            return this._isChildrenDirty;
        };
        DBase.prototype.onChildrenDirty = function () {
            // DO NOTHING
        };
        DBase.prototype.isDirty = function () {
            return this._isDirty;
        };
        DBase.prototype.hasDirty = function () {
            return this._hasDirty;
        };
        DBase.prototype.setHovered = function (isHovered) {
            return this.setState(DBaseState.HOVERED, isHovered);
        };
        DBase.prototype.setActive = function (isActive) {
            return this.setState(DBaseState.ACTIVE, isActive);
        };
        DBase.prototype.setPressed = function (isPressed) {
            return this.setState(DBaseState.PRESSED, isPressed);
        };
        DBase.prototype.setReadOnly = function (isReadOnly) {
            return this.setState(DBaseState.READ_ONLY, isReadOnly);
        };
        DBase.prototype.setDisabled = function (isDisabled) {
            return this.setState(DBaseState.DISABLED, isDisabled);
        };
        DBase.prototype.setDragging = function (isDragging) {
            return this.setState(DBaseState.DRAGGING, isDragging);
        };
        DBase.prototype.setInvalid = function (isInvalid) {
            return this.setState(DBaseState.INVALID, isInvalid);
        };
        DBase.prototype.setSucceeded = function (isSucceeded) {
            return this.setState(DBaseState.SUCCEEDED, isSucceeded);
        };
        DBase.prototype.setFailed = function (isFailed) {
            return this.setState(DBaseState.FAILED, isFailed);
        };
        DBase.prototype.setFocused = function (isFocused) {
            if (this.isFocused() !== isFocused) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.getFocusController().setFocused(this, isFocused, false);
                }
            }
            return this;
        };
        DBase.prototype.focus = function () {
            return this.setFocused(true);
        };
        DBase.prototype.blur = function (recursively) {
            if (recursively) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var focusController = layer.getFocusController();
                    var focused = focusController.getFocused();
                    if (focused instanceof DBase) {
                        var current = focused;
                        while (current) {
                            if (current === this) {
                                focused.setFocused(false);
                                break;
                            }
                            current = current.parent;
                        }
                    }
                }
            }
            else {
                this.setFocused(false);
            }
            return this;
        };
        DBase.prototype.isHovered = function () {
            return this.hasState(DBaseState.HOVERED);
        };
        DBase.prototype.isActive = function () {
            return this.hasState(DBaseState.ACTIVE);
        };
        DBase.prototype.isActiveIn = function () {
            return this.hasState(DBaseState.ACTIVE | DBaseState.ACTIVE_IN);
        };
        DBase.prototype.isPressed = function () {
            return this.hasState(DBaseState.PRESSED);
        };
        DBase.prototype.isReadOnly = function () {
            return this.hasState(DBaseState.READ_ONLY);
        };
        DBase.prototype.isDisabled = function () {
            return this.hasState(DBaseState.DISABLED);
        };
        DBase.prototype.isActionable = function () {
            return !this.hasState(DBaseState.DISABLED | DBaseState.READ_ONLY);
        };
        DBase.prototype.isDragging = function () {
            return this.hasState(DBaseState.DRAGGING);
        };
        DBase.prototype.isFocused = function () {
            return this.hasState(DBaseState.FOCUSED);
        };
        DBase.prototype.isFocusedIn = function () {
            return this.hasState(DBaseState.FOCUSED | DBaseState.FOCUSED_IN);
        };
        DBase.prototype.isUnfocusable = function () {
            return this.hasState(DBaseState.UNFOCUSABLE);
        };
        DBase.prototype.isInvalid = function () {
            return this.hasState(DBaseState.INVALID);
        };
        DBase.prototype.isSucceeded = function () {
            return this.hasState(DBaseState.SUCCEEDED);
        };
        DBase.prototype.isFailed = function () {
            return this.hasState(DBaseState.FAILED);
        };
        DBase.prototype.setState = function (state, isOn) {
            var oldStateLocal = this._stateLocal;
            var newStateLocal = (isOn ? (oldStateLocal | state) : (oldStateLocal & ~state));
            if (oldStateLocal !== newStateLocal) {
                this._stateLocal = newStateLocal;
                this.updateState();
            }
            return this;
        };
        DBase.prototype.setStates = function (statesOn, statesOff) {
            var oldStateLocal = this._stateLocal;
            var newStateLocal = ((oldStateLocal | statesOn) & ~statesOff);
            if (oldStateLocal !== newStateLocal) {
                this._stateLocal = newStateLocal;
                this.updateState();
            }
            return this;
        };
        DBase.prototype.updateState = function () {
            var parent = this.parent;
            var stateLocal = this._stateLocal;
            var newState = (parent instanceof DBase ?
                this.mergeState(stateLocal, parent.state) :
                stateLocal);
            var oldState = this._state;
            if (oldState !== newState) {
                this._state = newState;
                this.onStateChange(newState, oldState);
            }
        };
        DBase.prototype.mergeState = function (stateLocal, stateParent) {
            return stateLocal |
                (stateParent & DBaseState.DISABLED) |
                (stateParent & DBaseState.READ_ONLY) |
                (stateParent & (DBaseState.FOCUSED | DBaseState.FOCUSED_IN) ? DBaseState.FOCUSED_IN : DBaseState.NONE) |
                (stateParent & (DBaseState.ACTIVE | DBaseState.ACTIVE_IN) ? DBaseState.ACTIVE_IN : DBaseState.NONE);
        };
        DBase.prototype.onStateChange = function (newState, oldState) {
            this.toDirty();
            DApplications.update(this);
            this.emit("statechange", newState, oldState, this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentStateChange(newState, oldState);
                }
            }
            if (DBaseStates.isFocused(newState)) {
                if (!DBaseStates.isFocused(oldState)) {
                    this.onFocused();
                }
            }
            else {
                if (DBaseStates.isFocused(oldState)) {
                    this.onBlured();
                }
            }
        };
        DBase.prototype.onChildFocused = function (focused) {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildFocused(focused);
            }
        };
        DBase.prototype.onFocused = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildFocused(this);
            }
        };
        DBase.prototype.onBlured = function () {
            //
        };
        DBase.prototype.onParentStateChange = function (newStateParent, oldStateParent) {
            var newState = this.mergeState(this._stateLocal, newStateParent);
            var oldState = this._state;
            if (oldState !== newState) {
                this._state = newState;
                this.onStateChange(newState, oldState);
            }
        };
        Object.defineProperty(DBase.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        DBase.prototype.getState = function () {
            return this._state;
        };
        DBase.prototype.hasState = function (state) {
            return !!(this._state & state);
        };
        Object.defineProperty(DBase.prototype, "theme", {
            get: function () {
                return this._theme;
            },
            set: function (theme) {
                var result = this._theme;
                if (result !== theme) {
                    this._theme = theme;
                    this._padding.setTheme(theme);
                    this._background.setTheme(theme);
                    this._border.setTheme(theme);
                    this._outline.setTheme(theme);
                    this._corner.setTheme(theme);
                    this.toDirty();
                    DApplications.update(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        DBase.prototype.refit = function () {
            if (this._isChildrenDirty) {
                this._isChildrenDirty = false;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.refit();
                    }
                }
                this.onRefit();
            }
        };
        DBase.prototype.onRefit = function () {
            var isWidthAuto = this.isWidthAuto();
            var isHeightAuto = this.isHeightAuto();
            if (isWidthAuto && isHeightAuto) {
                var width = 0;
                var height = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible) {
                        if (this.hasRefitableWidth(child)) {
                            width = Math.max(width, child.x + child.width);
                        }
                        if (this.hasRefitableHeight(child)) {
                            height = Math.max(height, child.y + child.height);
                        }
                    }
                }
                var padding = this.padding;
                this.resize(width + padding.getRight(), height + padding.getBottom());
            }
            else if (isWidthAuto) {
                var width = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible && this.hasRefitableWidth(child)) {
                        width = Math.max(width, child.x + child.width);
                    }
                }
                var padding = this.padding;
                this.width = width + padding.getRight();
            }
            else if (isHeightAuto) {
                var height = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible && this.hasRefitableHeight(child)) {
                        height = Math.max(height, child.y + child.height);
                    }
                }
                var padding = this.padding;
                this.height = height + padding.getBottom();
            }
        };
        DBase.prototype.isRefitable = function (target) {
            return target instanceof DBase;
        };
        DBase.prototype.hasRefitableHeight = function (target) {
            return this.isRefitable(target) &&
                !(target instanceof DBase && isFunction(target.getHeight()));
        };
        DBase.prototype.hasRefitableWidth = function (target) {
            return this.isRefitable(target) &&
                !(target instanceof DBase && isFunction(target.getWidth()));
        };
        DBase.prototype.reflow = function () {
            if (this._isDirty) {
                this.onReflow();
                this._isDirty = false;
            }
            if (this._hasDirty) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.reflow();
                    }
                }
                this._hasDirty = false;
            }
        };
        DBase.prototype.onReflow = function () {
            var width = this._width;
            var height = this._height;
            var reflowables = this._reflowables;
            for (var i = 0, imax = reflowables.length; i < imax; ++i) {
                reflowables[i].onReflow(this, width, height);
            }
        };
        Object.defineProperty(DBase.prototype, "shadow", {
            get: function () {
                return this._shadow;
            },
            set: function (shadow) {
                var previous = this._shadow;
                if (previous !== shadow) {
                    if (previous != null) {
                        previous.off("update", this._onShadowUpdateBound);
                        this.removeReflowable(previous);
                        this.removeRenderable(previous, true);
                    }
                    this._shadow = shadow;
                    if (shadow != null) {
                        shadow.on("update", this._onShadowUpdateBound);
                        this.addReflowable(shadow);
                        this.prependRenderable(shadow, true);
                    }
                    DApplications.update(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        DBase.prototype.layout = function () {
            var parent = this.getParentOfSize();
            if (parent) {
                this.onParentResize(parent.width, parent.height, parent.padding);
            }
        };
        DBase.prototype.getParentOfSize = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                return parent;
            }
            else {
                return DApplications.getLayer(this);
            }
        };
        /**
         * Called when a parent resized.
         *
         * @param parentWidth a parent's local width
         * @param parentHeight a parent's local height
         */
        DBase.prototype.onParentResize = function (parentWidth, parentHeight, parentPadding) {
            var scalarSet = this._scalarSet;
            var position = this.transform.position;
            var x = position.x;
            var y = position.y;
            var width = this._width;
            var height = this._height;
            // Width & height
            var paddingWidth = parentPadding.getLeft() + parentPadding.getRight();
            var paddingHeight = parentPadding.getTop() + parentPadding.getBottom();
            var newWidth = (scalarSet.width != null ?
                scalarSet.width(parentWidth, width, paddingWidth, width) : width);
            var newHeight = (scalarSet.height != null ?
                scalarSet.height(parentHeight, height, paddingHeight, height) : height);
            this.resize(newWidth, newHeight);
            // X & Y
            var newX = (scalarSet.x != null ? scalarSet.x(parentWidth, this._width, parentPadding.getLeft(), x) : x);
            var newY = (scalarSet.y != null ? scalarSet.y(parentHeight, this._height, parentPadding.getTop(), y) : y);
            this.position.set(newX, newY);
        };
        DBase.prototype.resizeChildren = function () {
            var width = this._width;
            var height = this._height;
            var padding = this._padding;
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentResize(width, height, padding);
                }
            }
        };
        /**
         * Called when a parent moved.
         *
         * @param x a parent's local x position
         * @param y a parent's local y position
         */
        DBase.prototype.onParentMove = function (x, y) {
            // DO NOTHING
        };
        DBase.prototype.moveChildren = function () {
            var x = this.x;
            var y = this.y;
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentMove(x, y);
                }
            }
        };
        // Wheel
        DBase.prototype.onWheel = function (e, deltas, global) {
            this.emit("wheel", e, deltas, global, this);
            return false;
        };
        // Keydown
        DBase.prototype.onKeyDown = function (e) {
            this.emit("keydown", e, this);
            return false;
        };
        DBase.prototype.onKeyUp = function (e) {
            this.emit("keyup", e, this);
            return false;
        };
        // Down
        DBase.prototype.isEventTarget = function (e) {
            var target = e.target;
            if (target === this) {
                return true;
            }
            else if (!(target instanceof DBase)) {
                var parent_5 = target.parent;
                while (parent_5 != null && !(parent_5 instanceof DBase)) {
                    parent_5 = parent_5.parent;
                }
                return (parent_5 === this);
            }
            return false;
        };
        DBase.prototype.onDown = function (e) {
            if (this.isEventTarget(e)) {
                this.onDownThis(e);
            }
        };
        DBase.prototype.onDownThis = function (e) {
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                var lastDownPoint = this._lastDownPoint || new pixi_js.Point();
                this._lastDownPoint = lastDownPoint;
                lastDownPoint.copyFrom(e.data.global);
            }
            else {
                this.focusOnClosest();
            }
        };
        DBase.prototype.onUp = function (e) {
            if (this.isEventTarget(e)) {
                this.onUpThis(e);
            }
        };
        DBase.prototype.onUpThis = function (e) {
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                var lastDownPoint = this._lastDownPoint;
                if (lastDownPoint) {
                    var global_1 = e.data.global;
                    var dx = Math.abs(global_1.x - lastDownPoint.x);
                    var dy = Math.abs(global_1.y - lastDownPoint.y);
                    var threshold = UtilPointerEvent.CLICK_DISTANCE_THRESHOLD;
                    if (dx < threshold && dy < threshold) {
                        this.focusOnClosest();
                    }
                }
            }
        };
        DBase.prototype.focusOnClosest = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var focusController = layer.getFocusController();
                focusController.setFocused(focusController.findFocusableParent(this), true, true);
            }
        };
        // Over
        DBase.prototype.onOver = function (e) {
            // Hover
            this.setHovered(true);
            // Title
            if (e.target === this) {
                this.applyTitle();
            }
        };
        // Out
        DBase.prototype.onOut = function (e) {
            this.setHovered(false);
        };
        // Double click
        DBase.prototype.onDblClick = function (e, interactionManager) {
            this.emit("dblclick", e, interactionManager, this);
            return false;
        };
        //
        DBase.prototype.render = function (renderer) {
            if (this.visible && 0 < this.worldAlpha && this.renderable) {
                this.renderBefore(renderer);
                _super.prototype.render.call(this, renderer);
                this.renderAfter(renderer);
            }
        };
        DBase.prototype.renderBefore = function (renderer) {
            var befores = this._befores;
            for (var i = 0, imax = befores.length; i < imax; ++i) {
                var before = befores[i];
                before.updateTransform();
                before.render(renderer);
            }
        };
        DBase.prototype.renderAfter = function (renderer) {
            var afters = this._afters;
            for (var i = 0, imax = afters.length; i < imax; ++i) {
                var after = afters[i];
                after.updateTransform();
                after.render(renderer);
            }
        };
        //
        DBase.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DBase.prototype.getType = function () {
            return "DBase";
        };
        //
        DBase.prototype._calculateBounds = function () {
            var worldTransform = this.transform.worldTransform;
            var bounds = this._bounds;
            var work = DBase.WORK_CONTAINS_POINT;
            work.set(0, 0);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(this._width, this._height);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            _super.prototype._calculateBounds.call(this);
        };
        DBase.prototype.containsPoint = function (point) {
            return this.containsGlobalPoint(point) || this.containsLocalPoint(this.worldTransform.applyInverse(point, DBase.WORK_CONTAINS_POINT));
        };
        DBase.prototype.containsGlobalPoint = function (point) {
            return false;
        };
        DBase.prototype.containsLocalPoint = function (point) {
            return (0 <= point.x && point.x <= this._width &&
                0 <= point.y && point.y <= this._height);
        };
        /**
         * Returns a clipping rect.
         *
         * @param result a clipping rect
         */
        DBase.prototype.getClippingRect = function (target, result) {
            result.x = 0;
            result.y = 0;
            result.width = this._width;
            result.height = this._height;
        };
        DBase.prototype.destroy = function () {
            // Layout
            var scalarSet = this._scalarSet;
            scalarSet.x = null;
            scalarSet.y = null;
            scalarSet.width = null;
            scalarSet.height = null;
            // Shadow
            var shadow = this._shadow;
            if (shadow) {
                this._shadow = null;
                shadow.destroy();
            }
            // Children
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
            //
            _super.prototype.destroy.call(this);
        };
        DBase.WORK_CONTAINS_POINT = new pixi_js.Point();
        return DBase;
    }(pixi_js.Container));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOverflowMask = /** @class */ (function (_super) {
        __extends(DBaseOverflowMask, _super);
        function DBaseOverflowMask(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            return _this;
        }
        DBaseOverflowMask.prototype.render = function (renderer) {
            this.updateTransform();
            _super.prototype.render.call(this, renderer);
        };
        DBaseOverflowMask.prototype.onReflow = function (base, width, height) {
            var x = 0;
            var y = 0;
            var corner = base.corner;
            var cornerRadius = Math.max(0, corner.getRadius() - 0.5);
            var cornerMask = corner.getMask();
            var tl = (cornerMask & DCornerMask.TOP_LEFT ? 0 : cornerRadius);
            var tr = (cornerMask & DCornerMask.TOP_RIGHT ? 0 : cornerRadius);
            var bl = (cornerMask & DCornerMask.BOTTOM_LEFT ? 0 : cornerRadius);
            var br = (cornerMask & DCornerMask.BOTTOM_RIGHT ? 0 : cornerRadius);
            this.clear();
            this.beginFill(0xFFFFFF, 1);
            this.lineStyle(0, 0, 0, 0, false);
            if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
                this.moveTo(x, y);
                this.lineTo(x + width, y);
                this.lineTo(x + width, y + height);
                this.lineTo(x, y + height);
                this.lineTo(x, y);
            }
            else {
                this.moveTo(x + tl, y);
                if (0 < tr) {
                    this.arcTo(x + width, y, x + width, y + height, tr);
                }
                else {
                    this.lineTo(x + width, y);
                }
                if (0 < br) {
                    this.arcTo(x + width, y + height, x, y + height, br);
                }
                else {
                    this.lineTo(x + width, y + height);
                }
                if (0 < bl) {
                    this.arcTo(x, y + height, x, y, bl);
                }
                else {
                    this.lineTo(x, y + height);
                }
                if (0 < tl) {
                    this.arcTo(x, y, x + width, y, tl);
                }
                else {
                    this.lineTo(x, y);
                }
            }
            this.endFill();
        };
        return DBaseOverflowMask;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMouseModifier;
    (function (DMouseModifier) {
        DMouseModifier[DMouseModifier["NONE"] = 0] = "NONE";
        DMouseModifier[DMouseModifier["CTRL"] = 1] = "CTRL";
        DMouseModifier[DMouseModifier["SHIFT"] = 2] = "SHIFT";
        DMouseModifier[DMouseModifier["ALT"] = 4] = "ALT";
        DMouseModifier[DMouseModifier["AND"] = 8] = "AND";
        DMouseModifier[DMouseModifier["OR"] = 16] = "OR";
        DMouseModifier[DMouseModifier["NOT_NONE"] = 23] = "NOT_NONE";
    })(DMouseModifier || (DMouseModifier = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMouseModifiers = /** @class */ (function () {
        function DMouseModifiers() {
        }
        DMouseModifiers.from = function (e) {
            var oe = ("data" in e ? e.data.originalEvent : e);
            return (oe.ctrlKey ? DMouseModifier.CTRL : DMouseModifier.NONE) |
                (oe.altKey ? DMouseModifier.ALT : DMouseModifier.NONE) |
                (oe.shiftKey ? DMouseModifier.SHIFT : DMouseModifier.NONE);
        };
        DMouseModifiers.match = function (e, modifier) {
            if (modifier & DMouseModifier.OR) {
                return !!(DMouseModifiers.from(e) & modifier);
            }
            else {
                return DMouseModifiers.from(e) === modifier;
            }
        };
        return DMouseModifiers;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDragMode;
    (function (DDragMode) {
        DDragMode[DDragMode["OFF"] = 0] = "OFF";
        DDragMode[DDragMode["ON"] = 1] = "ON";
        DDragMode[DDragMode["TOUCH"] = 2] = "TOUCH";
    })(DDragMode || (DDragMode = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationTimings = /** @class */ (function () {
        function DAnimationTimings() {
        }
        DAnimationTimings.LINEAR = function (t) {
            return t;
        };
        DAnimationTimings.ELASTIC = function (t) {
            return t * (3 * (1 - t) * (1 - t) + t * (3 * (1 - t) + t));
        };
        DAnimationTimings.QUAD_IN_OUT = function (t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        };
        return DAnimationTimings;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationBase = /** @class */ (function (_super) {
        __extends(DAnimationBase, _super);
        function DAnimationBase(options) {
            var _this = _super.call(this) || this;
            _this._id = null;
            _this._target = (options && options.target != null ? options.target : null);
            _this._startTime = 0;
            _this._duration = (options != null && options.duration != null ? options.duration : 200);
            _this._durationInverse = 1 / Math.max(1, _this._duration);
            _this._reverse = false;
            _this._onTime = (options != null ? options.onTime : undefined);
            _this._onTimeBaseBound = function () {
                _this.onTimeBase();
            };
            _this._onStart = (options != null ? options.onStart : undefined);
            _this._onEnd = (options != null ? options.onEnd : undefined);
            _this._timing = (options != null && options.timing != null ? options.timing : DAnimationTimings.ELASTIC);
            // Events
            var on = options && options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DAnimationBase.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DAnimationBase.prototype, "duration", {
            get: function () {
                return this._duration;
            },
            set: function (duration) {
                this._duration = duration;
                this._durationInverse = 1 / Math.max(1, duration);
            },
            enumerable: true,
            configurable: true
        });
        DAnimationBase.prototype.start = function (reverse) {
            if (reverse === void 0) { reverse = false; }
            this.stop();
            this._startTime = Date.now();
            this._reverse = reverse;
            this._id = window.setTimeout(this._onTimeBaseBound, 0);
            // onStart
            this.onStart(reverse);
            // onTime
            var duration = this._duration;
            var time = this.toTime(reverse ? duration : 0);
            this.onTime(time, reverse, 0);
        };
        DAnimationBase.prototype.onStart = function (isReverse) {
            var onStart = this._onStart;
            if (onStart != null) {
                onStart(isReverse, this);
            }
            this.emit("start", isReverse, this);
        };
        DAnimationBase.prototype.onTime = function (time, isReverse, elapsedTime) {
            var onTime = this._onTime;
            if (onTime != null) {
                onTime(time, isReverse, elapsedTime, this);
            }
            this.emit("time", time, isReverse, elapsedTime, this);
        };
        DAnimationBase.prototype.onEnd = function (isReverse) {
            var onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(isReverse, this);
            }
            this.emit("end", isReverse, this);
        };
        DAnimationBase.prototype.isStarted = function () {
            return (this._id != null);
        };
        DAnimationBase.prototype.isReverse = function () {
            return this._reverse;
        };
        DAnimationBase.prototype.onTimeBase = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                var elapsedTime = Date.now() - this._startTime;
                var duration = this._duration;
                var reverse = this._reverse;
                if (elapsedTime < duration) {
                    this._id = window.setTimeout(this._onTimeBaseBound, 0);
                    // OnTime
                    var time = this.toTime(reverse ? duration - elapsedTime : elapsedTime);
                    this.onTime(time, reverse, elapsedTime);
                }
                else {
                    // OnTime
                    var time = this.toTime(reverse ? 0 : duration);
                    this.onTime(time, reverse, elapsedTime);
                    // OnEnd
                    this.onEnd(reverse);
                }
            }
        };
        DAnimationBase.prototype.toTime = function (elapsedTime) {
            return this._timing(elapsedTime * this._durationInverse, this);
        };
        DAnimationBase.prototype.stop = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                window.clearTimeout(id);
            }
        };
        DAnimationBase.prototype.end = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                window.clearTimeout(id);
                // OnTime
                var reverse = this._reverse;
                var elapsedTime = Date.now() - this._startTime;
                var duration = this._duration;
                var time = this.toTime(reverse ? 0 : duration);
                this.onTime(time, reverse, elapsedTime);
                // OnEnd
                this.onEnd(reverse);
            }
        };
        return DAnimationBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilDragEasingHistory = /** @class */ (function () {
        function UtilDragEasingHistory(dx, dy, ds, dt) {
            this.dx = dx;
            this.dy = dy;
            this.ds = ds;
            this.dt = dt;
        }
        UtilDragEasingHistory.prototype.set = function (dx, dy, ds, dt) {
            this.dx = dx;
            this.dy = dy;
            this.ds = ds;
            this.dt = dt;
        };
        return UtilDragEasingHistory;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilDragEasing = /** @class */ (function () {
        function UtilDragEasing(onMove, options) {
            var _this = this;
            this._histories = [];
            this._historiesSorted = [];
            this._historyBegin = 0;
            this._historyEnd = -1;
            this._dx = 0;
            this._dy = 0;
            this._ds = 0;
            this._dt = 0;
            this._animation = new DAnimationBase({
                onTime: function (t) {
                    _this.onEase(t);
                },
                timing: DAnimationTimings.LINEAR,
                duration: 1000
            });
            var duration = options && options.duration;
            if (duration) {
                if (isNumber(duration)) {
                    this._durationPosition = duration;
                    this._durationScale = duration;
                }
                else {
                    this._durationPosition = (duration.position != null ? duration.position : 1);
                    this._durationScale = (duration.scale != null ? duration.scale : 1);
                }
            }
            else {
                this._durationPosition = 1;
                this._durationScale = 1;
            }
            this._onMove = onMove;
        }
        UtilDragEasing.prototype.onStart = function () {
            // History
            var histories = this._histories;
            for (var i = histories.length, imax = UtilDragEasing.HISTORY_CAPACITY; i < imax; ++i) {
                histories.push(new UtilDragEasingHistory(0, 0, 1, 0));
            }
            this._historyBegin = 0;
            this._historyEnd = -1;
            // Stop animation
            this._animation.stop();
        };
        UtilDragEasing.prototype.onMove = function (dx, dy, ds, dt) {
            var capacity = UtilDragEasing.HISTORY_CAPACITY;
            var oldHistoryEnd = this._historyEnd;
            var newHistoryEnd = (oldHistoryEnd + 1) % capacity;
            this._historyEnd = newHistoryEnd;
            var oldHistoryBegin = this._historyBegin;
            if (newHistoryEnd < oldHistoryEnd || (0 <= oldHistoryEnd && oldHistoryEnd < oldHistoryBegin)) {
                this._historyBegin = (oldHistoryBegin + 1) % capacity;
            }
            this._histories[newHistoryEnd].set(dx, dy, ds, dt);
        };
        UtilDragEasing.prototype.updateHistoriesSorted = function (dt) {
            var unsorted = this._histories;
            var sorted = this._historiesSorted;
            var begin = this._historyBegin;
            var end = this._historyEnd;
            var length = unsorted.length;
            var threshold = 160;
            if (end < 0) {
                sorted.length = 0;
                return dt;
            }
            else if (end < begin) {
                var total = dt;
                sorted.length = 0;
                for (var i = end; 0 <= i; --i) {
                    var history_1 = unsorted[i];
                    if (total + history_1.dt < threshold) {
                        total += history_1.dt;
                        sorted.push(history_1);
                    }
                    else {
                        return total;
                    }
                }
                for (var i = length - 1; begin <= i; --i) {
                    var history_2 = unsorted[i];
                    if (total + history_2.dt < threshold) {
                        total += history_2.dt;
                        sorted.push(history_2);
                    }
                    else {
                        return total;
                    }
                }
                return total;
            }
            else {
                var total = dt;
                sorted.length = 0;
                for (var i = end; begin <= i; --i) {
                    var history_3 = unsorted[i];
                    if (total + history_3.dt < threshold) {
                        total += history_3.dt;
                        sorted.push(history_3);
                    }
                    else {
                        return total;
                    }
                }
                return total;
            }
        };
        UtilDragEasing.prototype.onEnd = function (ldt) {
            var adt = this.updateHistoriesSorted(ldt);
            var sorted = this._historiesSorted;
            var sortedLength = sorted.length;
            if (0 < sortedLength) {
                var dx = 0;
                var dy = 0;
                var ds = 0;
                var dt = 0;
                for (var i = 0; i < sortedLength; ++i) {
                    var history_4 = sorted[i];
                    dx += history_4.dx;
                    dy += history_4.dy;
                    ds += history_4.ds;
                    dt += history_4.dt;
                }
                var w = (1 - ldt / adt) / sortedLength;
                dx *= w;
                dy *= w;
                ds = 1 + (ds - sortedLength) * w;
                dt *= w;
                this._dx = dx;
                this._dy = dy;
                this._ds = ds;
                this._dt = dt;
                // Start animation
                var d0 = this._durationPosition * 40 * Math.sqrt(dx * dx + dy * dy);
                var d1 = this._durationScale * 10000 * Math.abs(ds - 1);
                var animation = this._animation;
                animation.duration = Math.max(d0, d1);
                animation.start();
            }
        };
        UtilDragEasing.prototype.onEase = function (time) {
            var w = 1 - time;
            this._onMove(this._dx * w, this._dy * w, 1 + (this._ds - 1) * w, time);
        };
        UtilDragEasing.prototype.stop = function () {
            this._animation.stop();
        };
        UtilDragEasing.HISTORY_CAPACITY = 5;
        return UtilDragEasing;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toEasingOptions = function (options) {
        return (options == null || options === true ?
            undefined : options);
    };
    var toChecker = function (options) {
        var checker = options && options.checker;
        var defaultChecker = DMouseModifiers.match;
        if (checker) {
            return {
                start: checker.start || defaultChecker,
                move: checker.move || defaultChecker
            };
        }
        return {
            start: defaultChecker,
            move: defaultChecker
        };
    };
    var UtilDrag = /** @class */ (function () {
        function UtilDrag(options) {
            var _this = this;
            var target = this._target = options.target;
            var on = options.on;
            if (on) {
                this._onStart = on.start;
                this._onMove = on.move;
                this._onEnd = on.end;
            }
            this._modifier = (options && options.modifier) || DMouseModifier.NONE;
            this._checker = toChecker(options);
            this._interactionManager = null;
            this._center = new pixi_js.Point();
            this._scale = 1;
            this._scalingCenter = new pixi_js.Point();
            this._time = 0;
            var easing = options.easing;
            if (easing == null || easing !== false) {
                var onEasingMoveBound = function (dx, dy, ds, time) {
                    _this.onEasingMove(dx, dy, ds, time);
                };
                this._easing = new UtilDragEasing(onEasingMoveBound, toEasingOptions(easing));
            }
            this._onDownBound = function (e) {
                _this.onDown(e);
            };
            this._onMoveBound = function (e) {
                _this.onMove(e);
            };
            this._onEndBound = function (e) {
                _this.onEnd(e);
            };
            if (options.touch) {
                this._down = "touchstart";
                this._move = "touchmove";
                this._up = "touchend";
            }
            else {
                this._down = UtilPointerEvent.down;
                this._move = UtilPointerEvent.move;
                this._up = UtilPointerEvent.up;
            }
            if (options.bind !== false) {
                target.on(this._down, this._onDownBound);
            }
        }
        UtilDrag.prototype.calcCenterAndScale = function (e, center, interactionManager) {
            var oe = e.data.originalEvent;
            var global = e.data.global;
            if ("touches" in oe) {
                var touches = oe.touches;
                var touchesLength = touches.length;
                if (0 < touchesLength) {
                    // Update the center
                    var first = touches[0];
                    var centerX = first.clientX;
                    var centerY = first.clientY;
                    for (var i = 1, imax = touches.length; i < imax; ++i) {
                        var touch = touches[i];
                        centerX += touch.clientX;
                        centerY += touch.clientY;
                    }
                    centerX /= touchesLength;
                    centerY /= touchesLength;
                    interactionManager.mapPositionToPoint(center, centerX, centerY);
                    if (1 < touchesLength) {
                        // Calculate the maximum distance from the center
                        var squareDistance = 0;
                        for (var i = 1, imax = touches.length; i < imax; ++i) {
                            var touch = touches[i];
                            var dx = touch.clientX - centerX;
                            var dy = touch.clientY - centerY;
                            squareDistance = Math.max(squareDistance, dx * dx + dy * dy);
                        }
                        return Math.sqrt(squareDistance);
                    }
                    else {
                        return 0;
                    }
                }
            }
            center.copyFrom(global);
            return 0;
        };
        UtilDrag.prototype.onDown = function (e) {
            var target = this._target;
            if (this._checker.start(e, this._modifier, target)) {
                var layer = DApplications.getLayer(target);
                if (layer) {
                    e.stopPropagation();
                    if (target.isDragging()) {
                        var interactionManager = this._interactionManager;
                        if (interactionManager) {
                            var center = this._center;
                            this._scale = this.calcCenterAndScale(e, center, interactionManager);
                        }
                    }
                    else {
                        target.setDragging(true);
                        // Interaction manager
                        var interactionManager = layer.renderer.plugins.interaction;
                        this._interactionManager = interactionManager;
                        // Update the center
                        var center = this._center;
                        this._scale = this.calcCenterAndScale(e, center, interactionManager);
                        //
                        this._time = e.data.originalEvent.timeStamp;
                        // Easing util
                        var easing = this._easing;
                        if (easing) {
                            easing.onStart();
                        }
                        // User-defined handler
                        var onStart = this._onStart;
                        if (onStart != null) {
                            onStart();
                        }
                        // Event handler
                        interactionManager.on(this._move, this._onMoveBound);
                        interactionManager.on(this._up, this._onEndBound);
                    }
                }
            }
        };
        UtilDrag.prototype.onMove = function (e) {
            var target = this._target;
            if (target.isDragging() && this._checker.move(e, this._modifier, target)) {
                var interactionManager = this._interactionManager;
                if (interactionManager) {
                    // Update the center
                    var center = this._center;
                    var centerX = center.x;
                    var centerY = center.y;
                    var newScale = this.calcCenterAndScale(e, center, interactionManager);
                    var oldScale = this._scale;
                    this._scale = newScale;
                    var oldTime = this._time;
                    var newTime = e.data.originalEvent.timeStamp;
                    this._time = newTime;
                    // Calculate the position
                    var dx = center.x - centerX;
                    var dy = center.y - centerY;
                    var dt = newTime - oldTime;
                    var ds = (UtilDrag.EPSILON < oldScale ? newScale / oldScale : 1);
                    // Easing util
                    var easing = this._easing;
                    if (easing) {
                        easing.onMove(dx, dy, ds, dt);
                    }
                    // User-defined handler
                    var onMove = this._onMove;
                    if (onMove != null) {
                        if (dx !== 0 || dy !== 0 || ds !== 1) {
                            onMove(dx, dy, center.x, center.y, ds);
                        }
                    }
                }
            }
        };
        UtilDrag.prototype.onEnd = function (e) {
            var target = this._target;
            if (target.isDragging()) {
                var interactionManager = this._interactionManager;
                if (interactionManager) {
                    // Update the center
                    var center = this._center;
                    this._scalingCenter.copyFrom(center);
                    this._scale = this.calcCenterAndScale(e, center, interactionManager);
                    // Finalize
                    var oe = e.data.originalEvent;
                    if ("touches" in oe ? oe.touches.length <= 0 : true) {
                        target.setDragging(false);
                        // Event handler
                        this._interactionManager = null;
                        interactionManager.off(this._move, this._onMoveBound);
                        interactionManager.off(this._up, this._onEndBound);
                        // User-defined handler
                        var onEnd = this._onEnd;
                        if (onEnd != null) {
                            onEnd();
                        }
                        // Easing util
                        var easing = this._easing;
                        if (easing) {
                            easing.onEnd(e.data.originalEvent.timeStamp - this._time);
                        }
                    }
                }
            }
        };
        UtilDrag.prototype.onEasingMove = function (dx, dy, ds, time) {
            var onMove = this._onMove;
            if (onMove != null) {
                if (dx !== 0 || dy !== 0 || ds !== 1) {
                    var scalingCenter = this._scalingCenter;
                    scalingCenter.set(scalingCenter.x + dx, scalingCenter.y + dy);
                    onMove(dx, dy, scalingCenter.x, scalingCenter.y, ds);
                }
            }
        };
        UtilDrag.prototype.stop = function () {
            var easing = this._easing;
            if (easing) {
                easing.stop();
            }
        };
        UtilDrag.EPSILON = 0.00001;
        return UtilDrag;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewDragImpl = /** @class */ (function () {
        function DViewDragImpl(parent, toTarget, stopper, theme, options) {
            var _this = this;
            this._parent = parent;
            this._toTarget = toTarget;
            this._stopper = stopper;
            var mode = (options && options.mode != null ?
                (isString(options.mode) ? DDragMode[options.mode] : options.mode) :
                theme.getDragMode());
            var modifier = (options && options.modifier != null ?
                (isString(options.modifier) ? DMouseModifier[options.modifier] : options.modifier) :
                theme.getDragModifier());
            var duration = (options && options.duration != null ?
                options.duration : {
                position: theme.getDragDurationPosition(),
                scale: theme.getDragDurationScale()
            });
            var bind = (mode === DDragMode.TOUCH);
            this._bind = bind;
            if (mode === DDragMode.ON || mode === DDragMode.TOUCH) {
                this._dragUtil = new UtilDrag({
                    target: parent,
                    touch: bind,
                    modifier: modifier,
                    checker: options && options.checker,
                    easing: {
                        duration: duration
                    },
                    bind: bind,
                    on: {
                        start: function () {
                            _this._stopper.stop();
                        },
                        move: function (dx, dy, x, y, ds) {
                            var target = toTarget(parent);
                            if (target != null) {
                                // Scale
                                var oldScale = target.scale.y;
                                var newScale = stopper.toNormalizedScale(oldScale * ds);
                                var scaleRatio = newScale / oldScale;
                                // Position
                                var cx = x - dx;
                                var cy = y - dy;
                                var position = target.position;
                                var newX = (position.x - cx) * scaleRatio + x;
                                var newY = (position.y - cy) * scaleRatio + y;
                                // Update
                                target.scale.set(newScale, newScale);
                                target.position.set(newX, newY);
                            }
                        }
                    }
                });
            }
        }
        DViewDragImpl.prototype.stop = function () {
            var dragUtil = this._dragUtil;
            if (dragUtil != null) {
                dragUtil.stop();
            }
        };
        DViewDragImpl.prototype.onDown = function (e) {
            if (!this._bind) {
                var dragUtil = this._dragUtil;
                if (dragUtil) {
                    dragUtil.onDown(e);
                }
            }
        };
        return DViewDragImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewTransformImpl = /** @class */ (function () {
        function DViewTransformImpl(parent, toTarget, stopper, duration) {
            var _this = this;
            this._parent = parent;
            this._toTarget = toTarget;
            this._newScaleX = 1;
            this._newScaleY = 1;
            this._newX = 0;
            this._newY = 0;
            this._oldScaleX = 1;
            this._oldScaleY = 1;
            this._oldX = 0;
            this._oldY = 0;
            this._animation = new DAnimationBase({
                onTime: function (time) {
                    _this.onTime(time);
                },
                duration: duration
            });
            this._stopper = stopper;
            this._duration = duration;
        }
        DViewTransformImpl.prototype.onTime = function (time) {
            var w0 = 1 - time;
            var w1 = time;
            var scaleX = this._oldScaleX * w0 + this._newScaleX * w1;
            var scaleY = this._oldScaleY * w0 + this._newScaleY * w1;
            var x = this._oldX * w0 + this._newX * w1;
            var y = this._oldY * w0 + this._newY * w1;
            var target = this._toTarget(this._parent);
            if (target != null) {
                target.scale.set(scaleX, scaleY);
                target.position.set(x, y);
            }
        };
        DViewTransformImpl.prototype.start = function (target, x, Y, scaleX, scaleY, duration, stop) {
            if (stop !== false) {
                this._stopper.stop();
            }
            if (duration == null) {
                duration = this._duration;
            }
            if (duration <= 0) {
                target.scale.set(scaleX, scaleY);
                target.position.set(x, Y);
            }
            else {
                var position = target.position;
                var scale = target.scale;
                this._oldX = position.x;
                this._oldY = position.y;
                this._oldScaleX = scale.x;
                this._oldScaleY = scale.y;
                this._newX = x;
                this._newY = Y;
                this._newScaleX = scaleX;
                this._newScaleY = scaleY;
                this._animation.duration = duration;
                this._animation.start();
            }
        };
        DViewTransformImpl.prototype.stop = function () {
            this._animation.stop();
        };
        return DViewTransformImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewImpl = /** @class */ (function () {
        function DViewImpl(parent, toTarget, options) {
            this._parent = parent;
            this._toTarget = toTarget;
            this._workRect = new pixi_js.Rectangle();
            // Theme
            var theme = this.toTheme(options) || this.getThemeDefault();
            // Zoom
            var zoom = options && options.zoom;
            this._zoomPoint = new pixi_js.Point();
            this._zoomMin = zoom && zoom.min != null ? zoom.min : theme.getZoomMin();
            this._zoomMax = zoom && zoom.max != null ? zoom.max : theme.getZoomMax();
            this._zoomKeepRatio = zoom && zoom.keepRatio != null ? zoom.keepRatio : theme.getZoomKeepRatio();
            // Zoom: Wheel
            var wheelZoom = zoom && zoom.wheel;
            this._isWheelZoomEnabled = (wheelZoom && wheelZoom.enable != null ?
                wheelZoom.enable : theme.isWheelZoomEnabled());
            this._wheelZoomSpeed = (wheelZoom && wheelZoom.speed != null ?
                wheelZoom.speed : theme.getWheelZoomSpeed());
            this._wheelZoomModifier = (wheelZoom && wheelZoom.modifier != null ?
                (isString(wheelZoom.modifier) ?
                    DMouseModifier[wheelZoom.modifier] : wheelZoom.modifier) :
                theme.getWheelZoomModifier());
            this._wheelZoomChecker = (wheelZoom && wheelZoom.checker) || DMouseModifiers.match;
            // Zoom: Dbl click
            var dblClickZoom = zoom && zoom.dblclick;
            this._isDblClickZoomEnabled = (dblClickZoom && dblClickZoom.enable != null ?
                dblClickZoom.enable : theme.isDblClickZoomEnabled());
            this._dblClickZoomSpeed = (dblClickZoom && dblClickZoom.amount != null ?
                dblClickZoom.amount : theme.getDblClickZoomSpeed());
            this._dblClickZoomModifier = (dblClickZoom && dblClickZoom.modifier != null ?
                (isString(dblClickZoom.modifier) ?
                    DMouseModifier[dblClickZoom.modifier] : dblClickZoom.modifier) :
                theme.getDblClickZoomModifier());
            this._dblClickZoomChecker = (dblClickZoom && dblClickZoom.checker) || DMouseModifiers.match;
            this._dblclickZoomDuration = (dblClickZoom && dblClickZoom.duration != null ?
                dblClickZoom.duration : theme.getDblClickZoomDuration());
            // Translation: Wheel
            var wheelTranslation = options && options.translation && options.translation.wheel;
            this._isWheelTranslationEnabled = (wheelTranslation && wheelTranslation.enable != null ?
                wheelTranslation.enable : theme.isWheelTranslationEnabled());
            this._wheelTranslationSpeed = (wheelTranslation && wheelTranslation.speed != null ?
                wheelTranslation.speed : theme.getWheelTranslationSpeed());
            this._wheelTranslationModifier = (wheelTranslation && wheelTranslation.modifier != null ?
                (isString(wheelTranslation.modifier) ?
                    DMouseModifier[wheelTranslation.modifier] : wheelTranslation.modifier) :
                theme.getWheelTranslationModifier());
            this._wheelTranslationChecker = (wheelTranslation && wheelTranslation.checker) || DMouseModifiers.match;
            // Drag
            this._drag = new DViewDragImpl(parent, toTarget, this, theme, options && options.drag);
            // Transform
            this._transform = new DViewTransformImpl(parent, toTarget, this, this._dblclickZoomDuration);
        }
        Object.defineProperty(DViewImpl.prototype, "drag", {
            get: function () {
                return this._drag;
            },
            enumerable: true,
            configurable: true
        });
        DViewImpl.prototype.stop = function () {
            this._drag.stop();
            this._transform.stop();
        };
        DViewImpl.prototype.reset = function (duration, stop) {
            var parent = this._parent;
            var target = this._toTarget(parent);
            if (target) {
                var targetRect = target.getLocalBounds(this._workRect);
                var newTargetX = (parent.width - targetRect.width) * 0.5 - targetRect.x;
                var newTargetY = (parent.height - targetRect.height) * 0.5 - targetRect.y;
                this._transform.start(target, newTargetX, newTargetY, 1, 1, duration, stop);
            }
        };
        DViewImpl.prototype.fit = function (duration, stop) {
            var parent = this._parent;
            var target = this._toTarget(parent);
            if (target) {
                var padding = parent.padding;
                var width = parent.width;
                var height = parent.height;
                var targetRect = target.getLocalBounds(this._workRect);
                var targetX = targetRect.x;
                var targetY = targetRect.y;
                var targetWidth = targetRect.width;
                var targetHeight = targetRect.height;
                var newTargetScaleX = (width - padding.getLeft() - padding.getRight()) / targetWidth;
                var newTargetScaleY = (height - padding.getTop() - padding.getBottom()) / targetHeight;
                if (this._zoomKeepRatio) {
                    var newTargetScale = this.toNormalizedScale(Math.min(newTargetScaleX, newTargetScaleY));
                    newTargetScaleX = newTargetScale;
                    newTargetScaleY = newTargetScale;
                }
                else {
                    newTargetScaleX = this.toNormalizedScale(newTargetScaleX);
                    newTargetScaleY = this.toNormalizedScale(newTargetScaleY);
                }
                var newTargetWidth = targetWidth * newTargetScaleX;
                var newTargetHeight = targetHeight * newTargetScaleY;
                var newTargetX = (width - newTargetWidth) * 0.5 - targetX * newTargetScaleX;
                var newTargetY = (height - newTargetHeight) * 0.5 - targetY * newTargetScaleY;
                this._transform.start(target, newTargetX, newTargetY, newTargetScaleX, newTargetScaleY, duration, stop);
            }
        };
        DViewImpl.prototype.zoomIn = function (duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var factor = this._dblClickZoomSpeed;
                var targetScale = target.scale;
                this.zoom(targetScale.x * factor, targetScale.y * factor, duration, stop);
            }
        };
        DViewImpl.prototype.zoomOut = function (duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var factor = 1 / this._dblClickZoomSpeed;
                var targetScale = target.scale;
                this.zoom(targetScale.x * factor, targetScale.y * factor, duration, stop);
            }
        };
        DViewImpl.prototype.zoomAt = function (x, y, scaleX, scaleY, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                // Scale
                var oldScaleX = target.scale.x;
                var oldScaleY = target.scale.y;
                var newScaleX = this.toNormalizedScale(scaleX);
                var newScaleY = this.toNormalizedScale(scaleY);
                var scaleRatioX = newScaleX / oldScaleX;
                var scaleRatioY = newScaleY / oldScaleY;
                // Position
                var newX = (target.position.x - x) * scaleRatioX + x;
                var newY = (target.position.y - y) * scaleRatioY + y;
                // Start
                this._transform.start(target, newX, newY, newScaleX, newScaleY, duration, stop);
            }
        };
        DViewImpl.prototype.zoomAtGlobal = function (x, y, scaleX, scaleY, duration, stop) {
            var local = this._zoomPoint;
            local.set(x, y);
            this.toLocal(local, local);
            this.zoomAt(local.x, local.y, scaleX, scaleY, duration, stop);
        };
        DViewImpl.prototype.zoom = function (scaleX, scaleY, duration, stop) {
            var parent = this._parent;
            this.zoomAt(parent.width * 0.5, parent.height * 0.5, scaleX, scaleY, duration, stop);
        };
        Object.defineProperty(DViewImpl.prototype, "scale", {
            get: function () {
                var target = this._toTarget(this._parent);
                if (target) {
                    return target.scale;
                }
                return new pixi_js.Point(1, 1);
            },
            set: function (scale) {
                var target = this._toTarget(this._parent);
                if (target) {
                    var newScaleX = this.toNormalizedScale(scale.x);
                    var newScaleY = this.toNormalizedScale(scale.y);
                    target.scale.set(newScaleX, newScaleY);
                }
            },
            enumerable: true,
            configurable: true
        });
        DViewImpl.prototype.moveTo = function (x, y, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var targetScale = target.scale;
                this._transform.start(target, x, y, targetScale.x, targetScale.y, duration, stop);
            }
        };
        Object.defineProperty(DViewImpl.prototype, "position", {
            get: function () {
                var target = this._toTarget(this._parent);
                if (target) {
                    return target.position;
                }
                return new pixi_js.Point(0, 0);
            },
            set: function (position) {
                var target = this._toTarget(this._parent);
                if (target) {
                    target.position.set(position.x, position.y);
                }
            },
            enumerable: true,
            configurable: true
        });
        DViewImpl.prototype.transform = function (x, y, scaleX, scaleY, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                this._transform.start(target, x, y, scaleX, scaleY, duration, stop);
            }
        };
        DViewImpl.prototype.toLocal = function (global, local, skipUpdate) {
            return this._parent.toLocal(global, undefined, local, skipUpdate);
        };
        DViewImpl.prototype.toGlobal = function (local, global, skipUpdate) {
            return this._parent.toGlobal(local, global, skipUpdate);
        };
        DViewImpl.prototype.toNormalizedScale = function (scale) {
            return Math.min(this._zoomMax, Math.max(this._zoomMin, scale));
        };
        DViewImpl.prototype.onWheel = function (e, deltas, global) {
            if (this._isWheelZoomEnabled &&
                this._wheelZoomChecker(e, this._wheelZoomModifier, this._parent)) {
                if (deltas.deltaY !== 0) {
                    var target = this._toTarget(this._parent);
                    if (target) {
                        var speed = deltas.lowest * this._wheelZoomSpeed;
                        var factor = 1 + deltas.deltaY * speed;
                        var targetScale = target.scale;
                        this.zoomAtGlobal(global.x, global.y, targetScale.x * factor, targetScale.y * factor, 0);
                        return true;
                    }
                }
            }
            if (this._isWheelTranslationEnabled &&
                this._wheelTranslationChecker(e, this._wheelTranslationModifier, this._parent)) {
                var target = this._toTarget(this._parent);
                if (target) {
                    this.stop();
                    var speed = deltas.lowest * this._wheelTranslationSpeed;
                    target.position.set(target.position.x - deltas.deltaX * speed, target.position.y + deltas.deltaY * speed);
                    return true;
                }
            }
            return false;
        };
        DViewImpl.prototype.onDown = function (e) {
            this._drag.onDown(e);
        };
        DViewImpl.prototype.onDblClick = function (e, interactionManager) {
            if (this._isDblClickZoomEnabled &&
                this._dblClickZoomChecker(e, this._dblClickZoomModifier, this._parent)) {
                var target = this._toTarget(this._parent);
                if (target) {
                    var global_1 = this._zoomPoint;
                    UtilPointerEvent.toGlobal(e, interactionManager, global_1);
                    var factor = this._dblClickZoomSpeed;
                    var targetScale = target.scale;
                    this.zoomAtGlobal(global_1.x, global_1.y, targetScale.x * factor, targetScale.y * factor, this._dblclickZoomDuration);
                    return true;
                }
            }
            return false;
        };
        DViewImpl.prototype.toTheme = function (options) {
            if (options && options.theme) {
                var theme = options.theme;
                if (isString(theme)) {
                    return DThemes.getInstance().get(theme);
                }
                else {
                    return theme;
                }
            }
            return null;
        };
        DViewImpl.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DViewImpl.prototype.getType = function () {
            return "DView";
        };
        return DViewImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isOverflowMaskEnabled = function (theme, options) {
        if (options && options.mask != null) {
            return options.mask;
        }
        return theme.isOverflowMaskEnabled();
    };
    var DCanvasContainer = /** @class */ (function (_super) {
        __extends(DCanvasContainer, _super);
        function DCanvasContainer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCanvasContainer.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._canvas = null;
            var theme = this.theme;
            this._view = new DViewImpl(this, function () { return _this._canvas; }, options && options.view);
            // Canvas
            this.canvas = (options && options.canvas ? options.canvas : null);
            // Overflow mask
            this._overflowMask = null;
            if (isOverflowMaskEnabled(theme, options)) {
                this.mask = this.getOrCreateOverflowMask();
            }
        };
        DCanvasContainer.prototype.getType = function () {
            return "DCanvasContainer";
        };
        DCanvasContainer.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.updateContentSize(newWidth, newHeight, oldWidth, oldHeight);
        };
        Object.defineProperty(DCanvasContainer.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            set: function (canvas) {
                var previous = this._canvas;
                if (previous != null) {
                    this._canvas = null;
                    this.removeChild(previous);
                    this.emit("unset", previous, this);
                    previous.destroy();
                }
                this._canvas = canvas;
                if (canvas != null) {
                    this.addChild(canvas);
                    this._view.reset(0);
                    this.emit("set", canvas, this);
                }
                else {
                    DApplications.update(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        DCanvasContainer.prototype.getOrCreateOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.addReflowable(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        DCanvasContainer.prototype.updateContentSize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var canvas = this._canvas;
            if (canvas != null) {
                var canvasX = canvas.x + (newWidth - oldWidth) * 0.5;
                var canvasY = canvas.y + (newHeight - oldHeight) * 0.5;
                canvas.position.set(canvasX, canvasY);
            }
        };
        Object.defineProperty(DCanvasContainer.prototype, "view", {
            get: function () {
                return this._view;
            },
            enumerable: true,
            configurable: true
        });
        DCanvasContainer.prototype.onWheel = function (e, deltas, global) {
            var vresult = this._view.onWheel(e, deltas, global);
            var sresult = _super.prototype.onWheel.call(this, e, deltas, global);
            return vresult || sresult;
        };
        DCanvasContainer.prototype.onDblClick = function (e, interactionManager) {
            var vresult = this._view.onDblClick(e, interactionManager);
            var sresult = _super.prototype.onDblClick.call(this, e, interactionManager);
            return vresult || sresult;
        };
        DCanvasContainer.prototype.onDown = function (e) {
            this._view.onDown(e);
            _super.prototype.onDown.call(this, e);
        };
        DCanvasContainer.prototype.destroy = function () {
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            this.mask = null;
            _super.prototype.destroy.call(this);
        };
        return DCanvasContainer;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntime = /** @class */ (function () {
        function EShapeActionRuntime(reset) {
            this.reset = reset || EShapeRuntimeReset.NONE;
        }
        EShapeActionRuntime.prototype.toExpression = function (expression, def, defLiteral) {
            if (expression.trim().length <= 0) {
                return def;
            }
            try {
                return Function("shape", "time", "try{ with( shape ) { return (" + expression + "); } } catch( e ) { return " + defLiteral + "; }");
            }
            catch (e) {
                return def;
            }
        };
        EShapeActionRuntime.prototype.toContainer = function (shape) {
            var current = shape;
            while (current != null) {
                if (current instanceof DCanvasContainer) {
                    return current;
                }
                current = current.parent;
            }
            return null;
        };
        EShapeActionRuntime.prototype.execute = function (shape, runtime, time) {
            // OVERRIDE THIS
        };
        return EShapeActionRuntime;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var conditionDefault = function () { return true; };
    var EShapeActionRuntimeConditional = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeConditional, _super);
        function EShapeActionRuntimeConditional(value, reset) {
            var _this = _super.call(this, reset) || this;
            _this.condition = _this.toExpression(value.condition, conditionDefault, "true");
            return _this;
        }
        return EShapeActionRuntimeConditional;
    }(EShapeActionRuntime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlink = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlink, _super);
        function EShapeActionRuntimeBlink(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.interval = value.interval;
            return _this;
        }
        EShapeActionRuntimeBlink.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var interval = this.interval;
                var dinterval = (interval << 1);
                var elapsed = (time % dinterval);
                if (elapsed < interval) {
                    this.toOff(shape, runtime);
                    runtime.effect = time + (interval - elapsed);
                }
                else {
                    this.toOn(shape, runtime);
                    runtime.effect = time + (dinterval - elapsed);
                }
            }
        };
        EShapeActionRuntimeBlink.prototype.toOn = function (shape, runtime) {
            //
        };
        EShapeActionRuntimeBlink.prototype.toOff = function (shape, runtime) {
            //
        };
        return EShapeActionRuntimeBlink;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkBrighten = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkBrighten, _super);
        function EShapeActionRuntimeBlinkBrighten(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeBlinkBrighten.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, UtilRgb.brighten(fill.color, 0.5), fill.alpha);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, UtilRgb.brighten(stroke.color, 0.5), stroke.alpha);
            var text = EShapeActionBases.toBaseText(shape, runtime);
            shape.text.set(undefined, UtilRgb.brighten(text.color, 0.5), text.alpha);
            var outline = EShapeActionBases.toBaseTextOutline(shape, runtime);
            shape.text.outline.set(undefined, UtilRgb.brighten(outline.color, 0.5), outline.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkBrighten;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkColorFill = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkColorFill, _super);
        function EShapeActionRuntimeBlinkColorFill(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.COLOR_FILL) || this;
            _this.color = value.color;
            _this.alpha = value.alpha;
            return _this;
        }
        EShapeActionRuntimeBlinkColorFill.prototype.toOn = function (shape, runtime) {
            shape.fill.set(undefined, this.color, this.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkColorFill;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkColorStroke = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkColorStroke, _super);
        function EShapeActionRuntimeBlinkColorStroke(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.COLOR_STROKE) || this;
            _this.color = value.color;
            _this.alpha = value.alpha;
            return _this;
        }
        EShapeActionRuntimeBlinkColorStroke.prototype.toOn = function (shape, runtime) {
            shape.stroke.set(undefined, this.color, this.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkColorStroke;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkDarken = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkDarken, _super);
        function EShapeActionRuntimeBlinkDarken(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeBlinkDarken.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, UtilRgb.darken(fill.color, 0.5), fill.alpha);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, UtilRgb.darken(stroke.color, 0.5), stroke.alpha);
            var text = EShapeActionBases.toBaseText(shape, runtime);
            shape.text.set(undefined, UtilRgb.darken(text.color, 0.5), text.alpha);
            var outline = EShapeActionBases.toBaseTextOutline(shape, runtime);
            shape.text.outline.set(undefined, UtilRgb.darken(outline.color, 0.5), outline.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkDarken;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkOpacity = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkOpacity, _super);
        function EShapeActionRuntimeBlinkOpacity(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_FILL_AND_STROKE) || this;
        }
        EShapeActionRuntimeBlinkOpacity.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, fill.color, fill.alpha * 0.5);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, stroke.color, stroke.alpha * 0.5);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkOpacity;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkVisibility = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkVisibility, _super);
        function EShapeActionRuntimeBlinkVisibility(value) {
            return _super.call(this, value, EShapeRuntimeReset.VISIBILITY) || this;
        }
        EShapeActionRuntimeBlinkVisibility.prototype.toOn = function (shape, runtime) {
            shape.visible = true;
            runtime.written |= this.reset;
        };
        EShapeActionRuntimeBlinkVisibility.prototype.toOff = function (shape, runtime) {
            shape.visible = false;
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkVisibility;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBlinkType;
    (function (EShapeActionValueBlinkType) {
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["VISIBILITY"] = 0] = "VISIBILITY";
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["BRIGHTEN"] = 1] = "BRIGHTEN";
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["DARKEN"] = 2] = "DARKEN";
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["OPACITY"] = 3] = "OPACITY";
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["COLOR_FILL"] = 4] = "COLOR_FILL";
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["COLOR_STROKE"] = 5] = "COLOR_STROKE";
    })(EShapeActionValueBlinkType || (EShapeActionValueBlinkType = {}));

    var EShapeActionValueBase = /** @class */ (function () {
        function EShapeActionValueBase(type, condition) {
            this.type = type;
            this.condition = condition;
        }
        EShapeActionValueBase.prototype.isEquals = function (value) {
            return (this.type === value.type &&
                this.condition === value.condition);
        };
        EShapeActionValueBase.prototype.toLabel = function () {
            return DThemes.getInstance().get("EShapeActionValue").toLabel(this);
        };
        return EShapeActionValueBase;
    }());

    var EShapeActionValueSubtyped = /** @class */ (function (_super) {
        __extends(EShapeActionValueSubtyped, _super);
        function EShapeActionValueSubtyped(type, condition, subtype) {
            var _this = _super.call(this, type, condition) || this;
            _this.subtype = subtype;
            return _this;
        }
        EShapeActionValueSubtyped.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueSubtyped) &&
                this.subtype === value.subtype);
        };
        return EShapeActionValueSubtyped;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueType;
    (function (EShapeActionValueType) {
        EShapeActionValueType[EShapeActionValueType["SHOW_HIDE"] = 0] = "SHOW_HIDE";
        EShapeActionValueType[EShapeActionValueType["BLINK"] = 1] = "BLINK";
        EShapeActionValueType[EShapeActionValueType["TRANSFORM"] = 2] = "TRANSFORM";
        EShapeActionValueType[EShapeActionValueType["OPEN"] = 3] = "OPEN";
        EShapeActionValueType[EShapeActionValueType["EMIT_EVENT"] = 4] = "EMIT_EVENT";
        EShapeActionValueType[EShapeActionValueType["CHANGE_COLOR"] = 5] = "CHANGE_COLOR";
        EShapeActionValueType[EShapeActionValueType["CHANGE_TEXT"] = 6] = "CHANGE_TEXT";
        EShapeActionValueType[EShapeActionValueType["CHANGE_CURSOR"] = 7] = "CHANGE_CURSOR";
        EShapeActionValueType[EShapeActionValueType["MISC"] = 8] = "MISC";
    })(EShapeActionValueType || (EShapeActionValueType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValues = /** @class */ (function () {
        function EShapeActionValues() {
        }
        EShapeActionValues.toResource = function (index, parsed, resources) {
            if (0 <= index && index < parsed.length) {
                var id = parsed[index];
                if (isNumber(id) && 0 <= id && id < resources.length) {
                    return resources[id];
                }
            }
            return "";
        };
        return EShapeActionValues;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBlink = /** @class */ (function (_super) {
        __extends(EShapeActionValueBlink, _super);
        function EShapeActionValueBlink(subtype, condition, interval, color, alpha) {
            var _this = _super.call(this, EShapeActionValueType.BLINK, condition, subtype) || this;
            _this.interval = interval;
            _this.color = color;
            _this.alpha = alpha;
            return _this;
        }
        EShapeActionValueBlink.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueBlink) &&
                this.interval === value.interval &&
                this.color === value.color &&
                this.alpha === value.alpha);
        };
        EShapeActionValueBlink.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueBlinkType.BRIGHTEN:
                    return new EShapeActionRuntimeBlinkBrighten(this);
                case EShapeActionValueBlinkType.COLOR_FILL:
                    return new EShapeActionRuntimeBlinkColorFill(this);
                case EShapeActionValueBlinkType.COLOR_STROKE:
                    return new EShapeActionRuntimeBlinkColorStroke(this);
                case EShapeActionValueBlinkType.DARKEN:
                    return new EShapeActionRuntimeBlinkDarken(this);
                case EShapeActionValueBlinkType.OPACITY:
                    return new EShapeActionRuntimeBlinkOpacity(this);
                case EShapeActionValueBlinkType.VISIBILITY:
                    return new EShapeActionRuntimeBlinkVisibility(this);
            }
        };
        EShapeActionValueBlink.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "," + this.interval + "," + this.color + "," + this.alpha + "]");
        };
        EShapeActionValueBlink.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueBlink(serialized[2], condition, serialized[3], serialized[4], serialized[5]);
        };
        return EShapeActionValueBlink;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilAlpha = /** @class */ (function () {
        function UtilAlpha() {
        }
        UtilAlpha.blend = function (alphaA, alphaB, t) {
            var w = Math.max(0, Math.min(1, t));
            return Math.max(0, Math.min(1, alphaA * (1 - w) + alphaB * w));
        };
        return UtilAlpha;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorTarget;
    (function (EShapeActionValueChangeColorTarget) {
        EShapeActionValueChangeColorTarget[EShapeActionValueChangeColorTarget["COLOR_AND_ALPHA"] = 0] = "COLOR_AND_ALPHA";
        EShapeActionValueChangeColorTarget[EShapeActionValueChangeColorTarget["COLOR"] = 1] = "COLOR";
        EShapeActionValueChangeColorTarget[EShapeActionValueChangeColorTarget["ALPHA"] = 2] = "ALPHA";
        EShapeActionValueChangeColorTarget[EShapeActionValueChangeColorTarget["CODE"] = 3] = "CODE";
        EShapeActionValueChangeColorTarget[EShapeActionValueChangeColorTarget["BRIGHTNESS"] = 4] = "BRIGHTNESS";
    })(EShapeActionValueChangeColorTarget || (EShapeActionValueChangeColorTarget = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var blendDefault = function () { return null; };
    var EShapeActionRuntimeChangeColor = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColor, _super);
        function EShapeActionRuntimeChangeColor(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            switch (value.target) {
                case EShapeActionValueChangeColorTarget.COLOR:
                    _this.color = value.color;
                    _this.alpha = undefined;
                    break;
                case EShapeActionValueChangeColorTarget.ALPHA:
                    _this.color = undefined;
                    _this.alpha = value.alpha;
                    break;
                default:
                    _this.color = value.color;
                    _this.alpha = value.alpha;
                    break;
            }
            _this.blend = _this.toExpression(value.blend, blendDefault, "null");
            return _this;
        }
        EShapeActionRuntimeChangeColor.prototype.set = function (shape, runtime, time, target, base) {
            var color = this.color;
            var alpha = this.alpha;
            if (color != null) {
                if (alpha != null) {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        target.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    else {
                        target.set(undefined, color, alpha);
                    }
                }
                else {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        target.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                    }
                    else {
                        target.set(undefined, color, base.alpha);
                    }
                }
                runtime.written |= this.reset;
            }
            else if (alpha != null) {
                var blend = this.blend(shape, time);
                if (blend != null) {
                    target.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                }
                else {
                    target.set(undefined, base.color, alpha);
                }
                runtime.written |= this.reset;
            }
        };
        EShapeActionRuntimeChangeColor.prototype.sets = function (shape, runtime, time, fill, stroke, baseFill, baseStroke) {
            var color = this.color;
            var alpha = this.alpha;
            if (color != null) {
                if (alpha != null) {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        fill.set(undefined, UtilRgb.blend(baseFill.color, color, blend), UtilAlpha.blend(baseFill.alpha, alpha, blend));
                        stroke.set(undefined, UtilRgb.blend(baseStroke.color, color, blend), UtilAlpha.blend(baseStroke.alpha, alpha, blend));
                    }
                    else {
                        fill.set(undefined, color, alpha);
                        stroke.set(undefined, color, alpha);
                    }
                }
                else {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        fill.set(undefined, UtilRgb.blend(baseFill.color, color, blend), baseFill.alpha);
                        stroke.set(undefined, UtilRgb.blend(baseStroke.color, color, blend), baseStroke.alpha);
                    }
                    else {
                        fill.set(undefined, color, baseFill.alpha);
                        stroke.set(undefined, color, baseStroke.alpha);
                    }
                }
                runtime.written |= this.reset;
            }
            else if (alpha != null) {
                var blend = this.blend(shape, time);
                if (blend != null) {
                    fill.set(undefined, baseFill.color, UtilAlpha.blend(baseFill.alpha, alpha, blend));
                    stroke.set(undefined, baseStroke.color, UtilAlpha.blend(baseStroke.alpha, alpha, blend));
                }
                else {
                    fill.set(undefined, baseFill.color, alpha);
                    stroke.set(undefined, baseStroke.color, alpha);
                }
                runtime.written |= this.reset;
            }
        };
        EShapeActionRuntimeChangeColor.prototype.setAll = function (shape, runtime, time, fill, stroke, text, outline, baseFill, baseStroke, baseText, baseOutline) {
            var color = this.color;
            var alpha = this.alpha;
            if (color != null) {
                if (alpha != null) {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        fill.set(undefined, UtilRgb.blend(baseFill.color, color, blend), UtilAlpha.blend(baseFill.alpha, alpha, blend));
                        stroke.set(undefined, UtilRgb.blend(baseStroke.color, color, blend), UtilAlpha.blend(baseStroke.alpha, alpha, blend));
                        text.set(undefined, UtilRgb.blend(baseText.color, color, blend), UtilAlpha.blend(baseText.alpha, alpha, blend));
                        outline.set(undefined, UtilRgb.blend(baseOutline.color, color, blend), UtilAlpha.blend(baseOutline.alpha, alpha, blend));
                    }
                    else {
                        fill.set(undefined, color, alpha);
                        stroke.set(undefined, color, alpha);
                        text.set(undefined, color, alpha);
                        outline.set(undefined, color, alpha);
                    }
                }
                else {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        fill.set(undefined, UtilRgb.blend(baseFill.color, color, blend), baseFill.alpha);
                        stroke.set(undefined, UtilRgb.blend(baseStroke.color, color, blend), baseStroke.alpha);
                        text.set(undefined, UtilRgb.blend(baseText.color, color, blend), baseText.alpha);
                        outline.set(undefined, UtilRgb.blend(baseOutline.color, color, blend), baseOutline.alpha);
                    }
                    else {
                        fill.set(undefined, color, baseFill.alpha);
                        stroke.set(undefined, color, baseStroke.alpha);
                        text.set(undefined, color, baseText.alpha);
                        outline.set(undefined, color, baseOutline.alpha);
                    }
                }
                runtime.written |= this.reset;
            }
            else if (alpha != null) {
                var blend = this.blend(shape, time);
                if (blend != null) {
                    fill.set(undefined, baseFill.color, UtilAlpha.blend(baseFill.alpha, alpha, blend));
                    stroke.set(undefined, baseStroke.color, UtilAlpha.blend(baseStroke.alpha, alpha, blend));
                    text.set(undefined, baseFill.color, UtilAlpha.blend(baseText.alpha, alpha, blend));
                    outline.set(undefined, baseStroke.color, UtilAlpha.blend(baseOutline.alpha, alpha, blend));
                }
                else {
                    fill.set(undefined, baseFill.color, alpha);
                    stroke.set(undefined, baseStroke.color, alpha);
                    text.set(undefined, baseText.color, alpha);
                    outline.set(undefined, baseOutline.color, alpha);
                }
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeChangeColor;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorAll = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorAll, _super);
        function EShapeActionRuntimeChangeColorAll(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeChangeColorAll.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.setAll(shape, runtime, time, shape.fill, shape.stroke, shape.text, shape.text.outline, EShapeActionBases.toBaseFill(shape, runtime), EShapeActionBases.toBaseStroke(shape, runtime), EShapeActionBases.toBaseText(shape, runtime), EShapeActionBases.toBaseTextOutline(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorAll;
    }(EShapeActionRuntimeChangeColor));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorFill = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorFill, _super);
        function EShapeActionRuntimeChangeColorFill(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_FILL) || this;
        }
        EShapeActionRuntimeChangeColorFill.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.fill, EShapeActionBases.toBaseFill(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorFill;
    }(EShapeActionRuntimeChangeColor));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorFillAndStroke = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorFillAndStroke, _super);
        function EShapeActionRuntimeChangeColorFillAndStroke(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_FILL_AND_STROKE) || this;
        }
        EShapeActionRuntimeChangeColorFillAndStroke.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.sets(shape, runtime, time, shape.fill, shape.stroke, EShapeActionBases.toBaseFill(shape, runtime), EShapeActionBases.toBaseStroke(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorFillAndStroke;
    }(EShapeActionRuntimeChangeColor));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorStroke = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorStroke, _super);
        function EShapeActionRuntimeChangeColorStroke(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_STROKE) || this;
        }
        EShapeActionRuntimeChangeColorStroke.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.stroke, EShapeActionBases.toBaseStroke(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorStroke;
    }(EShapeActionRuntimeChangeColor));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorText, _super);
        function EShapeActionRuntimeChangeColorText(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_TEXT) || this;
        }
        EShapeActionRuntimeChangeColorText.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.text, EShapeActionBases.toBaseText(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorText;
    }(EShapeActionRuntimeChangeColor));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorTextOutline = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorTextOutline, _super);
        function EShapeActionRuntimeChangeColorTextOutline(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_TEXT_OUTLINE) || this;
        }
        EShapeActionRuntimeChangeColorTextOutline.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.text.outline, EShapeActionBases.toBaseTextOutline(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorTextOutline;
    }(EShapeActionRuntimeChangeColor));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorType;
    (function (EShapeActionValueChangeColorType) {
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["FILL"] = 0] = "FILL";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["STROKE"] = 1] = "STROKE";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["FILL_AND_STROKE"] = 2] = "FILL_AND_STROKE";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["TEXT"] = 3] = "TEXT";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["TEXT_OUTLINE"] = 4] = "TEXT_OUTLINE";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["ALL"] = 5] = "ALL";
    })(EShapeActionValueChangeColorType || (EShapeActionValueChangeColorType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColor = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColor, _super);
        function EShapeActionValueChangeColor(subtype, condition, target, color, alpha, blend) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.target = target;
            _this.color = color;
            _this.alpha = alpha;
            _this.blend = blend;
            return _this;
        }
        EShapeActionValueChangeColor.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueChangeColor) &&
                this.target === value.target &&
                this.color === value.color &&
                this.alpha === value.alpha &&
                this.blend === value.blend);
        };
        EShapeActionValueChangeColor.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueChangeColorType.FILL:
                    return new EShapeActionRuntimeChangeColorFill(this);
                case EShapeActionValueChangeColorType.STROKE:
                    return new EShapeActionRuntimeChangeColorStroke(this);
                case EShapeActionValueChangeColorType.FILL_AND_STROKE:
                    return new EShapeActionRuntimeChangeColorFillAndStroke(this);
                case EShapeActionValueChangeColorType.TEXT:
                    return new EShapeActionRuntimeChangeColorText(this);
                case EShapeActionValueChangeColorType.TEXT_OUTLINE:
                    return new EShapeActionRuntimeChangeColorTextOutline(this);
                case EShapeActionValueChangeColorType.ALL:
                    return new EShapeActionRuntimeChangeColorAll(this);
            }
        };
        EShapeActionValueChangeColor.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            var blendId = manager.add(this.blend);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "," + this.target + "," + this.color + "," + this.alpha + "," + blendId + "]");
        };
        EShapeActionValueChangeColor.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var blend = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueChangeColor(serialized[2], condition, serialized[3], serialized[4], serialized[5], blend);
        };
        return EShapeActionValueChangeColor;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var brightnessDefault = function () { return null; };
    var EShapeActionRuntimeChangeColorBrightness = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBrightness, _super);
        function EShapeActionRuntimeChangeColorBrightness(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.brightness = _this.toExpression(value.brightness, brightnessDefault, "null");
            return _this;
        }
        EShapeActionRuntimeChangeColorBrightness.prototype.set = function (shape, runtime, time, target, base) {
            var brightness = this.brightness(shape, time);
            if (brightness != null) {
                target.set(undefined, this.toColorAdjusted(base.color, brightness), base.alpha);
                runtime.written |= this.reset;
            }
        };
        EShapeActionRuntimeChangeColorBrightness.prototype.sets = function (shape, runtime, time, fill, stroke, baseFill, baseStroke) {
            var brightness = this.brightness(shape, time);
            if (brightness != null) {
                fill.set(undefined, this.toColorAdjusted(baseFill.color, brightness), baseFill.alpha);
                stroke.set(undefined, this.toColorAdjusted(baseStroke.color, brightness), baseStroke.alpha);
                runtime.written |= this.reset;
            }
        };
        EShapeActionRuntimeChangeColorBrightness.prototype.setAll = function (shape, runtime, time, fill, stroke, text, outline, baseFill, baseStroke, baseText, baseOutline) {
            var brightness = this.brightness(shape, time);
            if (brightness != null) {
                fill.set(undefined, this.toColorAdjusted(baseFill.color, brightness), baseFill.alpha);
                stroke.set(undefined, this.toColorAdjusted(baseStroke.color, brightness), baseStroke.alpha);
                text.set(undefined, this.toColorAdjusted(baseText.color, brightness), baseText.alpha);
                outline.set(undefined, this.toColorAdjusted(baseOutline.color, brightness), baseOutline.alpha);
                runtime.written |= this.reset;
            }
        };
        EShapeActionRuntimeChangeColorBrightness.prototype.toColorAdjusted = function (color, brightness) {
            if (0 <= brightness) {
                return UtilRgb.brighten(color, +brightness);
            }
            else {
                return UtilRgb.darken(color, -brightness);
            }
        };
        return EShapeActionRuntimeChangeColorBrightness;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorBrightnessAll = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBrightnessAll, _super);
        function EShapeActionRuntimeChangeColorBrightnessAll(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeChangeColorBrightnessAll.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.setAll(shape, runtime, time, shape.fill, shape.stroke, shape.text, shape.text.outline, EShapeActionBases.toBaseFill(shape, runtime), EShapeActionBases.toBaseStroke(shape, runtime), EShapeActionBases.toBaseText(shape, runtime), EShapeActionBases.toBaseTextOutline(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorBrightnessAll;
    }(EShapeActionRuntimeChangeColorBrightness));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorBrightnessFill = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBrightnessFill, _super);
        function EShapeActionRuntimeChangeColorBrightnessFill(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_FILL) || this;
        }
        EShapeActionRuntimeChangeColorBrightnessFill.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.fill, EShapeActionBases.toBaseFill(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorBrightnessFill;
    }(EShapeActionRuntimeChangeColorBrightness));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorBrightnessFillAndStroke = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBrightnessFillAndStroke, _super);
        function EShapeActionRuntimeChangeColorBrightnessFillAndStroke(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_FILL_AND_STROKE) || this;
        }
        EShapeActionRuntimeChangeColorBrightnessFillAndStroke.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.sets(shape, runtime, time, shape.fill, shape.stroke, EShapeActionBases.toBaseFill(shape, runtime), EShapeActionBases.toBaseStroke(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorBrightnessFillAndStroke;
    }(EShapeActionRuntimeChangeColorBrightness));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorBrightnessStroke = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBrightnessStroke, _super);
        function EShapeActionRuntimeChangeColorBrightnessStroke(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_STROKE) || this;
        }
        EShapeActionRuntimeChangeColorBrightnessStroke.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.stroke, EShapeActionBases.toBaseStroke(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorBrightnessStroke;
    }(EShapeActionRuntimeChangeColorBrightness));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorBrightnessText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBrightnessText, _super);
        function EShapeActionRuntimeChangeColorBrightnessText(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_TEXT) || this;
        }
        EShapeActionRuntimeChangeColorBrightnessText.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.text, EShapeActionBases.toBaseText(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorBrightnessText;
    }(EShapeActionRuntimeChangeColorBrightness));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorBrightnessTextOutline = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBrightnessTextOutline, _super);
        function EShapeActionRuntimeChangeColorBrightnessTextOutline(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_TEXT_OUTLINE) || this;
        }
        EShapeActionRuntimeChangeColorBrightnessTextOutline.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.text.outline, EShapeActionBases.toBaseTextOutline(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorBrightnessTextOutline;
    }(EShapeActionRuntimeChangeColorBrightness));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorBrightness = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColorBrightness, _super);
        function EShapeActionValueChangeColorBrightness(subtype, condition, brightness) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.brightness = brightness;
            return _this;
        }
        EShapeActionValueChangeColorBrightness.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueChangeColorBrightness) &&
                this.brightness === value.brightness);
        };
        EShapeActionValueChangeColorBrightness.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueChangeColorType.FILL:
                    return new EShapeActionRuntimeChangeColorBrightnessFill(this);
                case EShapeActionValueChangeColorType.STROKE:
                    return new EShapeActionRuntimeChangeColorBrightnessStroke(this);
                case EShapeActionValueChangeColorType.FILL_AND_STROKE:
                    return new EShapeActionRuntimeChangeColorBrightnessFillAndStroke(this);
                case EShapeActionValueChangeColorType.TEXT:
                    return new EShapeActionRuntimeChangeColorBrightnessText(this);
                case EShapeActionValueChangeColorType.TEXT_OUTLINE:
                    return new EShapeActionRuntimeChangeColorBrightnessTextOutline(this);
                case EShapeActionValueChangeColorType.ALL:
                    return new EShapeActionRuntimeChangeColorBrightnessAll(this);
            }
        };
        EShapeActionValueChangeColorBrightness.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            var target = EShapeActionValueChangeColorTarget.BRIGHTNESS;
            var brightnessId = manager.add(this.brightness);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "," + target + "," + brightnessId + "]");
        };
        EShapeActionValueChangeColorBrightness.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var brightness = EShapeActionValues.toResource(4, serialized, manager.resources);
            return new EShapeActionValueChangeColorBrightness(serialized[2], condition, brightness);
        };
        return EShapeActionValueChangeColorBrightness;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var colorDefault = function () { return null; };
    var alphaDefault = function () { return null; };
    var blendDefault$1 = function () { return null; };
    var EShapeActionRuntimeChangeColorCode = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorCode, _super);
        function EShapeActionRuntimeChangeColorCode(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.color = _this.toExpression(value.color, colorDefault, "null");
            _this.alpha = _this.toExpression(value.alpha, alphaDefault, "null");
            _this.blend = _this.toExpression(value.blend, blendDefault$1, "null");
            return _this;
        }
        EShapeActionRuntimeChangeColorCode.prototype.set = function (shape, runtime, time, target, base) {
            var color = this.color(shape, time);
            var alpha = this.alpha(shape, time);
            if (color != null) {
                if (alpha != null) {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        target.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    else {
                        target.set(undefined, color, alpha);
                    }
                }
                else {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        target.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                    }
                    else {
                        target.set(undefined, color, base.alpha);
                    }
                }
                runtime.written |= this.reset;
            }
            else if (alpha != null) {
                var blend = this.blend(shape, time);
                if (blend != null) {
                    target.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                }
                else {
                    target.set(undefined, base.color, alpha);
                }
                runtime.written |= this.reset;
            }
        };
        EShapeActionRuntimeChangeColorCode.prototype.sets = function (shape, runtime, time, fill, stroke, baseFill, baseStroke) {
            var color = this.color(shape, time);
            var alpha = this.alpha(shape, time);
            if (color != null) {
                if (alpha != null) {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        fill.set(undefined, UtilRgb.blend(baseFill.color, color, blend), UtilAlpha.blend(baseFill.alpha, alpha, blend));
                        stroke.set(undefined, UtilRgb.blend(baseStroke.color, color, blend), UtilAlpha.blend(baseStroke.alpha, alpha, blend));
                    }
                    else {
                        fill.set(undefined, color, alpha);
                        stroke.set(undefined, color, alpha);
                    }
                }
                else {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        fill.set(undefined, UtilRgb.blend(baseFill.color, color, blend), baseFill.alpha);
                        stroke.set(undefined, UtilRgb.blend(baseStroke.color, color, blend), baseStroke.alpha);
                    }
                    else {
                        fill.set(undefined, color, baseFill.alpha);
                        stroke.set(undefined, color, baseStroke.alpha);
                    }
                }
                runtime.written |= this.reset;
            }
            else if (alpha != null) {
                var blend = this.blend(shape, time);
                if (blend != null) {
                    fill.set(undefined, baseFill.color, UtilAlpha.blend(baseFill.alpha, alpha, blend));
                    stroke.set(undefined, baseStroke.color, UtilAlpha.blend(baseStroke.alpha, alpha, blend));
                }
                else {
                    fill.set(undefined, baseFill.color, alpha);
                    stroke.set(undefined, baseStroke.color, alpha);
                }
                runtime.written |= this.reset;
            }
        };
        EShapeActionRuntimeChangeColorCode.prototype.setAll = function (shape, runtime, time, fill, stroke, text, outline, baseFill, baseStroke, baseText, baseOutline) {
            var color = this.color(shape, time);
            var alpha = this.alpha(shape, time);
            if (color != null) {
                if (alpha != null) {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        fill.set(undefined, UtilRgb.blend(baseFill.color, color, blend), UtilAlpha.blend(baseFill.alpha, alpha, blend));
                        stroke.set(undefined, UtilRgb.blend(baseStroke.color, color, blend), UtilAlpha.blend(baseStroke.alpha, alpha, blend));
                        text.set(undefined, UtilRgb.blend(baseText.color, color, blend), UtilAlpha.blend(baseText.alpha, alpha, blend));
                        outline.set(undefined, UtilRgb.blend(baseOutline.color, color, blend), UtilAlpha.blend(baseOutline.alpha, alpha, blend));
                    }
                    else {
                        fill.set(undefined, color, alpha);
                        stroke.set(undefined, color, alpha);
                        text.set(undefined, color, alpha);
                        outline.set(undefined, color, alpha);
                    }
                }
                else {
                    var blend = this.blend(shape, time);
                    if (blend != null) {
                        fill.set(undefined, UtilRgb.blend(baseFill.color, color, blend), baseFill.alpha);
                        stroke.set(undefined, UtilRgb.blend(baseStroke.color, color, blend), baseStroke.alpha);
                        text.set(undefined, UtilRgb.blend(baseText.color, color, blend), baseText.alpha);
                        outline.set(undefined, UtilRgb.blend(baseOutline.color, color, blend), baseOutline.alpha);
                    }
                    else {
                        fill.set(undefined, color, baseFill.alpha);
                        stroke.set(undefined, color, baseStroke.alpha);
                        text.set(undefined, color, baseText.alpha);
                        outline.set(undefined, color, baseOutline.alpha);
                    }
                }
                runtime.written |= this.reset;
            }
            else if (alpha != null) {
                var blend = this.blend(shape, time);
                if (blend != null) {
                    fill.set(undefined, baseFill.color, UtilAlpha.blend(baseFill.alpha, alpha, blend));
                    stroke.set(undefined, baseStroke.color, UtilAlpha.blend(baseStroke.alpha, alpha, blend));
                    text.set(undefined, baseFill.color, UtilAlpha.blend(baseText.alpha, alpha, blend));
                    outline.set(undefined, baseStroke.color, UtilAlpha.blend(baseOutline.alpha, alpha, blend));
                }
                else {
                    fill.set(undefined, baseFill.color, alpha);
                    stroke.set(undefined, baseStroke.color, alpha);
                    text.set(undefined, baseText.color, alpha);
                    outline.set(undefined, baseOutline.color, alpha);
                }
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeChangeColorCode;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorCodeAll = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorCodeAll, _super);
        function EShapeActionRuntimeChangeColorCodeAll(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeChangeColorCodeAll.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.setAll(shape, runtime, time, shape.fill, shape.stroke, shape.text, shape.text.outline, EShapeActionBases.toBaseFill(shape, runtime), EShapeActionBases.toBaseStroke(shape, runtime), EShapeActionBases.toBaseText(shape, runtime), EShapeActionBases.toBaseTextOutline(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorCodeAll;
    }(EShapeActionRuntimeChangeColorCode));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorCodeFill = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorCodeFill, _super);
        function EShapeActionRuntimeChangeColorCodeFill(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_FILL) || this;
        }
        EShapeActionRuntimeChangeColorCodeFill.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.fill, EShapeActionBases.toBaseFill(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorCodeFill;
    }(EShapeActionRuntimeChangeColorCode));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorCodeFillAndStroke = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorCodeFillAndStroke, _super);
        function EShapeActionRuntimeChangeColorCodeFillAndStroke(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_FILL_AND_STROKE) || this;
        }
        EShapeActionRuntimeChangeColorCodeFillAndStroke.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.sets(shape, runtime, time, shape.fill, shape.stroke, EShapeActionBases.toBaseFill(shape, runtime), EShapeActionBases.toBaseStroke(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorCodeFillAndStroke;
    }(EShapeActionRuntimeChangeColorCode));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorCodeStroke = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorCodeStroke, _super);
        function EShapeActionRuntimeChangeColorCodeStroke(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_STROKE) || this;
        }
        EShapeActionRuntimeChangeColorCodeStroke.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.stroke, EShapeActionBases.toBaseStroke(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorCodeStroke;
    }(EShapeActionRuntimeChangeColorCode));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorCodeText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorCodeText, _super);
        function EShapeActionRuntimeChangeColorCodeText(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_TEXT) || this;
        }
        EShapeActionRuntimeChangeColorCodeText.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.text, EShapeActionBases.toBaseText(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorCodeText;
    }(EShapeActionRuntimeChangeColorCode));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorCodeTextOutline = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorCodeTextOutline, _super);
        function EShapeActionRuntimeChangeColorCodeTextOutline(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_TEXT_OUTLINE) || this;
        }
        EShapeActionRuntimeChangeColorCodeTextOutline.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                this.set(shape, runtime, time, shape.text.outline, EShapeActionBases.toBaseTextOutline(shape, runtime));
            }
        };
        return EShapeActionRuntimeChangeColorCodeTextOutline;
    }(EShapeActionRuntimeChangeColorCode));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorCode = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColorCode, _super);
        function EShapeActionValueChangeColorCode(subtype, condition, color, alpha, blend) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.color = color;
            _this.alpha = alpha;
            _this.blend = blend;
            return _this;
        }
        EShapeActionValueChangeColorCode.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueChangeColorCode) &&
                this.color === value.color &&
                this.alpha === value.alpha &&
                this.blend === value.blend);
        };
        EShapeActionValueChangeColorCode.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueChangeColorType.FILL:
                    return new EShapeActionRuntimeChangeColorCodeFill(this);
                case EShapeActionValueChangeColorType.STROKE:
                    return new EShapeActionRuntimeChangeColorCodeStroke(this);
                case EShapeActionValueChangeColorType.FILL_AND_STROKE:
                    return new EShapeActionRuntimeChangeColorCodeFillAndStroke(this);
                case EShapeActionValueChangeColorType.TEXT:
                    return new EShapeActionRuntimeChangeColorCodeText(this);
                case EShapeActionValueChangeColorType.TEXT_OUTLINE:
                    return new EShapeActionRuntimeChangeColorCodeTextOutline(this);
                case EShapeActionValueChangeColorType.ALL:
                    return new EShapeActionRuntimeChangeColorCodeAll(this);
            }
        };
        EShapeActionValueChangeColorCode.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            var target = EShapeActionValueChangeColorTarget.CODE;
            var colorId = manager.add(this.color);
            var alphaId = manager.add(this.alpha);
            var blendId = manager.add(this.blend);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "," + target + "," + colorId + "," + alphaId + "," + blendId + "]");
        };
        EShapeActionValueChangeColorCode.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var color = EShapeActionValues.toResource(4, serialized, manager.resources);
            var alpha = EShapeActionValues.toResource(5, serialized, manager.resources);
            var blend = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueChangeColorCode(serialized[2], condition, color, alpha, blend);
        };
        return EShapeActionValueChangeColorCode;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var nameDefault = function () { return null; };
    var EShapeActionRuntimeChangeCursor = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeCursor, _super);
        function EShapeActionRuntimeChangeCursor(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.CURSOR) || this;
            _this.name = _this.toExpression(value.name, nameDefault, "null");
            return _this;
        }
        EShapeActionRuntimeChangeCursor.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var name_1 = this.name(shape, time);
                if (name_1 != null) {
                    shape.cursor = name_1;
                    runtime.written |= this.reset;
                }
            }
        };
        return EShapeActionRuntimeChangeCursor;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeCursor = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeCursor, _super);
        function EShapeActionValueChangeCursor(condition, name) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_CURSOR, condition) || this;
            _this.name = name;
            return _this;
        }
        EShapeActionValueChangeCursor.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueChangeCursor) &&
                this.name === value.name);
        };
        EShapeActionValueChangeCursor.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeCursor(this);
        };
        EShapeActionValueChangeCursor.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            var nameId = manager.add(this.name);
            return manager.add("[" + this.type + "," + conditionId + "," + nameId + "]");
        };
        EShapeActionValueChangeCursor.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var name = EShapeActionValues.toResource(2, serialized, manager.resources);
            return new EShapeActionValueChangeCursor(condition, name);
        };
        return EShapeActionValueChangeCursor;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeA = /** @class */ (function () {
        function FormatNodeA() {
        }
        FormatNodeA.prototype.format = function (target, step, date) {
            return (date.getHours() < 12 ? "AM" : "PM");
        };
        return FormatNodeA;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodea = /** @class */ (function () {
        function FormatNodea() {
        }
        FormatNodea.prototype.format = function (target, step, date) {
            return (date.getHours() < 12 ? "am" : "pm");
        };
        return FormatNodea;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeD = /** @class */ (function () {
        function FormatNodeD() {
        }
        FormatNodeD.prototype.format = function (target, step, date) {
            return String(date.getDate());
        };
        return FormatNodeD;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoded = /** @class */ (function () {
        function FormatNoded() {
        }
        FormatNoded.prototype.format = function (target, step, date) {
            return "" + (target | 0);
        };
        return FormatNoded;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePrecision = /** @class */ (function () {
        function FormatNodePrecision(precision) {
            if (precision != null) {
                this.precision = +precision.substring(1, precision.length);
            }
            else {
                this.precision = undefined;
            }
        }
        return FormatNodePrecision;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodee = /** @class */ (function (_super) {
        __extends(FormatNodee, _super);
        function FormatNodee() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodee.prototype.format = function (target, step, date) {
            return target.toExponential(this.precision);
        };
        return FormatNodee;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodef = /** @class */ (function (_super) {
        __extends(FormatNodef, _super);
        function FormatNodef() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodef.prototype.format = function (target, step, date) {
            return target.toFixed(this.precision);
        };
        return FormatNodef;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodefsi = /** @class */ (function (_super) {
        __extends(FormatNodefsi, _super);
        function FormatNodefsi() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodefsi.prototype.format = function (target, step, date) {
            var abs = this.toAbs(target, step, date);
            if (abs < 1e-24) {
                return this.format_(target, 1e+00, "");
            }
            else if (abs < 1e-21) {
                return this.format_(target, 1e+24, "y");
            }
            else if (abs < 1e-18) {
                return this.format_(target, 1e+21, "z");
            }
            else if (abs < 1e-15) {
                return this.format_(target, 1e+18, "a");
            }
            else if (abs < 1e-12) {
                return this.format_(target, 1e+15, "f");
            }
            else if (abs < 1e-09) {
                return this.format_(target, 1e+12, "p");
            }
            else if (abs < 1e-06) {
                return this.format_(target, 1e+09, "n");
            }
            else if (abs < 1e-03) {
                return this.format_(target, 1e+06, "μ");
            }
            else if (abs < 1e+00) {
                return this.format_(target, 1e+03, "m");
            }
            else if (abs < 1e+03) {
                return this.format_(target, 1e+00, "");
            }
            else if (abs < 1e+06) {
                return this.format_(target, 1e-03, "k");
            }
            else if (abs < 1e+09) {
                return this.format_(target, 1e-06, "M");
            }
            else if (abs < 1e+12) {
                return this.format_(target, 1e-09, "G");
            }
            else if (abs < 1e+15) {
                return this.format_(target, 1e-12, "T");
            }
            else if (abs < 1e+18) {
                return this.format_(target, 1e-15, "P");
            }
            else if (abs < 1e+21) {
                return this.format_(target, 1e-18, "E");
            }
            else if (abs < 1e+24) {
                return this.format_(target, 1e-21, "Z");
            }
            else {
                return this.format_(target, 1e-24, "Y");
            }
        };
        FormatNodefsi.prototype.toAbs = function (target, step, date) {
            return Math.abs(target);
        };
        FormatNodefsi.prototype.format_ = function (target, unitInverse, postfix) {
            var value = target * unitInverse;
            return "" + value.toFixed(this.precision) + postfix;
        };
        return FormatNodefsi;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeg = /** @class */ (function (_super) {
        __extends(FormatNodeg, _super);
        function FormatNodeg() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodeg.prototype.format = function (target, step, date) {
            return target.toPrecision(this.precision);
        };
        return FormatNodeg;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeH = /** @class */ (function () {
        function FormatNodeH() {
        }
        FormatNodeH.prototype.format = function (target, step, date) {
            return String(date.getHours());
        };
        return FormatNodeH;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeh = /** @class */ (function () {
        function FormatNodeh() {
        }
        FormatNodeh.prototype.format = function (target, step, date) {
            return String(date.getHours() % 12);
        };
        return FormatNodeh;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeM = /** @class */ (function () {
        function FormatNodeM() {
        }
        FormatNodeM.prototype.format = function (target, step, date) {
            return String(date.getMonth() + 1);
        };
        return FormatNodeM;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodem = /** @class */ (function () {
        function FormatNodem() {
        }
        FormatNodem.prototype.format = function (target, step, date) {
            return String(date.getMinutes());
        };
        return FormatNodem;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodemi = /** @class */ (function () {
        function FormatNodemi() {
        }
        FormatNodemi.prototype.format = function (target, step, date) {
            return String(date.getMilliseconds());
        };
        return FormatNodemi;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeP = /** @class */ (function () {
        function FormatNodeP() {
        }
        FormatNodeP.prototype.format = function (target, step, date) {
            return ((target * 100) | 0) + "%";
        };
        return FormatNodeP;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodep = /** @class */ (function () {
        function FormatNodep() {
        }
        FormatNodep.prototype.format = function (target, step, date) {
            return (target | 0) + "%";
        };
        return FormatNodep;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePadding = /** @class */ (function () {
        function FormatNodePadding(length, character, node) {
            this.length = length;
            this.character = character;
            this.node = node;
        }
        FormatNodePadding.prototype.format = function (target, step, date) {
            return toPadded(this.node.format(target, step, date), this.length, this.character);
        };
        return FormatNodePadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeParenthesis = /** @class */ (function () {
        function FormatNodeParenthesis(node) {
            this.node = node;
        }
        FormatNodeParenthesis.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] === "-") {
                return "(" + result.substring(1, result.length) + ")";
            }
            return result;
        };
        return FormatNodeParenthesis;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePlus = /** @class */ (function () {
        function FormatNodePlus(node) {
            this.node = node;
        }
        FormatNodePlus.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] !== "-") {
                return "+" + result;
            }
            return result;
        };
        return FormatNodePlus;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeRP = /** @class */ (function () {
        function FormatNodeRP() {
        }
        FormatNodeRP.prototype.format = function (target, step, date) {
            return Math.round(target * 100) + "%";
        };
        return FormatNodeRP;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoderp = /** @class */ (function () {
        function FormatNoderp() {
        }
        FormatNoderp.prototype.format = function (target, step, date) {
            return Math.round(target) + "%";
        };
        return FormatNoderp;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodesdt = /** @class */ (function () {
        function FormatNodesdt(Y, M, D, H, m, s, mi) {
            this.Y = Y;
            this.M = M;
            this.D = D;
            this.H = H;
            this.m = m;
            this.s = s;
            this.mi = mi;
        }
        FormatNodesdt.prototype.format = function (target, step, date) {
            if (step < 1000) {
                return this.s.format(target, step, date) + "." + this.mi.format(target, step, date);
            }
            else if (step < 60000) {
                return this.m.format(target, step, date) + ":" + this.s.format(target, step, date);
            }
            else if (step < 3600000) {
                return this.H.format(target, step, date) + ":" + this.m.format(target, step, date);
            }
            else if (step < 86400000) {
                var M = this.M.format(target, step, date);
                var D = this.D.format(target, step, date);
                return M + "/" + D + " " + this.H.format(target, step, date);
            }
            else if (step < 2592000000) {
                return this.M.format(target, step, date) + "/" + this.D.format(target, step, date);
            }
            else {
                return this.Y.format(target, step, date) + "/" + this.M.format(target, step, date);
            }
        };
        return FormatNodesdt;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeSpace = /** @class */ (function () {
        function FormatNodeSpace(node) {
            this.node = node;
        }
        FormatNodeSpace.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] !== "-") {
                return " " + result;
            }
            return result;
        };
        return FormatNodeSpace;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodessi = /** @class */ (function (_super) {
        __extends(FormatNodessi, _super);
        function FormatNodessi() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodessi.prototype.toAbs = function (target, step, date) {
            return Math.abs(step);
        };
        return FormatNodessi;
    }(FormatNodefsi));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeString = /** @class */ (function () {
        function FormatNodeString(str) {
            this.str = str;
        }
        FormatNodeString.prototype.format = function (target, step, date) {
            return this.str;
        };
        return FormatNodeString;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeY = /** @class */ (function () {
        function FormatNodeY() {
        }
        FormatNodeY.prototype.format = function (target, step, date) {
            return String(date.getFullYear());
        };
        return FormatNodeY;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodey = /** @class */ (function () {
        function FormatNodey() {
        }
        FormatNodey.prototype.format = function (target, step, date) {
            return String(date.getFullYear() % 100);
        };
        return FormatNodey;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodez = /** @class */ (function () {
        function FormatNodez() {
        }
        FormatNodez.prototype.format = function (target, step, date) {
            var z = date.getTimezoneOffset();
            var tzs = (z <= 0 ? "+" : "-");
            var tzh = toPadded(String(Math.floor(Math.abs(z) / 60)), 2, "0");
            var tzm = toPadded(String(Math.floor(Math.abs(z) % 60)), 2, "0");
            return "" + tzs + tzh + ":" + tzm;
        };
        return FormatNodez;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoderd = /** @class */ (function () {
        function FormatNoderd() {
        }
        FormatNoderd.prototype.format = function (target, step, date) {
            return "" + Math.round(target);
        };
        return FormatNoderd;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodes = /** @class */ (function () {
        function FormatNodes() {
        }
        FormatNodes.prototype.format = function (target, step, date) {
            return String(date.getSeconds());
        };
        return FormatNodes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // tslint:disable-next-line: max-line-length
    var REGEXP = /%(0|_|-|\+|\()?(\.\d+)?(Y(?:MD?)?|y(?:MD?)?|MD?|D|H(?:ms?)?|h(?:ms?)?|m(?:i|s)?|a|A|s(?:s?i|dt)?|z|%|f(?:si)?|e|g|d|r(?:d|p)|p|P|RP)/g;
    /**
     * A NumberFormatter implementation class.
     */
    var NumberFormatterImpl = /** @class */ (function () {
        function NumberFormatterImpl(format) {
            var previousIndex = 0;
            var isDateRequired = false;
            var nodes = [];
            REGEXP.lastIndex = 0;
            while (true) {
                var matched = REGEXP.exec(format);
                if (matched != null) {
                    var index = matched.index;
                    if (previousIndex < index) {
                        nodes.push(new FormatNodeString(format.substring(previousIndex, index)));
                    }
                    previousIndex = index + matched[0].length;
                    var all = matched[0];
                    var modifier = matched[1];
                    var precision = matched[2];
                    var specifier = matched[3];
                    switch (specifier) {
                        case "Y": // full year
                            isDateRequired = true;
                            nodes.push(new FormatNodeY());
                            break;
                        case "YM":
                            isDateRequired = true;
                            nodes.push(new FormatNodeY(), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeM()));
                            break;
                        case "YMD":
                            isDateRequired = true;
                            nodes.push(new FormatNodeY(), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeM()), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeD()));
                            break;
                        case "y": // short year: [0, 99]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodey()));
                            break;
                        case "yM":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodey()), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeM()));
                            break;
                        case "yMD":
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodey()), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeM()), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeD()));
                            break;
                        case "M": // month: [1, 12]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeM()));
                            break;
                        case "MD":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeM()), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeD()));
                            break;
                        case "D": // day of the month: [1, 31]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeD()));
                            break;
                        case "H": // 24-hour clock: [0, 23]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeH()));
                            break;
                        case "Hm":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeH()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodem()));
                            break;
                        case "Hms":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeH()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodem()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodes()));
                            break;
                        case "h": // 12-hour clock: [1, 12]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeh()));
                            break;
                        case "hm":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeh()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodem()));
                            break;
                        case "hms":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeh()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodem()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodes()));
                            break;
                        case "m": // minute [0, 59]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodem()));
                            break;
                        case "ms":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodem()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodes()));
                            break;
                        case "mi": // milliseconds [0, 999]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime3(modifier, new FormatNodemi()));
                            break;
                        case "a": // am or pm
                            isDateRequired = true;
                            nodes.push(new FormatNodea());
                            break;
                        case "A": // AM or PM
                            isDateRequired = true;
                            nodes.push(new FormatNodeA());
                            break;
                        case "s": // seconds: [0, 61]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodes()));
                            break;
                        case "sdt":
                            isDateRequired = true;
                            nodes.push(new FormatNodesdt(new FormatNodeY(), this.toModifiedNodeDatetime2(modifier, new FormatNodeM()), this.toModifiedNodeDatetime2(modifier, new FormatNodeD()), this.toModifiedNodeDatetime2(modifier, new FormatNodeH()), this.toModifiedNodeDatetime2(modifier, new FormatNodem()), this.toModifiedNodeDatetime2(modifier, new FormatNodes()), this.toModifiedNodeDatetime3(modifier, new FormatNodemi())));
                            break;
                        case "z": // time zone
                            isDateRequired = true;
                            nodes.push(new FormatNodez());
                            break;
                        case "%": // a % literal
                            nodes.push(new FormatNodeString("%"));
                            break;
                        case "f": // fixed point notation
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodef(precision)));
                            break;
                        case "e": // exponent notation
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodee(precision)));
                            break;
                        case "g": // %f or %e
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodeg(precision)));
                            break;
                        case "rd": // rounded decimal notation
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNoderd()));
                            break;
                        case "d": // decimal notation
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNoded()));
                            break;
                        case "P": // percent notation (Multiplied by 100)
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodeP()));
                            break;
                        case "p": // percent notation (Not multiplied by 100)
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodep()));
                            break;
                        case "RP": // percent notation (Multiplied by 100)
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodeRP()));
                            break;
                        case "rp": // percent notation (Not multiplied by 100)
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNoderp()));
                            break;
                        case "fsi": // fixed point notation with a SI prefix
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodefsi(precision)));
                            break;
                        case "ssi": // Step-based fixed point notation with a SI prefix
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodessi(precision)));
                            break;
                        default:
                            nodes.push(new FormatNodeString(all));
                            break;
                    }
                }
                else {
                    if (previousIndex < format.length) {
                        nodes.push(new FormatNodeString(format.substring(previousIndex, format.length)));
                    }
                    break;
                }
            }
            this.isDateRequired = isDateRequired;
            this.nodes = nodes;
            this.date = new Date();
        }
        NumberFormatterImpl.prototype.toModifiedNodeDatetime2 = function (modifier, node) {
            switch (modifier) {
                case "_":
                    return new FormatNodePadding(2, " ", node);
                case "-":
                    return node;
                default:
                    return new FormatNodePadding(2, "0", node);
            }
        };
        NumberFormatterImpl.prototype.toModifiedNodeDatetime3 = function (modifier, node) {
            switch (modifier) {
                case "_":
                    return new FormatNodePadding(3, " ", node);
                case "-":
                    return node;
                default:
                    return new FormatNodePadding(3, "0", node);
            }
        };
        NumberFormatterImpl.prototype.toModifiedNodeNumber = function (modifier, node) {
            switch (modifier) {
                case "_": // space for non-negative numbers
                    return new FormatNodeSpace(node);
                case "+": // plus sign for non-negative numbers
                    return new FormatNodePlus(node);
                case "(": // parenthesis for the negative numbers
                    return new FormatNodeParenthesis(node);
                default:
                    return node;
            }
        };
        NumberFormatterImpl.prototype.format = function (target, step) {
            var nodes = this.nodes;
            var date = this.date;
            if (this.isDateRequired) {
                date.setTime(target);
            }
            var result = "";
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                result += nodes[i].format(target, step, date);
            }
            return result;
        };
        return NumberFormatterImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An number formatter utility class.
     */
    var NumberFormatters = /** @class */ (function () {
        function NumberFormatters() {
        }
        /**
         * Creates a number formatter of the given format.
         * Please refer to {@link NumberFormatter} for format details.
         *
         * @return A created number formatter
         */
        NumberFormatters.create = function (format) {
            return new NumberFormatterImpl(format);
        };
        return NumberFormatters;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var numberDefault = function () { return 0; };
    var EShapeActionRuntimeChangeTextNumber = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeTextNumber, _super);
        function EShapeActionRuntimeChangeTextNumber(value, format) {
            var _this = _super.call(this, value, EShapeRuntimeReset.TEXT) || this;
            _this.number = _this.toExpression(value.value, numberDefault, "0");
            format = format.trim();
            _this.formatter = (0 < format.length ? NumberFormatters.create(format) : null);
            return _this;
        }
        EShapeActionRuntimeChangeTextNumber.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var value = this.number(shape, time);
                shape.text.value = (this.formatter != null ? this.formatter.format(value, 0) : String(value));
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeChangeTextNumber;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var textDefault = function () { return ""; };
    var EShapeActionRuntimeChangeTextText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeTextText, _super);
        function EShapeActionRuntimeChangeTextText(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.TEXT) || this;
            _this.text = _this.toExpression(value.value, textDefault, "\"\"");
            return _this;
        }
        EShapeActionRuntimeChangeTextText.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                shape.text.value = String(this.text(shape, time));
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeChangeTextText;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeTextType;
    (function (EShapeActionValueChangeTextType) {
        EShapeActionValueChangeTextType[EShapeActionValueChangeTextType["TEXT"] = 0] = "TEXT";
        EShapeActionValueChangeTextType[EShapeActionValueChangeTextType["NUMBER"] = 1] = "NUMBER";
    })(EShapeActionValueChangeTextType || (EShapeActionValueChangeTextType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeText = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeText, _super);
        function EShapeActionValueChangeText(subtype, condition, value) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_TEXT, condition, subtype) || this;
            _this.value = value;
            return _this;
        }
        EShapeActionValueChangeText.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueChangeText) &&
                this.value === value.value);
        };
        EShapeActionValueChangeText.prototype.toRuntime = function (shape) {
            switch (this.subtype) {
                case EShapeActionValueChangeTextType.TEXT:
                    return new EShapeActionRuntimeChangeTextText(this);
                case EShapeActionValueChangeTextType.NUMBER:
                    return new EShapeActionRuntimeChangeTextNumber(this, shape.text.value);
            }
        };
        EShapeActionValueChangeText.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            var valueId = manager.add(this.value);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "," + valueId + "]");
        };
        EShapeActionValueChangeText.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var value = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueChangeText(serialized[2], condition, value);
        };
        return EShapeActionValueChangeText;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var nameDefault$1 = function () { return null; };
    var EShapeActionRuntimeEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeEmitEvent, _super);
        function EShapeActionRuntimeEmitEvent(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.name = _this.toExpression(value.name, nameDefault$1, "null");
            return _this;
        }
        EShapeActionRuntimeEmitEvent.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var name_1 = this.name(shape, time);
                if (name_1 != null) {
                    shape.emit(name_1, shape);
                    var container = this.toContainer(shape);
                    if (container && ("shape" in container)) {
                        container.shape.emit(name_1, shape);
                    }
                }
            }
        };
        return EShapeActionRuntimeEmitEvent;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionValueEmitEvent, _super);
        function EShapeActionValueEmitEvent(condition, name) {
            var _this = _super.call(this, EShapeActionValueType.EMIT_EVENT, condition) || this;
            _this.name = name;
            return _this;
        }
        EShapeActionValueEmitEvent.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueEmitEvent) &&
                this.name === value.name);
        };
        EShapeActionValueEmitEvent.prototype.toRuntime = function () {
            return new EShapeActionRuntimeEmitEvent(this);
        };
        EShapeActionValueEmitEvent.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            var nameId = manager.add(this.name);
            return manager.add("[" + this.type + "," + conditionId + "," + nameId + "]");
        };
        EShapeActionValueEmitEvent.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var name = EShapeActionValues.toResource(2, serialized, manager.resources);
            return new EShapeActionValueEmitEvent(condition, name);
        };
        return EShapeActionValueEmitEvent;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ASCII_CHARACTERS = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasCharacterOrigin = /** @class */ (function () {
        function DynamicFontAtlasCharacterOrigin(x, y) {
            this.x = x;
            this.y = y;
        }
        return DynamicFontAtlasCharacterOrigin;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasCharacter = /** @class */ (function () {
        function DynamicFontAtlasCharacter(advance, width, height, reserved) {
            this.ref = 1;
            this.life = 10;
            this.x = 0;
            this.y = 0;
            this.width = width;
            this.height = height;
            this.advance = advance;
            this.origin = new DynamicFontAtlasCharacterOrigin(0, 0);
            this.reserved = reserved;
        }
        return DynamicFontAtlasCharacter;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER = "\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nvarying mediump vec2 vTextureCoord;\nvoid main(void) {\n\tgl_Position = vec4(aVertexPosition, 0.0, 1.0);\n\tvTextureCoord = aTextureCoord;\n}\n";
    var FRAGMENT_SHADER = "\nprecision mediump float;\n\nvarying mediump vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec2 uSize;\n\nfloat calcDistance( float x, float y, float dx, float dy ) {\n\tfloat xd = x + dx;\n\tfloat yd = y + dy;\n\tfloat u = xd / uSize.x;\n\tfloat v = yd / uSize.y;\n\tfloat ul = (xd - 1.0) / uSize.x;\n\tfloat vt = (yd - 1.0) / uSize.y;\n\n\tfloat m = texture2D(uSampler, vec2(u , v )).a;\n\tfloat l = texture2D(uSampler, vec2(ul, v )).a;\n\tfloat t = texture2D(uSampler, vec2(u , vt)).a;\n\n\tfloat xl = mix( xd - 1.0, xd, (0.5 - l) / (m - l) );\n\tfloat yt = mix( yd - 1.0, yd, (0.5 - t) / (m - t) );\n\n\tbool bl = ( min(l, m) < 0.5 && 0.5 <= max(l, m) );\n\tbool bt = ( min(t, m) < 0.5 && 0.5 <= max(t, m) );\n\n\tfloat ll = (bl ? length( vec2( xl - x, yd - y ) ) : 100.0);\n\tfloat lt = (bt ? length( vec2( xd - x, yt - y ) ) : 100.0);\n\n\treturn min( ll, lt );\n}\n\nfloat calcDistancesY( float x, float y, float dx ) {\n\tfloat d = 100.0;\n\tfor( float dy=-6.0; dy<6.5; dy++ ) {\n\t\td = min( d, calcDistance( x, y, dx, dy ) );\n\t}\n\treturn d;\n}\n\nfloat calcDistances( float x, float y ) {\n\tfloat d = 100.0;\n\tfor( float dx=-6.0; dx<6.5; dx++ ) {\n\t\td = min( d, calcDistancesY( x, y, dx ) );\n\t}\n\treturn d;\n}\n\nvoid main(void) {\n\tfloat t = texture2D(uSampler, vTextureCoord).a;\n\tfloat x = vTextureCoord.x * uSize.x;\n\tfloat y = vTextureCoord.y * uSize.y;\n\tfloat d = min( 6.0, calcDistances( x, y ) ) / 12.0;\n\td = clamp( mix( 0.5 - d, 0.5 + d, step( 0.5, t ) ), 0.0, 1.0 );\n\tgl_FragColor = vec4(1.0, 1.0, 1.0, d);\n}\n";
    var DynamicSDFFontGenerator = /** @class */ (function () {
        function DynamicSDFFontGenerator() {
            var _this = this;
            this._gl = null;
            this._texture = null;
            this._shaderProgram = null;
            this._vertexPositionAttribute = NaN;
            this._textureCoordAttribute = NaN;
            this._samplerUniform = NaN;
            this._sizeUniform = NaN;
            this._vb = null;
            this._uvb = null;
            var canvas = this._canvas = document.createElement("canvas");
            canvas.width = 64;
            canvas.height = 64;
            this._onLostBound = function (e) {
                e.preventDefault();
            };
            this._onRestoreBound = function () {
                _this.restore();
            };
            this._onUnloadBound = function () {
                _this.destroy();
            };
            canvas.addEventListener("webglcontextlost", this._onLostBound, false);
            canvas.addEventListener("webglcontextrestored", this._onRestoreBound, false);
            window.addEventListener("unload", this._onUnloadBound, false);
        }
        DynamicSDFFontGenerator.prototype.init = function () {
            var canvas = this._canvas;
            if (canvas != null && (this._gl == null || this._gl.isContextLost())) {
                var config = {
                    alpha: true,
                    antialias: false,
                    depth: false,
                    stencil: false,
                    premultipliedAlpha: false
                };
                var gl = this._gl = (canvas.getContext("webgl", config) ||
                    canvas.getContext("experimental-webgl", config));
                if (gl != null) {
                    gl.clearColor(1.0, 1.0, 1.0, 0.0);
                    this.makeVertexBuffer();
                    this.makeUvBuffer();
                    this.makeShaders();
                    this._texture = null;
                }
            }
            return this;
        };
        DynamicSDFFontGenerator.prototype.restore = function () {
            this.init();
        };
        DynamicSDFFontGenerator.prototype.getCanvas = function () {
            return this._canvas;
        };
        DynamicSDFFontGenerator.prototype.getShader = function (gl, code, type) {
            var shader = (type ?
                gl.createShader(gl.FRAGMENT_SHADER) :
                gl.createShader(gl.VERTEX_SHADER));
            if (shader != null) {
                gl.shaderSource(shader, code);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    // tslint:disable-next-line: no-console no-unused-expression
                    console && console.error("Failed to compile the shader: " + gl.getShaderInfoLog(shader));
                    return null;
                }
            }
            return shader;
        };
        DynamicSDFFontGenerator.prototype.makeShaders = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var vertexShader = this.getShader(gl, VERTEX_SHADER, false);
                if (vertexShader != null) {
                    var fragmentShader = this.getShader(gl, FRAGMENT_SHADER, true);
                    if (fragmentShader != null) {
                        var shaderProgram = this._shaderProgram = gl.createProgram();
                        if (shaderProgram != null) {
                            gl.attachShader(shaderProgram, vertexShader);
                            gl.attachShader(shaderProgram, fragmentShader);
                            gl.linkProgram(shaderProgram);
                            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                                // tslint:disable-next-line: no-console no-unused-expression
                                console && console.error("Failed to link the program: " + gl.getError());
                                gl.deleteShader(vertexShader);
                                gl.deleteShader(fragmentShader);
                                return null;
                            }
                            else {
                                gl.deleteShader(vertexShader);
                                gl.deleteShader(fragmentShader);
                                gl.useProgram(shaderProgram);
                                this._vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
                                this._textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
                                this._samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
                                this._sizeUniform = gl.getUniformLocation(shaderProgram, "uSize");
                                gl.useProgram(null);
                                return shaderProgram;
                            }
                        }
                        else {
                            gl.deleteShader(vertexShader);
                            gl.deleteShader(fragmentShader);
                        }
                    }
                    else {
                        gl.deleteShader(vertexShader);
                    }
                }
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyShaders = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var shaderProgram = this._shaderProgram;
                if (shaderProgram != null) {
                    this._shaderProgram = null;
                    gl.useProgram(null);
                    gl.deleteProgram(shaderProgram);
                }
            }
        };
        DynamicSDFFontGenerator.prototype.updateTexture = function (source) {
            var gl = this._gl;
            var canvas = this._canvas;
            if (gl != null && gl.isContextLost() !== true && canvas != null) {
                var width = source.width;
                var height = source.height;
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, width, height);
                }
                var texture = this._texture;
                if (texture == null) {
                    texture = this._texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                return texture;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyTexture = function () {
            var gl = this._gl;
            var texture = this._texture;
            if (gl != null && gl.isContextLost() !== true && texture != null) {
                this._texture = null;
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.deleteTexture(texture);
            }
        };
        DynamicSDFFontGenerator.prototype.makeVertexBuffer = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var vb = this._vb = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vb);
                var vertices = [
                    -1.0, +1.0,
                    +1.0, +1.0,
                    -1.0, -1.0,
                    +1.0, -1.0
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                return vb;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyVertexBuffer = function () {
            var gl = this._gl;
            var vb = this._vb;
            if (gl != null && gl.isContextLost() !== true && vb != null) {
                this._vb = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(vb);
            }
        };
        DynamicSDFFontGenerator.prototype.makeUvBuffer = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var uvb = this._uvb = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, uvb);
                var uvs = [
                    0.0, 0.0,
                    1.0, 0.0,
                    0.0, 1.0,
                    1.0, 1.0
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);
                return uvb;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyUvBuffer = function () {
            var gl = this._gl;
            var uvb = this._uvb;
            if (gl != null && gl.isContextLost() !== true && uvb != null) {
                this._uvb = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(uvb);
            }
        };
        DynamicSDFFontGenerator.prototype.render = function () {
            var gl = this._gl;
            var canvas = this._canvas;
            var shaderProgram = this._shaderProgram;
            var vb = this._vb;
            var uvb = this._uvb;
            var texture = this._texture;
            if (gl != null && gl.isContextLost() !== true && canvas != null &&
                shaderProgram != null && vb != null && uvb != null && texture != null) {
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(shaderProgram);
                gl.bindBuffer(gl.ARRAY_BUFFER, vb);
                var vertexPositionAttribute = this._vertexPositionAttribute;
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.vertexAttribPointer(vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, uvb);
                var textureCoordAttribute = this._textureCoordAttribute;
                gl.enableVertexAttribArray(textureCoordAttribute);
                gl.vertexAttribPointer(textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(this._samplerUniform, 0);
                gl.uniform2f(this._sizeUniform, canvas.width, canvas.height);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.useProgram(null);
            }
        };
        DynamicSDFFontGenerator.prototype.read = function (copyCanvas) {
            var gl = this._gl;
            var canvas = this._canvas;
            if (gl != null && gl.isContextLost() !== true && canvas != null) {
                var width = canvas.width;
                var height = canvas.height;
                copyCanvas.width = width;
                copyCanvas.height = height;
                var copyContext = copyCanvas.getContext("2d");
                if (copyContext != null) {
                    copyContext.drawImage(canvas, 0, 0);
                }
            }
        };
        DynamicSDFFontGenerator.prototype.destroy = function () {
            this.destroyVertexBuffer();
            this.destroyUvBuffer();
            this.destroyShaders();
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
                canvas.removeEventListener("webglcontextlost", this._onLostBound, false);
                canvas.removeEventListener("webglcontextrestored", this._onRestoreBound, false);
                window.removeEventListener("unload", this._onUnloadBound, false);
            }
            var gl = this._gl;
            if (gl != null) {
                this._gl = null;
                var WebGLLoseContext = gl.getExtension("WEBGL_lose_context");
                if (WebGLLoseContext != null) {
                    WebGLLoseContext.loseContext();
                }
            }
        };
        DynamicSDFFontGenerator.getInstance = function () {
            if (DynamicSDFFontGenerator._INSTANCE == null) {
                DynamicSDFFontGenerator._INSTANCE = new DynamicSDFFontGenerator();
            }
            return DynamicSDFFontGenerator._INSTANCE;
        };
        DynamicSDFFontGenerator._INSTANCE = null;
        return DynamicSDFFontGenerator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicSDFFontAtlas = /** @class */ (function () {
        function DynamicSDFFontAtlas(fontFamily) {
            this._id = "font-atlas:" + fontFamily;
            this._generator = DynamicSDFFontGenerator.getInstance().init();
            this._canvas = document.createElement("canvas");
            this._font = {
                family: DynamicSDFFontAtlas.toFontFamily(fontFamily),
                size: 32,
                italic: false
            };
            this._characters = {};
            this._length = 0;
            this._width = 1;
            this._height = 1;
            this._isDirty = true;
        }
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "font", {
            get: function () {
                return this._font;
            },
            set: function (font) {
                this._font.family = font.family;
                this._font.size = font.size;
                this._font.italic = font.italic;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "generator", {
            get: function () {
                return this._generator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "characters", {
            get: function () {
                return this._characters;
            },
            enumerable: true,
            configurable: true
        });
        DynamicSDFFontAtlas.prototype.begin = function () {
            this._length = 0;
            var characters = this._characters;
            for (var character in characters) {
                characters[character].ref = 0;
            }
        };
        DynamicSDFFontAtlas.prototype.end = function () {
            var characters = this._characters;
            for (var character in characters) {
                var data = characters[character];
                if (data.ref <= 0) {
                    data.life -= 1;
                    if (data.life <= 0) {
                        delete characters[character];
                        this._isDirty = true;
                    }
                }
            }
        };
        DynamicSDFFontAtlas.prototype.addAscii = function () {
            this.add(ASCII_CHARACTERS);
            this.addChar("...");
        };
        DynamicSDFFontAtlas.prototype.addChar = function (character) {
            var characters = this._characters;
            if (character !== "\n") {
                var data = characters[character];
                if (data != null) {
                    if (data.ref <= 0) {
                        this._length += 1;
                    }
                    data.ref += 1;
                }
                else {
                    characters[character] = new DynamicFontAtlasCharacter(0, 1, 1, false);
                    this._length += 1;
                    this._isDirty = true;
                }
            }
        };
        DynamicSDFFontAtlas.prototype.add = function (characters) {
            var iterator = UtilCharacterIterator.from(characters);
            while (iterator.hasNext()) {
                this.addChar(iterator.next());
            }
        };
        DynamicSDFFontAtlas.prototype.get = function (character) {
            return this._characters[character];
        };
        DynamicSDFFontAtlas.prototype.update = function () {
            if (this._isDirty) {
                var canvas = this._canvas;
                var generator = this._generator;
                if (canvas != null && generator != null) {
                    var context = canvas.getContext("2d");
                    if (context != null) {
                        this._isDirty = false;
                        var font = this._font;
                        var characters = this._characters;
                        var characterSize = font.size + 14;
                        var width = DynamicSDFFontAtlas.toPowerOf2(Math.ceil(Math.sqrt(this._length)) * characterSize);
                        this._width = width;
                        var fontStyle = (font.italic ? "italic " : "") + (font.size + "px ") + font.family;
                        context.font = fontStyle;
                        context.textAlign = "left";
                        context.textBaseline = "middle";
                        context.lineWidth = 0;
                        context.lineCap = "round";
                        context.lineJoin = "miter";
                        context.miterLimit = 0;
                        context.fillStyle = "#FFFFFF";
                        var offsetX = 7;
                        var offsetY = (characterSize >> 1);
                        var x = 0;
                        var y = 0;
                        for (var character in characters) {
                            var data = characters[character];
                            var advance = context.measureText(character).width;
                            var characterWidth = Math.ceil(offsetX + advance + offsetX);
                            var characterHeight = characterSize;
                            if (width <= x + characterWidth) {
                                x = 0;
                                y += characterSize;
                            }
                            data.x = x;
                            data.y = y;
                            data.width = characterWidth;
                            data.height = characterHeight;
                            data.advance = advance;
                            data.origin.x = x + offsetX;
                            data.origin.y = y + offsetY;
                            x += characterWidth;
                        }
                        var height = this._height = y + characterSize;
                        // Make a input canvas
                        // Here, we need to reset the context because
                        // context settings will be lost when we set the width/height.
                        canvas.width = width;
                        canvas.height = height;
                        context.font = fontStyle;
                        context.textAlign = "left";
                        context.textBaseline = "middle";
                        context.lineWidth = 0;
                        context.lineCap = "round";
                        context.lineJoin = "miter";
                        context.miterLimit = 4;
                        context.fillStyle = "#FFFFFF";
                        context.clearRect(0, 0, width, height);
                        for (var character in characters) {
                            var data = characters[character];
                            context.fillText(character, data.origin.x, data.origin.y);
                        }
                        // Convert to SDF font texture
                        generator.updateTexture(canvas);
                        generator.render();
                        generator.read(canvas);
                        return true;
                    }
                }
            }
            return false;
        };
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: true,
            configurable: true
        });
        DynamicSDFFontAtlas.prototype.toJson = function () {
            return {
                width: this._width,
                height: this._height,
                font: this._font,
                characters: this._characters
            };
        };
        DynamicSDFFontAtlas.prototype.toString = function () {
            return JSON.stringify(this.toJson());
        };
        DynamicSDFFontAtlas.prototype.destroy = function () {
            var generator = this._generator;
            if (generator != null) {
                this._generator = null;
            }
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
            }
            var characters = this._characters;
            for (var character in characters) {
                delete characters[character];
            }
        };
        DynamicSDFFontAtlas.toFontFamily = function (fontFamily) {
            return (fontFamily === "auto" ?
                DynamicSDFFontAtlas.getAutoFontFamily() :
                fontFamily);
        };
        DynamicSDFFontAtlas.toPowerOf2 = function (size) {
            var result = 32;
            while (result < size) {
                result <<= 1;
            }
            return result;
        };
        DynamicSDFFontAtlas.getAutoFontFamily = function () {
            if (DynamicSDFFontAtlas.FONT_FAMILY_AUTO == null) {
                DynamicSDFFontAtlas.FONT_FAMILY_AUTO = DThemes.getInstance().get("DBase").getFontFamilly();
            }
            return DynamicSDFFontAtlas.FONT_FAMILY_AUTO;
        };
        DynamicSDFFontAtlas.FONT_FAMILY_AUTO = null;
        return DynamicSDFFontAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputData = /** @class */ (function () {
        function EShapeActionRuntimeMiscInputData() {
            var _this = this;
            this.input = null;
            this.shape = null;
            this.value = "";
            this.point = new pixi_js.Point();
            this.rect = new pixi_js.Rectangle();
            this._onInputKeyDownBound = function (e) {
                _this.onInputKeyDown(e);
            };
            this._onInputBlurBound = function (e) {
                _this.onInputBlur(e);
            };
            this._updateInputBound = function () {
                _this.updateInput();
            };
            this._onInputChangeBound = function () {
                _this.onInputChange();
            };
            this._onInputInputBound = function (e) {
                _this.onInputInput(e);
            };
            this._updateInputBoundRenderer = null;
        }
        EShapeActionRuntimeMiscInputData.prototype.getInput = function (layer) {
            if (this.input == null) {
                layer.application.getRootElement().appendChild(this.input = this.createInput());
            }
            return this.input;
        };
        EShapeActionRuntimeMiscInputData.prototype.createInput = function () {
            var result = document.createElement("input");
            result.setAttribute("spellcheck", "false");
            return result;
        };
        EShapeActionRuntimeMiscInputData.prototype.getInputType = function () {
            return "text";
        };
        EShapeActionRuntimeMiscInputData.prototype.initInput = function (shape, input, value) {
            input.type = this.getInputType();
            input.value = value;
            input.addEventListener("keydown", this._onInputKeyDownBound);
            input.addEventListener("blur", this._onInputBlurBound);
            input.addEventListener("change", this._onInputChangeBound);
            input.addEventListener("input", this._onInputInputBound);
            // Style
            input.setAttribute("style", this.getInputStyle(shape));
            // ReadOnly
            if (shape.readonly) {
                input.setAttribute("readonly", "readonly");
            }
            else {
                input.removeAttribute("readonly");
            }
            // Disabled
            if (shape.disabled) {
                input.setAttribute("disabled", "disabled");
            }
            else {
                input.removeAttribute("disabled");
            }
        };
        EShapeActionRuntimeMiscInputData.prototype.getInputStyleBackground = function () {
            return "background-color: transparent;";
        };
        EShapeActionRuntimeMiscInputData.prototype.getInputStyleBorder = function () {
            return "border: none; box-sizing: border-box;";
        };
        EShapeActionRuntimeMiscInputData.prototype.getInputStylePadding = function (shape, scale) {
            var padding = shape.text.padding;
            var paddingVertical = 0;
            var paddingHorizontal = padding.horizontal * scale;
            return "padding: " + paddingVertical + "px " + paddingHorizontal + "px " + paddingVertical + "px " + paddingHorizontal + "px;";
        };
        EShapeActionRuntimeMiscInputData.prototype.getInputStyleOutline = function () {
            return "outline: none;";
        };
        EShapeActionRuntimeMiscInputData.prototype.getInputStylePosition = function (rect, matrix) {
            return "position: absolute;" +
                ("left: " + rect.x + "px;") +
                ("top: " + rect.y + "px;") +
                ("width: " + rect.width + "px;") +
                ("height: " + rect.height + "px;") +
                ("line-height: " + rect.height + "px;") +
                ("transform: matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," + matrix.d + "," + matrix.tx + "," + matrix.ty + ");");
        };
        EShapeActionRuntimeMiscInputData.prototype.getInputStyleText = function (shape, rect, scale) {
            var text = shape.text;
            return "font-family: " + DynamicSDFFontAtlas.toFontFamily(text.family) + ";" +
                ("font-size: " + text.size * scale + "px;") +
                ("font-weight: " + (text.weight === EShapeTextWeight.NORMAL ? "normal" : "bold") + ";") +
                ("color: #" + text.color.toString(16) + ";");
        };
        EShapeActionRuntimeMiscInputData.prototype.getInputStyleMargin = function (shape, rect, scale) {
            return "margin: 0;";
        };
        EShapeActionRuntimeMiscInputData.prototype.getInputStyle = function (shape) {
            var pivot = shape.transform.pivot;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var rect = this.rect;
            rect.x = -0.5 * sizeX + pivot.x;
            rect.y = -0.5 * sizeY + pivot.y;
            rect.width = sizeX;
            rect.height = sizeY;
            shape.updateTransform();
            var scale = 1.0;
            var worldTransform = shape.transform.worldTransform;
            return this.getInputStylePosition(rect, worldTransform) +
                this.getInputStyleMargin(shape, rect, scale) +
                this.getInputStyleText(shape, rect, scale) +
                this.getInputStyleBackground() +
                this.getInputStyleBorder() +
                this.getInputStylePadding(shape, scale) +
                this.getInputStyleOutline();
        };
        EShapeActionRuntimeMiscInputData.prototype.onInputKeyDown = function (e) {
            if (UtilKeyboardEvent.isFocusKey(e)) {
                var shape = this.shape;
                if (shape != null) {
                    this.onInputChange();
                    this.hide();
                    var layer = DApplications.getLayer(shape);
                    if (layer) {
                        var focusController = layer.getFocusController();
                        var direction = UtilKeyboardEvent.getFocusDirection(e);
                        var focusable = focusController.findFocusable(shape, false, false, direction);
                        if (focusable != null) {
                            layer.view.focus();
                            e.preventDefault();
                            focusController.setFocused(focusable, true, true);
                        }
                    }
                }
            }
            else if (UtilKeyboardEvent.isOkKey(e)) {
                this.onInputChange();
                this.hide();
            }
        };
        EShapeActionRuntimeMiscInputData.prototype.onInputBlur = function (e) {
            this.onInputChange();
            this.hide();
        };
        EShapeActionRuntimeMiscInputData.prototype.onInputInput = function (e) {
            if (e.target instanceof HTMLInputElement) {
                var shape = this.shape;
                var onInput = this.onInput;
                if (shape != null && onInput != null) {
                    onInput(shape, e.target.value);
                }
            }
        };
        EShapeActionRuntimeMiscInputData.prototype.updateInput = function () {
            var shape = this.shape;
            if (shape != null) {
                if (shape.visible) {
                    var input = this.input;
                    if (input != null) {
                        input.setAttribute("style", this.getInputStyle(shape));
                    }
                }
                else {
                    this.hide();
                }
            }
        };
        EShapeActionRuntimeMiscInputData.prototype.isShown = function (shape) {
            return (this.shape === shape);
        };
        EShapeActionRuntimeMiscInputData.prototype.show = function (newShape, value, onChange, onInput) {
            var oldShape = this.shape;
            if (oldShape != null && oldShape !== newShape) {
                this.hide();
            }
            if (this.shape == null) {
                this.shape = newShape;
                this.value = value;
                this.onChange = onChange;
                this.onInput = onInput;
                var text = newShape.text;
                if (text != null) {
                    text.enable = false;
                }
                var layer = DApplications.getLayer(newShape);
                if (layer) {
                    var input = this.getInput(layer);
                    if (input) {
                        this.initInput(newShape, input, value);
                        var updateInputBound = this._updateInputBound;
                        var renderer = this._updateInputBoundRenderer;
                        if (renderer != null) {
                            renderer.off("postrender", updateInputBound);
                        }
                        this._updateInputBoundRenderer = layer.renderer;
                        layer.renderer.on("postrender", updateInputBound);
                        input.style.display = "";
                        input.focus();
                        input.select();
                    }
                    layer.update();
                }
            }
        };
        EShapeActionRuntimeMiscInputData.prototype.hide = function () {
            var shape = this.shape;
            if (shape != null) {
                this.shape = null;
                this.value = "";
                var text = shape.text;
                if (text != null) {
                    text.enable = true;
                }
                var input = this.input;
                if (input != null) {
                    input.removeEventListener("keydown", this._onInputKeyDownBound);
                    input.removeEventListener("blur", this._onInputBlurBound);
                    input.removeEventListener("change", this._onInputChangeBound);
                    input.removeEventListener("input", this._onInputInputBound);
                    input.style.display = "none";
                }
                var renderer = this._updateInputBoundRenderer;
                if (renderer != null) {
                    this._updateInputBoundRenderer = null;
                    renderer.off("postrender", this._updateInputBound);
                }
                DApplications.update(shape);
            }
        };
        EShapeActionRuntimeMiscInputData.prototype.onInputChange = function () {
            var shape = this.shape;
            var input = this.input;
            var onChange = this.onChange;
            if (shape != null && input != null && onChange != null) {
                var newValue = input.value;
                if (this.value !== newValue) {
                    onChange(shape, newValue);
                }
            }
        };
        return EShapeActionRuntimeMiscInputData;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInput = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInput, _super);
        function EShapeActionRuntimeMiscInput() {
            return _super.call(this) || this;
        }
        EShapeActionRuntimeMiscInput.prototype.execute = function (shape, runtime, time) {
            var _this = this;
            if (!shape.disabled) {
                var data_1 = EShapeActionRuntimeMiscInput.getData();
                if (shape.focused) {
                    if (!data_1.isShown(shape)) {
                        setTimeout(function () {
                            data_1.show(shape, shape.text.value, function (_, value) {
                                shape.text.value = value;
                                shape.emit(name, shape, value);
                                var container = _this.toContainer(shape);
                                if (container && ("shape" in container)) {
                                    container.shape.emit(name, shape, value);
                                }
                            });
                        }, 0);
                    }
                }
                else {
                    if (data_1.isShown(shape)) {
                        data_1.onInputChange();
                        data_1.hide();
                    }
                }
            }
        };
        EShapeActionRuntimeMiscInput.getData = function () {
            if (EShapeActionRuntimeMiscInput.data == null) {
                EShapeActionRuntimeMiscInput.data = new EShapeActionRuntimeMiscInputData();
            }
            return EShapeActionRuntimeMiscInput.data;
        };
        EShapeActionRuntimeMiscInput.data = null;
        return EShapeActionRuntimeMiscInput;
    }(EShapeActionRuntime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscType;
    (function (EShapeActionValueMiscType) {
        EShapeActionValueMiscType[EShapeActionValueMiscType["INPUT"] = 0] = "INPUT";
    })(EShapeActionValueMiscType || (EShapeActionValueMiscType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMisc = /** @class */ (function (_super) {
        __extends(EShapeActionValueMisc, _super);
        function EShapeActionValueMisc(subtype, condition) {
            return _super.call(this, EShapeActionValueType.MISC, condition, subtype) || this;
        }
        EShapeActionValueMisc.prototype.toRuntime = function (shape) {
            switch (this.subtype) {
                case EShapeActionValueMiscType.INPUT:
                    return new EShapeActionRuntimeMiscInput();
            }
        };
        EShapeActionValueMisc.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "]");
        };
        EShapeActionValueMisc.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueMisc(serialized[2], condition);
        };
        return EShapeActionValueMisc;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var targetDefault = function () { return null; };
    var EShapeActionRuntimeOpen = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpen, _super);
        function EShapeActionRuntimeOpen(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.target = _this.toExpression(value.target, targetDefault, "null");
            return _this;
        }
        return EShapeActionRuntimeOpen;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenFlow = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenFlow, _super);
        function EShapeActionRuntimeOpenFlow(value) {
            return _super.call(this, value, EShapeRuntimeReset.NONE) || this;
        }
        EShapeActionRuntimeOpenFlow.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var target = this.target(shape, time);
                if (target != null) {
                    var container = this.toContainer(shape);
                    if (container && ("opener" in container)) {
                        container.opener(target);
                    }
                }
            }
        };
        return EShapeActionRuntimeOpenFlow;
    }(EShapeActionRuntimeOpen));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenPage = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenPage, _super);
        function EShapeActionRuntimeOpenPage(value) {
            return _super.call(this, value, EShapeRuntimeReset.NONE) || this;
        }
        EShapeActionRuntimeOpenPage.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var target = this.target(shape, time);
                if (target != null) {
                    window.open(target);
                }
            }
        };
        return EShapeActionRuntimeOpenPage;
    }(EShapeActionRuntimeOpen));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenPageInplace = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenPageInplace, _super);
        function EShapeActionRuntimeOpenPageInplace(value) {
            return _super.call(this, value, EShapeRuntimeReset.NONE) || this;
        }
        EShapeActionRuntimeOpenPageInplace.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var target = this.target(shape, time);
                if (target != null) {
                    window.location.href = target;
                }
            }
        };
        return EShapeActionRuntimeOpenPageInplace;
    }(EShapeActionRuntimeOpen));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenType;
    (function (EShapeActionValueOpenType) {
        EShapeActionValueOpenType[EShapeActionValueOpenType["FLOW"] = 0] = "FLOW";
        EShapeActionValueOpenType[EShapeActionValueOpenType["PAGE"] = 1] = "PAGE";
        EShapeActionValueOpenType[EShapeActionValueOpenType["PAGE_INPLACE"] = 2] = "PAGE_INPLACE";
    })(EShapeActionValueOpenType || (EShapeActionValueOpenType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpen = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpen, _super);
        function EShapeActionValueOpen(subtype, condition, target) {
            var _this = _super.call(this, EShapeActionValueType.OPEN, condition, subtype) || this;
            _this.target = target;
            return _this;
        }
        EShapeActionValueOpen.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueOpen) &&
                this.target === value.target);
        };
        EShapeActionValueOpen.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueOpenType.FLOW:
                    return new EShapeActionRuntimeOpenFlow(this);
                case EShapeActionValueOpenType.PAGE:
                    return new EShapeActionRuntimeOpenPage(this);
                case EShapeActionValueOpenType.PAGE_INPLACE:
                    return new EShapeActionRuntimeOpenPageInplace(this);
            }
        };
        EShapeActionValueOpen.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            var targetId = manager.add(this.target);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "," + targetId + "]");
        };
        EShapeActionValueOpen.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var target = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueOpen(serialized[2], condition, target);
        };
        return EShapeActionValueOpen;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueShowHideType;
    (function (EShapeActionValueShowHideType) {
        EShapeActionValueShowHideType[EShapeActionValueShowHideType["SHOW"] = 0] = "SHOW";
        EShapeActionValueShowHideType[EShapeActionValueShowHideType["HIDE"] = 1] = "HIDE";
    })(EShapeActionValueShowHideType || (EShapeActionValueShowHideType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeShowHide = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeShowHide, _super);
        function EShapeActionRuntimeShowHide(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.VISIBILITY) || this;
            _this.visibility = (value.subtype === EShapeActionValueShowHideType.SHOW);
            return _this;
        }
        EShapeActionRuntimeShowHide.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                shape.visible = this.visibility;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeShowHide;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueShowHide = /** @class */ (function (_super) {
        __extends(EShapeActionValueShowHide, _super);
        function EShapeActionValueShowHide(subtype, condition) {
            return _super.call(this, EShapeActionValueType.SHOW_HIDE, condition, subtype) || this;
        }
        EShapeActionValueShowHide.prototype.toRuntime = function () {
            return new EShapeActionRuntimeShowHide(this);
        };
        EShapeActionValueShowHide.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "]");
        };
        EShapeActionValueShowHide.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueShowHide(serialized[2], condition);
        };
        return EShapeActionValueShowHide;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var amountDefault = function () { return 0; };
    var EShapeActionRuntimeTransformMove = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMove, _super);
        function EShapeActionRuntimeTransformMove(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.amount = _this.toExpression(value.amount, amountDefault, "0");
            return _this;
        }
        return EShapeActionRuntimeTransformMove;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveAbsoluteX = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveAbsoluteX, _super);
        function EShapeActionRuntimeTransformMoveAbsoluteX(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_X) || this;
        }
        EShapeActionRuntimeTransformMoveAbsoluteX.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                shape.transform.position.x = amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveAbsoluteX;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveAbsoluteY = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveAbsoluteY, _super);
        function EShapeActionRuntimeTransformMoveAbsoluteY(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_Y) || this;
        }
        EShapeActionRuntimeTransformMoveAbsoluteY.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                shape.transform.position.y = amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveAbsoluteY;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveForwardOrBackward = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveForwardOrBackward, _super);
        function EShapeActionRuntimeTransformMoveForwardOrBackward(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformMoveForwardOrBackward.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var transform = shape.transform;
                var position = transform.position;
                var writtenPositionX = ((runtime.written & EShapeRuntimeReset.POSITION_X) !== 0);
                var writtenPositionY = ((runtime.written & EShapeRuntimeReset.POSITION_Y) !== 0);
                var oldPositionX = (writtenPositionX ? position.x : runtime.x);
                var oldPositionY = (writtenPositionY ? position.y : runtime.y);
                shape.updateTransform();
                var localTransform = shape.transform.localTransform;
                position.set(oldPositionX - localTransform.c * amount, oldPositionY - localTransform.d * amount);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveForwardOrBackward;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveLeftOrRight = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveLeftOrRight, _super);
        function EShapeActionRuntimeTransformMoveLeftOrRight(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformMoveLeftOrRight.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var transform = shape.transform;
                var position = transform.position;
                var writtenPositionX = ((runtime.written & EShapeRuntimeReset.POSITION_X) !== 0);
                var writtenPositionY = ((runtime.written & EShapeRuntimeReset.POSITION_Y) !== 0);
                var oldPositionX = (writtenPositionX ? position.x : runtime.x);
                var oldPositionY = (writtenPositionY ? position.y : runtime.y);
                shape.updateTransform();
                var localTransform = shape.transform.localTransform;
                position.set(oldPositionX + localTransform.a * amount, oldPositionY + localTransform.b * amount);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveLeftOrRight;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveRelativeX = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveRelativeX, _super);
        function EShapeActionRuntimeTransformMoveRelativeX(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_X) || this;
        }
        EShapeActionRuntimeTransformMoveRelativeX.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var writtenPositionX = ((runtime.written & EShapeRuntimeReset.POSITION_X) !== 0);
                var position = shape.transform.position;
                var oldPositionX = (writtenPositionX ? position.x : runtime.x);
                position.x = oldPositionX + amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveRelativeX;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveRelativeY = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveRelativeY, _super);
        function EShapeActionRuntimeTransformMoveRelativeY(action) {
            return _super.call(this, action, EShapeRuntimeReset.POSITION_Y) || this;
        }
        EShapeActionRuntimeTransformMoveRelativeY.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var writtenPositionY = ((runtime.written & EShapeRuntimeReset.POSITION_Y) !== 0);
                var position = shape.transform.position;
                var oldPositionY = (writtenPositionY ? position.y : runtime.y);
                position.y = oldPositionY + amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveRelativeY;
    }(EShapeActionRuntimeTransformMove));

    var EShapeActionValueOpetyped = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpetyped, _super);
        function EShapeActionValueOpetyped(type, condition, subtype, opetype) {
            var _this = _super.call(this, type, condition, subtype) || this;
            _this.opetype = opetype;
            return _this;
        }
        EShapeActionValueOpetyped.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueOpetyped) &&
                this.opetype === value.opetype);
        };
        return EShapeActionValueOpetyped;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformMoveType;
    (function (EShapeActionValueTransformMoveType) {
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["RELATIVE_X"] = 0] = "RELATIVE_X";
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["RELATIVE_Y"] = 1] = "RELATIVE_Y";
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["ABSOLUTE_X"] = 2] = "ABSOLUTE_X";
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["ABSOLUTE_Y"] = 3] = "ABSOLUTE_Y";
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["FORWARD_OR_BACKWARD"] = 4] = "FORWARD_OR_BACKWARD";
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["LEFT_OR_RIGHT"] = 5] = "LEFT_OR_RIGHT";
    })(EShapeActionValueTransformMoveType || (EShapeActionValueTransformMoveType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformType;
    (function (EShapeActionValueTransformType) {
        EShapeActionValueTransformType[EShapeActionValueTransformType["RESIZE"] = 0] = "RESIZE";
        EShapeActionValueTransformType[EShapeActionValueTransformType["MOVE"] = 1] = "MOVE";
        EShapeActionValueTransformType[EShapeActionValueTransformType["ROTATE"] = 2] = "ROTATE";
    })(EShapeActionValueTransformType || (EShapeActionValueTransformType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformMove = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformMove, _super);
        function EShapeActionValueTransformMove(opetype, condition, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.MOVE, opetype) || this;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformMove.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueTransformMove) &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformMove.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformMoveType.ABSOLUTE_X:
                    return new EShapeActionRuntimeTransformMoveAbsoluteX(this);
                case EShapeActionValueTransformMoveType.ABSOLUTE_Y:
                    return new EShapeActionRuntimeTransformMoveAbsoluteY(this);
                case EShapeActionValueTransformMoveType.FORWARD_OR_BACKWARD:
                    return new EShapeActionRuntimeTransformMoveForwardOrBackward(this);
                case EShapeActionValueTransformMoveType.LEFT_OR_RIGHT:
                    return new EShapeActionRuntimeTransformMoveLeftOrRight(this);
                case EShapeActionValueTransformMoveType.RELATIVE_X:
                    return new EShapeActionRuntimeTransformMoveRelativeX(this);
                case EShapeActionValueTransformMoveType.RELATIVE_Y:
                    return new EShapeActionRuntimeTransformMoveRelativeY(this);
            }
        };
        EShapeActionValueTransformMove.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            var amountId = manager.add(this.amount);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "," + this.opetype + "," + amountId + "]");
        };
        EShapeActionValueTransformMove.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(4, serialized, manager.resources);
            return new EShapeActionValueTransformMove(serialized[3], condition, amount);
        };
        return EShapeActionValueTransformMove;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeSizes = /** @class */ (function () {
        function EShapeSizes() {
        }
        EShapeSizes.toRounded = function (value) {
            return Math.round(value * 100) / 100;
        };
        EShapeSizes.toNormalized = function (size) {
            var THRESHOLD = 0.001;
            if (Math.abs(size) < THRESHOLD) {
                return (size < 0 ? -THRESHOLD : +THRESHOLD);
            }
            return EShapeSizes.toRounded(size);
        };
        EShapeSizes.resize = function (shape, from, to, centerMode, isPerfect) {
            shape.disallowUploadedUpdate();
            var position = shape.transform.position;
            if (centerMode) {
                var dx = Math.abs(to.x - from.x);
                var dy = Math.abs(to.y - from.y);
                if (isPerfect) {
                    var hsize = Math.max(dx, dy);
                    var size = hsize + hsize;
                    shape.size.set(EShapeSizes.toNormalized(size), EShapeSizes.toNormalized(size));
                    position.set(EShapeSizes.toRounded(from.x), EShapeSizes.toRounded(from.y));
                }
                else {
                    shape.size.set(EShapeSizes.toNormalized(dx + dx), EShapeSizes.toNormalized(dy + dy));
                    position.set(EShapeSizes.toRounded(from.x), EShapeSizes.toRounded(from.y));
                }
            }
            else {
                if (isPerfect) {
                    var dx = to.x - from.x;
                    var dy = to.y - from.y;
                    var size = Math.max(Math.abs(dx), Math.abs(dy));
                    var x2 = from.x + (dx < 0 ? -size : +size);
                    var y2 = from.y + (dy < 0 ? -size : +size);
                    var hsize = size * 0.5;
                    var x = Math.min(from.x, x2) + hsize;
                    var y = Math.min(from.y, y2) + hsize;
                    shape.size.set(EShapeSizes.toNormalized(size), EShapeSizes.toNormalized(size));
                    position.set(EShapeSizes.toRounded(x), EShapeSizes.toRounded(y));
                }
                else {
                    var x0 = Math.min(from.x, to.x);
                    var y0 = Math.min(from.y, to.y);
                    var x1 = Math.max(from.x, to.x);
                    var y1 = Math.max(from.y, to.y);
                    var width = x1 - x0;
                    var height = y1 - y0;
                    var px = width * 0.5;
                    var py = height * 0.5;
                    shape.size.set(EShapeSizes.toNormalized(width), EShapeSizes.toNormalized(height));
                    position.set(EShapeSizes.toRounded(x0 + px), EShapeSizes.toRounded(y0 + py));
                }
            }
            shape.allowUploadedUpdate();
        };
        return EShapeSizes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformResizeType;
    (function (EShapeActionValueTransformResizeType) {
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["RELATIVE_SIZE"] = 0] = "RELATIVE_SIZE";
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["RELATIVE_HEIGHT"] = 1] = "RELATIVE_HEIGHT";
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["RELATIVE_WIDTH"] = 2] = "RELATIVE_WIDTH";
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["ABSOLUTE_SIZE"] = 3] = "ABSOLUTE_SIZE";
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["ABSOLUTE_HEIGHT"] = 4] = "ABSOLUTE_HEIGHT";
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["ABSOLUTE_WIDTH"] = 5] = "ABSOLUTE_WIDTH";
    })(EShapeActionValueTransformResizeType || (EShapeActionValueTransformResizeType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var sizeRelativeDefault = function () { return 1; };
    var sizeAbsoluteDefault = function () { return 100; };
    var EShapeActionRuntimeTransformResize = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResize, _super);
        function EShapeActionRuntimeTransformResize(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            switch (value.opetype) {
                case EShapeActionValueTransformResizeType.RELATIVE_SIZE:
                    _this.size = _this.toExpression(value.amount, sizeRelativeDefault, "1");
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_SIZE:
                    _this.size = _this.toExpression(value.amount, sizeAbsoluteDefault, "100");
                    break;
                case EShapeActionValueTransformResizeType.RELATIVE_HEIGHT:
                    _this.size = _this.toExpression(value.amount, sizeRelativeDefault, "1");
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT:
                    _this.size = _this.toExpression(value.amount, sizeAbsoluteDefault, "100");
                    break;
                case EShapeActionValueTransformResizeType.RELATIVE_WIDTH:
                    _this.size = _this.toExpression(value.amount, sizeRelativeDefault, "1");
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH:
                    _this.size = _this.toExpression(value.amount, sizeAbsoluteDefault, "100");
                    break;
                default:
                    _this.size = sizeRelativeDefault;
            }
            return _this;
        }
        EShapeActionRuntimeTransformResize.prototype.adjustPosition = function (shape, runtime, dsx, dsy, originX, originY) {
            var dx = (-0.5 + originX) * dsx;
            var dy = (-0.5 + originY) * dsy;
            shape.updateTransform();
            var transform = shape.transform;
            var position = transform.position;
            var localTransform = transform.localTransform;
            var writtenPositionX = ((runtime.written & EShapeRuntimeReset.POSITION_X) !== 0);
            var writtenPositionY = ((runtime.written & EShapeRuntimeReset.POSITION_Y) !== 0);
            var oldPositionX = (writtenPositionX ? position.x : runtime.x);
            var oldPositionY = (writtenPositionY ? position.y : runtime.y);
            runtime.written |= EShapeRuntimeReset.POSITION;
            position.set(oldPositionX + dx * localTransform.a + dy * localTransform.c, oldPositionY + dx * localTransform.b + dy * localTransform.d);
        };
        return EShapeActionRuntimeTransformResize;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeHeightAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeHeightAbsolute, _super);
        function EShapeActionRuntimeTransformResizeHeightAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.HEIGHT) || this;
            _this.origin = value.originY;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeHeightAbsolute.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var sizeAbsolute = this.size(shape, time);
                var size = shape.size;
                var writtenHeight = ((runtime.written & EShapeRuntimeReset.HEIGHT) !== 0);
                var oldSizeY = (writtenHeight ? size.y : runtime.size.y);
                size.y = EShapeSizes.toNormalized(sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.HEIGHT;
                this.adjustPosition(shape, runtime, 0, oldSizeY - size.y, 0.5, this.origin);
            }
        };
        return EShapeActionRuntimeTransformResizeHeightAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeHeightRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeHeightRelative, _super);
        function EShapeActionRuntimeTransformResizeHeightRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.HEIGHT) || this;
            _this.origin = value.originY;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeHeightRelative.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var sizeRelative = this.size(shape, time);
                var size = shape.size;
                var writtenHeight = ((runtime.written & EShapeRuntimeReset.HEIGHT) !== 0);
                var oldSizeY = (writtenHeight ? size.y : runtime.size.y);
                size.y = EShapeSizes.toNormalized(oldSizeY * sizeRelative);
                runtime.written |= EShapeRuntimeReset.HEIGHT;
                this.adjustPosition(shape, runtime, 0, oldSizeY - size.y, 0.5, this.origin);
            }
        };
        return EShapeActionRuntimeTransformResizeHeightRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeSizeAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeSizeAbsolute, _super);
        function EShapeActionRuntimeTransformResizeSizeAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.SIZE) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeSizeAbsolute.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var sizeAbsolute = EShapeSizes.toNormalized(this.size(shape, time));
                var size = shape.size;
                var writtenWidth = ((runtime.written & EShapeRuntimeReset.WIDTH) !== 0);
                var writtenHeight = ((runtime.written & EShapeRuntimeReset.HEIGHT) !== 0);
                var oldSizeX = (writtenWidth ? size.x : runtime.size.x);
                var oldSizeY = (writtenHeight ? size.y : runtime.size.y);
                size.set(sizeAbsolute, sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.SIZE;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, oldSizeY - size.y, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformResizeSizeAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeSizeRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeSizeRelative, _super);
        function EShapeActionRuntimeTransformResizeSizeRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.SIZE) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeSizeRelative.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var sizeRelative = this.size(shape, time);
                var size = shape.size;
                var writtenWidth = ((runtime.written & EShapeRuntimeReset.WIDTH) !== 0);
                var writtenHeight = ((runtime.written & EShapeRuntimeReset.HEIGHT) !== 0);
                var oldSizeX = (writtenWidth ? size.x : runtime.size.x);
                var oldSizeY = (writtenHeight ? size.y : runtime.size.y);
                size.set(EShapeSizes.toNormalized(oldSizeX * sizeRelative), EShapeSizes.toNormalized(oldSizeY * sizeRelative));
                runtime.written |= EShapeRuntimeReset.SIZE;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, oldSizeY - size.y, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformResizeSizeRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeWidthAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeWidthAbsolute, _super);
        function EShapeActionRuntimeTransformResizeWidthAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.WIDTH) || this;
            _this.origin = value.originX;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeWidthAbsolute.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var sizeAbsolute = this.size(shape, time);
                var size = shape.size;
                var writtenWidth = ((runtime.written & EShapeRuntimeReset.WIDTH) !== 0);
                var oldSizeX = (writtenWidth ? size.x : runtime.size.x);
                size.x = EShapeSizes.toNormalized(sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.WIDTH;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, 0, this.origin, 0.5);
            }
        };
        return EShapeActionRuntimeTransformResizeWidthAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeWidthRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeWidthRelative, _super);
        function EShapeActionRuntimeTransformResizeWidthRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.WIDTH) || this;
            _this.origin = value.originX;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeWidthRelative.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var sizeRelative = this.size(shape, time);
                var size = shape.size;
                var writtenWidth = ((runtime.written & EShapeRuntimeReset.WIDTH) !== 0);
                var oldSizeX = (writtenWidth ? size.x : runtime.size.x);
                size.x = EShapeSizes.toNormalized(oldSizeX * sizeRelative);
                runtime.written |= EShapeRuntimeReset.WIDTH;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, 0, this.origin, 0.5);
            }
        };
        return EShapeActionRuntimeTransformResizeWidthRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformResize = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformResize, _super);
        function EShapeActionValueTransformResize(opetype, condition, originX, originY, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.RESIZE, opetype) || this;
            _this.originX = originX;
            _this.originY = originY;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformResize.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueTransformResize) &&
                this.originX === value.originX &&
                this.originY === value.originY &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformResize.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT:
                    return new EShapeActionRuntimeTransformResizeHeightAbsolute(this);
                case EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH:
                    return new EShapeActionRuntimeTransformResizeWidthAbsolute(this);
                case EShapeActionValueTransformResizeType.ABSOLUTE_SIZE:
                    return new EShapeActionRuntimeTransformResizeSizeAbsolute(this);
                case EShapeActionValueTransformResizeType.RELATIVE_HEIGHT:
                    return new EShapeActionRuntimeTransformResizeHeightRelative(this);
                case EShapeActionValueTransformResizeType.RELATIVE_WIDTH:
                    return new EShapeActionRuntimeTransformResizeWidthRelative(this);
                case EShapeActionValueTransformResizeType.RELATIVE_SIZE:
                    return new EShapeActionRuntimeTransformResizeSizeRelative(this);
            }
        };
        EShapeActionValueTransformResize.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            var amountId = manager.add(this.amount);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "," + this.opetype + "," + this.originX + "," + this.originY + "," + amountId + "]");
        };
        EShapeActionValueTransformResize.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueTransformResize(serialized[3], condition, serialized[4], serialized[5], amount);
        };
        return EShapeActionValueTransformResize;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var amountDefault$1 = function () { return 0; };
    var EShapeActionRuntimeTransformRotate = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotate, _super);
        function EShapeActionRuntimeTransformRotate(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            _this.amount = _this.toExpression("(" + value.amount + ") * (Math.PI / 180)", amountDefault$1, "0");
            return _this;
        }
        EShapeActionRuntimeTransformRotate.prototype.adjustPosition = function (shape, runtime, oldRotation, newRotation, originX, originY) {
            var writtenWidth = ((runtime.written & EShapeRuntimeReset.WIDTH) !== 0);
            var writtenHeight = ((runtime.written & EShapeRuntimeReset.HEIGHT) !== 0);
            var dx = (-0.5 + originX) * (writtenWidth ? shape.size.x : runtime.size.x);
            var dy = (-0.5 + originY) * (writtenHeight ? shape.size.y : runtime.size.y);
            var s = Math.sin(oldRotation) - Math.sin(newRotation);
            var c = Math.cos(oldRotation) - Math.cos(newRotation);
            var position = shape.transform.position;
            var writtenPositionX = ((runtime.written & EShapeRuntimeReset.POSITION_X) !== 0);
            var writtenPositionY = ((runtime.written & EShapeRuntimeReset.POSITION_Y) !== 0);
            var oldPositionX = (writtenPositionX ? position.x : runtime.x);
            var oldPositionY = (writtenPositionY ? position.y : runtime.y);
            runtime.written |= EShapeRuntimeReset.POSITION;
            position.set(oldPositionX + dx * c - dy * s, oldPositionY + dx * s + dy * c);
        };
        return EShapeActionRuntimeTransformRotate;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotateAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotateAbsolute, _super);
        function EShapeActionRuntimeTransformRotateAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.ROTATION) || this;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformRotateAbsolute.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var transform = shape.transform;
                var writtenRotation = ((runtime.written & EShapeRuntimeReset.ROTATION) !== 0);
                var oldRotation = (writtenRotation ? transform.rotation : runtime.rotation);
                transform.rotation = amount;
                runtime.written |= EShapeRuntimeReset.ROTATION;
                this.adjustPosition(shape, runtime, oldRotation, amount, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformRotateAbsolute;
    }(EShapeActionRuntimeTransformRotate));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotateRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotateRelative, _super);
        function EShapeActionRuntimeTransformRotateRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.ROTATION) || this;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformRotateRelative.prototype.execute = function (shape, runtime, time) {
            if (!!this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var transform = shape.transform;
                var writtenRotation = ((runtime.written & EShapeRuntimeReset.ROTATION) !== 0);
                var oldRotation = (writtenRotation ? transform.rotation : runtime.rotation);
                transform.rotation = oldRotation + amount;
                runtime.written |= EShapeRuntimeReset.ROTATION;
                this.adjustPosition(shape, runtime, oldRotation, transform.rotation, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformRotateRelative;
    }(EShapeActionRuntimeTransformRotate));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformRotateType;
    (function (EShapeActionValueTransformRotateType) {
        EShapeActionValueTransformRotateType[EShapeActionValueTransformRotateType["RELATIVE"] = 0] = "RELATIVE";
        EShapeActionValueTransformRotateType[EShapeActionValueTransformRotateType["ABSOLUTE"] = 1] = "ABSOLUTE";
    })(EShapeActionValueTransformRotateType || (EShapeActionValueTransformRotateType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformRotate = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformRotate, _super);
        function EShapeActionValueTransformRotate(opetype, condition, originX, originY, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.ROTATE, opetype) || this;
            _this.originX = originX;
            _this.originY = originY;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformRotate.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                (value instanceof EShapeActionValueTransformRotate) &&
                this.originX === value.originX &&
                this.originY === value.originY &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformRotate.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformRotateType.ABSOLUTE:
                    return new EShapeActionRuntimeTransformRotateAbsolute(this);
                case EShapeActionValueTransformRotateType.RELATIVE:
                    return new EShapeActionRuntimeTransformRotateRelative(this);
            }
        };
        EShapeActionValueTransformRotate.prototype.serialize = function (manager) {
            var conditionId = manager.add(this.condition);
            var amountId = manager.add(this.amount);
            return manager.add("[" + this.type + "," + conditionId + "," + this.subtype + "," + this.opetype + "," + this.originX + "," + this.originY + "," + amountId + "]");
        };
        EShapeActionValueTransformRotate.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueTransformRotate(serialized[3], condition, serialized[4], serialized[5], amount);
        };
        return EShapeActionValueTransformRotate;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueDeserializer = /** @class */ (function () {
        function EShapeActionValueDeserializer() {
        }
        EShapeActionValueDeserializer.toSerialized = function (resource) {
            try {
                var parsed = JSON.parse(resource);
                if (isArray(parsed)) {
                    for (var i = 0, imax = parsed.length; i < imax; ++i) {
                        if (!isNumber(parsed[i])) {
                            return null;
                        }
                    }
                    if (2 <= parsed.length) {
                        return parsed;
                    }
                }
                return null;
            }
            catch (e) {
                return null;
            }
        };
        EShapeActionValueDeserializer.deserialize = function (id, manager) {
            var actions = manager.actions;
            var action = actions.get(id);
            if (action != null) {
                return action;
            }
            var resources = manager.resources;
            var resource = resources[id];
            if (resource != null) {
                var serialized = this.toSerialized(resource);
                if (serialized != null) {
                    switch (serialized[0]) {
                        case EShapeActionValueType.SHOW_HIDE:
                            return EShapeActionValueShowHide.deserialize(serialized, manager);
                        case EShapeActionValueType.BLINK:
                            return EShapeActionValueBlink.deserialize(serialized, manager);
                        case EShapeActionValueType.CHANGE_COLOR:
                            switch (serialized[3]) {
                                case EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA:
                                case EShapeActionValueChangeColorTarget.COLOR:
                                case EShapeActionValueChangeColorTarget.ALPHA:
                                    return EShapeActionValueChangeColor.deserialize(serialized, manager);
                                case EShapeActionValueChangeColorTarget.CODE:
                                    return EShapeActionValueChangeColorCode.deserialize(serialized, manager);
                                case EShapeActionValueChangeColorTarget.BRIGHTNESS:
                                    return EShapeActionValueChangeColorBrightness.deserialize(serialized, manager);
                            }
                        case EShapeActionValueType.CHANGE_TEXT:
                            return EShapeActionValueChangeText.deserialize(serialized, manager);
                        case EShapeActionValueType.CHANGE_CURSOR:
                            return EShapeActionValueChangeCursor.deserialize(serialized, manager);
                        case EShapeActionValueType.EMIT_EVENT:
                            return EShapeActionValueEmitEvent.deserialize(serialized, manager);
                        case EShapeActionValueType.OPEN:
                            return EShapeActionValueOpen.deserialize(serialized, manager);
                        case EShapeActionValueType.TRANSFORM:
                            switch (serialized[2]) {
                                case EShapeActionValueTransformType.MOVE:
                                    return EShapeActionValueTransformMove.deserialize(serialized, manager);
                                case EShapeActionValueTransformType.RESIZE:
                                    return EShapeActionValueTransformResize.deserialize(serialized, manager);
                                case EShapeActionValueTransformType.ROTATE:
                                    return EShapeActionValueTransformRotate.deserialize(serialized, manager);
                            }
                            break;
                        case EShapeActionValueType.MISC:
                            return EShapeActionValueMisc.deserialize(serialized, manager);
                    }
                }
            }
            return new EShapeActionValueShowHide(EShapeActionValueShowHideType.SHOW, "");
        };
        return EShapeActionValueDeserializer;
    }());

    var EShapeImageElements = /** @class */ (function () {
        function EShapeImageElements() {
        }
        EShapeImageElements.toImageElement = function (dataUrl) {
            var imageElements = EShapeImageElements.imageElements;
            var cachedImageElement = imageElements[dataUrl];
            if (cachedImageElement != null) {
                if (cachedImageElement instanceof HTMLImageElement) {
                    return Promise.resolve(cachedImageElement);
                }
                else {
                    return cachedImageElement;
                }
            }
            else {
                var result = new Promise(function (resolve, reject) {
                    var imageElement = document.createElement("img");
                    imageElement.onload = function () {
                        imageElements[dataUrl] = imageElement;
                        resolve(imageElement);
                    };
                    imageElement.onabort = imageElement.onerror = function () {
                        reject();
                    };
                    imageElement.src = dataUrl;
                });
                imageElements[dataUrl] = result;
                return result;
            }
        };
        EShapeImageElements.imageElements = {};
        return EShapeImageElements;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeResourceManagerDeserialization = /** @class */ (function () {
        function EShapeResourceManagerDeserialization(resources) {
            this.resources = resources;
            this.actions = new Map();
            this.fills = new Map();
            this.strokes = new Map();
            this.tags = new Map();
            this.tagValues = new Map();
            this.ranges = new Map();
            this.aligns = new Map();
            this.margins = new Map();
            this.texts = new Map();
            this.textOutlines = new Map();
            this.extensions = new Map();
        }
        return EShapeResourceManagerDeserialization;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDeserializer = /** @class */ (function () {
        function EShapeDeserializer() {
        }
        EShapeDeserializer.toShape = function (item, manager) {
            var shapeDeserializer = EShapeDeserializers[item[0]];
            if (shapeDeserializer != null) {
                return shapeDeserializer(item, manager);
            }
            return null;
        };
        EShapeDeserializer.deserialize = function (item, manager, result) {
            result.id = manager.resources[item[1]] || "";
            result.transform.position.set(item[2], item[3]);
            result.transform.rotation = item[6];
            result.transform.skew.set(item[7], item[7]);
            result.transform.pivot.set(item[21], item[22]);
            result.size.set(EShapeSizes.toNormalized(item[4]), EShapeSizes.toNormalized(item[5]));
            result.fill.deserialize(item[8], manager);
            result.stroke.deserialize(item[9], manager);
            result.cursor = manager.resources[item[10]] || "";
            result.text.deserialize(item[11], manager);
            result.tag.deserialize(item[12], manager);
            result.radius = item[13];
            result.corner = item[14];
            result.interactive = !!(item[23] & 1);
            result.unfocusable = !!(item[23] & 2);
            result.shortcut = (0 <= item[24] ? manager.resources[item[24]] : undefined);
            result.title = (0 <= item[25] ? manager.resources[item[25]] : undefined);
            // Children
            var childrenPromise = null;
            var childrenSerialized = item[20];
            if (0 < childrenSerialized.length) {
                var childrenOrPromises = [];
                for (var i = 0, imax = childrenSerialized.length; i < imax; ++i) {
                    var childSerialized = childrenSerialized[i];
                    var childOrPromise = EShapeDeserializer.toShape(childSerialized, manager);
                    if (childOrPromise != null) {
                        childrenOrPromises.push(childOrPromise);
                    }
                }
                childrenPromise = Promise.all(childrenOrPromises).then(function (children) {
                    result.children = children;
                    for (var i = 0, imax = children.length; i < imax; ++i) {
                        children[i].parent = result;
                    }
                    result.onChildTransformChange();
                    result.toDirty();
                    return result;
                });
            }
            // Action
            var serializedActions = item[17];
            for (var i = 0, imax = serializedActions.length; i < imax; ++i) {
                result.action.add(EShapeActionValueDeserializer.deserialize(serializedActions[i], manager));
            }
            // Gradient
            var gradientId = item[19];
            if (0 <= gradientId && gradientId < manager.resources.length) {
                var gradient = manager.resources[gradientId];
                if (isString(gradient)) {
                    result.gradient = EShapeGradients.deserializeGradient(gradient);
                }
            }
            // Image
            var imagePromise = null;
            var imageId = item[18];
            if (0 <= imageId && imageId < manager.resources.length) {
                var imageSrc = manager.resources[imageId];
                if (isString(imageSrc)) {
                    imagePromise = EShapeImageElements.toImageElement(imageSrc).then(function (imageElement) {
                        result.image = imageElement;
                        return result;
                    });
                }
            }
            //
            if (childrenPromise != null) {
                if (imagePromise != null) {
                    return Promise.all([childrenPromise, imagePromise]).then(function () {
                        return result;
                    });
                }
                else {
                    return childrenPromise;
                }
            }
            else {
                if (imagePromise != null) {
                    return imagePromise;
                }
                else {
                    return result;
                }
            }
        };
        EShapeDeserializer.deserializeAll = function (serializeds, resources) {
            var manager = new EShapeResourceManagerDeserialization(resources);
            var shapes = [];
            for (var i = 0, imax = serializeds.length; i < imax; ++i) {
                var serialized = serializeds[i];
                var shape = EShapeDeserializer.toShape(serialized, manager);
                if (shape == null) {
                    if (0 < shapes.length) {
                        Promise.all(shapes).then(function (resolved) {
                            for (var j = 0, jmax = resolved.length; j < jmax; ++j) {
                                resolved[j].destroy();
                            }
                        });
                    }
                    return null;
                }
                shapes.push(shape);
            }
            if (0 < shapes.length) {
                return Promise.all(shapes);
            }
            return null;
        };
        return EShapeDeserializer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeBar = function (item, manager) {
        var shape = new EShapeBar(EShapeBarPosition.RIGHT, 10, 3, EShapePointsStyle.NONE);
        var result = EShapeDeserializer.deserialize(item, manager, shape);
        shape.points.deserialize(item[15], manager);
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeBar = function () {
        EShapeUploadeds[EShapeType.BAR] = createBarUploaded;
        EShapeDeserializers[EShapeType.BAR] = deserializeBar;
    };

    var buildStep = function (steps, clippings, voffset, vcount, swx, swy, px0, py0, px1, py1) {
        var ic = voffset * 3;
        var is = voffset * 6;
        for (var i = 0; i < vcount; ++i) {
            steps[is + 0] = swx * clippings[ic + 0];
            steps[is + 1] = swy * clippings[ic + 1];
            steps[is + 2] = px0;
            steps[is + 3] = py0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            ic += 3;
            is += 6;
        }
    };

    var STEP_VALUES = [0, 0, 0];
    var toStep = function (size, strokeWidth, antialiasWeight, result) {
        var FMIN = 0.00001;
        if (FMIN < strokeWidth) {
            var dpc0 = size - strokeWidth;
            if (FMIN < dpc0) {
                var pc0 = antialiasWeight / dpc0;
                var pc1 = antialiasWeight / Math.max(FMIN, size);
                var swc = 1 / Math.max(FMIN, 1 - strokeWidth / size);
                result[0] = swc;
                result[1] = pc0;
                result[2] = pc1;
            }
            else {
                var pc0 = antialiasWeight / FMIN;
                var pc1 = antialiasWeight / Math.max(FMIN, size);
                var swc = 1 / FMIN;
                result[0] = swc;
                result[1] = pc0;
                result[2] = pc1;
            }
        }
        else {
            // Assumes strokeWidth === 0
            var pc = antialiasWeight / Math.max(FMIN, size);
            result[0] = 1;
            result[1] = pc;
            result[2] = pc;
        }
        return result;
    };

    var CIRCLE_VERTEX_COUNT = 9;
    var CIRCLE_INDEX_COUNT = 8;
    var CIRCLE_WORLD_SIZE = [0, 0];
    var CIRCLE_WORK_POINT = new pixi_js.Point();
    var buildCircleClipping = function (clippings, voffset) {
        var ic = voffset * 3;
        clippings[ic + 0] = 1;
        clippings[ic + 1] = 1;
        clippings[ic + 2] = 1;
        clippings[ic + 3] = 0;
        clippings[ic + 4] = 1;
        clippings[ic + 5] = 1;
        clippings[ic + 6] = 1;
        clippings[ic + 7] = 1;
        clippings[ic + 8] = 1;
        clippings[ic + 9] = 1;
        clippings[ic + 10] = 0;
        clippings[ic + 11] = 1;
        clippings[ic + 12] = 0;
        clippings[ic + 13] = 0;
        clippings[ic + 14] = 1;
        clippings[ic + 15] = 1;
        clippings[ic + 16] = 0;
        clippings[ic + 17] = 1;
        clippings[ic + 18] = 1;
        clippings[ic + 19] = 1;
        clippings[ic + 20] = 1;
        clippings[ic + 21] = 0;
        clippings[ic + 22] = 1;
        clippings[ic + 23] = 1;
        clippings[ic + 24] = 1;
        clippings[ic + 25] = 1;
        clippings[ic + 26] = 1;
    };
    var buildCircleIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3;
        indices[ii + 0] = voffset + 0;
        indices[ii + 1] = voffset + 1;
        indices[ii + 2] = voffset + 3;
        indices[ii + 3] = voffset + 1;
        indices[ii + 4] = voffset + 4;
        indices[ii + 5] = voffset + 3;
        indices[ii + 6] = voffset + 1;
        indices[ii + 7] = voffset + 2;
        indices[ii + 8] = voffset + 4;
        indices[ii + 9] = voffset + 2;
        indices[ii + 10] = voffset + 5;
        indices[ii + 11] = voffset + 4;
        indices[ii + 12] = voffset + 3;
        indices[ii + 13] = voffset + 4;
        indices[ii + 14] = voffset + 6;
        indices[ii + 15] = voffset + 4;
        indices[ii + 16] = voffset + 7;
        indices[ii + 17] = voffset + 6;
        indices[ii + 18] = voffset + 4;
        indices[ii + 19] = voffset + 5;
        indices[ii + 20] = voffset + 7;
        indices[ii + 21] = voffset + 5;
        indices[ii + 22] = voffset + 8;
        indices[ii + 23] = voffset + 7;
    };
    var buildCircleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        //  0       1       2
        // |-------|-------|
        // |3      |4      |5
        // |-------|-------|
        // |6      |7      |8
        // |-------|-------|
        //
        var work = CIRCLE_WORK_POINT;
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        work.set(-sx + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(0 + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        var dx = x1 - x0;
        var dy = y1 - y0;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var x4 = work.x;
        var y4 = work.y;
        var x7 = x4 + (x4 - x1);
        var y7 = y4 + (y4 - y1);
        var x3 = x4 - dx;
        var y3 = y4 - dy;
        // Vertices
        var iv = voffset * 2;
        vertices[iv + 0] = x0;
        vertices[iv + 1] = y0;
        vertices[iv + 2] = x1;
        vertices[iv + 3] = y1;
        vertices[iv + 4] = x1 + dx;
        vertices[iv + 5] = y1 + dy;
        vertices[iv + 6] = x3;
        vertices[iv + 7] = y3;
        vertices[iv + 8] = x4;
        vertices[iv + 9] = y4;
        vertices[iv + 10] = x4 + dx;
        vertices[iv + 11] = y4 + dy;
        vertices[iv + 12] = x7 - dx;
        vertices[iv + 13] = y7 - dy;
        vertices[iv + 14] = x7;
        vertices[iv + 15] = y7;
        vertices[iv + 16] = x7 + dx;
        vertices[iv + 17] = y7 + dy;
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x3, y3);
    };
    var buildCircleStep = function (steps, clippings, voffset, strokeWidth, antialiasWeight, worldSize) {
        toStep(worldSize[0], strokeWidth, antialiasWeight, STEP_VALUES);
        var swx = STEP_VALUES[0];
        var px0 = STEP_VALUES[1];
        var px1 = STEP_VALUES[2];
        toStep(worldSize[1], strokeWidth, antialiasWeight, STEP_VALUES);
        var swy = STEP_VALUES[0];
        var py0 = STEP_VALUES[1];
        var py1 = STEP_VALUES[2];
        buildStep(steps, clippings, voffset, CIRCLE_VERTEX_COUNT, swx, swy, px0, py0, px1, py1);
    };
    var buildCircleUv = function (uvs, voffset, textureUvs) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        // UVs
        var iuv = voffset * 2;
        uvs[iuv + 0] = x0;
        uvs[iuv + 1] = y0;
        uvs[iuv + 2] = 0.5 * (x0 + x1);
        uvs[iuv + 3] = 0.5 * (y0 + y1);
        uvs[iuv + 4] = x1;
        uvs[iuv + 5] = y1;
        uvs[iuv + 6] = 0.5 * (x0 + x3);
        uvs[iuv + 7] = 0.5 * (y0 + y3);
        uvs[iuv + 8] = 0.5 * (x0 + x2);
        uvs[iuv + 9] = 0.5 * (y0 + y2);
        uvs[iuv + 10] = 0.5 * (x1 + x2);
        uvs[iuv + 11] = 0.5 * (y1 + y2);
        uvs[iuv + 12] = x3;
        uvs[iuv + 13] = y3;
        uvs[iuv + 14] = 0.5 * (x3 + x2);
        uvs[iuv + 15] = 0.5 * (y3 + y2);
        uvs[iuv + 16] = x2;
        uvs[iuv + 17] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCircleUploaded = /** @class */ (function (_super) {
        __extends(EShapeCircleUploaded, _super);
        function EShapeCircleUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeCircleUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Clippings & indices
            var buffer = this.buffer;
            buffer.updateClippings();
            buffer.updateIndices();
            var voffset = this.vertexOffset;
            buildCircleClipping(buffer.clippings, voffset);
            buildCircleIndex(buffer.indices, voffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeCircleUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateCircleVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateCircleUv(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeCircleUploaded.prototype.updateCircleVertexAndStep = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign || this.strokeWidth !== strokeWidth);
            if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                // Invalidate the text layout to update the text layout.
                this.textSpacingHorizontal = NaN;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                buildCircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, CIRCLE_WORLD_SIZE);
                buildCircleStep(buffer.steps, buffer.clippings, this.vertexOffset, strokeWidth, this.antialiasWeight, CIRCLE_WORLD_SIZE);
            }
        };
        EShapeCircleUploaded.prototype.updateCircleUv = function (buffer, shape) {
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var textureUvs = this.toTextureUvs(texture);
                buildCircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        };
        return EShapeCircleUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createCircle = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = CIRCLE_VERTEX_COUNT + tvcount;
        var icount = CIRCLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeCircleUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCircle = /** @class */ (function (_super) {
        __extends(EShapeCircle, _super);
        function EShapeCircle(type) {
            if (type === void 0) { type = EShapeType.CIRCLE; }
            return _super.call(this, type) || this;
        }
        EShapeCircle.prototype.clone = function () {
            return new EShapeCircle().copy(this);
        };
        EShapeCircle.prototype.containsAbs = function (x, y, ax, ay) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                var fill = this.fill;
                var stroke = this.stroke;
                if (fill.enable) {
                    var x2 = x * x;
                    var y2 = y * y;
                    var ax2 = ax * ax;
                    var ay2 = ay * ay;
                    if (x2 * ay2 + y2 * ax2 <= ax2 * ay2) {
                        return true;
                    }
                }
                else {
                    var strokeWidth = stroke.width;
                    if (stroke.enable && 0 < strokeWidth) {
                        var x2 = x * x;
                        var y2 = y * y;
                        var wx = Math.max(0.0, ax - strokeWidth);
                        var wy = Math.max(0.0, ay - strokeWidth);
                        var wx2 = wx * wx;
                        var wy2 = wy * wy;
                        if (wx2 * wy2 <= x2 * wy2 + y2 * wx2) {
                            var ax2 = ax * ax;
                            var ay2 = ay * ay;
                            if (x2 * ay2 + y2 * ax2 <= ax2 * ay2) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        };
        return EShapeCircle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeCircle = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeCircle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeCircle = function () {
        EShapeUploadeds[EShapeType.CIRCLE] = createCircle;
        EShapeDeserializers[EShapeType.CIRCLE] = deserializeCircle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupUploaded = /** @class */ (function (_super) {
        __extends(EShapeGroupUploaded, _super);
        function EShapeGroupUploaded(buffer, voffset, ioffset) {
            return _super.call(this, buffer, voffset, ioffset, 0, 0, 1) || this;
        }
        EShapeGroupUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            this.texture = shape.texture || pixi_js.Texture.WHITE;
            return this;
        };
        EShapeGroupUploaded.prototype.update = function (shape) {
            // DO NOTHING
        };
        return EShapeGroupUploaded;
    }(EShapeUploadedBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createGroupUploaded = function (buffer, shape, voffset, ioffset) {
        return new EShapeGroupUploaded(buffer, voffset, ioffset).init(shape);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupFillEditor = /** @class */ (function () {
        function EShapeGroupFillEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupFillEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.enable;
                }
                return true;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.enable = enable;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.color;
                }
                return 0xffffff;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.color = color;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.alpha = alpha;
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupFillEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.copy(target);
            }
        };
        EShapeGroupFillEditor.prototype.set = function (enable, color, alpha) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.set(enable, color, alpha);
            }
        };
        EShapeGroupFillEditor.prototype.clone = function () {
            return new EShapeGroupFillEditor(this._parent);
        };
        EShapeGroupFillEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].fill.toObject();
            }
            return {
                enable: true,
                color: 0xffffff,
                alpha: 1.0
            };
        };
        EShapeGroupFillEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupFillEditor.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupFillEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupPoints = /** @class */ (function () {
        function EShapeGroupPoints(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupPoints.prototype, "length", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.length;
                    }
                }
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "id", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.id;
                    }
                }
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "values", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.values;
                    }
                }
                return [];
            },
            set: function (values) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.values = values;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "segments", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.segments;
                    }
                }
                return [];
            },
            set: function (segments) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.segments = segments;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "style", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.style;
                    }
                }
                return EShapePointsStyle.NONE;
            },
            set: function (style) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.style = style;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupPoints.prototype.copy = function (source) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    points.copy(source);
                }
            }
            return this;
        };
        EShapeGroupPoints.prototype.set = function (values, segments, style) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    points.set(values, segments, style);
                }
            }
            return this;
        };
        EShapeGroupPoints.prototype.clone = function (parent) {
            return new EShapeGroupPoints(parent);
        };
        EShapeGroupPoints.prototype.toPoints = function (transform) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    return points.toPoints(transform);
                }
            }
            return [];
        };
        EShapeGroupPoints.prototype.serialize = function (manager) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    return points.serialize(manager);
                }
            }
            return -1;
        };
        return EShapeGroupPoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeEditor = /** @class */ (function () {
        function EShapeEditor() {
            this.localTransform = new pixi_js.Matrix();
            this.internalTransform = new pixi_js.Matrix();
            this.internalTransformParentInverse = new pixi_js.Matrix();
            this.rotation = 0;
            this.size = new pixi_js.Point();
        }
        return EShapeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTransforms = /** @class */ (function () {
        function EShapeTransforms() {
        }
        EShapeTransforms.prepare = function (shape) {
            var editor = shape.editor = (shape.editor || new EShapeEditor());
            // Ttransform
            shape.updateTransform();
            var parent = shape.parent;
            if (parent instanceof EShapeBase) {
                parent.transform.internalTransform.copyTo(editor.internalTransformParentInverse).invert();
            }
            else {
                editor.internalTransformParentInverse.identity();
            }
            shape.transform.internalTransform.copyTo(editor.internalTransform);
            // Rotation
            editor.rotation = shape.transform.rotation;
            // Size
            editor.size.copyFrom(shape.size);
            //
            shape.disallowOnTransformChange();
        };
        EShapeTransforms.finalize = function (shape) {
            shape.allowOnTransformChange(true);
        };
        EShapeTransforms.apply = function (shape, transform, keepSize) {
            var editor = shape.editor;
            if (editor != null) {
                var newLocalTransform = editor.localTransform;
                editor.internalTransformParentInverse.copyTo(newLocalTransform)
                    .append(transform).append(editor.internalTransform);
                if (keepSize) {
                    this.applyLocal(shape, newLocalTransform);
                }
                else {
                    var size = editor.size;
                    this.applyLocal(shape, newLocalTransform, size.x, size.y);
                }
            }
        };
        EShapeTransforms.applyLocal = function (shape, localTransform, bx, by) {
            shape.disallowUploadedUpdate();
            // Reconstruct the position, the rotation and the size
            var a = localTransform.a;
            var b = localTransform.b;
            var c = localTransform.c;
            var d = localTransform.d;
            var tx = localTransform.tx;
            var ty = localTransform.ty;
            // Rotation
            var transform = shape.transform;
            var rx = Math.atan2(-c, d); // rotation - skewX
            var ry = Math.atan2(+b, a); // rotation + skewY
            transform.rotation = (rx + ry) * 0.5; // Here, assumes `skewX` === `skewY`
            // Skew
            var skew = (ry - rx) * 0.5;
            transform.skew.set(skew, skew);
            // Position: Assumes the pivot is invariant.
            // tx = position.x - (a * px + c * py)
            // ty = position.y - (b * px + d * py)
            //
            // Thus,
            // position.x = tx + (a * px + c * py)
            // position.y = ty + (b * px + d * py)
            var pivot = transform.pivot;
            var px = pivot.x;
            var py = pivot.y;
            transform.position.set(tx + (a * px + c * py), ty + (b * px + d * py));
            // Scale
            if (bx != null && by != null) {
                var sx = Math.sqrt(a * a + b * b);
                var sy = Math.sqrt(c * c + d * d);
                shape.size.set(EShapeSizes.toNormalized(bx * sx), EShapeSizes.toNormalized(by * sy));
            }
            //
            shape.allowUploadedUpdate();
        };
        return EShapeTransforms;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeLayout = /** @class */ (function () {
        function EShapeGroupSizeLayout(shape, bx, by) {
            this.shape = shape;
            // Base group size
            this.base = new pixi_js.Point(bx, by);
            // Base shape size
            var size = shape.size;
            this.shapeBase = new pixi_js.Point(size.x, size.y);
            // Transform
            this.transform = new pixi_js.Matrix();
            shape.updateTransform();
            shape.transform.localTransform.copyTo(this.transform);
        }
        EShapeGroupSizeLayout.prototype.isCompatible = function (shape) {
            return this.shape === shape;
        };
        EShapeGroupSizeLayout.prototype.reset = function (shape, baseX, baseY) {
            this.base.set(baseX, baseY);
            // Base shape size
            var size = shape.size;
            this.shapeBase.copyFrom(size);
            // Transform
            shape.updateTransform();
            shape.transform.localTransform.copyTo(this.transform);
        };
        EShapeGroupSizeLayout.prototype.update = function (shape, baseX, baseY, pivotX, pivotY) {
            var sx = baseX / this.base.x;
            var sy = baseY / this.base.y;
            var childBase = this.shapeBase;
            var transform = EShapeGroupSizeLayout.WORK_TRANSFORM;
            transform.identity()
                .append(this.transform)
                .translate(-pivotX, -pivotY)
                .scale(sx, sy)
                .translate(+pivotX, +pivotY);
            shape.disallowOnTransformChange();
            EShapeTransforms.applyLocal(shape, transform, childBase.x, childBase.y);
            shape.allowOnTransformChange(false);
        };
        EShapeGroupSizeLayout.WORK_TRANSFORM = new pixi_js.Matrix();
        return EShapeGroupSizeLayout;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeEditor = /** @class */ (function () {
        function EShapeGroupSizeEditor(parent, x, y) {
            this._workPoint = new pixi_js.Point();
            this._workRectForCalcRect = new pixi_js.Rectangle();
            this._workRectForFit = new pixi_js.Rectangle();
            this._parent = parent;
            this._layouts = [];
            this._size = new pixi_js.Point(x, y);
        }
        EShapeGroupSizeEditor.prototype.init = function () {
            // DO NOTHING
        };
        Object.defineProperty(EShapeGroupSizeEditor.prototype, "x", {
            get: function () {
                return this._size.x;
            },
            set: function (x) {
                var size = this._size;
                if (size.x !== x) {
                    var ox = size.x;
                    size.x = x;
                    this.onChange(ox, size.y);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeEditor.prototype, "y", {
            get: function () {
                return this._size.y;
            },
            set: function (y) {
                var size = this._size;
                if (size.y !== y) {
                    var oy = size.y;
                    size.y = y;
                    this.onChange(size.x, oy);
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupSizeEditor.prototype.set = function (x, y) {
            var isChanged = false;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (x != null && ox !== x) {
                isChanged = true;
                size.x = x;
            }
            if (y != null && oy !== y) {
                isChanged = true;
                size.y = y;
            }
            if (isChanged) {
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeEditor.prototype.clone = function () {
            var size = this._size;
            return new EShapeGroupSizeEditor(this._parent, size.x, size.y);
        };
        EShapeGroupSizeEditor.prototype.copy = function () {
            // DO NOTHING
        };
        EShapeGroupSizeEditor.prototype.copyFrom = function (point) {
            var x = point.x;
            var y = point.y;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (ox !== x || oy !== y) {
                size.x = x;
                size.y = y;
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeEditor.prototype.copyTo = function (point) {
            return this._size.copyTo(point);
        };
        EShapeGroupSizeEditor.prototype.equals = function (point) {
            return this._size.equals(point);
        };
        EShapeGroupSizeEditor.prototype.fit = function () {
            var parent = this._parent;
            parent.disallowOnTransformChange();
            // Calculate the rect
            var rect = this.calcRect(this._workRectForFit);
            // Set size
            var size = this._size;
            size.set(rect.width, rect.height);
            // Position & Pivot
            // rx := rect.x
            // ry := rect.y
            //
            // | a c tx | | 1 0 +rx | | 1 0 -rx |   | a c tx + (a * rx + c * ry) | | 1 0 -rx |
            // | b d ty | | 0 1 +ry | | 0 1 -ry | = | b d ty + (b * rx + d * ry) | | 0 1 -ry |
            // | 0 0 1  | | 0 0  1  | | 0 0  1  |   | 0 0 1                      | | 0 0  1  |
            //
            // tx -> tx + (a * rx + c * ry) = poxition.x - (a * pivot.x + c * pivot.y)
            // ty -> ty + (b * rx + d * ry) = poxition.y - (b * pivot.x + d * pivot.y)
            // position.x -> position.x + (a * rx + c * ry) - (a * pivot.x + c * pivot.y)
            // position.y -> position.y + (b * rx + d * ry) - (b * pivot.x + d * pivot.y)
            // pivot.x -> 0
            // pivot.y -> 0
            //
            // a -> a', b -> b', c -> c', tx -> tx', ty -> ty'
            //
            // | a' c' tx' | | 1 0 -rx |   | a' c' tx' - (a' * rx + c' * ry) |
            // | b' d' ty' | | 0 1 -ry | = | b' d' ty' - (b' * rx + d' * ry) |
            // | 0  0  1   | | 0 0  1  |   | 0  0  1                         |
            //
            // tx' -> tx' - (a' * rx + c' * ry) = poxition.x - (a' * pivot.x + c' * pivot.y)
            // ty' -> ty' - (b' * rx + d' * ry) = poxition.y - (b' * pivot.x + d' * pivot.y)
            // pivot.x -> pivot.x + rx
            // pivot.y -> pivot.y + ry
            parent.updateTransform();
            var transform = parent.transform;
            var x = rect.x + rect.width * 0.5;
            var y = rect.y + rect.height * 0.5;
            var position = transform.position;
            var localTransform = transform.localTransform;
            var a = localTransform.a;
            var b = localTransform.b;
            var c = localTransform.c;
            var d = localTransform.d;
            var pivot = transform.pivot;
            position.set(position.x + (a * x + c * y) - (a * pivot.x + c * pivot.y), position.y + (b * x + d * y) - (b * pivot.x + d * pivot.y));
            pivot.set(x, y);
            // Reset the data
            this.reset(parent.children, this._layouts, size);
            //
            parent.allowOnTransformChange(true);
        };
        EShapeGroupSizeEditor.prototype.reset = function (children, layouts, size) {
            for (var i = 0, imax = Math.min(layouts.length, children.length); i < imax; ++i) {
                var child = children[i];
                var layout = layouts[i];
                if (layout.isCompatible(child)) {
                    layout.reset(child, size.x, size.y);
                }
                else {
                    layouts.length = i;
                    break;
                }
            }
            if (children.length < layouts.length) {
                layouts.length = children.length;
            }
        };
        EShapeGroupSizeEditor.prototype.calcRect = function (result) {
            var parent = this._parent;
            var children = parent.children;
            if (children.length <= 0) {
                result.x = 0;
                result.y = 0;
                result.width = 0;
                result.height = 0;
            }
            else {
                var workPoint = this._workPoint;
                var workRect = this._workRectForCalcRect;
                children[0].getBoundsLocal(workPoint, false, result);
                for (var i = 1, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    child.getBoundsLocal(workPoint, false, workRect);
                    result.enlarge(workRect);
                }
            }
            return result;
        };
        EShapeGroupSizeEditor.prototype.onChange = function (ox, oy) {
            var parent = this._parent;
            var size = this._size;
            var pivot = parent.transform.pivot;
            this.onChange_(parent.children, this._layouts, size.x, size.y, pivot.x, pivot.y, ox, oy);
            parent.onSizeChange();
        };
        EShapeGroupSizeEditor.prototype.onChange_ = function (children, layouts, sx, sy, px, py, ox, oy) {
            for (var i = 0, imax = Math.min(layouts.length, children.length); i < imax; ++i) {
                var child = children[i];
                var layout = layouts[i];
                if (layout.isCompatible(child)) {
                    layout.update(child, sx, sy, px, py);
                }
                else {
                    layouts.length = i;
                    break;
                }
            }
            for (var i = layouts.length, imax = children.length; i < imax; ++i) {
                var child = children[i];
                var layout = this.newLayout(child, ox, oy);
                layout.update(child, sx, sy, px, py);
                layouts.push(layout);
            }
            if (layouts.length !== children.length) {
                layouts.length = children.length;
            }
        };
        EShapeGroupSizeEditor.prototype.newLayout = function (shape, ox, oy) {
            return shape.layout || new EShapeGroupSizeLayout(shape, ox, oy);
        };
        return EShapeGroupSizeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeViewer = /** @class */ (function (_super) {
        __extends(EShapeGroupSizeViewer, _super);
        function EShapeGroupSizeViewer(cb, x, y) {
            var _this = _super.call(this, cb, undefined, x, y) || this;
            _this.base = new pixi_js.Point(x, y);
            return _this;
        }
        EShapeGroupSizeViewer.prototype.init = function () {
            this.base.copyFrom(this);
            this.cb();
        };
        EShapeGroupSizeViewer.prototype.fit = function () {
            // DO NOTHING
        };
        return EShapeGroupSizeViewer;
    }(pixi_js.ObservablePoint));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupStrokeEditor = /** @class */ (function () {
        function EShapeGroupStrokeEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.enable;
                }
                return false;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.enable = enable;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.color;
                }
                return 0xffffff;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.color = color;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.alpha = alpha;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "width", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.width;
                }
                return 1.0;
            },
            set: function (width) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.width = width;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "align", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.align;
                }
                return 1.0;
            },
            set: function (align) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.align = align;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "side", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.side;
                }
                return 1.0;
            },
            set: function (side) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.side = side;
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupStrokeEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.copy(target);
            }
        };
        EShapeGroupStrokeEditor.prototype.set = function (enable, color, alpha, width, side) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.set(enable, color, alpha, width, side);
            }
        };
        EShapeGroupStrokeEditor.prototype.clone = function () {
            return new EShapeGroupStrokeEditor(this._parent);
        };
        EShapeGroupStrokeEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.toObject();
            }
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0,
                align: 0.0,
                side: EShapeStrokeSide.NONE
            };
        };
        EShapeGroupStrokeEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupStrokeEditor.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupStrokeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextAlignEditor = /** @class */ (function () {
        function EShapeGroupTextAlignEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupTextAlignEditor.prototype, "horizontal", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.align.horizontal;
                }
                return EShapeTextAlignHorizontal.CENTER;
            },
            set: function (horizontal) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.align.horizontal = horizontal;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextAlignEditor.prototype, "vertical", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.align.vertical;
                }
                return EShapeTextAlignVertical.MIDDLE;
            },
            set: function (vertical) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.align.vertical = vertical;
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextAlignEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.align.copy(target);
            }
        };
        EShapeGroupTextAlignEditor.prototype.set = function (horizontal, vertical) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.align.set(horizontal, vertical);
            }
        };
        EShapeGroupTextAlignEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.align.toObject();
            }
            return {
                horizontal: EShapeTextAlignHorizontal.CENTER,
                vertical: EShapeTextAlignVertical.MIDDLE
            };
        };
        EShapeGroupTextAlignEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextAlignEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextAlignEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextOffsetEditor = /** @class */ (function () {
        function EShapeGroupTextOffsetEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupTextOffsetEditor.prototype, "horizontal", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.offset.horizontal;
                }
                return 0;
            },
            set: function (horizontal) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.offset.horizontal = horizontal;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOffsetEditor.prototype, "vertical", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.offset.vertical;
                }
                return 0;
            },
            set: function (vertical) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.offset.vertical = vertical;
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextOffsetEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.offset.copy(target);
            }
        };
        EShapeGroupTextOffsetEditor.prototype.set = function (horizontal, vertical) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.offset.set(horizontal, vertical);
            }
        };
        EShapeGroupTextOffsetEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.offset.toObject();
            }
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextOffsetEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextOffsetEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextOffsetEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextOutlineEditor = /** @class */ (function () {
        function EShapeGroupTextOutlineEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupTextOutlineEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.outline.enable;
                }
                return false;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.outline.enable = enable;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.outline.color;
                }
                return 0xffffff;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.outline.color = color;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.outline.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.outline.alpha = alpha;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineEditor.prototype, "width", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.outline.width;
                }
                return 1.0;
            },
            set: function (width) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.outline.width = width;
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextOutlineEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.outline.copy(target);
            }
        };
        EShapeGroupTextOutlineEditor.prototype.set = function (enable, color, alpha, width) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.outline.set(enable, color, alpha, width);
            }
        };
        EShapeGroupTextOutlineEditor.prototype.clone = function () {
            return new EShapeGroupTextOutlineEditor(this._parent);
        };
        EShapeGroupTextOutlineEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.outline.toObject();
            }
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0
            };
        };
        EShapeGroupTextOutlineEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextOutlineEditor.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupTextOutlineEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextPaddingEditor = /** @class */ (function () {
        function EShapeGroupTextPaddingEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupTextPaddingEditor.prototype, "horizontal", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.padding.horizontal;
                }
                return 0;
            },
            set: function (horizontal) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.padding.horizontal = horizontal;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextPaddingEditor.prototype, "vertical", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.padding.vertical;
                }
                return 0;
            },
            set: function (vertical) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.padding.vertical = vertical;
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextPaddingEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.padding.copy(target);
            }
        };
        EShapeGroupTextPaddingEditor.prototype.set = function (horizontal, vertical) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.padding.set(horizontal, vertical);
            }
        };
        EShapeGroupTextPaddingEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.padding.toObject();
            }
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextPaddingEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextPaddingEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextPaddingEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextSpacingEditor = /** @class */ (function () {
        function EShapeGroupTextSpacingEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupTextSpacingEditor.prototype, "horizontal", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.spacing.horizontal;
                }
                return 0;
            },
            set: function (horizontal) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.spacing.horizontal = horizontal;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextSpacingEditor.prototype, "vertical", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.spacing.vertical;
                }
                return 0;
            },
            set: function (vertical) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.spacing.vertical = vertical;
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextSpacingEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.spacing.copy(target);
            }
        };
        EShapeGroupTextSpacingEditor.prototype.set = function (horizontal, vertical) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.spacing.set(horizontal, vertical);
            }
        };
        EShapeGroupTextSpacingEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.spacing.toObject();
            }
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextSpacingEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextSpacingEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextSpacingEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextEditor = /** @class */ (function () {
        function EShapeGroupTextEditor(parent) {
            this._parent = parent;
            this.align = new EShapeGroupTextAlignEditor(parent);
            this.offset = new EShapeGroupTextOffsetEditor(parent);
            this.outline = new EShapeGroupTextOutlineEditor(parent);
            this.spacing = new EShapeGroupTextSpacingEditor(parent);
            this.padding = new EShapeGroupTextPaddingEditor(parent);
        }
        Object.defineProperty(EShapeGroupTextEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.enable;
                }
                return true;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.enable = enable;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "value", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.value;
                }
                return "";
            },
            set: function (value) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.value = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.color;
                }
                return 0x000000;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.color = color;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.alpha = alpha;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "family", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.family;
                }
                return "auto";
            },
            set: function (family) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.family = family;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "size", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.size;
                }
                return 24;
            },
            set: function (size) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.size = size;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "weight", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.weight;
                }
                return EShapeTextWeight.NORMAL;
            },
            set: function (weight) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.weight = weight;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "style", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.style;
                }
                return EShapeTextStyle.NORMAL;
            },
            set: function (style) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.style = style;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "direction", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.direction;
                }
                return 0;
            },
            set: function (direction) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.direction = direction;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "clipping", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.clipping;
                }
                return false;
            },
            set: function (clipping) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.clipping = clipping;
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.copy(target);
            }
            return this;
        };
        EShapeGroupTextEditor.prototype.set = function (value, color, alpha, family, size, weight, style, direction) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.set(value, color, alpha, family, size, weight, style, direction);
            }
            return this;
        };
        EShapeGroupTextEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.toObject();
            }
            return {
                value: "",
                color: 0x000000,
                alpha: 1.0,
                family: "auto",
                size: 24,
                weight: EShapeTextWeight.NORMAL,
                align: this.align.toObject(),
                offset: this.offset.toObject(),
                style: EShapeTextStyle.NORMAL,
                outline: this.outline.toObject(),
                spacing: this.spacing.toObject(),
                direction: EShapeTextDirection.LEFT_TO_RIGHT,
                padding: this.padding.toObject(),
                clipping: false
            };
        };
        EShapeGroupTextEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextEditor.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupTextEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroup = /** @class */ (function (_super) {
        __extends(EShapeGroup, _super);
        function EShapeGroup(type) {
            if (type === void 0) { type = EShapeType.GROUP; }
            var _this = _super.call(this, type) || this;
            _this.tag = new EShapeTagImpl();
            _this.size = _this.newGroupSize();
            _this.fill = _this.newGroupFill();
            _this.stroke = _this.newGroupStroke();
            _this.text = _this.newGroupText();
            _this.points = _this.newGroupPoints();
            return _this;
        }
        EShapeGroup.prototype.newGroupSize = function () {
            var _this = this;
            if (EShapeDefaults.IS_EDIT_MODE) {
                return new EShapeGroupSizeEditor(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            }
            else {
                var result_1 = new EShapeGroupSizeViewer(function () {
                    var base = result_1.base;
                    _this.transform.scale.set(result_1.x / base.x, result_1.y / base.y);
                }, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
                return result_1;
            }
        };
        EShapeGroup.prototype.newGroupFill = function () {
            return new EShapeGroupFillEditor(this);
        };
        EShapeGroup.prototype.newGroupStroke = function () {
            return new EShapeGroupStrokeEditor(this);
        };
        EShapeGroup.prototype.newGroupText = function () {
            return new EShapeGroupTextEditor(this);
        };
        EShapeGroup.prototype.newGroupPoints = function () {
            return new EShapeGroupPoints(this);
        };
        EShapeGroup.prototype.getBoundsSize = function () {
            var size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                return size.base;
            }
            else {
                return size;
            }
        };
        EShapeGroup.prototype.onChildTransformChange = function () {
            _super.prototype.onChildTransformChange.call(this);
            this.size.fit();
        };
        Object.defineProperty(EShapeGroup.prototype, "corner", {
            get: function () {
                var children = this.children;
                if (0 < children.length) {
                    return children[children.length - 1].corner;
                }
                return EShapeCorner.ALL;
            },
            set: function (corner) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].corner = corner;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "cursor", {
            get: function () {
                var children = this.children;
                if (0 < children.length) {
                    return children[children.length - 1].cursor;
                }
                return "";
            },
            set: function (cursor) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].cursor = cursor;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "gradient", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var gradient = children[i].gradient;
                    if (gradient != null) {
                        return gradient;
                    }
                }
                return undefined;
            },
            set: function (gradient) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].gradient = gradient;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "radius", {
            get: function () {
                var children = this.children;
                if (0 < children.length) {
                    return children[children.length - 1].radius;
                }
                return 0.5;
            },
            set: function (radius) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].radius = radius;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "image", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var image = children[i].image;
                    if (image != null) {
                        return image;
                    }
                }
                return undefined;
            },
            set: function (image) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].image = image;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "points", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var points = children[i].points;
                    if (points != null) {
                        return this._points;
                    }
                }
                return undefined;
            },
            set: function (points) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroup.prototype.clone = function () {
            var constructor = this.constructor;
            var result = new constructor().copy(this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            return result;
        };
        EShapeGroup.prototype.containsAbs = function (x, y, ax, ay) {
            return false;
        };
        return EShapeGroup;
    }(EShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeGroup = function (item, manager) {
        var shape = new EShapeGroup();
        var result = EShapeDeserializer.deserialize(item, manager, shape);
        shape.size.init();
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeGroup = function () {
        EShapeUploadeds[EShapeType.GROUP] = createGroupUploaded;
        EShapeDeserializers[EShapeType.GROUP] = deserializeGroup;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeShadowed = /** @class */ (function () {
        function EShapeGroupSizeShadowed(parent, x, y) {
            this._parent = parent;
            this._size = new pixi_js.Point(x, y);
        }
        EShapeGroupSizeShadowed.prototype.init = function () {
            // DO NOTHING
        };
        Object.defineProperty(EShapeGroupSizeShadowed.prototype, "x", {
            get: function () {
                return this._size.x;
            },
            set: function (x) {
                var size = this._size;
                if (size.x !== x) {
                    var ox = size.x;
                    size.x = x;
                    this.onChange(ox, size.y);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeShadowed.prototype, "y", {
            get: function () {
                return this._size.y;
            },
            set: function (y) {
                var size = this._size;
                if (size.y !== y) {
                    var oy = size.y;
                    size.y = y;
                    this.onChange(size.x, oy);
                }
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupSizeShadowed.prototype.set = function (x, y) {
            var isChanged = false;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (x != null && ox !== x) {
                isChanged = true;
                size.x = x;
            }
            if (y != null && oy !== y) {
                isChanged = true;
                size.y = y;
            }
            if (isChanged) {
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeShadowed.prototype.clone = function () {
            var size = this._size;
            return new EShapeGroupSizeShadowed(this._parent, size.x, size.y);
        };
        EShapeGroupSizeShadowed.prototype.copy = function () {
            // DO NOTHING
        };
        EShapeGroupSizeShadowed.prototype.copyFrom = function (point) {
            var x = point.x;
            var y = point.y;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (ox !== x || oy !== y) {
                size.x = x;
                size.y = y;
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeShadowed.prototype.copyTo = function (point) {
            return this._size.copyTo(point);
        };
        EShapeGroupSizeShadowed.prototype.equals = function (point) {
            return this._size.equals(point);
        };
        EShapeGroupSizeShadowed.prototype.fit = function () {
            // DO NOTHING
        };
        EShapeGroupSizeShadowed.prototype.onChange = function (ox, oy) {
            this._parent.onSizeChange();
        };
        return EShapeGroupSizeShadowed;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupShadowed = /** @class */ (function (_super) {
        __extends(EShapeGroupShadowed, _super);
        function EShapeGroupShadowed(type) {
            if (type === void 0) { type = EShapeType.GROUP_SHADOWED; }
            return _super.call(this, type) || this;
        }
        EShapeGroupShadowed.prototype.newGroupSize = function () {
            if (EShapeDefaults.IS_EDIT_MODE) {
                return new EShapeGroupSizeShadowed(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            }
            else {
                return _super.prototype.newGroupSize.call(this);
            }
        };
        return EShapeGroupShadowed;
    }(EShapeGroup));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeGroupShadowed = function (item, manager) {
        var shape = new EShapeGroupShadowed();
        var result = EShapeDeserializer.deserialize(item, manager, shape);
        shape.size.init();
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeGroupShadowed = function () {
        EShapeUploadeds[EShapeType.GROUP_SHADOWED] = createGroupUploaded;
        EShapeDeserializers[EShapeType.GROUP_SHADOWED] = deserializeGroupShadowed;
    };

    var RECTANGLE_VERTEX_COUNT = 18;
    var RECTANGLE_INDEX_COUNT = 12;
    var RECTANGLE_WORLD_SIZE = [0, 0, 0];
    var RECTANGLE_WORK_POINT = new pixi_js.Point();
    var buildRectangleClipping = function (clippings, voffset, worldSize) {
        var br = worldSize[0];
        var bri = 1 - br;
        var worldSizeX = worldSize[1];
        var worldSizeY = worldSize[2];
        if (worldSizeX < worldSizeY) {
            buildRectangleClippingVertical(0, 1, 0, bri, clippings, voffset);
        }
        else {
            buildRectangleClippingVertical(1, 0, bri, 0, clippings, voffset);
        }
    };
    var buildRectangleClippingVertical = function (cx, cy, cbx, cby, clippings, voffset) {
        var ic = voffset * 3;
        clippings[ic + 0] = cx;
        clippings[ic + 1] = cy;
        clippings[ic + 2] = 0;
        clippings[ic + 3] = cx;
        clippings[ic + 4] = cy;
        clippings[ic + 5] = 0;
        clippings[ic + 6] = cx;
        clippings[ic + 7] = cy;
        clippings[ic + 8] = 0;
        ic += 9;
        clippings[ic + 0] = cbx;
        clippings[ic + 1] = cby;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = cbx;
        clippings[ic + 1] = cby;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = cx;
        clippings[ic + 1] = cy;
        clippings[ic + 2] = 0;
        clippings[ic + 3] = cx;
        clippings[ic + 4] = cy;
        clippings[ic + 5] = 0;
        clippings[ic + 6] = cx;
        clippings[ic + 7] = cy;
        clippings[ic + 8] = 0;
        ic += 9;
        // --------------------------------
        clippings[ic + 0] = cy;
        clippings[ic + 1] = cx;
        clippings[ic + 2] = 0;
        clippings[ic + 3] = cy;
        clippings[ic + 4] = cx;
        clippings[ic + 5] = 0;
        clippings[ic + 6] = cy;
        clippings[ic + 7] = cx;
        clippings[ic + 8] = 0;
        clippings[ic + 9] = cy;
        clippings[ic + 10] = cx;
        clippings[ic + 11] = 0;
        ic += 12;
        clippings[ic + 0] = 0;
        clippings[ic + 1] = 0;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = 0;
        clippings[ic + 1] = 0;
        clippings[ic + 2] = 0;
        ic += 3;
        // --------------------------------
        clippings[ic + 0] = cy;
        clippings[ic + 1] = cx;
        clippings[ic + 2] = 0;
        clippings[ic + 3] = cy;
        clippings[ic + 4] = cx;
        clippings[ic + 5] = 0;
        clippings[ic + 6] = cy;
        clippings[ic + 7] = cx;
        clippings[ic + 8] = 0;
        clippings[ic + 9] = cy;
        clippings[ic + 10] = cx;
        clippings[ic + 11] = 0;
    };
    var buildRectangleIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3;
        indices[ii + 0] = voffset + 0;
        indices[ii + 1] = voffset + 1;
        indices[ii + 2] = voffset + 3;
        ii += 3;
        indices[ii + 0] = voffset + 1;
        indices[ii + 1] = voffset + 2;
        indices[ii + 2] = voffset + 3;
        ii += 3;
        indices[ii + 0] = voffset + 4;
        indices[ii + 1] = voffset + 6;
        indices[ii + 2] = voffset + 5;
        ii += 3;
        indices[ii + 0] = voffset + 4;
        indices[ii + 1] = voffset + 7;
        indices[ii + 2] = voffset + 6;
        ii += 3;
        // --------------------------------
        indices[ii + 0] = voffset + 8;
        indices[ii + 1] = voffset + 12;
        indices[ii + 2] = voffset + 9;
        ii += 3;
        indices[ii + 0] = voffset + 9;
        indices[ii + 1] = voffset + 12;
        indices[ii + 2] = voffset + 10;
        ii += 3;
        indices[ii + 0] = voffset + 10;
        indices[ii + 1] = voffset + 12;
        indices[ii + 2] = voffset + 13;
        ii += 3;
        indices[ii + 0] = voffset + 10;
        indices[ii + 1] = voffset + 13;
        indices[ii + 2] = voffset + 11;
        ii += 3;
        // --------------------------------
        indices[ii + 0] = voffset + 14;
        indices[ii + 1] = voffset + 15;
        indices[ii + 2] = voffset + 12;
        ii += 3;
        indices[ii + 0] = voffset + 12;
        indices[ii + 1] = voffset + 15;
        indices[ii + 2] = voffset + 16;
        ii += 3;
        indices[ii + 0] = voffset + 16;
        indices[ii + 1] = voffset + 13;
        indices[ii + 2] = voffset + 12;
        ii += 3;
        indices[ii + 0] = voffset + 13;
        indices[ii + 1] = voffset + 16;
        indices[ii + 2] = voffset + 17;
    };
    var buildRectangleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        // 0               1
        // |-------|-------|
        // |       |       |
        // |-------|-------|
        // |       |       |
        // |-------|-------|
        //                 2
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var work = RECTANGLE_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var bx0 = work.x;
        var by0 = work.y;
        work.set(originX + sx, originY - sy);
        internalTransform.apply(work, work);
        var bx1 = work.x;
        var by1 = work.y;
        work.set(originX + sx, originY + sy);
        internalTransform.apply(work, work);
        var bx2 = work.x;
        var by2 = work.y;
        var bx3 = bx0 + (bx2 - bx1);
        var by3 = by0 + (by2 - by1);
        var ax = toLength(bx0, by0, bx1, by1) * 0.5;
        var ay = toLength(bx1, by1, bx2, by2) * 0.5;
        worldSize[1] = ax;
        worldSize[2] = ay;
        if (ax <= ay) {
            var br = ax / ay;
            worldSize[0] = br;
            buildRectangleVertexVertical(br, bx0, by0, bx1, by1, bx2, by2, bx3, by3, vertices, voffset);
        }
        else {
            var br = ay / ax;
            worldSize[0] = br;
            buildRectangleVertexVertical(br, bx3, by3, bx0, by0, bx1, by1, bx2, by2, vertices, voffset);
        }
    };
    var buildRectangleVertexVertical = function (br, bx0, by0, bx1, by1, bx2, by2, bx3, by3, vertices, voffset, worldSize) {
        // 0       1       2
        // |-------|-------|
        // |       |       |
        // |-------3-------|
        // |       |       |
        // |-------4-------|
        // |       |       |
        // |-------|-------|
        // 5       6       7
        var x0 = bx0;
        var y0 = by0;
        var x1 = (bx0 + bx1) * 0.5;
        var y1 = (by0 + by1) * 0.5;
        var x2 = bx1;
        var y2 = by1;
        var xc = (bx0 + bx2) * 0.5;
        var yc = (by0 + by2) * 0.5;
        var x3 = x1 + br * (xc - x1);
        var y3 = y1 + br * (yc - y1);
        var x5 = bx3;
        var y5 = by3;
        var x6 = (bx3 + bx2) * 0.5;
        var y6 = (by3 + by2) * 0.5;
        var x7 = bx2;
        var y7 = by2;
        var x4 = x6 + br * (xc - x6);
        var y4 = y6 + br * (yc - y6);
        var iv = voffset << 1;
        vertices[iv + 0] = x0;
        vertices[iv + 1] = y0;
        vertices[iv + 2] = x1;
        vertices[iv + 3] = y1;
        vertices[iv + 4] = x2;
        vertices[iv + 5] = y2;
        iv += 6;
        vertices[iv + 0] = x3;
        vertices[iv + 1] = y3;
        iv += 2;
        vertices[iv + 0] = x4;
        vertices[iv + 1] = y4;
        iv += 2;
        vertices[iv + 0] = x5;
        vertices[iv + 1] = y5;
        vertices[iv + 2] = x6;
        vertices[iv + 3] = y6;
        vertices[iv + 4] = x7;
        vertices[iv + 5] = y7;
        iv += 6;
        // 8               14
        // |-------|-------|
        // |       |       |
        // 9-------12------15
        // |       |       |
        // 10------13------16
        // |       |       |
        // |-------|-------|
        // 11              17
        var xcl = (bx0 + bx3) * 0.5;
        var ycl = (by0 + by3) * 0.5;
        var x8 = bx0;
        var y8 = by0;
        var x9 = bx0 + br * (xcl - bx0);
        var y9 = by0 + br * (ycl - by0);
        var x10 = bx3 + br * (xcl - bx3);
        var y10 = by3 + br * (ycl - by3);
        var x11 = bx3;
        var y11 = by3;
        var x12 = x3;
        var y12 = y3;
        var x13 = x4;
        var y13 = y4;
        var xcr = (bx1 + bx2) * 0.5;
        var ycr = (by1 + by2) * 0.5;
        var x14 = bx1;
        var y14 = by1;
        var x15 = bx1 + br * (xcr - bx1);
        var y15 = by1 + br * (ycr - by1);
        var x16 = bx2 + br * (xcr - bx2);
        var y16 = by2 + br * (ycr - by2);
        var x17 = bx2;
        var y17 = by2;
        vertices[iv + 0] = x8;
        vertices[iv + 1] = y8;
        vertices[iv + 2] = x9;
        vertices[iv + 3] = y9;
        vertices[iv + 4] = x10;
        vertices[iv + 5] = y10;
        vertices[iv + 6] = x11;
        vertices[iv + 7] = y11;
        iv += 8;
        vertices[iv + 0] = x12;
        vertices[iv + 1] = y12;
        iv += 2;
        vertices[iv + 0] = x13;
        vertices[iv + 1] = y13;
        iv += 2;
        vertices[iv + 0] = x14;
        vertices[iv + 1] = y14;
        vertices[iv + 2] = x15;
        vertices[iv + 3] = y15;
        vertices[iv + 4] = x16;
        vertices[iv + 5] = y16;
        vertices[iv + 6] = x17;
        vertices[iv + 7] = y17;
    };
    var buildRectangleStep = function (voffset, steps, strokeWidth, strokeSide, antialiasWeight, worldSize) {
        var br = worldSize[0];
        var bri = 1 - br;
        var worldSizeX = worldSize[1];
        var worldSizeY = worldSize[2];
        toStep(worldSizeX, strokeWidth, antialiasWeight, STEP_VALUES);
        var swx = STEP_VALUES[0];
        var px0 = STEP_VALUES[1];
        var px1 = STEP_VALUES[2];
        toStep(worldSizeY, strokeWidth, antialiasWeight, STEP_VALUES);
        var swy = STEP_VALUES[0];
        var py0 = STEP_VALUES[1];
        var py1 = STEP_VALUES[2];
        var swt = swy;
        var pt0 = py0;
        if (!(strokeSide & EShapeStrokeSide.TOP)) {
            swt = 1;
            pt0 = py1;
        }
        var swr = swx;
        var pr0 = px0;
        if (!(strokeSide & EShapeStrokeSide.RIGHT)) {
            swr = 1;
            pr0 = px1;
        }
        var swb = swy;
        var pb0 = py0;
        if (!(strokeSide & EShapeStrokeSide.BOTTOM)) {
            swb = 1;
            pb0 = py1;
        }
        var swl = swx;
        var pl0 = px0;
        if (!(strokeSide & EShapeStrokeSide.LEFT)) {
            swl = 1;
            pl0 = px1;
        }
        var pc0 = 0.5 * (pl0 + pr0);
        var pm0 = 0.5 * (pt0 + pb0);
        if (worldSizeX < worldSizeY) {
            buildRectangleStepVertical(bri, swx, px0, px1, swy, py0, py1, swt, pt0, swr, pr0, swb, pb0, swl, pl0, pc0, pm0, voffset, steps);
        }
        else {
            buildRectangleStepHorizontal(bri, swx, px0, px1, swy, py0, py1, swt, pt0, swr, pr0, swb, pb0, swl, pl0, pc0, pm0, voffset, steps);
        }
    };
    var buildRectangleStepVertical = function (bri, swx, px0, px1, swy, py0, py1, swt, pt0, swr, pr0, swb, pb0, swl, pl0, pc0, pm0, voffset, steps) {
        var is = voffset * 6;
        // 0
        steps[is] = swl;
        steps[is + 1] = swt;
        steps[is + 2] = pl0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 1
        steps[is] = 0;
        steps[is + 1] = swt;
        steps[is + 2] = pc0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 2
        steps[is] = swr;
        steps[is + 1] = swt;
        steps[is + 2] = pr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 3
        steps[is] = 0;
        steps[is + 1] = bri * swt;
        steps[is + 2] = pc0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 4
        steps[is] = 0;
        steps[is + 1] = bri * swb;
        steps[is + 2] = pc0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 5
        steps[is] = swl;
        steps[is + 1] = swb;
        steps[is + 2] = pl0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 6
        steps[is] = 0;
        steps[is + 1] = swb;
        steps[is + 2] = pc0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 7
        steps[is] = swr;
        steps[is + 1] = swb;
        steps[is + 2] = pr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // ------------------------------
        // 8
        steps[is] = swl;
        steps[is + 1] = swt;
        steps[is + 2] = pl0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 9
        steps[is] = swl;
        steps[is + 1] = bri * swt;
        steps[is + 2] = pl0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 10
        steps[is] = swl;
        steps[is + 1] = bri * swb;
        steps[is + 2] = pl0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 11
        steps[is] = swl;
        steps[is + 1] = swb;
        steps[is + 2] = pl0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // ------------------------------
        // 12
        steps[is] = 0;
        steps[is + 1] = bri * swt;
        steps[is + 2] = pc0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 13
        steps[is] = 0;
        steps[is + 1] = bri * swb;
        steps[is + 2] = pc0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // ------------------------------
        // 14
        steps[is] = swr;
        steps[is + 1] = swt;
        steps[is + 2] = pr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 15
        steps[is] = swr;
        steps[is + 1] = bri * swt;
        steps[is + 2] = pr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 16
        steps[is] = swr;
        steps[is + 1] = bri * swb;
        steps[is + 2] = pr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 17
        steps[is] = swr;
        steps[is + 1] = swb;
        steps[is + 2] = pr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
    };
    var buildRectangleStepHorizontal = function (bri, swx, px0, px1, swy, py0, py1, swt, pt0, swr, pr0, swb, pb0, swl, pl0, pc0, pm0, voffset, steps) {
        var is = voffset * 6;
        // 0
        steps[is] = swl;
        steps[is + 1] = swb;
        steps[is + 2] = pl0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 1
        steps[is] = swl;
        steps[is + 1] = 0;
        steps[is + 2] = pl0;
        steps[is + 3] = pm0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 2
        steps[is] = swl;
        steps[is + 1] = swt;
        steps[is + 2] = pl0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 3
        steps[is] = bri * swl;
        steps[is + 1] = 0;
        steps[is + 2] = pl0;
        steps[is + 3] = pm0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 4
        steps[is] = bri * swr;
        steps[is + 1] = 0;
        steps[is + 2] = pr0;
        steps[is + 3] = pm0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 5
        steps[is] = swr;
        steps[is + 1] = swb;
        steps[is + 2] = pr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 6
        steps[is] = swr;
        steps[is + 1] = 0;
        steps[is + 2] = pr0;
        steps[is + 3] = pm0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 7
        steps[is] = swr;
        steps[is + 1] = swt;
        steps[is + 2] = pr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // ------------------------------
        // 8
        steps[is] = swl;
        steps[is + 1] = swb;
        steps[is + 2] = pl0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 9
        steps[is] = bri * swl;
        steps[is + 1] = swb;
        steps[is + 2] = pl0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 10
        steps[is] = bri * swr;
        steps[is + 1] = swb;
        steps[is + 2] = pr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 11
        steps[is] = swr;
        steps[is + 1] = swb;
        steps[is + 2] = pr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // ------------------------------
        // 12
        steps[is] = bri * swl;
        steps[is + 1] = 0;
        steps[is + 2] = pl0;
        steps[is + 3] = pm0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 13
        steps[is] = bri * swr;
        steps[is + 1] = 0;
        steps[is + 2] = pr0;
        steps[is + 3] = pm0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // ------------------------------
        // 14
        steps[is] = swl;
        steps[is + 1] = swt;
        steps[is + 2] = pl0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 15
        steps[is] = bri * swl;
        steps[is + 1] = swt;
        steps[is + 2] = pl0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 16
        steps[is] = bri * swr;
        steps[is + 1] = swt;
        steps[is + 2] = pr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // 17
        steps[is] = swr;
        steps[is + 1] = swt;
        steps[is + 2] = pr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
    };
    var buildRectangleUv = function (uvs, voffset, textureUvs, worldSize) {
        var br = worldSize[0];
        var bri = 1 - br;
        var worldSizeX = worldSize[1];
        var worldSizeY = worldSize[2];
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        if (worldSizeX < worldSizeY) {
            buildRectangleUvVertical(bri, x0, x1, x2, x3, y0, y1, y2, y3, uvs, voffset);
        }
        else {
            buildRectangleUvVertical(bri, x3, x0, x1, x2, y3, y0, y1, y2, uvs, voffset);
        }
    };
    var buildRectangleUvVertical = function (bri, x0, x1, x2, x3, y0, y1, y2, y3, uvs, voffset) {
        var x01 = 0.5 * (x0 + x1);
        var y01 = 0.5 * (y0 + y1);
        var x02 = 0.5 * (x0 + x2);
        var y02 = 0.5 * (y0 + y2);
        var x23 = 0.5 * (x2 + x3);
        var y23 = 0.5 * (y2 + y3);
        var x03 = 0.5 * (x0 + x3);
        var y03 = 0.5 * (y0 + y3);
        var x12 = 0.5 * (x1 + x2);
        var y12 = 0.5 * (y1 + y2);
        var xbu = x02 + bri * (x01 - x02);
        var ybu = y02 + bri * (y01 - y02);
        var xbb = x02 + bri * (x23 - x02);
        var ybb = y02 + bri * (y23 - y02);
        // UVs
        var iuv = voffset << 1;
        uvs[iuv + 0] = x0;
        uvs[iuv + 1] = y0;
        uvs[iuv + 2] = x01;
        uvs[iuv + 3] = y01;
        uvs[iuv + 4] = x1;
        uvs[iuv + 5] = y1;
        iuv += 6;
        uvs[iuv + 0] = xbu;
        uvs[iuv + 1] = ybu;
        iuv += 2;
        uvs[iuv + 0] = xbb;
        uvs[iuv + 1] = ybb;
        iuv += 2;
        uvs[iuv + 0] = x3;
        uvs[iuv + 1] = y3;
        uvs[iuv + 2] = x23;
        uvs[iuv + 3] = y23;
        uvs[iuv + 4] = x2;
        uvs[iuv + 5] = y2;
        iuv += 6;
        // ------------------------------
        uvs[iuv + 0] = x0;
        uvs[iuv + 1] = y0;
        uvs[iuv + 2] = x03 + bri * (x0 - x03);
        uvs[iuv + 3] = y03 + bri * (y0 - y03);
        uvs[iuv + 4] = x03 + bri * (x3 - x03);
        uvs[iuv + 5] = y03 + bri * (y3 - y03);
        uvs[iuv + 6] = x3;
        uvs[iuv + 7] = y3;
        iuv += 8;
        uvs[iuv + 0] = xbu;
        uvs[iuv + 1] = ybu;
        iuv += 2;
        uvs[iuv + 0] = xbb;
        uvs[iuv + 1] = ybb;
        iuv += 2;
        uvs[iuv + 0] = x1;
        uvs[iuv + 1] = y1;
        uvs[iuv + 2] = x12 + bri * (x1 - x12);
        uvs[iuv + 3] = y12 + bri * (y1 - y12);
        uvs[iuv + 4] = x12 + bri * (x2 - x12);
        uvs[iuv + 5] = y12 + bri * (y2 - y12);
        uvs[iuv + 6] = x2;
        uvs[iuv + 7] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangleUploaded = /** @class */ (function (_super) {
        __extends(EShapeRectangleUploaded, _super);
        function EShapeRectangleUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeRectangleUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeRectangleUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeRectangleUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var strokeSide = stroke.side;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth || this.strokeSide !== strokeSide);
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = (texture !== this.texture || textureTransformId !== this.textureTransformId);
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeSide = strokeSide;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isVertexChanged || isTransformChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Vertices
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, this.antialiasWeight, RECTANGLE_WORLD_SIZE);
                }
                // Clippings
                if (isVertexChanged) {
                    buffer.updateClippings();
                    buildRectangleClipping(buffer.clippings, voffset, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, this.toTextureUvs(texture), RECTANGLE_WORLD_SIZE);
                }
            }
        };
        return EShapeRectangleUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createRectangleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = RECTANGLE_VERTEX_COUNT + tvcount;
        var icount = RECTANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeRectangleUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangle = /** @class */ (function (_super) {
        __extends(EShapeRectangle, _super);
        function EShapeRectangle(type) {
            if (type === void 0) { type = EShapeType.RECTANGLE; }
            return _super.call(this, type) || this;
        }
        EShapeRectangle.prototype.clone = function () {
            return new EShapeRectangle().copy(this);
        };
        EShapeRectangle.prototype.containsAbs = function (x, y, ax, ay) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                var fill = this.fill;
                var stroke = this.stroke;
                if (fill.enable) {
                    return true;
                }
                else {
                    var strokeWidth = stroke.width;
                    var strokeSide = stroke.side;
                    if (stroke.enable && 0 < strokeWidth && strokeSide !== EShapeStrokeSide.NONE) {
                        var wx = Math.max(0.0, ax - strokeWidth);
                        var wy = Math.max(0.0, ay - strokeWidth);
                        if (!this.containsAbsBBox(x, y, wx, wy)) {
                            if (strokeSide === EShapeStrokeSide.ALL) {
                                return true;
                            }
                            else {
                                if (x <= -wx) {
                                    if (y <= -wy) {
                                        return (strokeSide & EShapeStrokeSide.TOP_OR_LEFT) !== 0;
                                    }
                                    else if (+wy <= y) {
                                        return (strokeSide & EShapeStrokeSide.BOTTOM_OR_LEFT) !== 0;
                                    }
                                    else {
                                        return (strokeSide & EShapeStrokeSide.LEFT) !== 0;
                                    }
                                }
                                else if (+wx <= x) {
                                    if (y <= -wy) {
                                        return (strokeSide & EShapeStrokeSide.TOP_OR_RIGHT) !== 0;
                                    }
                                    else if (+wy <= y) {
                                        return (strokeSide & EShapeStrokeSide.BOTTOM_OR_RIGHT) !== 0;
                                    }
                                    else {
                                        return (strokeSide & EShapeStrokeSide.RIGHT) !== 0;
                                    }
                                }
                                else {
                                    if (y <= -wy) {
                                        return (strokeSide & EShapeStrokeSide.TOP) !== 0;
                                    }
                                    else if (+wy <= y) {
                                        return (strokeSide & EShapeStrokeSide.BOTTOM) !== 0;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        };
        return EShapeRectangle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeImage = /** @class */ (function (_super) {
        __extends(EShapeImage, _super);
        function EShapeImage(image, type) {
            if (type === void 0) { type = EShapeType.IMAGE; }
            var _this = _super.call(this, type) || this;
            if (image != null) {
                _this.image = image;
                _this.size.set(image.width, image.height);
            }
            _this.fill.alpha = 1.0;
            return _this;
        }
        EShapeImage.prototype.clone = function () {
            return new EShapeImage(this.image).copy(this);
        };
        return EShapeImage;
    }(EShapeRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeImage = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeImage());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeImage = function () {
        EShapeUploadeds[EShapeType.IMAGE] = createRectangleUploaded;
        EShapeDeserializers[EShapeType.IMAGE] = deserializeImage;
    };

    var IMAGE_SDF_VERTEX_COUNT = 9;
    var IMAGE_SDF_INDEX_COUNT = 8;
    var IMAGE_SDF_WORLD_SIZE = [0, 0];
    var IMAGE_SDF_FMIN = 0.00001;
    var IMAGE_SDF_SDF_WINDOW = 12;
    var IMAGE_SDF_WORK_POINT = new pixi_js.Point();
    var buildImageSdfClipping = function (clippings, voffset) {
        for (var ic = voffset * 3, imax = (voffset + IMAGE_SDF_VERTEX_COUNT) * 3; ic < imax; ic += 3) {
            clippings[ic + 0] = 0;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 2;
        }
    };
    var buildImageSdfIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3;
        indices[ii + 0] = voffset + 0;
        indices[ii + 1] = voffset + 1;
        indices[ii + 2] = voffset + 3;
        indices[ii + 3] = voffset + 1;
        indices[ii + 4] = voffset + 4;
        indices[ii + 5] = voffset + 3;
        ii += 6;
        indices[ii + 0] = voffset + 1;
        indices[ii + 1] = voffset + 2;
        indices[ii + 2] = voffset + 4;
        indices[ii + 3] = voffset + 2;
        indices[ii + 4] = voffset + 5;
        indices[ii + 5] = voffset + 4;
        ii += 6;
        indices[ii + 0] = voffset + 3;
        indices[ii + 1] = voffset + 4;
        indices[ii + 2] = voffset + 6;
        indices[ii + 3] = voffset + 4;
        indices[ii + 4] = voffset + 7;
        indices[ii + 5] = voffset + 6;
        ii += 6;
        indices[ii + 0] = voffset + 4;
        indices[ii + 1] = voffset + 5;
        indices[ii + 2] = voffset + 7;
        indices[ii + 3] = voffset + 5;
        indices[ii + 4] = voffset + 8;
        indices[ii + 5] = voffset + 7;
    };
    var buildImageSdfStep = function (steps, voffset, strokeAlign, strokeWidth, textureWidth, textureHeight, antialiasWeight, worldSize) {
        var scaleBase = (0.333 / IMAGE_SDF_SDF_WINDOW) * antialiasWeight;
        var scaleX = scaleBase * (textureWidth / worldSize[0]);
        var scaleY = scaleBase * (textureHeight / worldSize[1]);
        var scaleZ = (scaleX + scaleY) * 0.5;
        var outlineLimit = 0.4;
        var strokeWidthMax = (outlineLimit / 0.5) * IMAGE_SDF_SDF_WINDOW;
        var strokeWidthRatio = Math.max(0.0, Math.min(1.0, strokeWidth / strokeWidthMax));
        var outlineWidth = strokeWidthRatio * outlineLimit;
        var outlinePosition = -outlineWidth * (1 - strokeAlign);
        var is = voffset * 6;
        steps[is + 0] = scaleZ;
        steps[is + 1] = outlineWidth;
        steps[is + 2] = outlinePosition;
        steps[is + 3] = IMAGE_SDF_FMIN;
        steps[is + 4] = IMAGE_SDF_FMIN;
        steps[is + 5] = IMAGE_SDF_FMIN;
        is += 6;
        steps[is + 0] = scaleY;
        steps[is + 1] = outlineWidth;
        steps[is + 2] = outlinePosition;
        steps[is + 3] = IMAGE_SDF_FMIN;
        steps[is + 4] = IMAGE_SDF_FMIN;
        steps[is + 5] = IMAGE_SDF_FMIN;
        is += 6;
        steps[is + 0] = scaleZ;
        steps[is + 1] = outlineWidth;
        steps[is + 2] = outlinePosition;
        steps[is + 3] = IMAGE_SDF_FMIN;
        steps[is + 4] = IMAGE_SDF_FMIN;
        steps[is + 5] = IMAGE_SDF_FMIN;
        is += 6;
        steps[is + 0] = scaleX;
        steps[is + 1] = outlineWidth;
        steps[is + 2] = outlinePosition;
        steps[is + 3] = IMAGE_SDF_FMIN;
        steps[is + 4] = IMAGE_SDF_FMIN;
        steps[is + 5] = IMAGE_SDF_FMIN;
        is += 6;
        steps[is + 0] = scaleZ;
        steps[is + 1] = outlineWidth;
        steps[is + 2] = outlinePosition;
        steps[is + 3] = IMAGE_SDF_FMIN;
        steps[is + 4] = IMAGE_SDF_FMIN;
        steps[is + 5] = IMAGE_SDF_FMIN;
        is += 6;
        steps[is + 0] = scaleX;
        steps[is + 1] = outlineWidth;
        steps[is + 2] = outlinePosition;
        steps[is + 3] = IMAGE_SDF_FMIN;
        steps[is + 4] = IMAGE_SDF_FMIN;
        steps[is + 5] = IMAGE_SDF_FMIN;
        is += 6;
        steps[is + 0] = scaleZ;
        steps[is + 1] = outlineWidth;
        steps[is + 2] = outlinePosition;
        steps[is + 3] = IMAGE_SDF_FMIN;
        steps[is + 4] = IMAGE_SDF_FMIN;
        steps[is + 5] = IMAGE_SDF_FMIN;
        is += 6;
        steps[is + 0] = scaleY;
        steps[is + 1] = outlineWidth;
        steps[is + 2] = outlinePosition;
        steps[is + 3] = IMAGE_SDF_FMIN;
        steps[is + 4] = IMAGE_SDF_FMIN;
        steps[is + 5] = IMAGE_SDF_FMIN;
        is += 6;
        steps[is + 0] = scaleY;
        steps[is + 1] = outlineWidth;
        steps[is + 2] = outlinePosition;
        steps[is + 3] = IMAGE_SDF_FMIN;
        steps[is + 4] = IMAGE_SDF_FMIN;
        steps[is + 5] = IMAGE_SDF_FMIN;
        is += 6;
    };
    var buildImageSdfVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        // 0       1       2
        // |-------|-------|
        // |       |       |
        // 3-------4-------5
        // |       |       |
        // |-------|-------|
        // 6       7       8
        //
        var work = IMAGE_SDF_WORK_POINT;
        var sx = sizeX * 0.5;
        var sy = sizeY * 0.5;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX + sx, originY - sy);
        internalTransform.apply(work, work);
        var x2 = work.x;
        var y2 = work.y;
        work.set(originX + sx, originY + sy);
        internalTransform.apply(work, work);
        var x8 = work.x;
        var y8 = work.y;
        var x6 = x0 + (x8 - x2);
        var y6 = y0 + (y8 - y2);
        // Vertices
        var iv = voffset << 1;
        vertices[iv + 0] = x0;
        vertices[iv + 1] = y0;
        vertices[iv + 2] = (x0 + x2) * 0.5;
        vertices[iv + 3] = (y0 + y2) * 0.5;
        vertices[iv + 4] = x2;
        vertices[iv + 5] = y2;
        iv += 6;
        vertices[iv + 0] = (x0 + x6) * 0.5;
        vertices[iv + 1] = (y0 + y6) * 0.5;
        vertices[iv + 2] = (x0 + x8) * 0.5;
        vertices[iv + 3] = (y0 + y8) * 0.5;
        vertices[iv + 4] = (x2 + x8) * 0.5;
        vertices[iv + 5] = (y2 + y8) * 0.5;
        iv += 6;
        vertices[iv + 0] = x6;
        vertices[iv + 1] = y6;
        vertices[iv + 2] = (x6 + x8) * 0.5;
        vertices[iv + 3] = (y6 + y8) * 0.5;
        vertices[iv + 4] = x8;
        vertices[iv + 5] = y8;
        worldSize[0] = toLength(x0, y0, x2, y2) * 0.5;
        worldSize[1] = toLength(x0, y0, x6, y6) * 0.5;
    };
    var buildImageSdfUv = function (uvs, voffset, textureUv) {
        var x0 = textureUv.x0;
        var y0 = textureUv.y0;
        var x1 = textureUv.x1;
        var y1 = textureUv.y1;
        var x2 = textureUv.x2;
        var y2 = textureUv.y2;
        var x3 = textureUv.x3;
        var y3 = textureUv.y3;
        var iv = voffset << 1;
        uvs[iv + 0] = x0;
        uvs[iv + 1] = y0;
        uvs[iv + 2] = (x1 + x0) * 0.5;
        uvs[iv + 3] = (y1 + y0) * 0.5;
        uvs[iv + 4] = x1;
        uvs[iv + 5] = y1;
        iv += 6;
        uvs[iv + 0] = (x0 + x3) * 0.5;
        uvs[iv + 1] = (y0 + y3) * 0.5;
        uvs[iv + 2] = (x0 + x2) * 0.5;
        uvs[iv + 3] = (y0 + y2) * 0.5;
        uvs[iv + 4] = (x1 + x2) * 0.5;
        uvs[iv + 5] = (y1 + y2) * 0.5;
        iv += 6;
        uvs[iv + 0] = x3;
        uvs[iv + 1] = y3;
        uvs[iv + 2] = (x3 + x2) * 0.5;
        uvs[iv + 3] = (y3 + y2) * 0.5;
        uvs[iv + 4] = x2;
        uvs[iv + 5] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeImageSdfUploaded = /** @class */ (function (_super) {
        __extends(EShapeImageSdfUploaded, _super);
        function EShapeImageSdfUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) {
            var _this = _super.call(this, buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) || this;
            _this.textureWidth = -1;
            _this.textureHeight = -1;
            return _this;
        }
        EShapeImageSdfUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Clippings & indices
            var buffer = this.buffer;
            var voffset = this.vertexOffset;
            buffer.updateClippings();
            buffer.updateIndices();
            buildImageSdfClipping(buffer.clippings, voffset);
            buildImageSdfIndex(buffer.indices, voffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeImageSdfUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeImageSdfUploaded.prototype.updateVertexAndStep = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign || this.strokeWidth !== strokeWidth);
            var texture = this.toTexture(shape);
            var textureWidth = texture.width * texture.resolution;
            var textureHeight = texture.height * texture.resolution;
            var isTextureSizeChanged = (this.textureWidth !== textureWidth || this.textureHeight !== textureHeight);
            if (isSizeChanged || isTransformChanged || isStrokeChanged || isTextureSizeChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.textureWidth = textureWidth;
                this.textureHeight = textureHeight;
                // Invalidate the text layout to update the text layout.
                this.textSpacingHorizontal = NaN;
                // Vertices
                buffer.updateVertices();
                buildImageSdfVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, shape.transform.internalTransform, IMAGE_SDF_WORLD_SIZE);
                // Steps
                buffer.updateSteps();
                buildImageSdfStep(buffer.steps, this.vertexOffset, strokeAlign, strokeWidth, textureWidth, textureHeight, this.antialiasWeight, IMAGE_SDF_WORLD_SIZE);
            }
        };
        EShapeImageSdfUploaded.prototype.updateUv = function (buffer, shape) {
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildImageSdfUv(buffer.uvs, this.vertexOffset, this.toTextureUvs(texture));
            }
        };
        return EShapeImageSdfUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImageSdfUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = IMAGE_SDF_VERTEX_COUNT + tvcount;
        var icount = IMAGE_SDF_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeImageSdfUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeImageSdf = /** @class */ (function (_super) {
        __extends(EShapeImageSdf, _super);
        function EShapeImageSdf(image, type) {
            if (type === void 0) { type = EShapeType.IMAGE_SDF; }
            return _super.call(this, image, type) || this;
        }
        EShapeImageSdf.prototype.clone = function () {
            return new EShapeImageSdf(this.image).copy(this);
        };
        return EShapeImageSdf;
    }(EShapeImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeImageSdf = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeImageSdf());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeImageSdf = function () {
        EShapeUploadeds[EShapeType.IMAGE_SDF] = createImageSdfUploaded;
        EShapeDeserializers[EShapeType.IMAGE_SDF] = deserializeImageSdf;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLabelUploaded = /** @class */ (function (_super) {
        __extends(EShapeLabelUploaded, _super);
        function EShapeLabelUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLabelUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLabelUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateLabelVertex(buffer, shape);
            this.updateLabelUv(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeLabelUploaded.prototype.updateLabelVertex = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            if (isSizeChanged || isTransformChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                // Invalidate the text layout to update the text layout.
                this.textSpacingHorizontal = NaN;
            }
        };
        EShapeLabelUploaded.prototype.updateLabelUv = function (buffer, shape) {
            this.texture = this.toTexture(shape);
        };
        return EShapeLabelUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLabelUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = tvcount;
        var icount = ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeLabelUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLabel = /** @class */ (function (_super) {
        __extends(EShapeLabel, _super);
        function EShapeLabel(type) {
            if (type === void 0) { type = EShapeType.LABEL; }
            return _super.call(this, type) || this;
        }
        EShapeLabel.prototype.clone = function () {
            return new EShapeLabel().copy(this);
        };
        return EShapeLabel;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLabel = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLabel());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLabel = function () {
        EShapeUploadeds[EShapeType.LABEL] = createLabelUploaded;
        EShapeDeserializers[EShapeType.LABEL] = deserializeLabel;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toIndexOf = function (array, value) {
        var i0 = 0;
        var i1 = array.length - 1;
        while (i0 <= i1) {
            var i2 = i0 + ((i1 - i0) >> 1);
            var v2 = array[i2];
            if (value < v2) {
                i1 = i2 - 1;
            }
            else if (v2 < value) {
                i0 = i2 + 1;
            }
            else {
                return i2;
            }
        }
        return -1;
    };

    var LINE_FMIN = 0.00001;
    var LINE_WORK_POINT = new pixi_js.Point();
    var toLineVertexCount = function (pointCount) {
        return (Math.ceil(pointCount / 12) * 12) * 4 + 2;
    };
    var buildLineClipping = function (clippings, voffset, vcount, pointCount, pointsClosed) {
        var ic = voffset * 3;
        if (2 <= pointCount) {
            // First
            if (!pointsClosed) {
                clippings[ic + 0] = 1;
                clippings[ic + 1] = 0;
                clippings[ic + 2] = 3;
                clippings[ic + 3] = 0;
                clippings[ic + 4] = 1;
                clippings[ic + 5] = 5;
                ic += 6;
            }
            // Middle
            for (var i = (pointsClosed ? 0 : 1), imax = pointCount - i; i < imax; ++i) {
                clippings[ic + 0] = 1;
                clippings[ic + 1] = 0;
                clippings[ic + 2] = 3;
                clippings[ic + 3] = 0;
                clippings[ic + 4] = 1;
                clippings[ic + 5] = 5;
                clippings[ic + 6] = 1;
                clippings[ic + 7] = 0;
                clippings[ic + 8] = 4;
                clippings[ic + 9] = 0;
                clippings[ic + 10] = 1;
                clippings[ic + 11] = 6;
                ic += 12;
            }
            // Last
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 3;
            clippings[ic + 3] = 0;
            clippings[ic + 4] = 1;
            clippings[ic + 5] = 5;
            ic += 6;
        }
        // Fill the rest
        for (var icmax = (voffset + vcount) * 3; ic < icmax; ic += 3) {
            clippings[ic + 0] = 0;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 0;
        }
    };
    var buildLineIndex = function (indices, voffset, ioffset, icount) {
        for (var ii = ioffset * 3, iimax = (ioffset + icount) * 3, io = voffset; ii < iimax; ii += 6, io += 2) {
            indices[ii + 0] = io + 0;
            indices[ii + 1] = io + 2;
            indices[ii + 2] = io + 1;
            indices[ii + 3] = io + 1;
            indices[ii + 4] = io + 2;
            indices[ii + 5] = io + 3;
        }
    };
    var buildLineUv = function (uvs, colorFills, voffset, vcount, pointCount, pointsClosed, textureUvs, length) {
        var iuv = voffset << 1;
        if (2 <= pointCount) {
            var x0 = textureUvs.x0;
            var x1 = textureUvs.x1;
            var x2 = textureUvs.x2;
            var x3 = textureUvs.x3;
            var y0 = textureUvs.y0;
            var y1 = textureUvs.y1;
            var y2 = textureUvs.y2;
            var y3 = textureUvs.y3;
            var dx01 = x1 - x0;
            var dy01 = y1 - y0;
            var dx32 = x2 - x3;
            var dy32 = y2 - y3;
            // Uvs
            var icf = voffset << 2;
            var lengthInverse = 1 / Math.max(LINE_FMIN, length);
            var r = 0;
            // UV: First
            if (!pointsClosed) {
                r = colorFills[icf] * lengthInverse;
                uvs[iuv + 0] = x0 + r * dx01;
                uvs[iuv + 1] = y0 + r * dy01;
                uvs[iuv + 2] = x3 + r * dx32;
                uvs[iuv + 3] = y3 + r * dy32;
                iuv += 4;
                icf += 8;
            }
            // UV: Middle
            for (var i = (pointsClosed ? 0 : 1), imax = pointCount - i; i < imax; ++i) {
                r = colorFills[icf] * lengthInverse;
                uvs[iuv + 0] = x0 + r * dx01;
                uvs[iuv + 1] = y0 + r * dy01;
                uvs[iuv + 2] = x3 + r * dx32;
                uvs[iuv + 3] = y3 + r * dy32;
                iuv += 4;
                icf += 8;
                r = colorFills[icf] * lengthInverse;
                uvs[iuv + 0] = x0 + r * dx01;
                uvs[iuv + 1] = y0 + r * dy01;
                uvs[iuv + 2] = x3 + r * dx32;
                uvs[iuv + 3] = y3 + r * dy32;
                iuv += 4;
                icf += 8;
            }
            // UV: Last
            r = colorFills[icf] * lengthInverse;
            uvs[iuv + 0] = x0 + r * dx01;
            uvs[iuv + 1] = y0 + r * dy01;
            uvs[iuv + 2] = x3 + r * dx32;
            uvs[iuv + 3] = y3 + r * dy32;
            iuv += 4;
        }
        // Fill the rest
        for (var iuvmax = ((voffset + vcount) << 1); iuv < iuvmax; iuv += 2) {
            uvs[iuv + 0] = 0;
            uvs[iuv + 1] = 0;
        }
    };
    var buildLineVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, pointCount, pointsClosed, pointValues, pointSegments, pointsStyle, strokeWidth, internalTransform) {
        var iv = voffset << 1;
        var is = voffset * 6;
        var icf = voffset << 2;
        var lmax = 0;
        var px = 0;
        var py = 0;
        if (2 <= pointCount) {
            var scaleInvariant = toScaleInvariant(pointsStyle);
            //
            var l = 0;
            var lprev = 0;
            var lnext = 0;
            var llop = 0;
            var llo = 0;
            var pprevx = 0;
            var pprevy = 0;
            var pnextx = 0;
            var pnexty = 0;
            var pseg = false;
            var psegnext = false;
            var icfprev = icf;
            var loffset = 0;
            //
            var a = internalTransform.a;
            var b = internalTransform.b;
            var c = internalTransform.c;
            var d = internalTransform.d;
            var tx = internalTransform.tx;
            var ty = internalTransform.ty;
            // First point
            var pv0 = pointValues[0];
            var pv1 = pointValues[1];
            var pfirstx = a * pv0 + c * pv1 + tx;
            var pfirsty = b * pv0 + d * pv1 + ty;
            var psegfirst = (0 <= toIndexOf(pointSegments, 0));
            // Last point
            var lastIndex = (pointCount - 1) << 1;
            var pvl0 = pointValues[lastIndex + 0];
            var pvl1 = pointValues[lastIndex + 1];
            var plastx = a * pvl0 + c * pvl1 + tx;
            var plasty = b * pvl0 + d * pvl1 + ty;
            var pseglast = (0 <= toIndexOf(pointSegments, pointCount - 1));
            // Second point
            var psecondx = plastx;
            var psecondy = plasty;
            var psegsecond = pseglast;
            if (2 < pointCount) {
                var pv2 = pointValues[2];
                var pv3 = pointValues[3];
                psecondx = a * pv2 + c * pv3 + tx;
                psecondy = b * pv2 + d * pv3 + ty;
                psegsecond = (0 <= toIndexOf(pointSegments, 1));
            }
            // First segment
            if (pointsClosed) {
                px = plastx;
                py = plasty;
                pnextx = pfirstx;
                pnexty = pfirsty;
                pseg = pseglast;
                psegnext = psegfirst;
            }
            else {
                pprevx = pfirstx - (psecondx - pfirstx);
                pprevy = pfirsty - (psecondy - pfirsty);
                px = pfirstx;
                py = pfirsty;
                pnextx = psecondx;
                pnexty = psecondy;
                pseg = psegfirst;
                psegnext = psegsecond;
                lnext += toLength(px, py, pnextx, pnexty);
                //
                vertices[iv + 0] = px;
                vertices[iv + 1] = py;
                vertices[iv + 2] = px;
                vertices[iv + 3] = py;
                steps[is + 0] = strokeWidth;
                steps[is + 1] = scaleInvariant;
                steps[is + 2] = pprevx;
                steps[is + 3] = pprevy;
                steps[is + 4] = pnextx;
                steps[is + 5] = pnexty;
                steps[is + 6] = strokeWidth;
                steps[is + 7] = scaleInvariant;
                steps[is + 8] = pprevx;
                steps[is + 9] = pprevy;
                steps[is + 10] = pnextx;
                steps[is + 11] = pnexty;
                colorFills[icf + 0] = llo;
                colorFills[icf + 4] = llo;
                iv += 4;
                is += 12;
                icf += 8;
            }
            // Middle segments
            for (var i = (pointsClosed ? 0 : 1), imax = pointCount - i; i < imax; ++i) {
                pprevx = px;
                pprevy = py;
                px = pnextx;
                py = pnexty;
                pseg = psegnext;
                if (i === pointCount - 2) {
                    pnextx = plastx;
                    pnexty = plasty;
                    psegnext = pseglast;
                }
                else if (i === 0) {
                    pnextx = psecondx;
                    pnexty = psecondy;
                    psegnext = psegsecond;
                }
                else if (i < pointCount - 1) {
                    var nextIndex = (i + 1) << 1;
                    var pvn0 = pointValues[nextIndex + 0];
                    var pvn1 = pointValues[nextIndex + 1];
                    pnextx = a * pvn0 + c * pvn1 + tx;
                    pnexty = b * pvn0 + d * pvn1 + ty;
                    psegnext = (0 <= toIndexOf(pointSegments, i + 1));
                }
                else {
                    pnextx = pfirstx;
                    pnexty = pfirsty;
                    psegnext = psegfirst;
                }
                lprev = l;
                l = lnext;
                lnext += toLength(px, py, pnextx, pnexty);
                var pnextxn = pnextx;
                var pnextyn = pnexty;
                var loffsetprev = loffset;
                if (pseg) {
                    pprevx = px - (pnextx - px);
                    pprevy = py - (pnexty - py);
                    lmax = Math.max(lmax, llo);
                    llop = lprev - loffset;
                    var dash = toDash(llop, strokeWidth, pointsStyle, LINE_WORK_POINT);
                    var dash0 = dash.x;
                    var dash1 = dash.y;
                    for (var j = icfprev; j < icf + 8; j += 4) {
                        colorFills[j + 1] = dash0;
                        colorFills[j + 2] = dash1;
                        colorFills[j + 3] = llop;
                    }
                    icfprev = icf + 8;
                    loffsetprev = loffset;
                    loffset = l;
                }
                else if (psegnext) {
                    pnextxn = px + (px - pprevx);
                    pnextyn = py + (py - pprevy);
                }
                // Vertices
                vertices[iv + 0] = px;
                vertices[iv + 1] = py;
                vertices[iv + 2] = px;
                vertices[iv + 3] = py;
                steps[is + 0] = strokeWidth;
                steps[is + 1] = scaleInvariant;
                steps[is + 2] = pprevx;
                steps[is + 3] = pprevy;
                steps[is + 4] = pnextxn;
                steps[is + 5] = pnextyn;
                steps[is + 6] = strokeWidth;
                steps[is + 7] = scaleInvariant;
                steps[is + 8] = pprevx;
                steps[is + 9] = pprevy;
                steps[is + 10] = pnextxn;
                steps[is + 11] = pnextyn;
                llop = l - loffsetprev;
                colorFills[icf + 0] = llop;
                colorFills[icf + 4] = llop;
                iv += 4;
                is += 12;
                icf += 8;
                vertices[iv + 0] = px;
                vertices[iv + 1] = py;
                vertices[iv + 2] = px;
                vertices[iv + 3] = py;
                steps[is + 0] = strokeWidth;
                steps[is + 1] = scaleInvariant;
                steps[is + 2] = pprevx;
                steps[is + 3] = pprevy;
                steps[is + 4] = pnextxn;
                steps[is + 5] = pnextyn;
                steps[is + 6] = strokeWidth;
                steps[is + 7] = scaleInvariant;
                steps[is + 8] = pprevx;
                steps[is + 9] = pprevy;
                steps[is + 10] = pnextxn;
                steps[is + 11] = pnextyn;
                llo = l - loffset;
                colorFills[icf + 0] = llo;
                colorFills[icf + 4] = llo;
                iv += 4;
                is += 12;
                icf += 8;
            }
            // Last segment
            {
                pprevx = px;
                pprevy = py;
                px = pnextx;
                py = pnexty;
                pseg = psegnext;
                if (pointsClosed) {
                    pnextx = psecondx;
                    pnexty = psecondy;
                    psegnext = psegsecond;
                }
                else {
                    pnextx = px + (px - pprevx);
                    pnexty = py + (py - pprevy);
                    psegnext = false;
                }
                lprev = l;
                l = lnext;
                var pnextxn = pnextx;
                var pnextyn = pnexty;
                var loffsetprev = loffset;
                if (pseg) {
                    pprevx = px - (pnextx - px);
                    pprevy = py - (pnexty - py);
                    lmax = Math.max(lmax, llo);
                    llop = lprev - loffset;
                    var dash = toDash(llop, strokeWidth, pointsStyle, LINE_WORK_POINT);
                    var dash0 = dash.x;
                    var dash1 = dash.y;
                    for (var j = icfprev; j < icf + 8; j += 4) {
                        colorFills[j + 1] = dash0;
                        colorFills[j + 2] = dash1;
                        colorFills[j + 3] = llop;
                    }
                    icfprev = icf + 8;
                    loffsetprev = loffset;
                    loffset = l;
                }
                else if (psegnext) {
                    pnextxn = px + (px - pprevx);
                    pnextyn = py + (py - pprevy);
                }
                // Vertices
                vertices[iv + 0] = px;
                vertices[iv + 1] = py;
                vertices[iv + 2] = px;
                vertices[iv + 3] = py;
                steps[is + 0] = strokeWidth;
                steps[is + 1] = scaleInvariant;
                steps[is + 2] = pprevx;
                steps[is + 3] = pprevy;
                steps[is + 4] = pnextxn;
                steps[is + 5] = pnextyn;
                steps[is + 6] = strokeWidth;
                steps[is + 7] = scaleInvariant;
                steps[is + 8] = pprevx;
                steps[is + 9] = pprevy;
                steps[is + 10] = pnextxn;
                steps[is + 11] = pnextyn;
                llop = l - loffsetprev;
                lmax = Math.max(lmax, llop);
                colorFills[icf + 0] = llop;
                colorFills[icf + 4] = llop;
                iv += 4;
                is += 12;
                icf += 8;
                // Total length
                if (icfprev < icf) {
                    var dash = toDash(llop, strokeWidth, pointsStyle, LINE_WORK_POINT);
                    var dash0 = dash.x;
                    var dash1 = dash.y;
                    if (pointsClosed) {
                        for (var i = icfprev; i < icf; i += 4) {
                            colorFills[i + 1] = dash0;
                            colorFills[i + 2] = dash1;
                            colorFills[i + 3] = -1;
                        }
                    }
                    else {
                        for (var i = icfprev; i < icf; i += 4) {
                            colorFills[i + 1] = dash0;
                            colorFills[i + 2] = dash1;
                            colorFills[i + 3] = llop;
                        }
                    }
                }
            }
        }
        // Fill the rest
        for (var ivmax = ((voffset + vcount) << 1); iv < ivmax; iv += 2, is += 6, icf += 4) {
            vertices[iv + 0] = px;
            vertices[iv + 1] = py;
            steps[is + 0] = 0;
            steps[is + 1] = 0;
            steps[is + 2] = 0;
            steps[is + 3] = 0;
            steps[is + 4] = 0;
            steps[is + 5] = 0;
            colorFills[icf + 0] = 0;
            colorFills[icf + 1] = 0;
            colorFills[icf + 2] = 0;
            colorFills[icf + 4] = 0;
        }
        return lmax;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineUploaded, _super);
        function EShapeLineUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) {
            var _this = _super.call(this, buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) || this;
            _this.pointId = -1;
            _this.pointCount = 0;
            _this.pointsClosed = false;
            _this.length = 1;
            return _this;
        }
        EShapeLineUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Clipping & indices
            var buffer = this.buffer;
            buffer.updateIndices();
            buildLineIndex(buffer.indices, this.vertexOffset, this.indexOffset, this.indexCount - this.textIndexCount);
            // Text
            this.initText();
            //
            this.update(shape);
            return this;
        };
        EShapeLineUploaded.prototype.isCompatible = function (shape) {
            if (_super.prototype.isCompatible.call(this, shape)) {
                var points = shape.points;
                var vcount = toLineVertexCount(points ? points.length : 0);
                return vcount === this.vertexCount - this.textVertexCount;
            }
            return false;
        };
        EShapeLineUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateLineClipping(buffer, shape);
            this.updateLineVertexStepAndColorFill(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateLineUv(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeLineUploaded.prototype.updateLineClipping = function (buffer, shape) {
            var points = shape.points;
            if (points) {
                var pointCount = points.length;
                var pointsClosed = (!!(points.style & EShapePointsStyle.CLOSED));
                if (this.pointCount !== pointCount || this.pointsClosed !== pointsClosed) {
                    this.pointCount = pointCount;
                    this.pointsClosed = pointsClosed;
                    // Invalidate the pointId to update the vertices
                    this.pointId = -1;
                    buffer.updateClippings();
                    buildLineClipping(buffer.clippings, this.vertexOffset, this.vertexCount - this.textVertexCount, pointCount, pointsClosed);
                }
            }
        };
        EShapeLineUploaded.prototype.updateLineVertexStepAndColorFill = function (buffer, shape) {
            var points = shape.points;
            if (points) {
                var pointId = points.id;
                var isPointChanged = (pointId !== this.pointId);
                var stroke = shape.stroke;
                var strokeWidth = (stroke.enable ? stroke.width : 0);
                var isStrokeWidthChanged = (strokeWidth !== this.strokeWidth);
                var transformLocalId = this.toTransformLocalId(shape);
                var isTransformChanged = (this.transformLocalId !== transformLocalId);
                if (isPointChanged || isTransformChanged || isStrokeWidthChanged) {
                    this.pointId = pointId;
                    this.strokeWidth = strokeWidth;
                    this.transformLocalId = transformLocalId;
                    if (isPointChanged || isTransformChanged) {
                        // Invalidate the text layout to update the text layout.
                        this.textSpacingHorizontal = NaN;
                    }
                    if (isPointChanged) {
                        // Invalidate the texture transform ID to update the UVs
                        this.textureTransformId = NaN;
                    }
                    buffer.updateVertices();
                    buffer.updateSteps();
                    buffer.updateColorFills();
                    this.length = buildLineVertexStepAndColorFill(buffer.vertices, buffer.steps, buffer.colorFills, this.vertexOffset, this.vertexCount - this.textVertexCount, this.pointCount, this.pointsClosed, points.values, points.segments, points.style, strokeWidth, shape.transform.internalTransform);
                }
            }
        };
        EShapeLineUploaded.prototype.updateColorFillAndStroke = function (buffer, shape, vertexCount) {
            this.updateColorStroke(buffer, shape, vertexCount);
        };
        EShapeLineUploaded.prototype.updateLineUv = function (buffer, shape) {
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                var pointCount = this.pointCount;
                buffer.updateUvs();
                buildLineUv(buffer.uvs, buffer.colorFills, this.vertexOffset, this.vertexCount - this.textVertexCount, pointCount, this.pointsClosed, this.toTextureUvs(texture), this.length);
            }
        };
        return EShapeLineUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var points = shape.points;
        var pointCount = (points ? points.length : 0);
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = toLineVertexCount(pointCount) + tvcount;
        var icount = vcount - tvcount - 2 + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeLineUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLinePoints = /** @class */ (function () {
        function EShapeLinePoints(parent, points, segments, style) {
            // Calculate the center
            var values = [];
            var minX = 0;
            var maxX = 0;
            var minY = 0;
            var maxY = 0;
            var pointsLength = points.length;
            if (2 <= pointsLength) {
                minX = maxX = points[0];
                minY = maxY = points[1];
                for (var i = 2; i < pointsLength; i += 2) {
                    var x = points[i];
                    var y = points[i + 1];
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                }
            }
            var cx = (maxX + minX) * 0.5;
            var cy = (maxY + minY) * 0.5;
            for (var i = 0; i < pointsLength; i += 2) {
                var x = points[i + 0] - cx;
                var y = points[i + 1] - cy;
                values.push(x, y);
            }
            var sx = maxX - minX;
            var sy = maxY - minY;
            //
            this._parent = parent;
            this._valuesBase = undefined;
            this._valuesBaseLength = values.length;
            this._values = values;
            this._segments = segments.slice(0);
            this._sizeBase = new pixi_js.Point(sx, sy);
            this.size = new pixi_js.Point(sx, sy);
            this.position = new pixi_js.Point(cx, cy);
            this._id = 0;
            this._style = style;
        }
        Object.defineProperty(EShapeLinePoints.prototype, "length", {
            get: function () {
                return this._values.length >> 1;
            },
            enumerable: true,
            configurable: true
        });
        EShapeLinePoints.prototype.fitToParentSize = function () {
            var size = this.size;
            var parentSize = this._parent.size;
            var ssx = parentSize.x;
            var ssy = parentSize.y;
            var threshold = 0.00001;
            if (threshold < Math.abs(ssx - size.x) || threshold < Math.abs(ssy - size.y)) {
                size.set(ssx, ssy);
                var sizeBase = this._sizeBase;
                var hasSizeBaseX = threshold < Math.abs(sizeBase.x);
                var hasSizeBaseY = threshold < Math.abs(sizeBase.y);
                if (hasSizeBaseX || hasSizeBaseY) {
                    var scaleX = (hasSizeBaseX ? ssx / sizeBase.x : 1);
                    var scaleY = (hasSizeBaseY ? ssy / sizeBase.y : 1);
                    var values = this._values;
                    var valuesBase = this._valuesBase;
                    if (valuesBase == null) {
                        valuesBase = [];
                        this._valuesBase = valuesBase;
                        for (var i = 0, imax = this.length << 1; i < imax; i += 2) {
                            var x = values[i];
                            var y = values[i + 1];
                            values[i] = x * scaleX;
                            values[i + 1] = y * scaleY;
                            valuesBase.push(x, y);
                        }
                    }
                    else {
                        for (var i = 0, imax = this.length << 1; i < imax; i += 2) {
                            values[i] = valuesBase[i] * scaleX;
                            values[i + 1] = valuesBase[i + 1] * scaleY;
                        }
                    }
                    this._id += 1;
                }
            }
        };
        Object.defineProperty(EShapeLinePoints.prototype, "id", {
            get: function () {
                this.fitToParentSize();
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "values", {
            get: function () {
                this.fitToParentSize();
                return this._values;
            },
            set: function (values) {
                this.set(values, undefined, undefined);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            /**
             * Must be sorted in ascending order.
             */
            set: function (segments) {
                this.set(undefined, segments, undefined);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                this.set(undefined, undefined, style);
            },
            enumerable: true,
            configurable: true
        });
        EShapeLinePoints.prototype.copy = function (source) {
            return this.set(source.values, source.segments, source.style);
        };
        EShapeLinePoints.prototype.set = function (newValues, newSegments, newStyle) {
            var isDirty = false;
            var isUpdated = false;
            // Values
            if (newValues != null) {
                var values = this._values;
                var valuesBaseLength = this._valuesBaseLength;
                var newValuesLength = newValues.length;
                var iupdate = Math.min(newValuesLength, valuesBaseLength);
                this._valuesBase = undefined;
                if (values !== newValues) {
                    for (var i = 0; i < iupdate; ++i) {
                        values[i] = newValues[i];
                    }
                    for (var i = iupdate; i < newValuesLength; ++i) {
                        values.push(newValues[i]);
                    }
                    if (valuesBaseLength !== newValuesLength) {
                        values.length = newValuesLength;
                        this._valuesBaseLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
                else {
                    if (valuesBaseLength !== newValuesLength) {
                        this._valuesBaseLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
            }
            // Segments
            if (newSegments != null) {
                var segments = this._segments;
                if (segments !== newSegments) {
                    var newSegmentsLength = newSegments.length;
                    var iupdate = Math.min(segments.length, newSegmentsLength);
                    for (var i = 0; i < iupdate; ++i) {
                        segments[i] = newSegments[i];
                    }
                    for (var i = iupdate; i < newSegmentsLength; ++i) {
                        segments.push(newSegments[i]);
                    }
                    if (segments.length !== newSegmentsLength) {
                        segments.length = newSegmentsLength;
                    }
                }
                isUpdated = true;
            }
            // Style
            if (newStyle != null) {
                var oldStyle = this._style;
                if (oldStyle !== newStyle) {
                    this._style = newStyle;
                    isUpdated = true;
                }
            }
            //
            if (isDirty) {
                this._id += 1;
                var parent_1 = this._parent;
                var uploaded = parent_1.uploaded;
                if (uploaded) {
                    if (uploaded.isCompatible(parent_1)) {
                        parent_1.updateUploaded();
                    }
                    else {
                        parent_1.uploaded = undefined;
                        parent_1.toDirty();
                    }
                }
                else {
                    parent_1.updateUploaded();
                }
            }
            else if (isUpdated) {
                this._id += 1;
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeLinePoints.prototype.clone = function (parent) {
            return new EShapeLinePoints(parent, this._values, this._segments, this._style);
        };
        EShapeLinePoints.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeLinePoints.prototype.serialize = function (manager) {
            return manager.add("[" + JSON.stringify(this._values) + "," + JSON.stringify(this._segments) + "," + this._style + "]");
        };
        EShapeLinePoints.prototype.calcHitPointAbs = function (x, y, ax, ay, threshold, range, tester, result) {
            var pointCount = this.length;
            if (2 <= pointCount) {
                var pointValues = this._values;
                var pointSegments = this._segments;
                var istart = 0;
                var iend = pointCount;
                if (range) {
                    var rangeResult = range(x, y, threshold, pointValues, EShapeLinePoints.WORK_RANGE);
                    istart = rangeResult[0];
                    iend = rangeResult[1];
                }
                for (var i = istart, imax = Math.min(iend, pointCount - 1), iv = 2 * istart; i < imax; i += 1, iv += 2) {
                    if (toIndexOf(pointSegments, i + 1) < 0) {
                        var p0x = pointValues[iv + 0];
                        var p0y = pointValues[iv + 1];
                        var p1x = pointValues[iv + 2];
                        var p1y = pointValues[iv + 3];
                        if (tester(x, y, p0x, p0y, p1x, p1y, i, threshold, result)) {
                            return true;
                        }
                    }
                }
                if (2 < pointCount && pointCount <= iend && (this.style & EShapePointsStyle.CLOSED)) {
                    if (toIndexOf(pointSegments, 0) < 0) {
                        var i = pointCount - 1;
                        var iv = i << 1;
                        var p0x = pointValues[iv + 0];
                        var p0y = pointValues[iv + 1];
                        var p1x = pointValues[0];
                        var p1y = pointValues[1];
                        if (tester(x, y, p0x, p0y, p1x, p1y, i, threshold, result)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        EShapeLinePoints.WORK_RANGE = [0, 0];
        return EShapeLinePoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLine = /** @class */ (function (_super) {
        __extends(EShapeLine, _super);
        function EShapeLine(lineOrPoints, segments, width, style) {
            var _this = _super.call(this, EShapeType.LINE) || this;
            if (lineOrPoints instanceof EShapeLine) {
                _this.copy(lineOrPoints);
            }
            else {
                _this.fill.enable = false;
                _this.stroke.set(true, undefined, undefined, width);
                _this.points = new EShapeLinePoints(_this, lineOrPoints, segments, style);
                _this.transform.position.copyFrom(_this.points.position);
                _this.size.copyFrom(_this.points.size);
            }
            return _this;
        }
        EShapeLine.prototype.clone = function () {
            return new EShapeLine(this);
        };
        return EShapeLine;
    }(EShapeLineBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLine = function (item, manager) {
        var resources = manager.resources;
        var resourceId = item[15];
        if (0 <= resourceId && resourceId < resources.length) {
            var parsed = manager.extensions.get(resourceId);
            if (parsed == null) {
                parsed = JSON.parse(resources[resourceId]);
                manager.extensions.set(resourceId, parsed);
            }
            var shape = new EShapeLine(parsed[0], parsed[1], EShapeDefaults.STROKE_WIDTH, parsed[2]);
            return EShapeDeserializer.deserialize(item, manager, shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLine = function () {
        EShapeUploadeds[EShapeType.LINE] = createLineUploaded;
        EShapeDeserializers[EShapeType.LINE] = deserializeLine;
    };

    var toLineOfAnyPointCount = function (pointCount) {
        return (Math.ceil(pointCount / 12) * 12);
    };
    var buildLineOfAnyColor = function (voffset, vcountPerPoint, point, pointCount, colors, isEnabled, colorDef, alphaDef) {
        if (isEnabled) {
            if (point.isStaticColor()) {
                var color = point.getColor(0, colorDef);
                if (point.isStaticAlpha()) {
                    var alpha = point.getAlpha(0, alphaDef);
                    buildColor(color, alpha, voffset, vcountPerPoint * pointCount, colors);
                }
                else {
                    for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                        var alpha = point.getAlpha(i, alphaDef);
                        buildColor(color, alpha, iv, vcountPerPoint, colors);
                    }
                }
            }
            else {
                if (point.isStaticAlpha()) {
                    var alpha = point.getAlpha(0, alphaDef);
                    for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                        var color = point.getColor(i, colorDef);
                        buildColor(color, alpha, iv, vcountPerPoint, colors);
                    }
                }
                else {
                    for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                        var color = point.getColor(i, colorDef);
                        var alpha = point.getAlpha(i, alphaDef);
                        buildColor(color, alpha, iv, vcountPerPoint, colors);
                    }
                }
            }
        }
        else {
            if (point.isStaticColor()) {
                var color = point.getColor(0, colorDef);
                buildColor(color, 0, voffset, vcountPerPoint * pointCount, colors);
            }
            else {
                for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                    var color = point.getColor(i, colorDef);
                    buildColor(color, 0, iv, vcountPerPoint, colors);
                }
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfAnyUploaded = function (buffer, shape, voffset, vcountPerPoint, ioffset, icountPerPoint, antialiasWeight, constructor) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var points = shape.points;
        var pointCount = toLineOfAnyPointCount(points ? points.length : 0);
        var vcount = pointCount * vcountPerPoint + tvcount;
        var icount = pointCount * icountPerPoint + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new constructor(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight, pointCount).init(shape);
        }
        return null;
    };

    var buildNullClipping = function (clippings, voffset, vcount) {
        for (var i = voffset * 3, imax = (voffset + vcount) * 3; i < imax; i += 3) {
            clippings[i + 0] = 0;
            clippings[i + 1] = 0;
            clippings[i + 2] = 0;
        }
    };
    var buildNullIndex = function (indices, voffset, ioffset, icount) {
        for (var ii = ioffset * 3, iimax = (ioffset + icount) * 3; ii < iimax; ii += 3) {
            indices[ii + 0] = voffset;
            indices[ii + 1] = voffset;
            indices[ii + 2] = voffset;
        }
    };
    var buildNullVertex = function (vertices, voffset, vcount) {
        for (var i = voffset * 2, imax = (voffset + vcount) * 2; i < imax; i += 2) {
            vertices[i + 0] = 0;
            vertices[i + 1] = 0;
        }
    };
    var buildNullStep = function (steps, voffset, vcount) {
        for (var i = voffset * 6, imax = (voffset + vcount) * 6; i < imax; i += 6) {
            steps[i + 0] = 0;
            steps[i + 1] = 0;
            steps[i + 2] = 0;
            steps[i + 3] = 0;
            steps[i + 4] = 0;
            steps[i + 5] = 0;
        }
    };
    var buildNullUv = function (uvs, voffset, vcount) {
        for (var i = voffset * 2, imax = (voffset + vcount) * 2; i < imax; i += 2) {
            uvs[i + 0] = 0;
            uvs[i + 1] = 0;
        }
    };

    var copyClipping = function (clippings, voffset, vcountPerPoint, pointCount) {
        var iv = voffset + vcountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var icd = iv * 3;
            var ics = voffset * 3;
            for (var j = 0; j < vcountPerPoint; ++j) {
                clippings[icd + 0] = clippings[ics + 0];
                clippings[icd + 1] = clippings[ics + 1];
                clippings[icd + 2] = clippings[ics + 2];
                icd += 3;
                ics += 3;
            }
            iv += vcountPerPoint;
        }
    };

    var copyIndex = function (indices, vcountPerPoint, ioffset, icountPerPoint, pointCount) {
        var idiv = vcountPerPoint;
        var ii = ioffset + icountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var iid = ii * 3;
            var iis = ioffset * 3;
            for (var j = 0; j < icountPerPoint; ++j) {
                indices[iid + 0] = indices[iis + 0] + idiv;
                indices[iid + 1] = indices[iis + 1] + idiv;
                indices[iid + 2] = indices[iis + 2] + idiv;
                iid += 3;
                iis += 3;
            }
            idiv += vcountPerPoint;
            ii += icountPerPoint;
        }
    };

    var copyStep = function (steps, voffset, vcountPerPoint, pointCount) {
        var iss0 = voffset * 6;
        var isd = (voffset + vcountPerPoint) * 6;
        for (var i = 1; i < pointCount; ++i) {
            var iss = iss0;
            for (var j = 0; j < vcountPerPoint; ++j) {
                steps[isd + 0] = steps[iss + 0];
                steps[isd + 1] = steps[iss + 1];
                steps[isd + 2] = steps[iss + 2];
                steps[isd + 3] = steps[iss + 3];
                steps[isd + 4] = steps[iss + 4];
                steps[isd + 5] = steps[iss + 5];
                isd += 6;
                iss += 6;
            }
        }
    };

    var copyUvs = function (uvs, voffset, vcountPerPoint, pointCount) {
        var iv = voffset + vcountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var iuvd = iv << 1;
            var iuvs = voffset << 1;
            for (var j = 0; j < vcountPerPoint; ++j) {
                uvs[iuvd] = uvs[iuvs];
                uvs[iuvd + 1] = uvs[iuvs + 1];
                iuvd += 2;
                iuvs += 2;
            }
            iv += vcountPerPoint;
        }
    };

    var copyVertex = function (vertices, internalTransform, voffset, vcountPerPoint, pointCount, pointsValues, pointOffset) {
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var i = pointCount - 1;
        var iv = voffset + i * vcountPerPoint;
        if (pointOffset.isStaticX() && pointOffset.isStaticY()) {
            var ox = pointOffset.getX(0);
            var oy = pointOffset.getY(0);
            for (; 0 <= i; --i) {
                var ip = i << 1;
                var px = pointsValues[ip] + ox;
                var py = pointsValues[ip + 1] + oy;
                var dx = a * px + c * py;
                var dy = b * px + d * py;
                var ivd = iv << 1;
                var ivs = voffset << 1;
                for (var j = 0; j < vcountPerPoint; ++j) {
                    vertices[ivd] = vertices[ivs] + dx;
                    vertices[ivd + 1] = vertices[ivs + 1] + dy;
                    ivd += 2;
                    ivs += 2;
                }
                iv -= vcountPerPoint;
            }
        }
        else {
            for (; 0 <= i; --i) {
                var ip = i << 1;
                var px = pointsValues[ip] + pointOffset.getX(i);
                var py = pointsValues[ip + 1] + pointOffset.getY(i);
                var dx = a * px + c * py;
                var dy = b * px + d * py;
                var ivd = iv << 1;
                var ivs = voffset << 1;
                for (var j = 0; j < vcountPerPoint; ++j) {
                    vertices[ivd] = vertices[ivs] + dx;
                    vertices[ivd + 1] = vertices[ivs + 1] + dy;
                    ivd += 2;
                    ivs += 2;
                }
                iv -= vcountPerPoint;
            }
        }
    };

    var isStatic = function (value) {
        return isNumber(value) || value == null;
    };

    var toComputed = function (index, value, def) {
        if (isNumber(value)) {
            return value;
        }
        else if (isFunction(value)) {
            return value(index);
        }
        else if (value) {
            return value[index % value.length];
        }
        return def;
    };

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsFillImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsFillImpl(parent) {
            this._parent = parent;
            this._id = 0;
            this._color = null;
            this._alpha = null;
        }
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this.set(color, undefined);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                this.set(undefined, alpha);
            },
            enumerable: true,
            configurable: true
        });
        EShapeLineOfAnyPointsFillImpl.prototype.set = function (color, alpha) {
            var isChanged = false;
            if (color !== undefined && this._color !== color) {
                isChanged = true;
                this._color = color;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                isChanged = true;
                this._alpha = alpha;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsFillImpl.prototype.getColor = function (index, def) {
            return toComputed(index, this._color, def);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.getAlpha = function (index, def) {
            return toComputed(index, this._alpha, def);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.isStaticColor = function () {
            return isStatic(this._color);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.isStaticAlpha = function () {
            return isStatic(this._alpha);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsFillImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItem = /** @class */ (function () {
        function DynamicAtlasItem(id, width, height, strokeWidth, baseTexture) {
            this.id = id;
            this.ref = 0;
            var resolution = baseTexture.resolution;
            this.frame = new pixi_js.Rectangle(0, 0, width * resolution, height * resolution);
            this.texture = new pixi_js.Texture(baseTexture, new pixi_js.Rectangle(0, 0, 1, 1));
            this.width = width;
            this.height = height;
            this.strokeWidth = strokeWidth;
        }
        DynamicAtlasItem.prototype.applyFrame = function () {
            var resolutionInverse = 1 / this.texture.baseTexture.resolution;
            this.texture.frame.x = this.frame.x * resolutionInverse;
            this.texture.frame.y = this.frame.y * resolutionInverse;
            this.texture.frame.width = this.width;
            this.texture.frame.height = this.height;
            this.texture.updateUvs();
            this.texture.emit("update", this);
        };
        DynamicAtlasItem.prototype.destroy = function () {
            this.texture.destroy();
        };
        return DynamicAtlasItem;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemEmpty = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemEmpty, _super);
        function DynamicAtlasItemEmpty() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DynamicAtlasItemEmpty.prototype.render = function (context) {
            // DO NOTHING
        };
        return DynamicAtlasItemEmpty;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemFontAtlas = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemFontAtlas, _super);
        function DynamicAtlasItemFontAtlas(atlas, baseTexture) {
            var _this = _super.call(this, atlas.id, atlas.width / baseTexture.resolution, atlas.height / baseTexture.resolution, 0, baseTexture) || this;
            _this.canvas = atlas.canvas;
            return _this;
        }
        DynamicAtlasItemFontAtlas.prototype.render = function (context) {
            var canvas = this.canvas;
            if (canvas != null) {
                var frame = this.frame;
                context.drawImage(canvas, frame.x, frame.y, frame.width, frame.height);
            }
        };
        return DynamicAtlasItemFontAtlas;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemImage = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemImage, _super);
        function DynamicAtlasItemImage(image, baseTexture) {
            var _this = _super.call(this, image.src, image.width / baseTexture.resolution, image.height / baseTexture.resolution, 0, baseTexture) || this;
            _this.image = image;
            return _this;
        }
        DynamicAtlasItemImage.prototype.render = function (context) {
            var frame = this.frame;
            var x = frame.x;
            var y = frame.y;
            var w = frame.width;
            var h = frame.height;
            var image = this.image;
            context.drawImage(image, x, y, w, h);
            context.drawImage(image, 0, 0, 1, h, x - 1, y - 1, 1, h + 2);
            context.drawImage(image, 0, 0, w, 1, x, y - 1, w, 1);
            context.drawImage(image, w - 1, 0, 1, h, x + w, y - 1, 1, h + 2);
            context.drawImage(image, 0, h - 1, w, 1, x, y + h, w, 1);
        };
        return DynamicAtlasItemImage;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemText = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemText, _super);
        function DynamicAtlasItemText(id, text, baseTexture) {
            var _this = _super.call(this, id, text.width, text.height, 0, baseTexture) || this;
            _this._text = text;
            return _this;
        }
        DynamicAtlasItemText.prototype.render = function (context) {
            var frame = this.frame;
            context.drawImage(this._text.canvas, frame.x, frame.y, frame.width, frame.height);
        };
        return DynamicAtlasItemText;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemWhite = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemWhite, _super);
        function DynamicAtlasItemWhite() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DynamicAtlasItemWhite.prototype.render = function (context) {
            var frame = this.frame;
            context.save();
            context.fillStyle = "#ffffff";
            context.fillRect(frame.x - 1, frame.y - 1, frame.width + 2, frame.height + 2);
            context.restore();
        };
        return DynamicAtlasItemWhite;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var MAXIMUM_TEXTURE_SIZE = 4096;
    var DynamicAtlas = /** @class */ (function () {
        function DynamicAtlas(resolution) {
            var canvas = this._canvas = document.createElement("canvas");
            canvas.width = canvas.height = 256;
            var baseTexture = this._baseTexture = pixi_js.BaseTexture.from(canvas, {
                mipmap: pixi_js.MIPMAP_MODES.OFF,
                resolution: resolution
            });
            this._idToDatum = {};
            this._sortedData = [];
            this._predefined = {
                empty: new DynamicAtlasItemEmpty("empty", 10, 10, 0, baseTexture),
                white: new DynamicAtlasItemWhite("white", 10, 10, 0, baseTexture)
            };
            this._isDirty = true;
        }
        DynamicAtlas.prototype.updateFrames = function (width, data) {
            var padding = 4;
            var x = padding;
            var y = padding;
            var maxRowHeight = 0;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                if (width < x + datum.frame.width + padding) {
                    x = padding;
                    y += maxRowHeight + padding;
                    maxRowHeight = 0;
                }
                datum.frame.x = x | 0;
                datum.frame.y = y | 0;
                x += datum.frame.width + padding;
                maxRowHeight = Math.max(maxRowHeight, datum.frame.height);
            }
            var minHeight = y + maxRowHeight + padding;
            var result = 256;
            while (result < minHeight) {
                result <<= 1;
            }
            return Math.min(MAXIMUM_TEXTURE_SIZE, result);
        };
        DynamicAtlas.prototype.renderFrames = function (width, height, data) {
            var canvas = this._canvas;
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext("2d");
            if (context != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    var datum = data[i];
                    datum.render(context);
                }
            }
        };
        DynamicAtlas.prototype.applyFrames = function (data) {
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                datum.applyFrame();
            }
        };
        DynamicAtlas.prototype.calcCanvasWidth = function (data) {
            var result = 128;
            for (var i = data.length - 1; 0 <= i; --i) {
                var datum = data[i];
                var size = Math.max(datum.frame.width, datum.frame.height);
                while (result < size) {
                    result <<= 1;
                }
            }
            return Math.min(MAXIMUM_TEXTURE_SIZE, result << 1);
        };
        DynamicAtlas.prototype.cleanup = function (data) {
            data.sort(DynamicAtlas.ITEM_COMPARATOR);
            for (var i = data.length - 1; 0 <= i; --i) {
                var datum = data[i];
                if (0 < datum.ref) {
                    data.length = i + 1;
                    return;
                }
            }
            data.length = 0;
        };
        DynamicAtlas.prototype.begin = function () {
            var data = this._sortedData;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                datum.ref = 0;
            }
            this._isDirty = false;
        };
        DynamicAtlas.prototype.end = function () {
            var idToDatum = this._idToDatum;
            var data = this._sortedData;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                if (datum.ref <= 0) {
                    if (!(datum.id in this._predefined)) {
                        datum.destroy();
                    }
                    delete idToDatum[datum.id];
                    this._isDirty = true;
                }
            }
        };
        DynamicAtlas.prototype.repack = function (forcibly) {
            if (forcibly === true || this._isDirty) {
                this._isDirty = false;
                var data = this._sortedData;
                this.cleanup(data);
                var canvasWidth = this.calcCanvasWidth(data);
                var canvasHeight = this.updateFrames(canvasWidth, data);
                this.renderFrames(canvasWidth, canvasHeight, data);
                this._baseTexture.setRealSize(canvasWidth, canvasHeight);
                this.applyFrames(data);
            }
        };
        DynamicAtlas.prototype.get = function (id) {
            var idToDatum = this._idToDatum;
            var datum = idToDatum[id];
            if (datum != null) {
                datum.ref += 1;
                return datum;
            }
            else {
                var predefined = this._predefined[id];
                if (predefined != null) {
                    this.set(id, predefined);
                    return predefined;
                }
            }
            return null;
        };
        DynamicAtlas.prototype.set = function (id, item) {
            var result = this._idToDatum[id];
            item.ref += 1;
            this._idToDatum[id] = item;
            this._sortedData.push(item);
            this._isDirty = true;
            return result;
        };
        DynamicAtlas.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DynamicAtlas.prototype.getDefaultTexture = function () {
            return this.get("white").texture;
        };
        DynamicAtlas.prototype.getBaseTexture = function () {
            return this._baseTexture;
        };
        DynamicAtlas.prototype.release = function (id) {
            var idToDatum = this._idToDatum;
            var datum = idToDatum[id];
            if (datum != null) {
                datum.ref -= 1;
                if (datum.ref <= 0) {
                    if (!(datum.id in this._predefined)) {
                        datum.destroy();
                    }
                    delete idToDatum[id];
                    this._isDirty = true;
                }
            }
        };
        DynamicAtlas.ITEM_COMPARATOR = function (a, b) {
            if (a.ref <= 0) {
                if (b.ref <= 0) {
                    return 0;
                }
                else {
                    return +1;
                }
            }
            else {
                if (b.ref <= 0) {
                    return -1;
                }
            }
            if (a.frame.height < b.frame.height) {
                return -1;
            }
            else if (b.frame.height < a.frame.height) {
                return +1;
            }
            else {
                return a.frame.width - b.frame.width;
            }
        };
        return DynamicAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasFont = /** @class */ (function () {
        function DynamicFontAtlasFont(fontId, size, color, padding) {
            this.id = fontId;
            this.size = size;
            this.color = pixi_js.utils.hex2string(color);
            this.height = size + padding * 2;
            var metrics = pixi_js.TextMetrics.measureFont(fontId);
            this.ascent = metrics.ascent;
            this.descent = metrics.descent;
        }
        return DynamicFontAtlasFont;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var PADDING = 3;
    var DynamicFontAtlas = /** @class */ (function () {
        function DynamicFontAtlas(fontId, fontSize, fontColor, resolution) {
            this._id = fontId;
            this._canvas = document.createElement("canvas");
            this._context = null;
            this._font = new DynamicFontAtlasFont(fontId, fontSize, fontColor, PADDING);
            this._characters = {};
            this._length = 0;
            this._unrefCount = 0;
            this._width = 1;
            this._height = 1;
            this._revision = 0;
            this._revisionUpdated = 0;
            this._texture = pixi_js.Texture.from(this._canvas, {
                mipmap: pixi_js.MIPMAP_MODES.OFF,
                resolution: resolution,
                scaleMode: pixi_js.SCALE_MODES.NEAREST
            });
            this.add(ASCII_CHARACTERS, true);
            this.add_("...", this._characters, true);
        }
        Object.defineProperty(DynamicFontAtlas.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "font", {
            get: function () {
                return this._font;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "characters", {
            get: function () {
                return this._characters;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: true,
            configurable: true
        });
        DynamicFontAtlas.prototype.add_ = function (character, characters, reserved) {
            if (character !== "\n") {
                var data = characters[character];
                if (data != null) {
                    if (!data.reserved) {
                        if (data.ref === 0) {
                            this._unrefCount -= 1;
                        }
                        data.ref += 1;
                    }
                }
                else {
                    var advance = this.getAdvance(character);
                    var width = Math.ceil(PADDING + advance + PADDING);
                    var height = this.font.height;
                    characters[character] = new DynamicFontAtlasCharacter(advance, width, height, !!reserved);
                    this._length += 1;
                    this._revision += 1;
                }
            }
        };
        DynamicFontAtlas.prototype.remove_ = function (character, characters) {
            if (character !== "\n") {
                var data = characters[character];
                if (data != null) {
                    if (!data.reserved && 0 < data.ref) {
                        data.ref -= 1;
                        if (data.ref === 0) {
                            this._unrefCount += 1;
                        }
                    }
                }
            }
        };
        DynamicFontAtlas.prototype.cleanup_ = function () {
            if ((this._length >> 1) <= this._unrefCount) {
                var characters = this._characters;
                for (var character in characters) {
                    if (characters[character].ref <= 0) {
                        delete characters[character];
                    }
                }
                this._length -= this._unrefCount;
                this._revision += 1;
                this._unrefCount = 0;
            }
        };
        DynamicFontAtlas.prototype.add = function (targets, reserved) {
            var characters = this._characters;
            var iterator = UtilCharacterIterator.from(targets);
            while (iterator.hasNext()) {
                this.add_(iterator.next(), characters, reserved);
            }
        };
        DynamicFontAtlas.prototype.remove = function (targets) {
            var characters = this._characters;
            var iterator = UtilCharacterIterator.from(targets);
            while (iterator.hasNext()) {
                this.remove_(iterator.next(), characters);
            }
        };
        DynamicFontAtlas.prototype.get = function (character) {
            return this._characters[character];
        };
        DynamicFontAtlas.prototype.getAdvance = function (target) {
            var context = this.getContext();
            if (context != null) {
                return context.measureText(target).width;
            }
            return 0;
        };
        DynamicFontAtlas.prototype.getContext = function () {
            var context = this._context;
            if (context == null) {
                var canvas = this._canvas;
                if (canvas != null) {
                    context = this._context = canvas.getContext("2d", { alpha: true });
                    if (context == null) {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
            var font = this._font;
            if (context.font !== font.id) {
                context.font = font.id;
                font.id = context.font;
                context.textAlign = "left";
                context.textBaseline = "alphabetic";
                context.lineWidth = 0;
                context.lineCap = "round";
                context.lineJoin = "miter";
                context.miterLimit = 0;
                context.fillStyle = font.color;
                context.strokeStyle = "#0000ff";
            }
            return context;
        };
        DynamicFontAtlas.prototype.update = function () {
            this.cleanup_();
            if (this._revisionUpdated < this._revision) {
                this._revisionUpdated = this._revision;
                var canvas = this._canvas;
                if (canvas != null) {
                    var font = this._font;
                    var fontHeight = font.height;
                    var characters = this._characters;
                    var width = this._width = this.toPowerOf2(Math.ceil(Math.sqrt(this._length)) * fontHeight);
                    var offsetX = PADDING;
                    var offsetY = Math.round((fontHeight - (font.ascent + font.descent)) * 0.5 + font.ascent);
                    var x = 0;
                    var y = 0;
                    for (var key in characters) {
                        var character = characters[key];
                        if (width <= x + character.width) {
                            x = 0;
                            y += fontHeight;
                        }
                        character.x = x;
                        character.y = y;
                        character.origin.x = x + offsetX;
                        character.origin.y = y + offsetY;
                        x += character.width;
                    }
                    var height = this._height = y + fontHeight;
                    // Make a input canvas
                    // Here, we need to reset the context because
                    // context settings will be lost when we set the width/height.
                    var baseTexture = this._texture.baseTexture;
                    var resolution = baseTexture.resolution;
                    var realWidth = Math.ceil(width * resolution);
                    var realHeight = Math.ceil(height * resolution);
                    canvas.width = realWidth;
                    canvas.height = realHeight;
                    var context = this.getContext();
                    if (context != null) {
                        context.save();
                        context.scale(resolution, resolution);
                        context.clearRect(0, 0, width, height);
                        for (var key in characters) {
                            var character = characters[key];
                            context.fillText(key, character.origin.x, character.origin.y);
                        }
                        context.restore();
                    }
                    baseTexture.setRealSize(realWidth, realHeight);
                    return true;
                }
            }
            return false;
        };
        DynamicFontAtlas.prototype.getRevision = function () {
            return this._revision;
        };
        DynamicFontAtlas.prototype.getRevisionUpdate = function () {
            return this._revisionUpdated;
        };
        Object.defineProperty(DynamicFontAtlas.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: true,
            configurable: true
        });
        DynamicFontAtlas.prototype.destroy = function () {
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
            }
            var characters = this._characters;
            for (var character in characters) {
                delete characters[character];
            }
        };
        DynamicFontAtlas.prototype.toPowerOf2 = function (size) {
            var result = 32;
            while (result < size) {
                result <<= 1;
            }
            return result;
        };
        return DynamicFontAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var update = function (atlas) {
        atlas.update();
    };
    var updateAll = function (colorToAltas) {
        colorToAltas.forEach(update);
    };
    var destroy = function (atlas) {
        atlas.update();
    };
    var destroyAll = function (colorToAltas) {
        colorToAltas.forEach(destroy);
    };
    var DynamicFontAtlases = /** @class */ (function () {
        function DynamicFontAtlases(layer) {
            var _this = this;
            this._atlases = new Map();
            this._resolution = layer.renderer.resolution;
            layer.renderer.on("prerender", function () {
                _this.update();
            });
        }
        DynamicFontAtlases.prototype.add = function (fontId, fontSize, fontColor, targets) {
            var atlases = this._atlases;
            var colorToAtlas = atlases.get(fontId);
            if (colorToAtlas == null) {
                colorToAtlas = new Map();
                atlases.set(fontId, colorToAtlas);
            }
            var atlas = colorToAtlas.get(fontColor);
            if (atlas == null) {
                atlas = new DynamicFontAtlas(fontId, fontSize, fontColor, this._resolution);
                colorToAtlas.set(fontColor, atlas);
            }
            atlas.add(targets);
        };
        DynamicFontAtlases.prototype.remove = function (fontId, fontColor, targets) {
            var colorToAtlas = this._atlases.get(fontId);
            if (colorToAtlas != null) {
                var atlas = colorToAtlas.get(fontColor);
                if (atlas != null) {
                    atlas.remove(targets);
                }
            }
        };
        DynamicFontAtlases.prototype.get = function (fontId, fontColor) {
            var atlases = this._atlases;
            var colorToAtlas = atlases.get(fontId);
            if (colorToAtlas == null) {
                return null;
            }
            var atlas = colorToAtlas.get(fontColor);
            if (atlas == null) {
                return null;
            }
            return atlas;
        };
        DynamicFontAtlases.prototype.update = function () {
            this._atlases.forEach(updateAll);
        };
        DynamicFontAtlases.prototype.destroy = function () {
            var atlases = this._atlases;
            atlases.forEach(destroyAll);
            atlases.clear();
        };
        return DynamicFontAtlases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicSDFFontAtlases = /** @class */ (function () {
        function DynamicSDFFontAtlases() {
            this._atlases = {};
        }
        DynamicSDFFontAtlases.prototype.begin = function () {
            var atlases = this._atlases;
            for (var family in atlases) {
                var atlas = atlases[family];
                atlas.begin();
            }
        };
        DynamicSDFFontAtlases.prototype.end = function () {
            var atlases = this._atlases;
            for (var family in atlases) {
                var atlas = atlases[family];
                if (0 < atlas.length) {
                    atlas.addAscii();
                }
                atlas.end();
                if (atlas.length <= 0) {
                    atlas.destroy();
                    delete atlases[family];
                }
            }
        };
        DynamicSDFFontAtlases.prototype.add = function (family, targets) {
            var atlas = this._atlases[family];
            if (atlas != null) {
                atlas.add(targets);
            }
            else {
                var newAtlas = new DynamicSDFFontAtlas(family);
                newAtlas.add(targets);
                this._atlases[family] = newAtlas;
            }
        };
        DynamicSDFFontAtlases.prototype.get = function (family) {
            var atlas = this._atlases[family];
            if (atlas != null) {
                return atlas;
            }
            return null;
        };
        DynamicSDFFontAtlases.prototype.update = function (baseAtlas) {
            var atlases = this._atlases;
            var baseTexture = baseAtlas.getBaseTexture();
            for (var family in atlases) {
                var atlas = atlases[family];
                if (atlas.update()) {
                    var atlasId = atlas.id;
                    var item = baseAtlas.get(atlasId);
                    if (item != null) {
                        var width = atlas.width;
                        var height = atlas.height;
                        var resolution = baseTexture.resolution;
                        item.frame.width = width;
                        item.frame.height = height;
                        item.width = width / resolution;
                        item.height = height / resolution;
                        baseAtlas.toDirty();
                    }
                    else {
                        baseAtlas.set(atlasId, new DynamicAtlasItemFontAtlas(atlas, baseTexture));
                    }
                }
            }
        };
        DynamicSDFFontAtlases.prototype.destroy = function () {
            var atlases = this._atlases;
            for (var family in atlases) {
                var atlas = atlases[family];
                atlas.destroy();
            }
            this._atlases = {};
        };
        return DynamicSDFFontAtlases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isNaN = function (target) {
        return target !== target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var Lazy = /** @class */ (function () {
        function Lazy(newInstance, options, base) {
            var _this = this;
            this.instance = null;
            this.newInstance = newInstance;
            this.options = options;
            if (base != null) {
                if (base.isActive()) {
                    setTimeout(function () {
                        _this.get();
                    }, 0);
                }
                base.on("active", function () {
                    _this.get();
                });
            }
        }
        Lazy.prototype.get = function () {
            var instance = this.instance;
            if (instance == null) {
                instance = this.instance = new (this.newInstance)(this.options);
            }
            return instance;
        };
        return Lazy;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Returns a ceiling index of the given value.
     * The array must be sorted in an ascending order.
     *
     * @param array an array sorted in an ascending order
     * @param value a value to be searched
     * @returns a ceiling index of the given value
     */
    var toCeilingIndex = function (array, value, size, offset) {
        var i0 = 0;
        var i1 = Math.floor(array.length / size) - 1;
        while (i0 <= i1) {
            var i2 = i0 + ((i1 - i0) >> 1);
            var v2 = array[i2 * size + offset];
            if (value < v2) {
                i1 = i2 - 1;
            }
            else if (v2 < value) {
                i0 = i2 + 1;
            }
            else {
                return i2;
            }
        }
        return Math.max(i0, i1);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLabel = function (target) {
        if (target != null) {
            if (isString(target)) {
                return target;
            }
            else if (isNumber(target)) {
                return String(target);
            }
            else if ("name" in target) {
                return target.name;
            }
            else if ("label" in target) {
                return target.label;
            }
            else if ("id" in target) {
                return target.id;
            }
        }
        return "";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toString = function (value) {
        return (value != null ? String(value) : "");
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSvgUrl = function (svg) {
        return "data:image/svg+xml;base64," + btoa(svg);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSvgTexture = function (svg, resolution) {
        return pixi_js.Texture.from(toSvgUrl(svg), {
            resolution: resolution
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var SVGResource = /** @class */ (function (_super) {
        __extends(SVGResource, _super);
        function SVGResource(source, options) {
            var _this = _super.call(this, new Image()) || this;
            _this._load = null;
            _this._width = 0;
            _this._height = 0;
            _this.svg = source;
            pixi_js.resources.BaseImageResource.crossOrigin(_this.source, _this.svg, options && options.crossorigin);
            if (!options || options.autoLoad !== false) {
                _this.load();
            }
            return _this;
        }
        SVGResource.prototype.load = function () {
            var _this = this;
            if (this._load) {
                return this._load;
            }
            this._load = new Promise(function (resolve) {
                var image = _this.source;
                image.onerror = function (event) {
                    image.onerror = null;
                    _this.onError.run(event); // TODO: Fix PixiJS
                };
                var ua = navigator.userAgent;
                // IE and Edge generates wrong images without setTimeout.
                if (0 <= ua.indexOf("Trident/") || 0 <= ua.indexOf("Edge/")) {
                    image.onload = function () {
                        setTimeout(function () {
                            _this.resize(image.width, image.height);
                            resolve();
                        }, 0);
                    };
                }
                else {
                    image.onload = function () {
                        _this.resize(image.width, image.height);
                        resolve();
                    };
                }
                image.src = _this.svg;
            });
            return this._load;
        };
        SVGResource.test = function (source, extension) {
            // url file extension is SVG
            return extension === "svg"
                // source is SVG data-uri
                || (typeof source === "string" && source.indexOf("data:image/svg+xml;base64") === 0)
                // source is SVG inline
                || (typeof source === "string" && source.indexOf("<svg") === 0);
        };
        return SVGResource;
    }(pixi_js.resources.BaseImageResource));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // PixiJS's SVGResource has a issue on Microsoft Edge.
    // Edge may invoke the HTMLImageElement#onload on an unexpected timing.
    // Thus, PixiJS may lost the `load` event in some situations.
    pixi_js.resources.INSTALLED.push(SVGResource);
    var UtilSvgAtlasBuilder = /** @class */ (function () {
        function UtilSvgAtlasBuilder(width, ratio, margin) {
            this._width = width;
            this._ratio = ratio;
            this._margin = margin;
            this._frames = {};
            this._svg = "";
            this._nextX = 0;
            this._nextY = 0;
            this._height = 0;
        }
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "ratio", {
            get: function () {
                return this._ratio;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: true,
            configurable: true
        });
        UtilSvgAtlasBuilder.prototype.add = function (name, width, height, path) {
            var frames = this._frames;
            if (!(name in frames)) {
                // Position
                var margin = this._margin;
                var x = this._nextX;
                var y = this._nextY;
                if (this._width <= x + width) {
                    x = 0;
                    y = this._nextY + this._height + margin;
                    this._height = height;
                    this._nextY = y;
                }
                else {
                    this._height = Math.max(this._height, height);
                }
                this._nextX = x + width + margin;
                // Frame
                frames[name] = new pixi_js.Rectangle(x, y, width, height);
                // Svg
                var ratio = this._ratio;
                this._svg += "<g transform=\"translate(" + x * ratio + "," + y * ratio + ")\">" + path + "</g>";
                return true;
            }
            return false;
        };
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "mappings", {
            get: function () {
                return this.build();
            },
            enumerable: true,
            configurable: true
        });
        UtilSvgAtlasBuilder.prototype.build = function (options) {
            var built = this._built;
            if (built == null || (options && options.force)) {
                var resolution = (options && options.resolution != null ?
                    options.resolution : (window.devicePixelRatio || 1));
                var width = this._width;
                var height = Math.pow(2, Math.ceil(Math.log(this._nextY + this._height) / Math.LN2));
                var realWidth = width * resolution;
                var realHeight = height * resolution;
                var ratio = this._ratio;
                var attrWidth = "width=\"" + realWidth + "\"";
                var attrHeight = "height=\"" + realHeight + "\"";
                var attrViewBox = "viewBox=\"0 0 " + width * ratio + " " + height * ratio + "\"";
                var attrXmlns = "xmlns=\"http://www.w3.org/2000/svg\"";
                var url = toSvgUrl("<svg " + attrWidth + " " + attrHeight + " " + attrViewBox + " " + attrXmlns + ">" + this._svg + "</svg>");
                var scaleMode = (options && options.scaling != null ? options.scaling : pixi_js.SCALE_MODES.NEAREST);
                var baseTexture = pixi_js.BaseTexture.from(url, {
                    resolution: resolution,
                    scaleMode: scaleMode
                });
                var frames_1 = this._frames;
                built = this._built = {};
                for (var name_1 in frames_1) {
                    built[name_1] = new pixi_js.Texture(baseTexture, frames_1[name_1]);
                }
            }
            return built;
        };
        return UtilSvgAtlasBuilder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilAttachAlign;
    (function (UtilAttachAlign) {
        UtilAttachAlign[UtilAttachAlign["TOP"] = 0] = "TOP";
        UtilAttachAlign[UtilAttachAlign["LEFT"] = 1] = "LEFT";
        UtilAttachAlign[UtilAttachAlign["RIGHT"] = 2] = "RIGHT";
        UtilAttachAlign[UtilAttachAlign["BOTTOM"] = 3] = "BOTTOM";
    })(UtilAttachAlign || (UtilAttachAlign = {}));
    var UtilAttach = /** @class */ (function () {
        function UtilAttach() {
        }
        UtilAttach.attach = function (target, bounds, offsetX, offsetY, clippingWidth, clippingHeight, align) {
            var width = target.width;
            var height = target.height;
            var x = 0;
            var y = 0;
            switch (align) {
                case UtilAttachAlign.LEFT:
                    x = bounds.left - width - offsetX;
                    if (x < 0) {
                        x = bounds.right + offsetX;
                        if (clippingWidth < x + width) {
                            x = 0;
                        }
                    }
                    y = this.adjust(bounds.top, bounds.bottom, height, clippingHeight);
                    break;
                case UtilAttachAlign.TOP:
                    x = this.adjust(bounds.left, bounds.right, width, clippingWidth);
                    y = bounds.top - height - offsetY;
                    if (y < 0) {
                        y = bounds.bottom + offsetY;
                        if (clippingHeight < y + height) {
                            y = 0;
                        }
                    }
                    break;
                case UtilAttachAlign.RIGHT:
                    x = bounds.right + offsetX;
                    if (clippingWidth < x + width) {
                        x = bounds.left - width - offsetX;
                        if (x < 0) {
                            x = clippingWidth - width;
                        }
                    }
                    y = this.adjust(bounds.top, bounds.bottom, height, clippingHeight);
                    break;
                case UtilAttachAlign.BOTTOM:
                    x = this.adjust(bounds.left, bounds.right, width, clippingWidth);
                    y = bounds.bottom + offsetY;
                    if (clippingHeight < y + height) {
                        y = bounds.top - height - offsetY;
                        if (y < 0) {
                            y = clippingHeight - height;
                        }
                    }
                    break;
            }
            target.position.set(x, y);
        };
        UtilAttach.adjust = function (positionFirst, positionSecond, size, clippingSize) {
            if (positionFirst < 0) {
                if (clippingSize < positionFirst + size) {
                    return (clippingSize - size) * 0.5;
                }
                else {
                    return 0;
                }
            }
            else if (clippingSize < positionFirst + size) {
                if (clippingSize < size) {
                    return (clippingSize - size) * 0.5;
                }
                else {
                    return Math.min(clippingSize, positionSecond) - size;
                }
            }
            return positionFirst;
        };
        return UtilAttach;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilClickOutside = /** @class */ (function () {
        function UtilClickOutside() {
        }
        UtilClickOutside.apply = function (target, onClick) {
            var _this = this;
            target.on(UtilPointerEvent.down, function (e) {
                if (e.target === target) {
                    var point = _this.point;
                    point.copyFrom(e.data.global);
                    target.toLocal(point, undefined, point, true);
                    var x = point.x;
                    var y = point.y;
                    if (x < 0 || y < 0 || target.width < x || target.height < y) {
                        onClick(e);
                    }
                }
            });
        };
        UtilClickOutside.point = new pixi_js.Point();
        return UtilClickOutside;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var getSelection = function (element) {
        var selection = document.getSelection();
        if (selection) {
            var range = document.createRange();
            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        return selection;
    };
    var toClipboardData = function (e) {
        return e.clipboardData || window.clipboardData;
    };
    var copyUsingDiv = function (text) {
        var div = document.createElement("div");
        div.setAttribute("style", "-webkit-user-select: text !important");
        div.textContent = "Dummy";
        document.body.appendChild(div);
        var selection = getSelection(div);
        var result = false;
        if (selection) {
            var handler = function (e) {
                if (e.target === div) {
                    var clipboardData = toClipboardData(e);
                    clipboardData.setData("text/plain", text);
                    result = (clipboardData.getData("text/plain") === text);
                    e.preventDefault();
                }
            };
            document.addEventListener("copy", handler);
            try {
                document.execCommand("copy");
            }
            finally {
                document.removeEventListener("copy", handler);
            }
            selection.removeAllRanges();
        }
        document.body.removeChild(div);
        return result;
    };
    var copyUsingSpan = function (text) {
        var div = document.createElement("div");
        div.setAttribute("style", "-webkit-user-select: text !important");
        var span = document.createElement("span");
        span.innerText = text;
        var root = (div.attachShadow ? div.attachShadow({ mode: "open" }) : div);
        root.appendChild(span);
        document.body.appendChild(div);
        var result = false;
        var selection = getSelection(div);
        if (selection) {
            result = document.execCommand("copy");
            selection.removeAllRanges();
        }
        document.body.removeChild(div);
        return result;
    };
    var copyUsingWindow = function (window, text) {
        if (typeof ClipboardEvent === "undefined") {
            var clipboardData = window.clipboardData;
            if (typeof clipboardData !== "undefined" && typeof clipboardData.setData !== "undefined") {
                clipboardData.setData("Text", text);
                return true;
            }
        }
        return false;
    };
    var UtilClipboard = /** @class */ (function (_super) {
        __extends(UtilClipboard, _super);
        function UtilClipboard() {
            var _this = _super.call(this) || this;
            var element = document.body;
            element.addEventListener("copy", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("copy", toClipboardData(e));
                }
            });
            element.addEventListener("cut", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("cut", toClipboardData(e));
                }
            });
            element.addEventListener("paste", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("paste", toClipboardData(e));
                }
            });
            return _this;
        }
        UtilClipboard.copy = function (text) {
            var clipboard = navigator.clipboard;
            if (clipboard && clipboard.writeText) {
                clipboard.writeText(text);
            }
            else {
                if (!copyUsingWindow(window, text)) {
                    if (!copyUsingDiv(text)) {
                        if (navigator.userAgent.indexOf("Edge") < 0) {
                            copyUsingSpan(text);
                        }
                    }
                }
            }
        };
        return UtilClipboard;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilExtractor = /** @class */ (function () {
        function UtilExtractor() {
        }
        UtilExtractor.toTexture = function (target, resolution, clear, skipUpdateTransform) {
            var result = pixi_js.RenderTexture.create({
                width: target.width,
                height: target.height,
                scaleMode: pixi_js.SCALE_MODES.LINEAR,
                resolution: resolution
            });
            var matrix = new pixi_js.Matrix(undefined, undefined, undefined, undefined, -target.position.x, -target.position.y);
            var layer = DApplications.getLayer(target);
            if (layer) {
                layer.renderer.render(target, result, clear, matrix, skipUpdateTransform);
            }
            return result;
        };
        UtilExtractor.toPixels = function (renderTexture, renderer) {
            var resolution = renderTexture.resolution;
            var frame = renderTexture.frame;
            var width = Math.floor(frame.width * resolution);
            var height = Math.floor(frame.height * resolution);
            var pixels = new Uint8Array(4 * width * height);
            renderer.renderTexture.bind(renderTexture);
            var gl = renderer.gl;
            gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            return {
                width: width,
                height: height,
                array: pixels
            };
        };
        UtilExtractor.toCanvas = function (pixels, scale, ignorePremutipliedAlpha) {
            var width = pixels.width;
            var height = pixels.height;
            var array = pixels.array;
            var canvasRenderTarget = new pixi_js.utils.CanvasRenderTarget(width, height, 1);
            var imageData = canvasRenderTarget.context.getImageData(0, 0, width, height);
            if (ignorePremutipliedAlpha) {
                imageData.data.set(array);
            }
            else {
                pixi_js.Extract.arrayPostDivide(array, imageData.data);
            }
            canvasRenderTarget.context.putImageData(imageData, 0, 0);
            // Scale down
            if (scale != null && scale !== 1) {
                canvasRenderTarget.context.scale(scale, scale);
                canvasRenderTarget.context.drawImage(canvasRenderTarget.canvas, 0, 0);
                var scaledWidth = Math.floor(width * scale);
                var scaledHeight = Math.floor(height * scale);
                var scaledImageData = canvasRenderTarget.context.getImageData(0, 0, scaledWidth, scaledHeight);
                canvasRenderTarget.resize(scaledWidth, scaledHeight);
                canvasRenderTarget.context.putImageData(scaledImageData, 0, 0);
            }
            return canvasRenderTarget.canvas;
        };
        UtilExtractor.toBase64 = function (canvas, format, quality) {
            return canvas.toDataURL(format, quality);
        };
        return UtilExtractor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilFileDownloader = /** @class */ (function () {
        function UtilFileDownloader() {
        }
        UtilFileDownloader.downloadUrl = function (filename, url) {
            var a = document.createElement("a");
            if ("download" in a) {
                a.href = url;
                a.setAttribute("download", filename);
                a.style.display = "none";
                document.body.appendChild(a);
                a.click();
                setTimeout(function () {
                    document.body.removeChild(a);
                }, 66);
            }
            else {
                if (!window.open(url)) {
                    location.href = url;
                }
            }
        };
        UtilFileDownloader.download = function (filename, contents) {
            var blob = new Blob([contents], { type: "text/plain" });
            if (window.navigator.msSaveBlob) {
                window.navigator.msSaveBlob(blob, filename);
            }
            else {
                this.downloadUrl(filename, URL.createObjectURL(blob));
            }
        };
        return UtilFileDownloader;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSkipUpdateTransform = function (options) {
        return options.transform && options.transform.update;
    };
    var toResolution = function (options) {
        var target = options.target;
        if (options.resolution != null) {
            if (isNumber(options.resolution)) {
                return options.resolution;
            }
            else {
                return Math.min(1, options.resolution.size / Math.max(target.width, target.height));
            }
        }
        else {
            return window.devicePixelRatio || 1;
        }
    };
    var toIgnorePremultipliedAlpha = function (options) {
        return (options.alpha && options.alpha.premultiplied && options.alpha.premultiplied.ignore);
    };
    var toScale = function (pixels, options) {
        if (options.scale != null) {
            if (isNumber(options.scale)) {
                return options.scale;
            }
            else {
                var size = options.scale.size;
                return Math.min(1, size / pixels.width, size / pixels.height);
            }
        }
    };
    var toRenderer = function (options) {
        if (options.renderer) {
            return options.renderer;
        }
        else if (options.application) {
            return options.application.getLayerBase().renderer;
        }
        else if (options.layer) {
            return options.layer.renderer;
        }
        else {
            var layer = DApplications.getLayer(options.target);
            if (layer) {
                return layer.renderer;
            }
            else {
                throw new Error("No renderer / application / layer found.");
            }
        }
    };
    var UtilExtract = /** @class */ (function () {
        function UtilExtract() {
        }
        UtilExtract.texture = function (options) {
            var target = options.target;
            var resolution = toResolution(options);
            var skipUpdateTransform = toSkipUpdateTransform(options);
            return UtilExtractor.toTexture(target, resolution, options.clear, skipUpdateTransform);
        };
        UtilExtract.pixels = function (options) {
            var renderer = toRenderer(options);
            return UtilExtractor.toPixels(this.texture(options), renderer);
        };
        UtilExtract.canvas = function (options) {
            var pixels = this.pixels(options);
            var ignorePremutipliedAlpha = toIgnorePremultipliedAlpha(options);
            var scale = toScale(pixels, options);
            return UtilExtractor.toCanvas(pixels, scale, ignorePremutipliedAlpha);
        };
        UtilExtract.base64 = function (options) {
            return UtilExtractor.toBase64(this.canvas(options), options.format, options.quality);
        };
        UtilExtract.file = function (options) {
            UtilFileDownloader.downloadUrl(options.filename, this.base64(options));
        };
        return UtilExtract;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An output format.
     */
    var UtilFileAs;
    (function (UtilFileAs) {
        UtilFileAs[UtilFileAs["TEXT"] = 0] = "TEXT";
        UtilFileAs[UtilFileAs["DATA_URL"] = 1] = "DATA_URL";
        UtilFileAs[UtilFileAs["BINARY_STRING"] = 2] = "BINARY_STRING";
        UtilFileAs[UtilFileAs["ARRAY_BUTTER"] = 3] = "ARRAY_BUTTER";
    })(UtilFileAs || (UtilFileAs = {}));
    var UtilFileOpener = /** @class */ (function () {
        function UtilFileOpener(as, facade) {
            this._input = null;
            this._as = as;
            this._facade = facade;
        }
        UtilFileOpener.prototype.open = function () {
            var input = this.getOrCreateInput();
            if (input != null) {
                input.click();
            }
            else {
                this.onCancel();
            }
        };
        UtilFileOpener.prototype.getOrCreateInput = function () {
            var _this = this;
            if ("FileReader" in window && this._input == null) {
                var input_1 = this._input = document.createElement("input");
                input_1.setAttribute("type", "file");
                input_1.setAttribute("style", "display:none");
                input_1.addEventListener("change", function (e) {
                    _this.onInputChange(input_1);
                    input_1.value = "";
                    e.stopImmediatePropagation();
                    e.preventDefault();
                });
                document.body.appendChild(input_1);
            }
            return this._input;
        };
        UtilFileOpener.prototype.onInputChange = function (input) {
            var _this = this;
            var files = input.files;
            if (files != null && 0 < files.length) {
                var file = files[0];
                var fileReader = new FileReader();
                fileReader.onload = function (e) {
                    if (e.target != null) {
                        var target = e.target;
                        _this.onOpen(target.result);
                    }
                };
                fileReader.onabort = function (e) {
                    _this.onAboart(e);
                };
                switch (this._as) {
                    case UtilFileAs.TEXT:
                        fileReader.readAsText(file);
                        break;
                    case UtilFileAs.DATA_URL:
                        fileReader.readAsDataURL(file);
                        break;
                    case UtilFileAs.BINARY_STRING:
                        fileReader.readAsBinaryString(file);
                        break;
                    case UtilFileAs.ARRAY_BUTTER:
                        fileReader.readAsArrayBuffer(file);
                        break;
                    default:
                        fileReader.readAsText(file);
                        break;
                }
            }
            else {
                this.onCancel();
            }
        };
        UtilFileOpener.prototype.onOpen = function (result) {
            var facade = this._facade;
            facade.emit("open", result, facade);
        };
        UtilFileOpener.prototype.onAboart = function (e) {
            var facade = this._facade;
            facade.emit("abort", e, facade);
        };
        UtilFileOpener.prototype.onCancel = function () {
            var facade = this._facade;
            facade.emit("cancel", facade);
        };
        return UtilFileOpener;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHsv = /** @class */ (function () {
        function UtilHsv() {
        }
        UtilHsv.fromRgb = function (color) {
            var r = (color & 0xff0000) >> 16;
            var g = (color & 0x00ff00) >> 8;
            var b = (color & 0x0000ff) | 0;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var length = max - min;
            var h = 0;
            if (0 < length) {
                if (r === max) {
                    h = 60 * (g - b) / length;
                }
                else if (g === max) {
                    h = 60 * (b - r) / length + 120;
                }
                else if (b === max) {
                    h = 60 * (r - g) / length + 240;
                }
                if (h < 0) {
                    h += 360;
                }
            }
            var s = (length / max) * 255;
            var v = max;
            return [h, s, v];
        };
        UtilHsv.toRgb = function (h, s, v) {
            var max = v;
            var min = v - (s / 255) * v;
            var length = max - min;
            var r = 0;
            var g = 0;
            var b = 0;
            if (h <= 60) {
                r = max;
                g = (h / 60) * length + min;
                b = min;
            }
            else if (h <= 120) {
                r = ((120 - h) / 60) * length + min;
                g = max;
                b = min;
            }
            else if (h <= 180) {
                r = min;
                g = max;
                b = ((h - 120) / 60) * length + min;
            }
            else if (h <= 240) {
                r = min;
                g = ((240 - h) / 60) * length + min;
                b = max;
            }
            else if (h <= 300) {
                r = ((h - 240) / 60) * length + min;
                g = min;
                b = max;
            }
            else {
                r = max;
                g = min;
                b = ((360 - h) / 60) * length + min;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            return (r << 16) | (g << 8) | b;
        };
        return UtilHsv;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilName = /** @class */ (function () {
        function UtilName() {
        }
        UtilName.create = function (type) {
            var mapping = this._mapping;
            if (type in mapping) {
                return type + " " + ++mapping[type];
            }
            else {
                mapping[type] = 1;
                return type + " 1";
            }
        };
        UtilName._mapping = {};
        return UtilName;
    }());

    var UtilOverlay = /** @class */ (function () {
        function UtilOverlay(options) {
            this._layer = null;
            this._application = (options == null || options.parent == null ?
                DApplications.last() : null);
        }
        Object.defineProperty(UtilOverlay.prototype, "picked", {
            get: function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        UtilOverlay.prototype.pick = function (target) {
            var layer = this._layer;
            if (layer == null) {
                layer = DApplications.getLayerOverlay(target);
                if (!layer) {
                    var application = this._application;
                    if (application) {
                        layer = application.getLayerOverlay();
                    }
                    else {
                        layer = DApplications.last().getLayerOverlay();
                    }
                }
                this._layer = layer;
            }
            return layer;
        };
        return UtilOverlay;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilPromise = /** @class */ (function () {
        function UtilPromise() {
        }
        UtilPromise.IDENTITY = function () { };
        return UtilPromise;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilRgba = /** @class */ (function () {
        function UtilRgba() {
        }
        UtilRgba.toCode = function (color, alpha) {
            var r = (color >> 16) & 0xff;
            var g = (color >> 8) & 0xff;
            var b = (color & 0xff);
            return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
        };
        return UtilRgba;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilTexturePlane = /** @class */ (function () {
        function UtilTexturePlane() {
            this._backgroundCache = new Map();
            this._backgroundAttribute = "fill=\"#fff\" stroke=\"none\"";
            this._borderCache = new Map();
            this._borderAttribute = function (width) {
                return "fill=\"none\" stroke=\"#fff\" stroke-width=\"" + width + "\"";
            };
            this._onUpdate = function () {
                DApplications.update();
            };
        }
        UtilTexturePlane.prototype.toCornerTl = function (offset, size, tl) {
            return (0 < tl ? "A" + tl + " " + tl + " 0 0 1 " + (offset + tl) + " " + offset : "");
        };
        UtilTexturePlane.prototype.toCornerBr = function (offset, size, br) {
            return (0 < br ? "A" + br + " " + br + " 0 0 1 " + (offset + size - br) + " " + (offset + size) : "");
        };
        UtilTexturePlane.prototype.make = function (radius, offset, attr) {
            var realRadius = Math.max(0, radius - offset);
            var size = realRadius * 2 + 4;
            var realSize = size + offset * 2;
            var d = "M" + (offset + realRadius) + " " + offset +
                ("L" + (offset + size) + " " + offset) +
                ("L" + (offset + size) + " " + (offset + size - realRadius)) +
                this.toCornerBr(offset, size, realRadius) +
                ("L" + offset + " " + (offset + size)) +
                ("L" + offset + " " + (offset + realRadius)) +
                this.toCornerTl(offset, size, realRadius) +
                "Z";
            return this.toSvg(realSize, attr, d);
        };
        UtilTexturePlane.prototype.toSvg = function (realSize, attr, d) {
            var resolution = (window.devicePixelRatio || 1);
            var widthAttr = "width=\"" + realSize * resolution + "\"";
            var heightAttr = "height=\"" + realSize * resolution + "\"";
            var viewBoxAttr = "viewBox=\"0 0 " + realSize + " " + realSize + "\"";
            var svg = "<svg " + widthAttr + " " + heightAttr + " " + viewBoxAttr + " xmlns=\"http://www.w3.org/2000/svg\">" +
                ("<path " + attr + " d=\"" + d + "\"></path>") +
                "</svg>";
            return pixi_js.Texture.from(toSvgUrl(svg), {
                resolution: resolution
            });
        };
        UtilTexturePlane.prototype.newBackground = function (radius) {
            var result = this.make(radius, 0, this._backgroundAttribute);
            result.on("update", this._onUpdate);
            return result;
        };
        UtilTexturePlane.prototype.newBorder = function (radius, width) {
            var result = this.make(radius, 0.5 * width, this._borderAttribute(width));
            result.on("update", this._onUpdate);
            return result;
        };
        UtilTexturePlane.prototype.getBackground = function (radius) {
            var cache = this._backgroundCache;
            var texture = cache.get(radius);
            if (texture == null) {
                texture = this.newBackground(radius);
                cache.set(radius, texture);
            }
            return texture;
        };
        UtilTexturePlane.prototype.getBorder = function (radius, width) {
            var cache = this._borderCache;
            var maskToTexture = cache.get(radius);
            if (maskToTexture == null) {
                maskToTexture = new Map();
                cache.set(radius, maskToTexture);
            }
            var texture = maskToTexture.get(width);
            if (texture == null) {
                texture = this.newBorder(radius, width);
                maskToTexture.set(width, texture);
            }
            return texture;
        };
        UtilTexturePlane.getInstance = function () {
            if (UtilTexturePlane.INSTANCE == null) {
                UtilTexturePlane.INSTANCE = new UtilTexturePlane();
            }
            return UtilTexturePlane.INSTANCE;
        };
        UtilTexturePlane.INSTANCE = null;
        return UtilTexturePlane;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilTexture = /** @class */ (function () {
        function UtilTexture() {
        }
        UtilTexture.fromImage = function (url, resolution, onLoad) {
            var texture = pixi_js.Texture.from(url, {
                resolution: resolution
            });
            if (!texture.baseTexture.valid) {
                texture.once("update", onLoad);
            }
            else {
                onLoad(texture);
            }
        };
        return UtilTexture;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilTransition = /** @class */ (function () {
        function UtilTransition(options) {
            this._duration = (options != null && options.duration != null ? options.duration : 300);
            this._current = null;
            this._lastUpdate = 0;
            this._updateId = null;
        }
        UtilTransition.prototype.show = function (next, forcibly) {
            var _this = this;
            var updateId = this._updateId;
            if (updateId != null) {
                clearTimeout(updateId);
            }
            var current = this._current;
            if (next !== current) {
                var duration = this._duration;
                var lastUpdate = this._lastUpdate;
                var now = Date.now();
                var remaining = (lastUpdate + duration) - now;
                if (forcibly === true || remaining <= 0) {
                    this.update(now, next);
                }
                else {
                    this._updateId = window.setTimeout(function () {
                        _this.update(Date.now(), next);
                    }, remaining);
                }
            }
        };
        UtilTransition.prototype.update = function (now, next) {
            var current = this._current;
            if (current !== next) {
                this._lastUpdate = now;
                if (current !== null) {
                    current.hide();
                }
                this._current = next;
                if (next != null) {
                    next.show();
                }
            }
        };
        UtilTransition.prototype.hide = function () {
            this.show(null);
        };
        return UtilTransition;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /*!
    * jQuery Mousewheel 3.1.13
    *
    * Copyright jQuery Foundation and other contributors
    * Released under the MIT license
    * http://jquery.org/license
    *
    * See also https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
    * and https://github.com/openlayers/openlayers/blob/v5.2.0/src/ol/interaction/MouseWheelZoom.js#L51
    */
    var UtilWheelEvent = /** @class */ (function () {
        function UtilWheelEvent() {
            this._lowest = null;
            this._timestamp = 0;
            this._lineHeight = null;
            this._pageHeight = null;
            this._names = ("onwheel" in document || 9 <= document.documentMode ?
                ["wheel"] : ["mousewheel", "DOMMouseScroll", "MozMousePixelScroll"]);
        }
        UtilWheelEvent.prototype.on = function (target, handler, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            var names = this._names;
            for (var i = names.length - 1; 0 <= i; --i) {
                var name_1 = names[i];
                target.addEventListener(name_1, handler, useCapture);
            }
        };
        UtilWheelEvent.prototype.off = function (target, handler, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            var names = this._names;
            for (var i = names.length - 1; 0 <= i; --i) {
                var name_2 = names[i];
                target.removeEventListener(name_2, handler, useCapture);
            }
        };
        UtilWheelEvent.prototype.getLineHeight = function () {
            if (this._lineHeight == null) {
                var theme = DThemes.getInstance().get("DBase");
                this._lineHeight = theme.getLineHeight();
            }
            return this._lineHeight;
        };
        UtilWheelEvent.prototype.getPageHeight = function () {
            if (this._pageHeight == null) {
                this._pageHeight = this.getLineHeight() * 12;
            }
            return this._pageHeight;
        };
        UtilWheelEvent.prototype.normalize = function (e) {
            var deltaX = 0;
            var deltaY = 0;
            // Old school scrollwheel delta
            if ("detail" in e) {
                deltaY = e.detail * -1;
            }
            if ("wheelDelta" in e) {
                deltaY = e.wheelDelta;
            }
            if ("wheelDeltaY" in e) {
                deltaY = e.wheelDeltaY;
            }
            if ("wheelDeltaX" in e) {
                deltaX = e.wheelDeltaX * -1;
            }
            // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
            if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
                deltaX = deltaY * -1;
                deltaY = 0;
            }
            // New school wheel delta (wheel event)
            if ("deltaY" in e) {
                deltaY = e.deltaY * -1;
            }
            if ("deltaX" in e) {
                deltaX = e.deltaX;
            }
            // No change actually happened, no reason to go any further
            if (deltaY === 0 && deltaX === 0) {
                return null;
            }
            // Store lowest absolute delta to normalize the delta values
            var delta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
            // Reset the this._lowest to better handle multiple device types
            // that give different a different lowestDelta
            // Ex: trackpad = 3 and mouse wheel = 120
            var now = Date.now();
            if (this._timestamp + 200 <= now) {
                this._lowest = null;
            }
            this._timestamp = now;
            //
            var shouldAdjust = (e.type === "mousewheel" && delta % 120 === 0);
            if (!this._lowest || delta < this._lowest) {
                this._lowest = delta;
                // Adjust older deltas if necessary
                if (shouldAdjust) {
                    this._lowest /= 40;
                }
            }
            // Adjust older deltas if necessary
            if (shouldAdjust) {
                // Divide all the things by 40!
                delta /= 40;
                deltaX /= 40;
                deltaY /= 40;
            }
            // Get a whole, normalized value for the deltas
            var lowest = this._lowest;
            delta = Math.floor(delta / lowest);
            deltaX = Math[1 <= deltaX ? "floor" : "ceil"](deltaX / lowest);
            deltaY = Math[1 <= deltaY ? "floor" : "ceil"](deltaY / lowest);
            // Mode
            var mode = e.deltaMode || 0;
            if (mode !== 0) {
                var scale = (mode === 1 ? this.getLineHeight() : this.getPageHeight());
                delta *= scale;
                deltaX *= scale;
                deltaY *= scale;
            }
            return {
                mode: mode,
                delta: delta,
                deltaX: deltaX,
                deltaY: deltaY,
                lowest: lowest
            };
        };
        UtilWheelEvent.getInstance = function () {
            if (this.INSTANCE == null) {
                this.INSTANCE = new UtilWheelEvent();
            }
            return this.INSTANCE;
        };
        return UtilWheelEvent;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsPointImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsPointImpl(parent, defX, defY) {
            this._parent = parent;
            this._id = 0;
            this._x = null;
            this._y = null;
            this._defX = defX;
            this._defY = defY;
            this._limit = null;
            this._limitComputed = 0;
            this._limitId = -1;
            this._limitParentLength = 0;
        }
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                this.set(x, undefined);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                this.set(undefined, y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "limit", {
            get: function () {
                return this._limit;
            },
            set: function (limit) {
                this._limit = limit;
            },
            enumerable: true,
            configurable: true
        });
        EShapeLineOfAnyPointsPointImpl.prototype.set = function (x, y) {
            var isChanged = false;
            if (x !== undefined && this._x !== x) {
                isChanged = true;
                this._x = x;
            }
            if (y !== undefined && this._y !== y) {
                isChanged = true;
                this._y = y;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getX = function (index) {
            return toComputed(index, this._x, this._defX);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getY = function (index) {
            return toComputed(index, this._y, this._defY);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getLimit = function () {
            var limit = this._limit;
            if (limit != null) {
                return limit;
            }
            this.updateLimitComputed();
            return this._limitComputed;
        };
        EShapeLineOfAnyPointsPointImpl.prototype.updateLimitComputed = function () {
            var limitId = this._id;
            var parent = this._parent;
            var limitParentLength = parent.length;
            if (this._limitId !== limitId || this._limitParentLength !== limitParentLength) {
                this._limitId = limitId;
                this._limitParentLength = limitParentLength;
                this._limitComputed = Math.max(this.calcLimit(this._x, limitParentLength, this._defX), this.calcLimit(this._y, limitParentLength, this._defY));
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.calcLimit = function (value, parentLenght, def) {
            if (isNumber(value)) {
                return Math.abs(value);
            }
            else if (isFunction(value)) {
                if (0 < parentLenght) {
                    var result = Math.abs(value(0));
                    for (var i = 1; i < parentLenght; ++i) {
                        result = Math.max(result, Math.abs(value(i)));
                    }
                    return result;
                }
                return 0;
            }
            else if (value != null) {
                var l = value.length;
                if (0 < l) {
                    var result = value[0];
                    for (var i = 1; i < l; ++i) {
                        result = Math.max(result, Math.abs(value[i]));
                    }
                    return result;
                }
                return 0;
            }
            else {
                return Math.abs(def);
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.isStaticX = function () {
            return isStatic(this._x);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.isStaticY = function () {
            return isStatic(this._y);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsPointImpl;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsStrokeImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsStrokeImpl(parent) {
            this._parent = parent;
            this._id = 0;
            this._color = null;
            this._alpha = null;
        }
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this.set(color, undefined);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                this.set(undefined, alpha);
            },
            enumerable: true,
            configurable: true
        });
        EShapeLineOfAnyPointsStrokeImpl.prototype.set = function (color, alpha) {
            var isChanged = false;
            if (color !== undefined && this._color !== color) {
                isChanged = true;
                this._color = color;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                isChanged = true;
                this._alpha = alpha;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.getColor = function (index, def) {
            return toComputed(index, this._color, def);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.getAlpha = function (index, def) {
            return toComputed(index, this._alpha, def);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.isStaticColor = function () {
            return isStatic(this._color);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.isStaticAlpha = function () {
            return isStatic(this._alpha);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsImpl(parent) {
            this._parent = parent;
            this._values = [];
            this._valuesLength = 0;
            this._segments = [];
            this._size = new EShapeLineOfAnyPointsPointImpl(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            this._offset = new EShapeLineOfAnyPointsPointImpl(this, 0, 0);
            this._fill = new EShapeLineOfAnyPointsFillImpl(parent);
            this._stroke = new EShapeLineOfAnyPointsStrokeImpl(parent);
            this._id = 0;
        }
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "length", {
            get: function () {
                return this._values.length >> 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "values", {
            get: function () {
                return this._values;
            },
            set: function (values) {
                this.set(values, undefined, undefined);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            set: function (segments) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "style", {
            get: function () {
                return EShapePointsStyle.NONE;
            },
            set: function (style) {
                this.set(undefined, undefined, style);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "offset", {
            get: function () {
                return this._offset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "fill", {
            get: function () {
                return this._fill;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "stroke", {
            get: function () {
                return this._stroke;
            },
            enumerable: true,
            configurable: true
        });
        EShapeLineOfAnyPointsImpl.prototype.copy = function (source) {
            return this.set(source.values, source.segments, source.style);
        };
        EShapeLineOfAnyPointsImpl.prototype.set = function (newValues, newSegments, newStyle) {
            var isDirty = false;
            var isUpdated = false;
            // Values
            if (newValues != null) {
                var values = this._values;
                var valuesLength = this._valuesLength;
                var newValuesLength = newValues.length;
                if (values !== newValues) {
                    var iupdate = Math.min(valuesLength, newValuesLength);
                    for (var i = 0; i < iupdate; ++i) {
                        values[i] = newValues[i];
                    }
                    for (var i = iupdate; i < newValuesLength; ++i) {
                        values.push(newValues[i]);
                    }
                    if (valuesLength !== newValuesLength) {
                        values.length = newValuesLength;
                        this._valuesLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
                else {
                    if (valuesLength !== newValuesLength) {
                        this._valuesLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
            }
            //
            if (isDirty) {
                this._id += 1;
                var parent_1 = this._parent;
                var uploaded = parent_1.uploaded;
                if (uploaded) {
                    if (uploaded.isCompatible(parent_1)) {
                        parent_1.updateUploaded();
                    }
                    else {
                        parent_1.uploaded = undefined;
                        parent_1.toDirty();
                    }
                }
                else {
                    parent_1.updateUploaded();
                }
            }
            else if (isUpdated) {
                this._id += 1;
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeLineOfAnyPointsImpl.prototype.updateUploaded = function () {
            this._parent.updateUploaded();
        };
        EShapeLineOfAnyPointsImpl.prototype.clone = function (parent) {
            return new EShapeLineOfAnyPointsImpl(parent);
        };
        EShapeLineOfAnyPointsImpl.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeLineOfAnyPointsImpl.prototype.serialize = function (manager) {
            return manager.add("[]");
        };
        EShapeLineOfAnyPointsImpl.prototype.calcHitPointAbs = function (x, y, threshold, range, tester, result) {
            var pointCount = this.length;
            var pointValues = this._values;
            var size = this._size;
            var offset = this._offset;
            var istart = 0;
            var iend = pointCount;
            if (range) {
                var s = size.getLimit() * 0.5;
                var o = offset.getLimit();
                var rangeResult = range(x, y, s, s, o, o, threshold, pointValues, EShapeLineOfAnyPointsImpl.WORK_RANGE);
                istart = rangeResult[0];
                iend = rangeResult[1];
            }
            tester = tester;
            for (var i = istart, imax = Math.min(iend, pointCount), iv = istart << 1; i < imax; i += 1, iv += 2) {
                var px = pointValues[iv];
                var py = pointValues[iv + 1];
                var sx = size.getX(i) * 0.5;
                var sy = size.getY(i) * 0.5;
                var ox = offset.getX(i);
                var oy = offset.getY(i);
                if (tester(x, y, sx, sy, ox, oy, px, py, i, threshold, result)) {
                    return true;
                }
            }
            return false;
        };
        EShapeLineOfAnyPointsImpl.WORK_RANGE = [0, 0];
        return EShapeLineOfAnyPointsImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfAnyUploaded, _super);
        function EShapeLineOfAnyUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight, pointCountReserved) {
            var _this = _super.call(this, buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) || this;
            _this.pointId = -1;
            _this.pointCount = 0;
            _this.pointCountReserved = pointCountReserved;
            _this.pointSizeId = -1;
            _this.pointOffsetId = -1;
            _this.pointFillId = -1;
            _this.pointStrokeId = -1;
            return _this;
        }
        EShapeLineOfAnyUploaded.prototype.isCompatible = function (shape) {
            if (_super.prototype.isCompatible.call(this, shape)) {
                var points = shape.points;
                var pointCount = toLineOfAnyPointCount(points ? points.length : 0);
                return pointCount === this.pointCountReserved;
            }
            return false;
        };
        EShapeLineOfAnyUploaded.prototype.updateLineOfAnyColorFill = function (buffer, shape, points, vcountPerPoint) {
            var pointFill = points.fill;
            var pointFillId = pointFill.id;
            var isPointFillChanged = (pointFillId !== this.pointFillId);
            var fill = shape.fill;
            var isFillEnabled = shape.visible && fill.enable;
            var colorFill = fill.color;
            var alphaFill = (isFillEnabled ? fill.alpha : 0);
            var isFillChanged = (colorFill !== this.colorFill || alphaFill !== this.alphaFill);
            if (isPointFillChanged || isFillChanged) {
                this.colorFill = colorFill;
                this.alphaFill = alphaFill;
                this.pointFillId = pointFillId;
                buffer.updateColorFills();
                buildLineOfAnyColor(this.vertexOffset, vcountPerPoint, pointFill, this.pointCountReserved, buffer.colorFills, isFillEnabled, colorFill, alphaFill);
            }
        };
        EShapeLineOfAnyUploaded.prototype.updateLineOfAnyColorStroke = function (buffer, shape, points, vcountPerPoint) {
            var pointStroke = points.stroke;
            var pointStrokeId = pointStroke.id;
            var isPointStrokeChanged = (pointStrokeId !== this.pointStrokeId);
            var stroke = shape.stroke;
            var isStrokeEnabled = shape.visible && stroke.enable;
            var colorStroke = stroke.color;
            var alphaStroke = (isStrokeEnabled ? stroke.alpha : 0);
            var isStrokeChanged = (colorStroke !== this.colorStroke || alphaStroke !== this.alphaStroke);
            if (isPointStrokeChanged || isStrokeChanged) {
                this.colorStroke = colorStroke;
                this.alphaStroke = alphaStroke;
                this.pointStrokeId = pointStrokeId;
                buffer.updateColorStrokes();
                buildLineOfAnyColor(this.vertexOffset, vcountPerPoint, pointStroke, this.pointCountReserved, buffer.colorStrokes, isStrokeEnabled, colorStroke, alphaStroke);
            }
        };
        return EShapeLineOfAnyUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfCirclesUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfCirclesUploaded, _super);
        function EShapeLineOfCirclesUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineOfCirclesUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Clippings & indices
            var buffer = this.buffer;
            buffer.updateClippings();
            buffer.updateIndices();
            var clippings = buffer.clippings;
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildCircleClipping(clippings, voffset);
                copyClipping(clippings, voffset, CIRCLE_VERTEX_COUNT, pointCountReserved);
                buildCircleIndex(indices, voffset, ioffset);
                copyIndex(indices, CIRCLE_VERTEX_COUNT, ioffset, CIRCLE_INDEX_COUNT, pointCountReserved);
            }
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLineOfCirclesUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexAndStep(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, CIRCLE_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, CIRCLE_VERTEX_COUNT);
                this.updateUv(buffer, shape);
                this.updateText(buffer, shape);
            }
        };
        EShapeLineOfCirclesUploaded.prototype.updateVertexAndStep = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = (pointId !== this.pointId || pointOffsetId !== this.pointOffsetId);
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = (pointSizeId !== this.pointSizeId);
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign || this.strokeWidth !== strokeWidth);
            if (isPointChanged || isPointSizeChanged || isSizeChanged || isTransformChanged || isStrokeChanged) {
                this.pointId = pointId;
                this.pointCount = points.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                var pointCount = this.pointCount;
                var pointsValues = points.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var clippings = buffer.clippings;
                var internalTransform = shape.transform.internalTransform;
                var antialiasWeight = this.antialiasWeight;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    buildCircleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, CIRCLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    buildCircleStep(steps, clippings, voffset, strokeWidth, antialiasWeight, CIRCLE_WORLD_SIZE);
                    copyStep(steps, voffset, CIRCLE_VERTEX_COUNT, pointCount);
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * CIRCLE_VERTEX_COUNT;
                        buildCircleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                        buildCircleStep(steps, clippings, iv, strokeWidth, antialiasWeight, CIRCLE_WORLD_SIZE);
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * CIRCLE_VERTEX_COUNT;
                var vcountReserved = CIRCLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
            }
        };
        EShapeLineOfCirclesUploaded.prototype.updateUv = function (buffer, shape) {
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var uvs = buffer.uvs;
                var voffset = this.vertexOffset;
                var textureUvs = this.toTextureUvs(texture);
                var pointCountReserved = this.pointCountReserved;
                if (0 < pointCountReserved) {
                    buildCircleUv(uvs, voffset, textureUvs);
                    copyUvs(uvs, voffset, CIRCLE_VERTEX_COUNT, pointCountReserved);
                }
            }
        };
        return EShapeLineOfCirclesUploaded;
    }(EShapeLineOfAnyUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfCirclesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, CIRCLE_VERTEX_COUNT, ioffset, CIRCLE_INDEX_COUNT, antialiasWeight, EShapeLineOfCirclesUploaded);
    };

    var toHitThreshold = function (target, toThreshold) {
        var stroke = target.stroke;
        var size = target.points.size.getLimit() + (stroke.enable ? stroke.width * stroke.align : 0);
        return (toThreshold ?
            toThreshold(size, 1) :
            size * 0.5);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfCircles = /** @class */ (function (_super) {
        __extends(EShapeLineOfCircles, _super);
        function EShapeLineOfCircles(other) {
            var _this = _super.call(this, EShapeType.LINE_OF_CIRCLES) || this;
            if (other) {
                _this.copy(other);
            }
            else {
                _this.points = new EShapeLineOfAnyPointsImpl(_this);
            }
            _this._tester = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py);
            };
            _this._testerBBox = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbsBBox(x, y, ax, ay, ox, oy, px, py);
            };
            return _this;
        }
        EShapeLineOfCircles.prototype.clone = function () {
            return new EShapeLineOfCircles(this);
        };
        EShapeLineOfCircles.prototype.containsAbs = function (x, y, ax, ay) {
            var threshold = toHitThreshold(this, null);
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this.points.calcHitPointAbs(x, y, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfCircles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfCircles.prototype.containsPointAbsBBox = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbsBBox.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfCircles.prototype.calcHitPoint = function (point, toThreshold, range, tester, result) {
            var rect = this.toLocalRect(point, EShapeBase.WORK_RECT);
            var threshold = toHitThreshold(this, toThreshold);
            if (this.containsAbsBBox(rect.x, rect.y, rect.width + threshold, rect.height + threshold)) {
                return this.points.calcHitPointAbs(rect.x, rect.y, threshold, range, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfCircles;
    }(EShapeCircle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfCircles = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLineOfCircles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfCircles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_CIRCLES] = createLineOfCirclesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_CIRCLES] = deserializeLineOfCircles;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCapability;
    (function (EShapeCapability) {
        EShapeCapability[EShapeCapability["NONE"] = 0] = "NONE";
        EShapeCapability[EShapeCapability["ID"] = 1] = "ID";
        EShapeCapability[EShapeCapability["POSITION"] = 2] = "POSITION";
        EShapeCapability[EShapeCapability["WIDTH"] = 4] = "WIDTH";
        EShapeCapability[EShapeCapability["HEIGHT"] = 8] = "HEIGHT";
        EShapeCapability[EShapeCapability["ROTATION"] = 16] = "ROTATION";
        EShapeCapability[EShapeCapability["SKEW"] = 32] = "SKEW";
        EShapeCapability[EShapeCapability["ALIGN"] = 64] = "ALIGN";
        EShapeCapability[EShapeCapability["REPLACING"] = 128] = "REPLACING";
        EShapeCapability[EShapeCapability["GROUPING"] = 256] = "GROUPING";
        EShapeCapability[EShapeCapability["FILL"] = 512] = "FILL";
        EShapeCapability[EShapeCapability["STROKE"] = 1024] = "STROKE";
        EShapeCapability[EShapeCapability["STROKE_SIDE"] = 2048] = "STROKE_SIDE";
        EShapeCapability[EShapeCapability["BORDER_RADIUS"] = 4096] = "BORDER_RADIUS";
        EShapeCapability[EShapeCapability["TEXT"] = 8192] = "TEXT";
        EShapeCapability[EShapeCapability["TEXTURE"] = 16384] = "TEXTURE";
        EShapeCapability[EShapeCapability["TAG"] = 32768] = "TAG";
        EShapeCapability[EShapeCapability["ACTION"] = 65536] = "ACTION";
        EShapeCapability[EShapeCapability["CURSOR"] = 131072] = "CURSOR";
        EShapeCapability[EShapeCapability["ORDER_IN_LAYER"] = 262144] = "ORDER_IN_LAYER";
        EShapeCapability[EShapeCapability["COORDINATE"] = 127] = "COORDINATE";
        EShapeCapability[EShapeCapability["SHAPE"] = 1920] = "SHAPE";
        EShapeCapability[EShapeCapability["SHAPE_ROUNDED"] = 6016] = "SHAPE_ROUNDED";
        EShapeCapability[EShapeCapability["SHAPE_SIDED"] = 3968] = "SHAPE_SIDED";
        EShapeCapability[EShapeCapability["SHAPE_SIDED_AND_ROUNDED"] = 8064] = "SHAPE_SIDED_AND_ROUNDED";
        EShapeCapability[EShapeCapability["LAYER"] = 262144] = "LAYER";
        EShapeCapability[EShapeCapability["PRIMITIVE"] = 518143] = "PRIMITIVE";
        EShapeCapability[EShapeCapability["SHADOW"] = 0] = "SHADOW";
        EShapeCapability[EShapeCapability["ALL"] = 524287] = "ALL";
    })(EShapeCapability || (EShapeCapability = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCapabilities = /** @class */ (function () {
        function EShapeCapabilities() {
        }
        EShapeCapabilities.get = function (type) {
            return this.mappings[type] || EShapeCapability.PRIMITIVE;
        };
        EShapeCapabilities.contains = function (shape, capability) {
            if (shape != null) {
                if (this.get(shape.type) & capability) {
                    return true;
                }
                var children = shape.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    if (this.contains(children[i], capability)) {
                        return true;
                    }
                }
            }
            return false;
        };
        EShapeCapabilities.set = function (type, capability) {
            this.mappings[type] = capability;
        };
        EShapeCapabilities.mappings = {};
        return EShapeCapabilities;
    }());

    var RECTANGLE_ROUNDED_VERTEX_COUNT = 36;
    var RECTANGLE_ROUNDED_INDEX_COUNT = 24;
    var RECTANGLE_ROUNDED_WORLD_SIZE = [0, 0, 0];
    var RECTANGLE_ROUNDED_WORK_POINT = new pixi_js.Point();
    var buildRectangleRoundedIndex = function (indices, voffset, ioffset) {
        // Top-left corner
        var ii = ioffset * 3;
        indices[ii + 0] = voffset + 0;
        indices[ii + 1] = voffset + 1;
        indices[ii + 2] = voffset + 2;
        indices[ii + 3] = voffset + 1;
        indices[ii + 4] = voffset + 3;
        indices[ii + 5] = voffset + 2;
        ii += 6;
        // Top-right corner
        indices[ii + 0] = voffset + 4;
        indices[ii + 1] = voffset + 5;
        indices[ii + 2] = voffset + 6;
        indices[ii + 3] = voffset + 5;
        indices[ii + 4] = voffset + 7;
        indices[ii + 5] = voffset + 6;
        ii += 6;
        // Bottom-left corner
        indices[ii + 0] = voffset + 8;
        indices[ii + 1] = voffset + 9;
        indices[ii + 2] = voffset + 10;
        indices[ii + 3] = voffset + 9;
        indices[ii + 4] = voffset + 11;
        indices[ii + 5] = voffset + 10;
        ii += 6;
        // Bottom-right corner
        indices[ii + 0] = voffset + 12;
        indices[ii + 1] = voffset + 13;
        indices[ii + 2] = voffset + 14;
        indices[ii + 3] = voffset + 13;
        indices[ii + 4] = voffset + 15;
        indices[ii + 5] = voffset + 14;
        ii += 6;
        // Top edge
        indices[ii + 0] = voffset + 16;
        indices[ii + 1] = voffset + 17;
        indices[ii + 2] = voffset + 20;
        indices[ii + 3] = voffset + 17;
        indices[ii + 4] = voffset + 21;
        indices[ii + 5] = voffset + 20;
        ii += 6;
        indices[ii + 0] = voffset + 17;
        indices[ii + 1] = voffset + 18;
        indices[ii + 2] = voffset + 21;
        indices[ii + 3] = voffset + 18;
        indices[ii + 4] = voffset + 22;
        indices[ii + 5] = voffset + 21;
        ii += 6;
        // Upper middle
        indices[ii + 0] = voffset + 19;
        indices[ii + 1] = voffset + 21;
        indices[ii + 2] = voffset + 24;
        indices[ii + 3] = voffset + 21;
        indices[ii + 4] = voffset + 25;
        indices[ii + 5] = voffset + 24;
        ii += 6;
        indices[ii + 0] = voffset + 21;
        indices[ii + 1] = voffset + 23;
        indices[ii + 2] = voffset + 26;
        indices[ii + 3] = voffset + 23;
        indices[ii + 4] = voffset + 27;
        indices[ii + 5] = voffset + 26;
        ii += 6;
        // Lower middle
        indices[ii + 0] = voffset + 24;
        indices[ii + 1] = voffset + 25;
        indices[ii + 2] = voffset + 28;
        indices[ii + 3] = voffset + 25;
        indices[ii + 4] = voffset + 30;
        indices[ii + 5] = voffset + 28;
        ii += 6;
        indices[ii + 0] = voffset + 26;
        indices[ii + 1] = voffset + 27;
        indices[ii + 2] = voffset + 30;
        indices[ii + 3] = voffset + 27;
        indices[ii + 4] = voffset + 32;
        indices[ii + 5] = voffset + 30;
        ii += 6;
        // Bottom edge
        indices[ii + 0] = voffset + 29;
        indices[ii + 1] = voffset + 30;
        indices[ii + 2] = voffset + 33;
        indices[ii + 3] = voffset + 30;
        indices[ii + 4] = voffset + 34;
        indices[ii + 5] = voffset + 33;
        ii += 6;
        indices[ii + 0] = voffset + 30;
        indices[ii + 1] = voffset + 31;
        indices[ii + 2] = voffset + 34;
        indices[ii + 3] = voffset + 31;
        indices[ii + 4] = voffset + 35;
        indices[ii + 5] = voffset + 34;
    };
    var buildRectangleRoundedVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, radius, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        //  0   1       4   5
        // |---|       |---|
        // |2  |3      |6  |7
        // |---|       |---|
        //
        //
        //
        //
        //
        // |---|       |---|
        // |8  |9      |12 |13
        // |---|       |---|
        //  10  11      14  15
        //
        //
        //      16  17  18       <-- Top edge
        //     |---|---|
        //  19 |20 |21 |22  23   <-- Top
        // |---|---|---|---|
        // |       |       |
        // |24   25|26     |27   <-- Middle
        // |-------|-------|
        // |       |       |
        // |       |       |
        // |---|---|---|---|
        //  28 |29 |30 |31  32   <-- Bottom
        //     |---|---|
        //      33  34  35       <-- Bottom edge
        //
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var ax = Math.abs(sx);
        var ay = Math.abs(sy);
        var a = radius * Math.min(ax, ay);
        var rx = a / ax;
        var ry = a / ay;
        var work = RECTANGLE_ROUNDED_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x2 = work.x;
        var y2 = work.y;
        var dxh = x2 - x0;
        var dyh = y2 - y0;
        var dxhr = rx * dxh;
        var dyhr = rx * dyh;
        var x1 = x0 + dxhr;
        var y1 = y0 + dyhr;
        var x4 = x2 + dxh;
        var y4 = y2 + dyh;
        var x3 = x4 - dxhr;
        var y3 = y4 - dyhr;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var x11 = work.x;
        var y11 = work.y;
        var dxv = x11 - x2;
        var dyv = y11 - y2;
        var dxvr = ry * dxv;
        var dyvr = ry * dyv;
        var x7 = x2 + dxvr;
        var y7 = y2 + dyvr;
        var x5 = x7 - dxh;
        var y5 = y7 - dyh;
        var x6 = x5 + dxhr;
        var y6 = y5 + dyhr;
        var x9 = x7 + dxh;
        var y9 = y7 + dyh;
        var x8 = x9 - dxhr;
        var y8 = y9 - dyhr;
        var x10 = x11 - dxh;
        var y10 = y11 - dyh;
        var x12 = x11 + dxh;
        var y12 = y11 + dyh;
        var x20 = x11 + dxv;
        var y20 = y11 + dyv;
        var x15 = x20 - dxvr;
        var y15 = y20 - dyvr;
        var x13 = x15 - dxh;
        var y13 = y15 - dyh;
        var x14 = x13 + dxhr;
        var y14 = y13 + dyhr;
        var x17 = x15 + dxh;
        var y17 = y15 + dyh;
        var x16 = x17 - dxhr;
        var y16 = y17 - dyhr;
        var x18 = x20 - dxh;
        var y18 = y20 - dyh;
        var x19 = x18 + dxhr;
        var y19 = y18 + dyhr;
        var x22 = x20 + dxh;
        var y22 = y20 + dyh;
        var x21 = x22 - dxhr;
        var y21 = y22 - dyhr;
        // World size
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x2, y2);
        worldSize[2] = toLength(x0, y0, x10, y10);
        // Vertices
        var iv = voffset * 2;
        // Top-left corner
        vertices[iv + 0] = x0;
        vertices[iv + 1] = y0;
        vertices[iv + 2] = x1;
        vertices[iv + 3] = y1;
        vertices[iv + 4] = x5;
        vertices[iv + 5] = y5;
        vertices[iv + 6] = x6;
        vertices[iv + 7] = y6;
        iv += 8;
        // Top-right corner
        vertices[iv + 0] = x3;
        vertices[iv + 1] = y3;
        vertices[iv + 2] = x4;
        vertices[iv + 3] = y4;
        vertices[iv + 4] = x8;
        vertices[iv + 5] = y8;
        vertices[iv + 6] = x9;
        vertices[iv + 7] = y9;
        iv += 8;
        // Bottom-left corner
        vertices[iv + 0] = x13;
        vertices[iv + 1] = y13;
        vertices[iv + 2] = x14;
        vertices[iv + 3] = y14;
        vertices[iv + 4] = x18;
        vertices[iv + 5] = y18;
        vertices[iv + 6] = x19;
        vertices[iv + 7] = y19;
        iv += 8;
        // Bottom-right corner
        vertices[iv + 0] = x16;
        vertices[iv + 1] = y16;
        vertices[iv + 2] = x17;
        vertices[iv + 3] = y17;
        vertices[iv + 4] = x21;
        vertices[iv + 5] = y21;
        vertices[iv + 6] = x22;
        vertices[iv + 7] = y22;
        iv += 8;
        // Top edge
        vertices[iv + 0] = x1;
        vertices[iv + 1] = y1;
        vertices[iv + 2] = x2;
        vertices[iv + 3] = y2;
        vertices[iv + 4] = x3;
        vertices[iv + 5] = y3;
        iv += 6;
        // Top
        vertices[iv + 0] = x5;
        vertices[iv + 1] = y5;
        vertices[iv + 2] = x6;
        vertices[iv + 3] = y6;
        vertices[iv + 4] = x7;
        vertices[iv + 5] = y7;
        vertices[iv + 6] = x8;
        vertices[iv + 7] = y8;
        vertices[iv + 8] = x9;
        vertices[iv + 9] = y9;
        iv += 10;
        // Middle
        vertices[iv + 0] = x10;
        vertices[iv + 1] = y10;
        vertices[iv + 2] = x11;
        vertices[iv + 3] = y11;
        vertices[iv + 4] = x11;
        vertices[iv + 5] = y11;
        vertices[iv + 6] = x12;
        vertices[iv + 7] = y12;
        iv += 8;
        // Bottom
        vertices[iv + 0] = x13;
        vertices[iv + 1] = y13;
        vertices[iv + 2] = x14;
        vertices[iv + 3] = y14;
        vertices[iv + 4] = x15;
        vertices[iv + 5] = y15;
        vertices[iv + 6] = x16;
        vertices[iv + 7] = y16;
        vertices[iv + 8] = x17;
        vertices[iv + 9] = y17;
        iv += 10;
        // Bottom edge
        vertices[iv + 0] = x19;
        vertices[iv + 1] = y19;
        vertices[iv + 2] = x20;
        vertices[iv + 3] = y20;
        vertices[iv + 4] = x21;
        vertices[iv + 5] = y21;
    };
    var buildRectangleRoundedClipping = function (clippings, voffset, corner, worldSize) {
        var ic = voffset * 3;
        var rxc = 1 - worldSize[0] / worldSize[1];
        var ryc = 1 - worldSize[0] / worldSize[2];
        // Top-left corner
        if (corner & EShapeCorner.TOP_LEFT) {
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 0;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 0;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 1;
            ic += 3;
        }
        else {
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = rxc;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = ryc;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = rxc;
            clippings[ic + 1] = ryc;
            clippings[ic + 2] = 0;
            ic += 3;
        }
        // Top-right corner
        if (corner & EShapeCorner.TOP_RIGHT) {
            clippings[ic + 0] = 0;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 0;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 1;
            ic += 3;
        }
        else {
            clippings[ic + 0] = rxc;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = rxc;
            clippings[ic + 1] = ryc;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = ryc;
            clippings[ic + 2] = 0;
            ic += 3;
        }
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 0;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 0;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 1;
            ic += 3;
        }
        else {
            clippings[ic + 0] = 1;
            clippings[ic + 1] = ryc;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = rxc;
            clippings[ic + 1] = ryc;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = rxc;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 0;
            ic += 3;
        }
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            clippings[ic + 0] = 0;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 0;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 0;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 1;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 1;
            ic += 3;
        }
        else {
            clippings[ic + 0] = rxc;
            clippings[ic + 1] = ryc;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = ryc;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = rxc;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 0;
            ic += 3;
            clippings[ic + 0] = 1;
            clippings[ic + 1] = 1;
            clippings[ic + 2] = 0;
            ic += 3;
        }
        // Top edge
        clippings[ic + 0] = rxc;
        clippings[ic + 1] = 1;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = 0;
        clippings[ic + 1] = 1;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = rxc;
        clippings[ic + 1] = 1;
        clippings[ic + 2] = 0;
        ic += 3;
        // Top
        clippings[ic + 0] = 1;
        clippings[ic + 1] = ryc;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = rxc;
        clippings[ic + 1] = ryc;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = 0;
        clippings[ic + 1] = ryc;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = rxc;
        clippings[ic + 1] = ryc;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = 1;
        clippings[ic + 1] = ryc;
        clippings[ic + 2] = 0;
        ic += 3;
        // Middle
        clippings[ic + 0] = 1;
        clippings[ic + 1] = 0;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = 0;
        clippings[ic + 1] = 0;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = 0;
        clippings[ic + 1] = 0;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = 1;
        clippings[ic + 1] = 0;
        clippings[ic + 2] = 0;
        ic += 3;
        // Bottom
        clippings[ic + 0] = 1;
        clippings[ic + 1] = ryc;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = rxc;
        clippings[ic + 1] = ryc;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = 0;
        clippings[ic + 1] = ryc;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = rxc;
        clippings[ic + 1] = ryc;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = 1;
        clippings[ic + 1] = ryc;
        clippings[ic + 2] = 0;
        ic += 3;
        // Bottom edge
        clippings[ic + 0] = rxc;
        clippings[ic + 1] = 1;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = 0;
        clippings[ic + 1] = 1;
        clippings[ic + 2] = 0;
        ic += 3;
        clippings[ic + 0] = rxc;
        clippings[ic + 1] = 1;
        clippings[ic + 2] = 0;
        ic += 3;
    };
    var buildRectangleRoundedStep = function (steps, voffset, strokeWidth, strokeSide, corner, antialiasWeight, worldSize) {
        toStep(worldSize[0], strokeWidth, antialiasWeight, STEP_VALUES);
        var swc = STEP_VALUES[0];
        var pc0 = STEP_VALUES[1];
        var pc1 = STEP_VALUES[2];
        toStep(worldSize[1], strokeWidth, antialiasWeight, STEP_VALUES);
        var swx = STEP_VALUES[0];
        var px0 = STEP_VALUES[1];
        var px1 = STEP_VALUES[2];
        toStep(worldSize[2], strokeWidth, antialiasWeight, STEP_VALUES);
        var swy = STEP_VALUES[0];
        var py0 = STEP_VALUES[1];
        var py1 = STEP_VALUES[2];
        var rxc = 1 - worldSize[0] / worldSize[1];
        var ryc = 1 - worldSize[0] / worldSize[2];
        var swt = swy;
        var pt0 = py0;
        var swtc = swc;
        var ptc0 = pc0;
        if (!(strokeSide & EShapeStrokeSide.TOP)) {
            swt = 1;
            pt0 = py1;
            swtc = 1;
            ptc0 = pc1;
        }
        var swr = swx;
        var pr0 = px0;
        var swrc = swc;
        var prc0 = pc0;
        if (!(strokeSide & EShapeStrokeSide.RIGHT)) {
            swr = 1;
            pr0 = px1;
            swrc = 1;
            prc0 = pc1;
        }
        var swb = swy;
        var pb0 = py0;
        var swbc = swc;
        var pbc0 = pc0;
        if (!(strokeSide & EShapeStrokeSide.BOTTOM)) {
            swb = 1;
            pb0 = py1;
            swbc = 1;
            pbc0 = pc1;
        }
        var swl = swx;
        var pl0 = px0;
        var swlc = swc;
        var plc0 = pc0;
        if (!(strokeSide & EShapeStrokeSide.LEFT)) {
            swl = 1;
            pl0 = px1;
            swlc = 1;
            plc0 = pc1;
        }
        var plr0 = 0.5 * (pl0 + pr0);
        var ptb0 = 0.5 * (pt0 + pb0);
        // Top-left corner
        var is = voffset * 6;
        if (corner & EShapeCorner.TOP_LEFT) {
            steps[is + 0] = swlc;
            steps[is + 1] = swtc;
            steps[is + 2] = plc0;
            steps[is + 3] = ptc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = 0;
            steps[is + 1] = swtc;
            steps[is + 2] = plc0;
            steps[is + 3] = ptc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = swlc;
            steps[is + 1] = 0;
            steps[is + 2] = plc0;
            steps[is + 3] = ptc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = 0;
            steps[is + 1] = 0;
            steps[is + 2] = plc0;
            steps[is + 3] = ptc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
        }
        else {
            steps[is + 0] = swl;
            steps[is + 1] = swt;
            steps[is + 2] = pl0;
            steps[is + 3] = pt0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swl * rxc;
            steps[is + 1] = swt;
            steps[is + 2] = pl0;
            steps[is + 3] = pt0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swl;
            steps[is + 1] = swt * ryc;
            steps[is + 2] = pl0;
            steps[is + 3] = pt0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swl * rxc;
            steps[is + 1] = swt * ryc;
            steps[is + 2] = pl0;
            steps[is + 3] = pt0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
        }
        // Top-right corner
        if (corner & EShapeCorner.TOP_RIGHT) {
            steps[is + 0] = 0;
            steps[is + 1] = swtc;
            steps[is + 2] = prc0;
            steps[is + 3] = ptc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = swrc;
            steps[is + 1] = swtc;
            steps[is + 2] = prc0;
            steps[is + 3] = ptc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = 0;
            steps[is + 1] = 0;
            steps[is + 2] = prc0;
            steps[is + 3] = ptc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = swrc;
            steps[is + 1] = 0;
            steps[is + 2] = prc0;
            steps[is + 3] = ptc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
        }
        else {
            steps[is + 0] = swr * rxc;
            steps[is + 1] = swt;
            steps[is + 2] = pr0;
            steps[is + 3] = pt0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swr;
            steps[is + 1] = swt;
            steps[is + 2] = pr0;
            steps[is + 3] = pt0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swr * rxc;
            steps[is + 1] = swt * ryc;
            steps[is + 2] = pr0;
            steps[is + 3] = pt0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swr;
            steps[is + 1] = swt * ryc;
            steps[is + 2] = pr0;
            steps[is + 3] = pt0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
        }
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            steps[is + 0] = swlc;
            steps[is + 1] = 0;
            steps[is + 2] = plc0;
            steps[is + 3] = pbc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = 0;
            steps[is + 1] = 0;
            steps[is + 2] = plc0;
            steps[is + 3] = pbc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = swlc;
            steps[is + 1] = swbc;
            steps[is + 2] = plc0;
            steps[is + 3] = pbc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = 0;
            steps[is + 1] = swbc;
            steps[is + 2] = plc0;
            steps[is + 3] = pbc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
        }
        else {
            steps[is + 0] = swl;
            steps[is + 1] = swb * ryc;
            steps[is + 2] = pl0;
            steps[is + 3] = pb0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swl * rxc;
            steps[is + 1] = swb * ryc;
            steps[is + 2] = pl0;
            steps[is + 3] = pb0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swl;
            steps[is + 1] = swb;
            steps[is + 2] = pl0;
            steps[is + 3] = pb0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swl * rxc;
            steps[is + 1] = swb;
            steps[is + 2] = pl0;
            steps[is + 3] = pb0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
        }
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            steps[is + 0] = 0;
            steps[is + 1] = 0;
            steps[is + 2] = prc0;
            steps[is + 3] = pbc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = swrc;
            steps[is + 1] = 0;
            steps[is + 2] = prc0;
            steps[is + 3] = pbc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = 0;
            steps[is + 1] = swbc;
            steps[is + 2] = prc0;
            steps[is + 3] = pbc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
            steps[is + 0] = swrc;
            steps[is + 1] = swbc;
            steps[is + 2] = prc0;
            steps[is + 3] = pbc0;
            steps[is + 4] = pc1;
            steps[is + 5] = pc1;
            is += 6;
        }
        else {
            steps[is + 0] = swr * rxc;
            steps[is + 1] = swb * ryc;
            steps[is + 2] = pr0;
            steps[is + 3] = pb0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swr;
            steps[is + 1] = swb * ryc;
            steps[is + 2] = pr0;
            steps[is + 3] = pb0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swr * rxc;
            steps[is + 1] = swb;
            steps[is + 2] = pr0;
            steps[is + 3] = pb0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
            steps[is + 0] = swr;
            steps[is + 1] = swb;
            steps[is + 2] = pr0;
            steps[is + 3] = pb0;
            steps[is + 4] = px1;
            steps[is + 5] = py1;
            is += 6;
        }
        // Top edge
        steps[is + 0] = swl * rxc;
        steps[is + 1] = swt;
        steps[is + 2] = pl0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = 0;
        steps[is + 1] = swt;
        steps[is + 2] = plr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = swr * rxc;
        steps[is + 1] = swt;
        steps[is + 2] = plr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // Top
        steps[is + 0] = swl;
        steps[is + 1] = swt * ryc;
        steps[is + 2] = pl0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = swl * rxc;
        steps[is + 1] = swt * ryc;
        steps[is + 2] = pl0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = 0;
        steps[is + 1] = swt * ryc;
        steps[is + 2] = plr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = swr * rxc;
        steps[is + 1] = swt * ryc;
        steps[is + 2] = pr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = swr;
        steps[is + 1] = swt * ryc;
        steps[is + 2] = pr0;
        steps[is + 3] = pt0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // Middle
        steps[is + 0] = swl;
        steps[is + 1] = 0;
        steps[is + 2] = pl0;
        steps[is + 3] = ptb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = 0;
        steps[is + 1] = 0;
        steps[is + 2] = pl0;
        steps[is + 3] = ptb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = 0;
        steps[is + 1] = 0;
        steps[is + 2] = pr0;
        steps[is + 3] = ptb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = swr;
        steps[is + 1] = 0;
        steps[is + 2] = pr0;
        steps[is + 3] = ptb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // Bottom
        steps[is + 0] = swl;
        steps[is + 1] = swb * ryc;
        steps[is + 2] = pl0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = swl * rxc;
        steps[is + 1] = swb * ryc;
        steps[is + 2] = pl0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = 0;
        steps[is + 1] = swb * ryc;
        steps[is + 2] = plr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = swr * rxc;
        steps[is + 1] = swb * ryc;
        steps[is + 2] = pr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = swr;
        steps[is + 1] = swb * ryc;
        steps[is + 2] = pr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        // Bottom edge
        steps[is + 0] = swl * rxc;
        steps[is + 1] = swb;
        steps[is + 2] = pl0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = 0;
        steps[is + 1] = swb;
        steps[is + 2] = plr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
        steps[is + 0] = swr * rxc;
        steps[is + 1] = swb;
        steps[is + 2] = pr0;
        steps[is + 3] = pb0;
        steps[is + 4] = px1;
        steps[is + 5] = py1;
        is += 6;
    };
    var buildRectangleRoundedUv = function (uvs, voffset, textureUvs, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var x5 = 0.5 * (x3 + x2);
        var y5 = 0.5 * (y3 + y2);
        var ruvx = 0.5 * worldSize[0] / worldSize[1];
        var ruvy = 0.5 * worldSize[0] / worldSize[2];
        var d0x = ruvx * (x1 - x0);
        var d0y = ruvx * (y1 - y0);
        var d1x = ruvy * (x3 - x0);
        var d1y = ruvy * (y3 - y0);
        // UVs
        var iuv = voffset * 2;
        // Top-left corner
        uvs[iuv + 0] = x0;
        uvs[iuv + 1] = y0;
        uvs[iuv + 2] = x0 + d0x;
        uvs[iuv + 3] = y0 + d0y;
        uvs[iuv + 4] = x0 + d1x;
        uvs[iuv + 5] = y0 + d1y;
        uvs[iuv + 6] = x0 + d0x + d1x;
        uvs[iuv + 7] = y0 + d0y + d1y;
        iuv += 8;
        // Top-right corner
        uvs[iuv + 0] = x1 - d0x;
        uvs[iuv + 1] = y1 - d0y;
        uvs[iuv + 2] = x1;
        uvs[iuv + 3] = y1;
        uvs[iuv + 4] = x1 - d0x + d1x;
        uvs[iuv + 5] = y1 - d0y + d1y;
        uvs[iuv + 6] = x1 + d1x;
        uvs[iuv + 7] = y1 + d1y;
        iuv += 8;
        // Bottom-left corner
        uvs[iuv + 0] = x3 - d1x;
        uvs[iuv + 1] = y3 - d1y;
        uvs[iuv + 2] = x3 + d0x - d1x;
        uvs[iuv + 3] = y3 + d0y - d1y;
        uvs[iuv + 4] = x3;
        uvs[iuv + 5] = y3;
        uvs[iuv + 6] = x3 + d0x;
        uvs[iuv + 7] = y3 + d0y;
        iuv += 8;
        // Bottom-right corner
        uvs[iuv + 0] = x2 - d0x - d1x;
        uvs[iuv + 1] = y2 - d0y - d1y;
        uvs[iuv + 2] = x2 - d1x;
        uvs[iuv + 3] = y2 - d1y;
        uvs[iuv + 4] = x2 - d0x;
        uvs[iuv + 5] = y2 - d0y;
        uvs[iuv + 6] = x2;
        uvs[iuv + 7] = y2;
        iuv += 8;
        // Top edge
        uvs[iuv + 0] = x0 + d0x;
        uvs[iuv + 1] = y0 + d0y;
        uvs[iuv + 2] = x4;
        uvs[iuv + 3] = y4;
        uvs[iuv + 4] = x1 - d0x;
        uvs[iuv + 5] = y1 - d0y;
        iuv += 6;
        // Top
        uvs[iuv + 0] = x0 + d1x;
        uvs[iuv + 1] = y0 + d1y;
        uvs[iuv + 2] = x0 + d1x + d0x;
        uvs[iuv + 3] = y0 + d1y + d0y;
        uvs[iuv + 4] = x4 + d1x;
        uvs[iuv + 5] = y4 + d1y;
        uvs[iuv + 6] = x1 + d1x - d0x;
        uvs[iuv + 7] = y1 + d1y - d0y;
        uvs[iuv + 8] = x1 + d1x;
        uvs[iuv + 9] = y1 + d1y;
        iuv += 10;
        // Middle
        var x02 = 0.5 * (x0 + x2);
        var y02 = 0.5 * (y0 + y2);
        uvs[iuv + 0] = 0.5 * (x0 + x3);
        uvs[iuv + 1] = 0.5 * (y0 + y3);
        uvs[iuv + 2] = x02;
        uvs[iuv + 3] = y02;
        uvs[iuv + 4] = x02;
        uvs[iuv + 5] = y02;
        uvs[iuv + 6] = 0.5 * (x1 + x2);
        uvs[iuv + 7] = 0.5 * (y1 + y2);
        iuv += 8;
        // Bottom
        uvs[iuv + 0] = x3 - d1x;
        uvs[iuv + 1] = y3 - d1y;
        uvs[iuv + 2] = x3 - d1x + d0x;
        uvs[iuv + 3] = y3 - d1y + d0y;
        uvs[iuv + 4] = x5 - d1x;
        uvs[iuv + 5] = y5 - d1y;
        uvs[iuv + 6] = x2 - d1x - d0x;
        uvs[iuv + 7] = y2 - d1y - d0y;
        uvs[iuv + 8] = x2 - d1x;
        uvs[iuv + 9] = y2 - d1y;
        iuv += 10;
        // Bottom edge
        uvs[iuv + 0] = x3 + d0x;
        uvs[iuv + 1] = y3 + d0y;
        uvs[iuv + 2] = x5;
        uvs[iuv + 3] = y5;
        uvs[iuv + 4] = x2 - d0x;
        uvs[iuv + 5] = y2 - d0y;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectangleRoundedsUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectangleRoundedsUploaded, _super);
        function EShapeLineOfRectangleRoundedsUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineOfRectangleRoundedsUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildRectangleRoundedIndex(indices, voffset, ioffset);
                copyIndex(indices, RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset, RECTANGLE_ROUNDED_INDEX_COUNT, pointCountReserved);
            }
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLineOfRectangleRoundedsUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexClippingStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, RECTANGLE_ROUNDED_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, RECTANGLE_ROUNDED_VERTEX_COUNT);
                this.updateText(buffer, shape);
            }
        };
        EShapeLineOfRectangleRoundedsUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = (pointId !== this.pointId || pointOffsetId !== this.pointOffsetId);
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = (pointSizeId !== this.pointSizeId);
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var radius = shape.radius;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY || radius !== this.radius);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var strokeSide = stroke.side;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth || this.strokeSide !== strokeSide);
            var corner = shape.corner;
            var isCornerChanged = (corner !== this.corner);
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = (texture !== this.texture || textureTransformId !== this.textureTransformId);
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.pointId = pointId;
                this.pointCount = points.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeSide = strokeSide;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged || isCornerChanged) {
                    buffer.updateClippings();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = points.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var clippings = buffer.clippings;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = this.toTextureUvs(texture);
                var antialiasWeight = this.antialiasWeight;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildRectangleRoundedVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isVertexChanged || isTransformChanged) {
                        buildRectangleRoundedStep(steps, voffset, strokeWidth, strokeSide, corner, antialiasWeight, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyStep(steps, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // Clippings
                    if (isVertexChanged || isCornerChanged) {
                        buildRectangleRoundedClipping(clippings, voffset, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyClipping(clippings, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isVertexChanged || isTextureChanged) {
                        buildRectangleRoundedUv(uvs, voffset, textureUvs, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyUvs(uvs, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * RECTANGLE_ROUNDED_VERTEX_COUNT;
                        // Vertices
                        buildRectangleRoundedVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                        // Steps
                        if (isVertexChanged || isTransformChanged) {
                            buildRectangleRoundedStep(steps, iv, strokeWidth, strokeSide, corner, antialiasWeight, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // Clippings
                        if (isVertexChanged || isCornerChanged) {
                            buildRectangleRoundedClipping(clippings, iv, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // UVs
                        if (isVertexChanged || isTextureChanged) {
                            buildRectangleRoundedUv(uvs, iv, textureUvs, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * RECTANGLE_ROUNDED_VERTEX_COUNT;
                var vcountReserved = RECTANGLE_ROUNDED_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullClipping(clippings, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return EShapeLineOfRectangleRoundedsUploaded;
    }(EShapeLineOfAnyUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfRectangleRoundedsUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset, RECTANGLE_ROUNDED_INDEX_COUNT, antialiasWeight, EShapeLineOfRectangleRoundedsUploaded);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangleRounded = /** @class */ (function (_super) {
        __extends(EShapeRectangleRounded, _super);
        function EShapeRectangleRounded(type) {
            if (type === void 0) { type = EShapeType.RECTANGLE_ROUNDED; }
            return _super.call(this, type) || this;
        }
        EShapeRectangleRounded.prototype.clone = function () {
            return new EShapeRectangleRounded().copy(this);
        };
        EShapeRectangleRounded.prototype.containsAbs_ = function (x, y, ax, ay, r, corner) {
            var bx0 = -ax + r;
            if (x <= bx0) {
                var by0 = -ay + r;
                if (y <= by0 && (corner & EShapeCorner.TOP_LEFT)) {
                    // Top-left corner
                    var dx = x - bx0;
                    var dy = y - by0;
                    return dx * dx + dy * dy <= r * r;
                }
                else {
                    var by1 = +ay - r;
                    if (by1 <= y && (corner & EShapeCorner.BOTTOM_LEFT)) {
                        // Bottom-left corner
                        var dx = x - bx0;
                        var dy = y - by1;
                        return dx * dx + dy * dy <= r * r;
                    }
                    else {
                        // Middle-left box
                        return -ax <= x;
                    }
                }
            }
            else {
                var bx1 = +ax - r;
                if (bx1 <= x) {
                    var by0 = -ay + r;
                    if (y <= by0 && (corner & EShapeCorner.TOP_RIGHT)) {
                        // Top-right corner
                        var dx = x - bx1;
                        var dy = y - by0;
                        return dx * dx + dy * dy <= r * r;
                    }
                    else {
                        var by1 = +ay - r;
                        if (by1 <= y && (corner & EShapeCorner.BOTTOM_RIGHT)) {
                            // Bottom-right corner
                            var dx = x - bx1;
                            var dy = y - by1;
                            return dx * dx + dy * dy <= r * r;
                        }
                        else {
                            // Middle-right box
                            return x <= +ax;
                        }
                    }
                }
                else {
                    return -ay <= y && y <= +ay;
                }
            }
        };
        EShapeRectangleRounded.prototype.containsAbs = function (x, y, ax, ay) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                var fill = this.fill;
                var stroke = this.stroke;
                var strokeWidth = (stroke.enable ? stroke.width : 0);
                if (fill.enable || 0 < strokeWidth) {
                    var r = this.radius * Math.min(ax, ay);
                    var corner = this.corner;
                    var strokeSide = stroke.side;
                    if (this.containsAbs_(x, y, ax, ay, r, corner)) {
                        if (fill.enable) {
                            return true;
                        }
                        else {
                            var wx = Math.max(0.0, ax - strokeWidth);
                            var wy = Math.max(0.0, ay - strokeWidth);
                            var wr = Math.max(0.0, r - strokeWidth);
                            if (!this.containsAbs_(x, y, wx, wy, wr, corner)) {
                                if (strokeSide === EShapeStrokeSide.ALL) {
                                    return true;
                                }
                                else {
                                    if (x <= -wx + wr) {
                                        var hasLeftSide = (strokeSide & EShapeStrokeSide.LEFT) !== 0;
                                        if (y <= -wy + wr) {
                                            var hasTopSide = (strokeSide & EShapeStrokeSide.TOP);
                                            if (hasTopSide && hasLeftSide) {
                                                return true;
                                            }
                                            else if (hasTopSide) {
                                                return -wx <= y;
                                            }
                                            else if (hasLeftSide) {
                                                return x <= -wx;
                                            }
                                            else {
                                                return false;
                                            }
                                        }
                                        else if (+wy - wr <= y) {
                                            var hasBottomSide = (strokeSide & EShapeStrokeSide.BOTTOM);
                                            if (hasBottomSide && hasLeftSide) {
                                                return true;
                                            }
                                            else if (hasBottomSide) {
                                                return +wx <= y;
                                            }
                                            else if (hasLeftSide) {
                                                return x <= -wx;
                                            }
                                            else {
                                                return false;
                                            }
                                        }
                                        else {
                                            return hasLeftSide;
                                        }
                                    }
                                    else if (+wx - wr <= x) {
                                        var hasRightSide = (strokeSide & EShapeStrokeSide.RIGHT) !== 0;
                                        if (y <= -wy + wr) {
                                            var hasTopSide = (strokeSide & EShapeStrokeSide.TOP);
                                            if (hasTopSide && hasRightSide) {
                                                return true;
                                            }
                                            else if (hasTopSide) {
                                                return -wx <= y;
                                            }
                                            else if (hasRightSide) {
                                                return +wx <= x;
                                            }
                                            else {
                                                return false;
                                            }
                                        }
                                        else if (+wy - wr <= y) {
                                            var hasBottomSide = (strokeSide & EShapeStrokeSide.BOTTOM);
                                            if (hasBottomSide && hasRightSide) {
                                                return true;
                                            }
                                            else if (hasBottomSide) {
                                                return +wx <= y;
                                            }
                                            else if (hasRightSide) {
                                                return +wx <= x;
                                            }
                                            else {
                                                return false;
                                            }
                                        }
                                        else {
                                            return hasRightSide;
                                        }
                                    }
                                    else {
                                        if (y <= -wy + wr) {
                                            return (strokeSide & EShapeStrokeSide.TOP) !== 0;
                                        }
                                        else if (+wy - wr <= y) {
                                            return (strokeSide & EShapeStrokeSide.BOTTOM) !== 0;
                                        }
                                        else {
                                            return false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        };
        return EShapeRectangleRounded;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectangleRoundeds = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectangleRoundeds, _super);
        function EShapeLineOfRectangleRoundeds(other) {
            var _this = _super.call(this, EShapeType.LINE_OF_RECTANGLE_ROUNDEDS) || this;
            if (other) {
                _this.copy(other);
            }
            else {
                _this.points = new EShapeLineOfAnyPointsImpl(_this);
            }
            _this._tester = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py);
            };
            _this._testerBBox = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbsBBox(x, y, ax, ay, ox, oy, px, py);
            };
            return _this;
        }
        EShapeLineOfRectangleRoundeds.prototype.clone = function () {
            return new EShapeLineOfRectangleRoundeds(this);
        };
        EShapeLineOfRectangleRoundeds.prototype.containsAbs = function (x, y, ax, ay) {
            var threshold = toHitThreshold(this, null);
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this.points.calcHitPointAbs(x, y, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfRectangleRoundeds.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfRectangleRoundeds.prototype.containsPointAbsBBox = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbsBBox.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfRectangleRoundeds.prototype.calcHitPoint = function (point, toThreshold, range, tester, result) {
            var rect = this.toLocalRect(point, EShapeBase.WORK_RECT);
            var threshold = toHitThreshold(this, toThreshold);
            if (this.containsAbsBBox(rect.x, rect.y, rect.width + threshold, rect.height + threshold)) {
                return this.points.calcHitPointAbs(rect.x, rect.y, threshold, range, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfRectangleRoundeds;
    }(EShapeRectangleRounded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfRectangleRoundeds = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLineOfRectangleRoundeds());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfRectangleRoundeds = function () {
        EShapeUploadeds[EShapeType.LINE_OF_RECTANGLE_ROUNDEDS] = createLineOfRectangleRoundedsUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_RECTANGLE_ROUNDEDS] = deserializeLineOfRectangleRoundeds;
        EShapeCapabilities.set(EShapeType.LINE_OF_RECTANGLE_ROUNDEDS, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectanglesUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectanglesUploaded, _super);
        function EShapeLineOfRectanglesUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineOfRectanglesUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildRectangleIndex(indices, voffset, ioffset);
                copyIndex(indices, RECTANGLE_VERTEX_COUNT, ioffset, RECTANGLE_INDEX_COUNT, pointCountReserved);
            }
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLineOfRectanglesUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexClippingStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, RECTANGLE_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, RECTANGLE_VERTEX_COUNT);
                this.updateText(buffer, shape);
            }
        };
        EShapeLineOfRectanglesUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = (pointId !== this.pointId || pointOffsetId !== this.pointOffsetId);
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = (pointSizeId !== this.pointSizeId);
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var strokeSide = stroke.side;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth || this.strokeSide !== strokeSide);
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = (texture !== this.texture || textureTransformId !== this.textureTransformId);
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.pointId = pointId;
                this.pointCount = points.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeSide = strokeSide;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged) {
                    buffer.updateClippings();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = points.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var clippings = buffer.clippings;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var antialiasWeight = this.antialiasWeight;
                var textureUvs = this.toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildRectangleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, RECTANGLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isVertexChanged || isTransformChanged) {
                        buildRectangleStep(voffset, steps, strokeWidth, strokeSide, antialiasWeight, RECTANGLE_WORLD_SIZE);
                        copyStep(steps, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                    // Clippings
                    if (isVertexChanged) {
                        buildRectangleClipping(clippings, voffset, RECTANGLE_WORLD_SIZE);
                        copyClipping(clippings, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isVertexChanged || isTextureChanged) {
                        buildRectangleUv(uvs, voffset, textureUvs, RECTANGLE_WORLD_SIZE);
                        copyUvs(uvs, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * RECTANGLE_VERTEX_COUNT;
                        // Vertices
                        buildRectangleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                        // Steps
                        if (isVertexChanged || isTransformChanged) {
                            buildRectangleStep(iv, steps, strokeWidth, strokeSide, antialiasWeight, RECTANGLE_WORLD_SIZE);
                        }
                        // Clippings
                        if (isVertexChanged) {
                            buildRectangleClipping(clippings, iv, RECTANGLE_WORLD_SIZE);
                        }
                        // UVs
                        if (isVertexChanged || isTextureChanged) {
                            buildRectangleUv(uvs, iv, textureUvs, RECTANGLE_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * RECTANGLE_VERTEX_COUNT;
                var vcountReserved = RECTANGLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullClipping(clippings, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return EShapeLineOfRectanglesUploaded;
    }(EShapeLineOfAnyUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfRectanglesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, RECTANGLE_VERTEX_COUNT, ioffset, RECTANGLE_INDEX_COUNT, antialiasWeight, EShapeLineOfRectanglesUploaded);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectangles = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectangles, _super);
        function EShapeLineOfRectangles(other) {
            var _this = _super.call(this, EShapeType.LINE_OF_RECTANGLES) || this;
            if (other) {
                _this.copy(other);
            }
            else {
                _this.points = new EShapeLineOfAnyPointsImpl(_this);
            }
            _this._tester = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py);
            };
            _this._testerBBox = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbsBBox(x, y, ax, ay, ox, oy, px, py);
            };
            return _this;
        }
        EShapeLineOfRectangles.prototype.clone = function () {
            return new EShapeLineOfRectangles(this);
        };
        EShapeLineOfRectangles.prototype.containsAbs = function (x, y, ax, ay) {
            var threshold = toHitThreshold(this, null);
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this.points.calcHitPointAbs(x, y, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfRectangles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfRectangles.prototype.containsPointAbsBBox = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbsBBox.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfRectangles.prototype.calcHitPoint = function (point, toThreshold, range, tester, result) {
            var rect = this.toLocalRect(point, EShapeBase.WORK_RECT);
            var threshold = toHitThreshold(this, toThreshold);
            if (this.containsAbsBBox(rect.x, rect.y, rect.width + threshold, rect.height + threshold)) {
                return this.points.calcHitPointAbs(rect.x, rect.y, threshold, range, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfRectangles;
    }(EShapeRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfRectangles = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLineOfRectangles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfRectangles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_RECTANGLES] = createLineOfRectanglesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_RECTANGLES] = deserializeLineOfRectangles;
        EShapeCapabilities.set(EShapeType.LINE_OF_RECTANGLES, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    var TRIANGLE_ROUNDED_VERTEX_COUNT = 22;
    var TRIANGLE_ROUNDED_INDEX_COUNT = 15;
    var TRIANGLE_ROUNDED_WORLD_SIZE = [0, 0, 0, 0, 0];
    var TRIANGLE_ROUNDED_WORK_POINT = new pixi_js.Point();
    var buildTriangleRoundedIndex = function (indices, voffset, ioffset) {
        // Top corner
        var ii = ioffset * 3;
        indices[ii + 0] = voffset + 0;
        indices[ii + 1] = voffset + 1;
        indices[ii + 2] = voffset + 3;
        indices[ii + 3] = voffset + 1;
        indices[ii + 4] = voffset + 2;
        indices[ii + 5] = voffset + 3;
        // Bottom-right corner
        indices[ii + 6] = voffset + 4;
        indices[ii + 7] = voffset + 5;
        indices[ii + 8] = voffset + 7;
        indices[ii + 9] = voffset + 5;
        indices[ii + 10] = voffset + 6;
        indices[ii + 11] = voffset + 7;
        // Bottom-left corner
        indices[ii + 12] = voffset + 8;
        indices[ii + 13] = voffset + 9;
        indices[ii + 14] = voffset + 11;
        indices[ii + 15] = voffset + 9;
        indices[ii + 16] = voffset + 10;
        indices[ii + 17] = voffset + 11;
        // Others
        indices[ii + 18] = voffset + 12;
        indices[ii + 19] = voffset + 13;
        indices[ii + 20] = voffset + 16;
        indices[ii + 21] = voffset + 13;
        indices[ii + 22] = voffset + 14;
        indices[ii + 23] = voffset + 16;
        indices[ii + 24] = voffset + 14;
        indices[ii + 25] = voffset + 15;
        indices[ii + 26] = voffset + 16;
        //
        indices[ii + 27] = voffset + 12;
        indices[ii + 28] = voffset + 16;
        indices[ii + 29] = voffset + 19;
        indices[ii + 30] = voffset + 16;
        indices[ii + 31] = voffset + 17;
        indices[ii + 32] = voffset + 19;
        indices[ii + 33] = voffset + 17;
        indices[ii + 34] = voffset + 18;
        indices[ii + 35] = voffset + 19;
        //
        indices[ii + 36] = voffset + 12;
        indices[ii + 37] = voffset + 19;
        indices[ii + 38] = voffset + 13;
        indices[ii + 39] = voffset + 19;
        indices[ii + 40] = voffset + 20;
        indices[ii + 41] = voffset + 13;
        indices[ii + 42] = voffset + 20;
        indices[ii + 43] = voffset + 21;
        indices[ii + 44] = voffset + 13;
    };
    var buildTriangleRoundedVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, radius, internalTransform, worldSize) {
        // Calculate the transformed positions
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var sz = Math.sqrt(sx * sx + 4 * sy * sy);
        var sw = 2 * sx * sy / (sx + sz);
        var ry = (sw * radius) / (2 * sy);
        var rz = (0.5 * (sz - sw) * radius) / (sz);
        var rx = (ry * sz) / (2 * sx);
        var work = TRIANGLE_ROUNDED_WORK_POINT;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var tx = work.x;
        var ty = work.y;
        work.set(originX + sx, originY);
        internalTransform.apply(work, work);
        var dx = tx - x1;
        var dy = ty - y1;
        var x4 = work.x + dx;
        var y4 = work.y + dy;
        var x7 = tx + (tx - work.x) + dx;
        var y7 = ty + (ty - work.y) + dy;
        var dx14 = x4 - x1;
        var dy14 = y4 - y1;
        var x2 = x1 + rz * dx14;
        var y2 = y1 + rz * dy14;
        var x3 = x4 - ry * dx14;
        var y3 = y4 - ry * dy14;
        var dx47r = rx * (x7 - x4);
        var dy47r = rx * (y7 - y4);
        var x5 = x4 + dx47r;
        var y5 = y4 + dy47r;
        var x6 = x7 - dx47r;
        var y6 = y7 - dy47r;
        var dx71 = x1 - x7;
        var dy71 = y1 - y7;
        var x8 = x7 + ry * dx71;
        var y8 = y7 + ry * dy71;
        var x9 = x1 - rz * dx71;
        var y9 = y1 - rz * dy71;
        work.set(originX, originY + sy - sw); // Incenter of a triangle
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        var x10 = x1 + radius * (x0 - x1);
        var y10 = y1 + radius * (y0 - y1);
        var x11 = x4 + radius * (x0 - x4);
        var y11 = y4 + radius * (y0 - y4);
        var x12 = x7 + radius * (x0 - x7);
        var y12 = y7 + radius * (y0 - y7);
        // World size
        var xb = tx + dx;
        var yb = ty + dy;
        worldSize[0] = toLength(xb, yb, x0, y0);
        worldSize[1] = rx;
        worldSize[2] = ry;
        worldSize[3] = rz;
        worldSize[4] = 1 - 0.5 * sw / sy;
        // Vertices
        // Top corner
        var iv = voffset * 2;
        vertices[iv + 0] = x10;
        vertices[iv + 1] = y10;
        vertices[iv + 2] = x9;
        vertices[iv + 3] = y9;
        vertices[iv + 4] = x1;
        vertices[iv + 5] = y1;
        vertices[iv + 6] = x2;
        vertices[iv + 7] = y2;
        // Bottom-right corner
        vertices[iv + 8] = x11;
        vertices[iv + 9] = y11;
        vertices[iv + 10] = x3;
        vertices[iv + 11] = y3;
        vertices[iv + 12] = x4;
        vertices[iv + 13] = y4;
        vertices[iv + 14] = x5;
        vertices[iv + 15] = y5;
        // Bottom-left corner
        vertices[iv + 16] = x12;
        vertices[iv + 17] = y12;
        vertices[iv + 18] = x6;
        vertices[iv + 19] = y6;
        vertices[iv + 20] = x7;
        vertices[iv + 21] = y7;
        vertices[iv + 22] = x8;
        vertices[iv + 23] = y8;
        // Others
        vertices[iv + 24] = x0;
        vertices[iv + 25] = y0;
        vertices[iv + 26] = x10;
        vertices[iv + 27] = y10;
        vertices[iv + 28] = x2;
        vertices[iv + 29] = y2;
        vertices[iv + 30] = x3;
        vertices[iv + 31] = y3;
        vertices[iv + 32] = x11;
        vertices[iv + 33] = y11;
        vertices[iv + 34] = x5;
        vertices[iv + 35] = y5;
        vertices[iv + 36] = x6;
        vertices[iv + 37] = y6;
        vertices[iv + 38] = x12;
        vertices[iv + 39] = y12;
        vertices[iv + 40] = x8;
        vertices[iv + 41] = y8;
        vertices[iv + 42] = x9;
        vertices[iv + 43] = y9;
    };
    var buildTriangleRoundedClipping = function (clippings, voffset, corner, radius) {
        // Top corner
        var iv = voffset * 3;
        var w = 1 - radius;
        if (corner & EShapeCorner.TOP) {
            clippings[iv + 0] = 0;
            clippings[iv + 1] = 0;
            clippings[iv + 2] = 1;
            clippings[iv + 3] = 1;
            clippings[iv + 4] = 0;
            clippings[iv + 5] = 1;
            clippings[iv + 6] = 1;
            clippings[iv + 7] = 1;
            clippings[iv + 8] = 1;
            clippings[iv + 9] = 0;
            clippings[iv + 10] = 1;
            clippings[iv + 11] = 1;
        }
        else {
            clippings[iv + 0] = w;
            clippings[iv + 1] = w;
            clippings[iv + 2] = 0;
            clippings[iv + 3] = 1;
            clippings[iv + 4] = w;
            clippings[iv + 5] = 0;
            clippings[iv + 6] = 1;
            clippings[iv + 7] = 1;
            clippings[iv + 8] = 0;
            clippings[iv + 9] = w;
            clippings[iv + 10] = 1;
            clippings[iv + 11] = 0;
        }
        iv += 12;
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            clippings[iv + 0] = 0;
            clippings[iv + 1] = 0;
            clippings[iv + 2] = 1;
            clippings[iv + 3] = 1;
            clippings[iv + 4] = 0;
            clippings[iv + 5] = 1;
            clippings[iv + 6] = 1;
            clippings[iv + 7] = 1;
            clippings[iv + 8] = 1;
            clippings[iv + 9] = 0;
            clippings[iv + 10] = 1;
            clippings[iv + 11] = 1;
        }
        else {
            clippings[iv + 0] = w;
            clippings[iv + 1] = w;
            clippings[iv + 2] = 0;
            clippings[iv + 3] = 1;
            clippings[iv + 4] = w;
            clippings[iv + 5] = 0;
            clippings[iv + 6] = 1;
            clippings[iv + 7] = 1;
            clippings[iv + 8] = 0;
            clippings[iv + 9] = w;
            clippings[iv + 10] = 1;
            clippings[iv + 11] = 0;
        }
        iv += 12;
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            clippings[iv + 0] = 0;
            clippings[iv + 1] = 0;
            clippings[iv + 2] = 1;
            clippings[iv + 3] = 1;
            clippings[iv + 4] = 0;
            clippings[iv + 5] = 1;
            clippings[iv + 6] = 1;
            clippings[iv + 7] = 1;
            clippings[iv + 8] = 1;
            clippings[iv + 9] = 0;
            clippings[iv + 10] = 1;
            clippings[iv + 11] = 1;
        }
        else {
            clippings[iv + 0] = w;
            clippings[iv + 1] = w;
            clippings[iv + 2] = 0;
            clippings[iv + 3] = 1;
            clippings[iv + 4] = w;
            clippings[iv + 5] = 0;
            clippings[iv + 6] = 1;
            clippings[iv + 7] = 1;
            clippings[iv + 8] = 0;
            clippings[iv + 9] = w;
            clippings[iv + 10] = 1;
            clippings[iv + 11] = 0;
        }
        iv += 12;
        // Others
        clippings[iv + 0] = 0;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        iv += 3;
        clippings[iv + 0] = w;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        iv += 3;
        clippings[iv + 0] = 1;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        clippings[iv + 3] = 1;
        clippings[iv + 4] = 0;
        clippings[iv + 5] = 0;
        iv += 6;
        clippings[iv + 0] = w;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        iv += 3;
        clippings[iv + 0] = 1;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        clippings[iv + 3] = 1;
        clippings[iv + 4] = 0;
        clippings[iv + 5] = 0;
        iv += 6;
        clippings[iv + 0] = w;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        iv += 3;
        clippings[iv + 0] = 1;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        clippings[iv + 3] = 1;
        clippings[iv + 4] = 0;
        clippings[iv + 5] = 0;
    };
    var buildTriangleRoundedStep = function (steps, clippings, voffset, strokeWidth, radius, antialiasWeight, worldSize) {
        var wsr = worldSize[0];
        toStep(wsr, strokeWidth, antialiasWeight, STEP_VALUES);
        var swc = STEP_VALUES[0];
        var pc0 = STEP_VALUES[1];
        var pc1 = STEP_VALUES[2];
        toStep(radius * wsr, strokeWidth, antialiasWeight, STEP_VALUES);
        var swr = STEP_VALUES[0];
        var pr0 = STEP_VALUES[1];
        var pr1 = STEP_VALUES[2];
        var ic = voffset * 3;
        var is = voffset * 6;
        for (var i = 0; i < TRIANGLE_ROUNDED_VERTEX_COUNT; ++i) {
            var sw = swc;
            var p0 = pc0;
            var p1 = pc1;
            if (0.5 < clippings[ic + 2]) {
                sw = swr;
                p0 = pr0;
                p1 = pr1;
            }
            steps[is + 0] = sw * clippings[ic + 0];
            steps[is + 1] = sw * clippings[ic + 1];
            steps[is + 2] = p0;
            steps[is + 3] = p0;
            steps[is + 4] = p1;
            steps[is + 5] = p1;
            ic += 3;
            is += 6;
        }
    };
    var buildTriangleRoundedUv = function (uvs, voffset, textureUvs, radius, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var c = worldSize[4];
        var x5 = x4 + c * (x3 - x0);
        var y5 = y4 + c * (y3 - y0);
        var rx = worldSize[1];
        var ry = worldSize[2];
        var rz = worldSize[3];
        var x6 = x4 + rz * (x3 - x4);
        var y6 = y4 + rz * (y3 - y4);
        var x7 = x4 + radius * (x5 - x4);
        var y7 = y4 + radius * (y5 - y4);
        var x8 = x4 + rz * (x2 - x4);
        var y8 = y4 + rz * (y2 - y4);
        var x9 = x2 + ry * (x4 - x2);
        var y9 = y2 + ry * (y4 - y2);
        var x10 = x2 + radius * (x5 - x2);
        var y10 = y2 + radius * (y5 - y2);
        var x11 = x2 + rx * (x3 - x2);
        var y11 = y2 + rx * (y3 - y2);
        var x12 = x3 + rx * (x2 - x3);
        var y12 = y3 + rx * (y2 - y3);
        var x13 = x3 + radius * (x5 - x3);
        var y13 = y3 + radius * (y5 - y3);
        var x14 = x3 + ry * (x4 - x3);
        var y14 = y3 + ry * (y4 - y3);
        // Uvs
        // Top corner
        var iuv = voffset * 2;
        uvs[iuv + 0] = x7;
        uvs[iuv + 1] = y7;
        uvs[iuv + 2] = x6;
        uvs[iuv + 3] = y6;
        uvs[iuv + 4] = x4;
        uvs[iuv + 5] = y4;
        uvs[iuv + 6] = x8;
        uvs[iuv + 7] = y8;
        iuv += 8;
        // Bottom-right corner
        uvs[iuv + 0] = x10;
        uvs[iuv + 1] = y10;
        uvs[iuv + 2] = x9;
        uvs[iuv + 3] = y9;
        uvs[iuv + 4] = x2;
        uvs[iuv + 5] = y2;
        uvs[iuv + 6] = x11;
        uvs[iuv + 7] = y11;
        iuv += 8;
        // Bottom-left corner
        uvs[iuv + 0] = x13;
        uvs[iuv + 1] = y13;
        uvs[iuv + 2] = x12;
        uvs[iuv + 3] = y12;
        uvs[iuv + 4] = x3;
        uvs[iuv + 5] = y3;
        uvs[iuv + 6] = x14;
        uvs[iuv + 7] = y14;
        iuv += 8;
        // Others
        uvs[iuv + 0] = x5;
        uvs[iuv + 1] = y5;
        uvs[iuv + 2] = x7;
        uvs[iuv + 3] = y7;
        uvs[iuv + 4] = x8;
        uvs[iuv + 5] = y8;
        uvs[iuv + 6] = x9;
        uvs[iuv + 7] = y9;
        uvs[iuv + 8] = x10;
        uvs[iuv + 9] = y10;
        uvs[iuv + 10] = x11;
        uvs[iuv + 11] = y11;
        uvs[iuv + 12] = x12;
        uvs[iuv + 13] = y12;
        uvs[iuv + 14] = x13;
        uvs[iuv + 15] = y13;
        uvs[iuv + 16] = x14;
        uvs[iuv + 17] = y14;
        uvs[iuv + 18] = x6;
        uvs[iuv + 19] = y6;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTriangleRoundedsUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfTriangleRoundedsUploaded, _super);
        function EShapeLineOfTriangleRoundedsUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineOfTriangleRoundedsUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildTriangleRoundedIndex(buffer.indices, voffset, ioffset);
                copyIndex(buffer.indices, TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset, TRIANGLE_ROUNDED_INDEX_COUNT, pointCountReserved);
            }
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLineOfTriangleRoundedsUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexClippingStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, TRIANGLE_ROUNDED_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, TRIANGLE_ROUNDED_VERTEX_COUNT);
                this.updateText(buffer, shape);
            }
        };
        EShapeLineOfTriangleRoundedsUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = (pointId !== this.pointId || pointOffsetId !== this.pointOffsetId);
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = (pointSizeId !== this.pointSizeId);
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
            var radius = shape.radius;
            var isRadiusChanged = (radius !== this.radius);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign || this.strokeWidth !== strokeWidth);
            var corner = shape.corner;
            var isCornerChanged = (this.corner !== corner);
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = (texture !== this.texture || textureTransformId !== this.textureTransformId);
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isRadiusChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.pointId = pointId;
                this.pointCount = points.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isCornerChanged) {
                    buffer.updateClippings();
                }
                if (isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = points.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var clippings = buffer.clippings;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = this.toTextureUvs(texture);
                var antialiasWeight = this.antialiasWeight;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildTriangleRoundedVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Clippings
                    if (isVertexChanged || isCornerChanged) {
                        buildTriangleRoundedClipping(clippings, voffset, corner, radius);
                        copyClipping(clippings, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // Steps
                    if (isVertexChanged || isTransformChanged || isCornerChanged) {
                        buildTriangleRoundedStep(steps, clippings, voffset, strokeWidth, radius, antialiasWeight, TRIANGLE_ROUNDED_WORLD_SIZE);
                        copyStep(steps, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isVertexChanged || isTextureChanged) {
                        buildTriangleRoundedUv(uvs, voffset, textureUvs, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        copyUvs(uvs, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * TRIANGLE_ROUNDED_VERTEX_COUNT;
                        // Vertices
                        buildTriangleRoundedVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                        // Clippings
                        if (isVertexChanged || isCornerChanged) {
                            buildTriangleRoundedClipping(clippings, iv, corner, radius);
                        }
                        // Steps
                        if (isVertexChanged || isTransformChanged || isCornerChanged) {
                            buildTriangleRoundedStep(steps, clippings, iv, strokeWidth, radius, antialiasWeight, TRIANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // UVs
                        if (isVertexChanged || isTextureChanged) {
                            buildTriangleRoundedUv(uvs, iv, textureUvs, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * TRIANGLE_ROUNDED_VERTEX_COUNT;
                var vcountReserved = TRIANGLE_ROUNDED_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullClipping(clippings, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return EShapeLineOfTriangleRoundedsUploaded;
    }(EShapeLineOfAnyUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfTriangleRoundedsUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset, TRIANGLE_ROUNDED_INDEX_COUNT, antialiasWeight, EShapeLineOfTriangleRoundedsUploaded);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTriangle = /** @class */ (function (_super) {
        __extends(EShapeTriangle, _super);
        function EShapeTriangle(type) {
            if (type === void 0) { type = EShapeType.TRIANGLE; }
            return _super.call(this, type) || this;
        }
        EShapeTriangle.prototype.clone = function () {
            return new EShapeTriangle().copy(this);
        };
        EShapeTriangle.prototype.containsAbs_ = function (x, y, a, ay1, ay2) {
            // a = 2 * ay / ax
            // y = + a * x + ay1
            // y = - a * x + ay1
            // y = ay2;
            return (+a * x + ay1 - y <= 0 && -a * x + ay1 - y <= 0 && y <= ay2);
        };
        EShapeTriangle.prototype.containsAbs = function (x, y, ax, ay) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                var a = 2 * ay / ax;
                var fill = this.fill;
                if (fill.enable) {
                    if (this.containsAbs_(x, y, a, -ay, +ay)) {
                        return true;
                    }
                }
                else {
                    var stroke = this.stroke;
                    var strokeWidth = stroke.width;
                    if (stroke.enable && 0 < strokeWidth) {
                        if (this.containsAbs_(x, y, a, -ay, +ay)) {
                            var az = Math.sqrt(ax * ax + 4 * ay * ay);
                            var aw = 2 * ax * ay / (ax + az);
                            var cy = ay - aw;
                            var ay1 = cy + (-ay - cy) * Math.max(0.0, aw - strokeWidth) / aw;
                            var ay2 = ay - strokeWidth;
                            if (!this.containsAbs_(x, y, a, ay1, ay2)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        };
        return EShapeTriangle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FMIN = 0.00001;
    var EShapeTriangleRounded = /** @class */ (function (_super) {
        __extends(EShapeTriangleRounded, _super);
        function EShapeTriangleRounded(type) {
            if (type === void 0) { type = EShapeType.TRIANGLE_ROUNDED; }
            return _super.call(this, type) || this;
        }
        EShapeTriangleRounded.prototype.clone = function () {
            return new EShapeTriangleRounded().copy(this);
        };
        EShapeTriangleRounded.prototype.containsCorner_ = function (x, y, r, aw) {
            var fill = this.fill;
            if (fill.enable) {
                if (x * x + y * y <= r * r) {
                    return true;
                }
            }
            else {
                var stroke = this.stroke;
                var strokeWidth = stroke.width;
                if (stroke.enable && 0 < strokeWidth) {
                    var d = x * x + y * y;
                    if (d <= r * r) {
                        var w = Math.max(0.0, r * (1 - strokeWidth / aw));
                        if (w * w <= d) {
                            return true;
                        }
                    }
                }
            }
        };
        EShapeTriangleRounded.prototype.containsCorner = function (x, y, x0, y0, x1, y1, x2, y2, x3, y3, r12, r13, aw, radius) {
            var xl = x1 + r12 * (x2 - x1) - x0;
            var yl = y1 + r12 * (y2 - y1) - y0;
            var n = Math.sqrt(xl * xl + yl * yl);
            if (FMIN < n) {
                var ni = 1 / n;
                var nlx = xl * ni;
                var nly = yl * ni;
                var xr = x1 + r13 * (x3 - x1) - x0;
                var yr = y1 + r13 * (y3 - y1) - y0;
                var nrx = xr * ni;
                var nry = yr * ni;
                var det = nlx * nry - nrx * nly;
                if (FMIN < Math.abs(det)) {
                    var deti = 1 / det;
                    var xc = x - x0;
                    var yc = y - y0;
                    var dx = (+nry * xc - nrx * yc) * deti;
                    var dy = (-nly * xc + nlx * yc) * deti;
                    if (this.containsCorner_(dx, dy, n, aw * radius)) {
                        return true;
                    }
                }
            }
        };
        EShapeTriangleRounded.prototype.containsAbs = function (x, y, ax, ay) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                var a = 2 * ay / ax;
                if (this.containsAbs_(x, y, a, -ay, +ay)) {
                    var az = Math.sqrt(ax * ax + 4 * ay * ay);
                    var aw = 2 * ax * ay / (ax + az);
                    var radius = this.radius;
                    var x0 = 0;
                    var y0 = ay - aw;
                    var x1 = 0;
                    var y1 = -ay;
                    var x4 = +ax;
                    var y4 = +ay;
                    var x7 = -x4;
                    var y7 = +y4;
                    var x10 = x1 + radius * (x0 - x1);
                    var y10 = y1 + radius * (y0 - y1);
                    var x11 = x4 + radius * (x0 - x4);
                    var y11 = y4 + radius * (y0 - y4);
                    var y12 = +y11;
                    var x12 = -x11;
                    var c0 = -a * x + y10 - y <= 0;
                    var c1 = +a * x + y10 - y <= 0;
                    var c2 = y <= y11;
                    var corner = this.corner;
                    if (!c0 && !c1 && (corner & EShapeCorner.TOP)) {
                        // Top corner
                        var rz = (0.5 * (az - aw) * radius) / (az);
                        if (this.containsCorner(x, y, x10, y10, x1, y1, x7, y7, x4, y4, rz, rz, aw, radius)) {
                            return true;
                        }
                    }
                    else if (!c0 && !c2 && (corner & EShapeCorner.BOTTOM_LEFT)) {
                        // Bottom-left corner
                        var ry = (aw * radius) / (2 * ay);
                        var rx = (ry * az) / (2 * ax);
                        if (this.containsCorner(x, y, x12, y12, x7, y7, x4, y4, x1, y1, rx, ry, aw, radius)) {
                            return true;
                        }
                    }
                    else if (!c1 && !c2 && (corner & EShapeCorner.BOTTOM_RIGHT)) {
                        // Bottom-right corner
                        var ry = (aw * radius) / (2 * ay);
                        var rx = (ry * az) / (2 * ax);
                        if (this.containsCorner(x, y, x11, y11, x4, y4, x1, y1, x7, y7, ry, rx, aw, radius)) {
                            return true;
                        }
                    }
                    else {
                        // Others
                        var fill = this.fill;
                        if (fill.enable) {
                            return true;
                        }
                        else {
                            var stroke = this.stroke;
                            var strokeWidth = stroke.width;
                            if (stroke.enable && 0 < strokeWidth) {
                                var cy = ay - aw;
                                var ay1 = cy + (-ay - cy) * Math.max(0.0, aw - strokeWidth) / aw;
                                var ay2 = ay - strokeWidth;
                                if (!this.containsAbs_(x, y, a, ay1, ay2)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        };
        return EShapeTriangleRounded;
    }(EShapeTriangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTriangleRoundeds = /** @class */ (function (_super) {
        __extends(EShapeLineOfTriangleRoundeds, _super);
        function EShapeLineOfTriangleRoundeds(other) {
            var _this = _super.call(this, EShapeType.LINE_OF_TRIANGLE_ROUNDEDS) || this;
            if (other) {
                _this.copy(other);
            }
            else {
                _this.points = new EShapeLineOfAnyPointsImpl(_this);
            }
            _this._tester = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py);
            };
            _this._testerBBox = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbsBBox(x, y, ax, ay, ox, oy, px, py);
            };
            return _this;
        }
        EShapeLineOfTriangleRoundeds.prototype.clone = function () {
            return new EShapeLineOfTriangleRoundeds(this);
        };
        EShapeLineOfTriangleRoundeds.prototype.containsAbs = function (x, y, ax, ay) {
            var threshold = toHitThreshold(this, null);
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this.points.calcHitPointAbs(x, y, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfTriangleRoundeds.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfTriangleRoundeds.prototype.containsPointAbsBBox = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbsBBox.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfTriangleRoundeds.prototype.calcHitPoint = function (point, toThreshold, range, tester, result) {
            var rect = this.toLocalRect(point, EShapeBase.WORK_RECT);
            var threshold = toHitThreshold(this, toThreshold);
            if (this.containsAbsBBox(rect.x, rect.y, rect.width + threshold, rect.height + threshold)) {
                return this.points.calcHitPointAbs(rect.x, rect.y, threshold, range, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfTriangleRoundeds;
    }(EShapeTriangleRounded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfTriangleRoundeds = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLineOfTriangleRoundeds());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfTriangleRoundeds = function () {
        EShapeUploadeds[EShapeType.LINE_OF_TRIANGLE_ROUNDEDS] = createLineOfTriangleRoundedsUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_TRIANGLE_ROUNDEDS] = deserializeLineOfTriangleRoundeds;
        EShapeCapabilities.set(EShapeType.LINE_OF_TRIANGLE_ROUNDEDS, EShapeCapability.PRIMITIVE | EShapeCapability.BORDER_RADIUS);
    };

    var TRIANGLE_VERTEX_COUNT = 7;
    var TRIANGLE_INDEX_COUNT = 3;
    var TRIANGLE_WORLD_SIZE = [0, 0, 0];
    var TRIANGLE_WORK_POINT = new pixi_js.Point();
    var buildTriangleClipping = function (clippings, voffset) {
        // Clippings
        var iv = voffset * 3;
        clippings[iv + 0] = 0;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        iv += 3;
        clippings[iv + 0] = 1;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        iv += 3;
        clippings[iv + 0] = 1;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        iv += 3;
        clippings[iv + 0] = 0;
        clippings[iv + 1] = 1;
        clippings[iv + 2] = 0;
        iv += 3;
        clippings[iv + 0] = 0;
        clippings[iv + 1] = 1;
        clippings[iv + 2] = 0;
        iv += 3;
        clippings[iv + 0] = 1;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
        iv += 3;
        clippings[iv + 0] = 1;
        clippings[iv + 1] = 0;
        clippings[iv + 2] = 0;
    };
    var buildTriangleIndex = function (indices, voffset, ioffset) {
        // Indices
        var ii = ioffset * 3;
        indices[ii + 0] = voffset + 0;
        indices[ii + 1] = voffset + 1;
        indices[ii + 2] = voffset + 2;
        indices[ii + 3] = voffset + 0;
        indices[ii + 4] = voffset + 3;
        indices[ii + 5] = voffset + 4;
        indices[ii + 6] = voffset + 0;
        indices[ii + 7] = voffset + 5;
        indices[ii + 8] = voffset + 6;
    };
    var buildTriangleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var sz = Math.sqrt(sx * sx + 4 * sy * sy);
        var sw = 2 * sx * sy / (sx + sz);
        var work = TRIANGLE_WORK_POINT;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var tx = work.x;
        var ty = work.y;
        work.set(originX + sx, originY);
        internalTransform.apply(work, work);
        var dx = tx - x0;
        var dy = ty - y0;
        var x1 = work.x + dx;
        var y1 = work.y + dy;
        var x2 = tx + (tx - work.x) + dx;
        var y2 = ty + (ty - work.y) + dy;
        work.set(originX, originY + sy - sw); // Incenter of a triangle
        internalTransform.apply(work, work);
        var x3 = work.x;
        var y3 = work.y;
        // World size
        var xb = tx + dx;
        var yb = ty + dy;
        worldSize[0] = toLength(xb, yb, x3, y3);
        worldSize[1] = toLength(x1, y1, xb, yb);
        worldSize[2] = toLength(x0, y0, tx, ty);
        // Vertices
        var iv = voffset << 1;
        vertices[iv + 0] = x3;
        vertices[iv + 1] = y3;
        vertices[iv + 2] = x0;
        vertices[iv + 3] = y0;
        vertices[iv + 4] = x1;
        vertices[iv + 5] = y1;
        vertices[iv + 6] = x1;
        vertices[iv + 7] = y1;
        vertices[iv + 8] = x2;
        vertices[iv + 9] = y2;
        vertices[iv + 10] = x2;
        vertices[iv + 11] = y2;
        vertices[iv + 12] = x0;
        vertices[iv + 13] = y0;
    };
    var buildTriangleStep = function (steps, clippings, voffset, vcount, strokeWidth, antialiasWeight, worldSize) {
        toStep(worldSize[0], strokeWidth, antialiasWeight, STEP_VALUES);
        var swc = STEP_VALUES[0];
        var pc0 = STEP_VALUES[1];
        var pc1 = STEP_VALUES[2];
        buildStep(steps, clippings, voffset, vcount, swc, swc, pc0, pc0, pc1, pc1);
    };
    var buildTriangleUv = function (uvs, textureUvs, voffset, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var c = 1 - 0.5 * worldSize[0] / worldSize[2];
        var x5 = x4 + c * (x3 - x0);
        var y5 = y4 + c * (y3 - y0);
        var iuv = voffset << 1;
        uvs[iuv + 0] = x5;
        uvs[iuv + 1] = y5;
        uvs[iuv + 2] = x4;
        uvs[iuv + 3] = y4;
        uvs[iuv + 4] = x2;
        uvs[iuv + 5] = y2;
        uvs[iuv + 6] = x2;
        uvs[iuv + 7] = y2;
        uvs[iuv + 8] = x3;
        uvs[iuv + 9] = y3;
        uvs[iuv + 10] = x3;
        uvs[iuv + 11] = y3;
        uvs[iuv + 12] = x4;
        uvs[iuv + 13] = y4;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTrianglesUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfTrianglesUploaded, _super);
        function EShapeLineOfTrianglesUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineOfTrianglesUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            var buffer = this.buffer;
            buffer.updateClippings();
            buffer.updateIndices();
            var clippings = buffer.clippings;
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildTriangleClipping(clippings, voffset);
                copyClipping(clippings, voffset, TRIANGLE_VERTEX_COUNT, pointCountReserved);
                buildTriangleIndex(indices, voffset, ioffset);
                copyIndex(indices, TRIANGLE_VERTEX_COUNT, ioffset, TRIANGLE_INDEX_COUNT, pointCountReserved);
            }
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLineOfTrianglesUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexStepAndUvs(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, TRIANGLE_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, TRIANGLE_VERTEX_COUNT);
                this.updateText(buffer, shape);
            }
        };
        EShapeLineOfTrianglesUploaded.prototype.updateVertexStepAndUvs = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = (pointId !== this.pointId || pointOffsetId !== this.pointOffsetId);
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = (pointSizeId !== this.pointSizeId);
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign || this.strokeWidth !== strokeWidth);
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = (texture !== this.texture || textureTransformId !== this.textureTransformId);
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.pointId = pointId;
                this.pointCount = points.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = points.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var clippings = buffer.clippings;
                var uvs = buffer.uvs;
                var textureUvs = this.toTextureUvs(texture);
                var internalTransform = shape.transform.internalTransform;
                var antialiasWeight = this.antialiasWeight;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    buildTriangleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, TRIANGLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    if (isVertexChanged || isTransformChanged) {
                        buildTriangleStep(steps, clippings, voffset, TRIANGLE_VERTEX_COUNT, strokeWidth, antialiasWeight, TRIANGLE_WORLD_SIZE);
                        copyStep(steps, voffset, TRIANGLE_VERTEX_COUNT, pointCount);
                    }
                    if (isVertexChanged || isTextureChanged) {
                        buildTriangleUv(uvs, textureUvs, voffset, TRIANGLE_WORLD_SIZE);
                        copyUvs(uvs, voffset, TRIANGLE_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * TRIANGLE_VERTEX_COUNT;
                        buildTriangleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                        if (isVertexChanged || isTransformChanged) {
                            buildTriangleStep(steps, clippings, iv, TRIANGLE_VERTEX_COUNT, strokeWidth, antialiasWeight, TRIANGLE_WORLD_SIZE);
                        }
                        if (isVertexChanged || isTextureChanged) {
                            buildTriangleUv(uvs, textureUvs, iv, TRIANGLE_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * TRIANGLE_VERTEX_COUNT;
                var vcountReserved = TRIANGLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return EShapeLineOfTrianglesUploaded;
    }(EShapeLineOfAnyUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfTrianglesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, TRIANGLE_VERTEX_COUNT, ioffset, TRIANGLE_INDEX_COUNT, antialiasWeight, EShapeLineOfTrianglesUploaded);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTriangles = /** @class */ (function (_super) {
        __extends(EShapeLineOfTriangles, _super);
        function EShapeLineOfTriangles(other) {
            var _this = _super.call(this, EShapeType.LINE_OF_TRIANGLES) || this;
            if (other) {
                _this.copy(other);
            }
            else {
                _this.points = new EShapeLineOfAnyPointsImpl(_this);
            }
            _this._tester = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py);
            };
            _this._testerBBox = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbsBBox(x, y, ax, ay, ox, oy, px, py);
            };
            return _this;
        }
        EShapeLineOfTriangles.prototype.clone = function () {
            return new EShapeLineOfTriangles(this);
        };
        EShapeLineOfTriangles.prototype.containsAbs = function (x, y, ax, ay) {
            var threshold = toHitThreshold(this, null);
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this.points.calcHitPointAbs(x, y, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfTriangles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfTriangles.prototype.containsPointAbsBBox = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbsBBox.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfTriangles.prototype.calcHitPoint = function (point, toThreshold, range, tester, result) {
            var rect = this.toLocalRect(point, EShapeBase.WORK_RECT);
            var threshold = toHitThreshold(this, toThreshold);
            if (this.containsAbsBBox(rect.x, rect.y, rect.width + threshold, rect.height + threshold)) {
                return this.points.calcHitPointAbs(rect.x, rect.y, threshold, range, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfTriangles;
    }(EShapeTriangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfTriangles = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLineOfTriangles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfTriangles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_TRIANGLES] = createLineOfTrianglesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_TRIANGLES] = deserializeLineOfTriangles;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeNullUploaded = /** @class */ (function (_super) {
        __extends(EShapeNullUploaded, _super);
        function EShapeNullUploaded(buffer, voffset, ioffset) {
            return _super.call(this, buffer, voffset, ioffset, 0, 0, 1) || this;
        }
        EShapeNullUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            this.texture = shape.texture || pixi_js.Texture.WHITE;
            return this;
        };
        EShapeNullUploaded.prototype.update = function (shape) {
            // DO NOTHING
        };
        return EShapeNullUploaded;
    }(EShapeUploadedBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createNullUploaded = function (buffer, shape, voffset, ioffset) {
        return new EShapeNullUploaded(buffer, voffset, ioffset).init(shape);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeNull = /** @class */ (function (_super) {
        __extends(EShapeNull, _super);
        function EShapeNull(type) {
            if (type === void 0) { type = EShapeType.NULL; }
            return _super.call(this, type) || this;
        }
        EShapeNull.prototype.clone = function () {
            return new EShapeNull().copy(this);
        };
        return EShapeNull;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeNull = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeNull());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeNull = function () {
        EShapeUploadeds[EShapeType.NULL] = createNullUploaded;
        EShapeDeserializers[EShapeType.NULL] = deserializeNull;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeRectangle = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeRectangle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeRectangle = function () {
        EShapeUploadeds[EShapeType.RECTANGLE] = createRectangleUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE] = deserializeRectangle;
        EShapeCapabilities.set(EShapeType.RECTANGLE, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangleRoundedUploaded = /** @class */ (function (_super) {
        __extends(EShapeRectangleRoundedUploaded, _super);
        function EShapeRectangleRoundedUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeRectangleRoundedUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleRoundedIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeRectangleRoundedUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeRectangleRoundedUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var radius = shape.radius;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY || radius !== this.radius);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var strokeSide = stroke.side;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth || this.strokeSide !== strokeSide);
            var corner = shape.corner;
            var isCornerChanged = (corner !== this.corner);
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = (texture !== this.texture || textureTransformId !== this.textureTransformId);
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isVertexChanged || isTransformChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Vertices
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleRoundedVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, radius, shape.transform.internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                // Steps
                if (isVertexChanged || isCornerChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleRoundedStep(buffer.steps, voffset, strokeWidth, strokeSide, corner, this.antialiasWeight, RECTANGLE_ROUNDED_WORLD_SIZE);
                }
                // Clippings
                if (isVertexChanged || isCornerChanged) {
                    buffer.updateClippings();
                    buildRectangleRoundedClipping(buffer.clippings, voffset, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                }
                // UVs
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleRoundedUv(buffer.uvs, voffset, this.toTextureUvs(texture), RECTANGLE_ROUNDED_WORLD_SIZE);
                }
            }
        };
        return EShapeRectangleRoundedUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createRectangleRoundedUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = RECTANGLE_ROUNDED_VERTEX_COUNT + tvcount;
        var icount = RECTANGLE_ROUNDED_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeRectangleRoundedUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeRectangleRounded = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeRectangleRounded());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeRectangleRounded = function () {
        EShapeUploadeds[EShapeType.RECTANGLE_ROUNDED] = createRectangleRoundedUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE_ROUNDED] = deserializeRectangleRounded;
        EShapeCapabilities.set(EShapeType.RECTANGLE_ROUNDED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTriangleUploaded = /** @class */ (function (_super) {
        __extends(EShapeTriangleUploaded, _super);
        function EShapeTriangleUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeTriangleUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            var buffer = this.buffer;
            buffer.updateClippings();
            buffer.updateIndices();
            buildTriangleClipping(buffer.clippings, this.vertexOffset);
            buildTriangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeTriangleUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeTriangleUploaded.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign || this.strokeWidth !== strokeWidth);
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = (texture !== this.texture || textureTransformId !== this.textureTransformId);
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isVertexChanged || isTransformChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildTriangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, TRIANGLE_WORLD_SIZE);
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildTriangleStep(buffer.steps, buffer.clippings, voffset, TRIANGLE_VERTEX_COUNT, strokeWidth, this.antialiasWeight, TRIANGLE_WORLD_SIZE);
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleUv(buffer.uvs, this.toTextureUvs(texture), voffset, TRIANGLE_WORLD_SIZE);
                }
            }
        };
        return EShapeTriangleUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createTriangleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = TRIANGLE_VERTEX_COUNT + tvcount;
        var icount = TRIANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeTriangleUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeTriangle = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeTriangle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeTriangle = function () {
        EShapeUploadeds[EShapeType.TRIANGLE] = createTriangleUploaded;
        EShapeDeserializers[EShapeType.TRIANGLE] = deserializeTriangle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTriangleRoundedUploaded = /** @class */ (function (_super) {
        __extends(EShapeTriangleRoundedUploaded, _super);
        function EShapeTriangleRoundedUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeTriangleRoundedUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            buildTriangleRoundedIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeTriangleRoundedUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeTriangleRoundedUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = (sizeX !== this.sizeX || sizeY !== this.sizeY);
            var radius = shape.radius;
            var isRadiusChanged = (radius !== this.radius);
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = (this.transformLocalId !== transformLocalId);
            var stroke = shape.stroke;
            var strokeWidth = (stroke.enable ? stroke.width : 0);
            var strokeAlign = stroke.align;
            var isStrokeChanged = (this.strokeAlign !== strokeAlign || this.strokeWidth !== strokeWidth);
            var corner = shape.corner;
            var isCornerChanged = (corner !== this.corner);
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = (texture !== this.texture || textureTransformId !== this.textureTransformId);
            var isVertexChanged = isSizeChanged || isRadiusChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildTriangleRoundedVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, radius, shape.transform.internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                if (isRadiusChanged || isCornerChanged) {
                    buffer.updateClippings();
                    buildTriangleRoundedClipping(buffer.clippings, voffset, corner, radius);
                }
                if (isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                    buildTriangleRoundedStep(buffer.steps, buffer.clippings, voffset, strokeWidth, shape.radius, this.antialiasWeight, TRIANGLE_ROUNDED_WORLD_SIZE);
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleRoundedUv(buffer.uvs, voffset, this.toTextureUvs(texture), radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                }
            }
        };
        return EShapeTriangleRoundedUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createTriangleRoundedUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = TRIANGLE_ROUNDED_VERTEX_COUNT + tvcount;
        var icount = TRIANGLE_ROUNDED_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeTriangleRoundedUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeTriangleRounded = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeTriangleRounded());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeTriangleRounded = function () {
        EShapeUploadeds[EShapeType.TRIANGLE_ROUNDED] = createTriangleRoundedUploaded;
        EShapeDeserializers[EShapeType.TRIANGLE_ROUNDED] = deserializeTriangleRounded;
        EShapeCapabilities.set(EShapeType.TRIANGLE_ROUNDED, EShapeCapability.PRIMITIVE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeAll = function () {
        loadShapeBar();
        loadShapeCircle();
        loadShapeGroupShadowed();
        loadShapeGroup();
        loadShapeImage();
        loadShapeImageSdf();
        loadShapeLabel();
        loadShapeLine();
        loadShapeNull();
        loadShapeRectangleRounded();
        loadShapeRectangle();
        loadShapeTriangleRounded();
        loadShapeTriangle();
        loadShapeLineOfCircles();
        loadShapeLineOfRectangleRoundeds();
        loadShapeLineOfRectangles();
        loadShapeLineOfTriangleRoundeds();
        loadShapeLineOfTriangles();
    };

    var DDynamicTextMeasureResultCharacter = /** @class */ (function () {
        function DDynamicTextMeasureResultCharacter(x, y, character) {
            this.x = x;
            this.y = y;
            this.character = character;
        }
        DDynamicTextMeasureResultCharacter.prototype.set = function (x, y, character) {
            this.x = x;
            this.y = y;
            this.character = character;
        };
        return DDynamicTextMeasureResultCharacter;
    }());

    var DDynamicTextMeasureResult = /** @class */ (function () {
        function DDynamicTextMeasureResult() {
            this.count = 0;
            this.width = 0;
            this.height = 0;
            this.characters = [];
            this.clipped = false;
            this.x = 0;
            this.y = 0;
        }
        DDynamicTextMeasureResult.prototype.start = function () {
            this.count = 0;
            this.width = 0;
            this.height = 0;
            this.clipped = false;
            this.x = 0;
            this.y = 0;
        };
        DDynamicTextMeasureResult.prototype.push = function (character) {
            var x = this.x;
            this.x += character.advance;
            var y = this.y;
            var count = this.count;
            var characters = this.characters;
            if (count < characters.length) {
                characters[count].set(x, y, character);
            }
            else {
                characters.push(new DDynamicTextMeasureResultCharacter(x, y, character));
            }
            this.count += 1;
        };
        DDynamicTextMeasureResult.prototype.newLine = function (lineHeight) {
            this.width = Math.max(this.width, this.x);
            this.x = 0;
            this.y += lineHeight;
        };
        DDynamicTextMeasureResult.prototype.pop = function () {
            if (0 < this.x) {
                var count = this.count;
                var characters = this.characters;
                if (0 < count) {
                    var character = characters[count - 1];
                    this.x -= character.character.advance;
                    this.count -= 1;
                    return true;
                }
            }
            return false;
        };
        DDynamicTextMeasureResult.prototype.end = function (lineHeight) {
            this.newLine(lineHeight);
            this.height = this.y;
        };
        return DDynamicTextMeasureResult;
    }());

    var DDynamicTextMeasure = /** @class */ (function () {
        function DDynamicTextMeasure() {
        }
        DDynamicTextMeasure.measure = function (text, atlas, clippingWidth) {
            var result = DDynamicTextMeasure.RESULT = DDynamicTextMeasure.RESULT || new DDynamicTextMeasureResult();
            result.start();
            if (atlas != null) {
                var iterator = UtilCharacterIterator.from(text);
                var lineHeight = atlas.font.height;
                var newLine = "\n";
                while (iterator.hasNext()) {
                    var character = iterator.next();
                    if (character === newLine) {
                        result.newLine(lineHeight);
                    }
                    else {
                        var a = atlas.get(character);
                        if (a != null) {
                            if (clippingWidth != null && clippingWidth < result.x + a.advance) {
                                result.clipped = true;
                                var dots = atlas.get("...");
                                if (dots != null) {
                                    while (clippingWidth - dots.advance < result.x) {
                                        if (!result.pop()) {
                                            break;
                                        }
                                    }
                                    if (result.x <= clippingWidth - dots.advance) {
                                        result.push(dots);
                                    }
                                }
                                while (iterator.hasNext()) {
                                    if (iterator.next() === newLine) {
                                        result.newLine(lineHeight);
                                        break;
                                    }
                                }
                            }
                            else {
                                result.push(a);
                            }
                        }
                    }
                }
                result.end(lineHeight);
            }
            return result;
        };
        DDynamicTextMeasure.RESULT = null;
        return DDynamicTextMeasure;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicTextGeometry = /** @class */ (function (_super) {
        __extends(DDynamicTextGeometry, _super);
        function DDynamicTextGeometry() {
            var _this = _super.call(this, new Float32Array(64), new Float32Array(64), new Uint16Array(48)) || this;
            _this.width = 0;
            _this.height = 0;
            _this.clipped = false;
            return _this;
        }
        DDynamicTextGeometry.prototype.update = function (text, atlas, clippingWidth) {
            var vertexBuffer = this.getBuffer("aVertexPosition");
            var uvBuffer = this.getBuffer("aTextureCoord");
            var indexBuffer = this.getIndex();
            var result = DDynamicTextMeasure.measure(text, atlas, clippingWidth);
            var requiredTextSize = Math.ceil(result.count / 8) << 3;
            var requiredVertexSize = requiredTextSize << 3;
            if (vertexBuffer.data.length < requiredVertexSize) {
                vertexBuffer.data = new Float32Array(requiredVertexSize);
                uvBuffer.data = new Float32Array(requiredVertexSize);
            }
            var requiredIndexSize = requiredTextSize * 6;
            if (indexBuffer.data.length < requiredIndexSize) {
                indexBuffer.data = new Uint16Array(requiredIndexSize);
            }
            var vertices = vertexBuffer.data;
            var uvs = uvBuffer.data;
            var indices = indexBuffer.data;
            if (atlas != null) {
                var count = result.count;
                var characters = result.characters;
                for (var i = 0; i < count; ++i) {
                    var character = characters[i];
                    this.writeCharacter(vertices, uvs, indices, i, character.x, character.y, character.character, atlas.width, atlas.height);
                }
                for (var i = count, imax = vertices.length >> 3; i < imax; ++i) {
                    this.writeCharacterEmpty(vertices, uvs, indices, i);
                }
                this.width = result.width;
                this.height = result.height;
                this.clipped = result.clipped;
            }
            else {
                for (var i = 0, imax = vertices.length >> 3; i < imax; ++i) {
                    this.writeCharacterEmpty(vertices, uvs, indices, i);
                }
                this.width = 0;
                this.height = 0;
                this.clipped = false;
            }
            vertexBuffer.update();
            uvBuffer.update();
            indexBuffer.update();
        };
        DDynamicTextGeometry.prototype.writeCharacter = function (vertices, uvs, indices, index, x, y, character, width, height) {
            var offsetX = character.x - character.origin.x;
            var offsetY = 0;
            var iv = index << 3;
            vertices[iv + 0] = x + offsetX;
            vertices[iv + 1] = y + offsetY;
            vertices[iv + 2] = x + offsetX + character.width;
            vertices[iv + 3] = y + offsetY;
            vertices[iv + 4] = x + offsetX + character.width;
            vertices[iv + 5] = y + offsetY + character.height;
            vertices[iv + 6] = x + offsetX;
            vertices[iv + 7] = y + offsetY + character.height;
            var x0 = character.x / width;
            var y0 = character.y / height;
            var x1 = (character.x + character.width) / width;
            var y1 = (character.y + character.height) / height;
            uvs[iv + 0] = x0;
            uvs[iv + 1] = y0;
            uvs[iv + 2] = x1;
            uvs[iv + 3] = y0;
            uvs[iv + 4] = x1;
            uvs[iv + 5] = y1;
            uvs[iv + 6] = x0;
            uvs[iv + 7] = y1;
            var ii = index * 6;
            var vo = index << 2;
            indices[ii + 0] = vo + 0;
            indices[ii + 1] = vo + 1;
            indices[ii + 2] = vo + 3;
            indices[ii + 3] = vo + 1;
            indices[ii + 4] = vo + 2;
            indices[ii + 5] = vo + 3;
        };
        DDynamicTextGeometry.prototype.writeCharacterEmpty = function (vertices, uvs, indices, index) {
            var iv = index << 3;
            vertices[iv + 0] = 0;
            vertices[iv + 1] = 0;
            vertices[iv + 2] = 0;
            vertices[iv + 3] = 0;
            vertices[iv + 4] = 0;
            vertices[iv + 5] = 0;
            vertices[iv + 6] = 0;
            vertices[iv + 7] = 0;
            uvs[iv + 0] = 0;
            uvs[iv + 1] = 0;
            uvs[iv + 2] = 0;
            uvs[iv + 3] = 0;
            uvs[iv + 4] = 0;
            uvs[iv + 5] = 0;
            uvs[iv + 6] = 0;
            uvs[iv + 7] = 0;
            var ii = index * 6;
            var vo = index << 2;
            indices[ii + 0] = vo + 0;
            indices[ii + 1] = vo + 1;
            indices[ii + 2] = vo + 3;
            indices[ii + 3] = vo + 1;
            indices[ii + 4] = vo + 2;
            indices[ii + 5] = vo + 3;
        };
        return DDynamicTextGeometry;
    }(pixi_js.MeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicTextStyle = /** @class */ (function () {
        function DDynamicTextStyle(options, onChange) {
            this._id = 0;
            this._idApproved = -1;
            var font = DDynamicTextStyle.FONT = (DDynamicTextStyle.FONT || DThemes.getInstance().get("DBase"));
            this._align = (options && options.align) || "left";
            this._fontFamily = (options && options.fontFamily) || font.getFontFamilly();
            this._fontSize = (options && options.fontSize) || font.getFontSize();
            this._fontStyle = (options && options.fontStyle) || "normal";
            this._fontVariant = (options && options.fontVariant) || "normal";
            this._fontWeight = (options && options.fontWeight) || "normal";
            this._fontIdId = -1;
            this._fontId = "";
            this._fontIdApproved = "";
            this._fill = (options && options.fill) || font.getColor(0);
            this._fillApproved = 0x000000;
            this._clipping = ((options && options.clipping != null) ? options.clipping : true);
            this._onChange = onChange;
        }
        Object.defineProperty(DDynamicTextStyle.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "idApproved", {
            get: function () {
                return this._idApproved;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontId", {
            get: function () {
                this.update();
                return this._fontId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontIdApproved", {
            get: function () {
                return this._fontIdApproved;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fill", {
            get: function () {
                return this._fill;
            },
            set: function (fill) {
                if (this._fill !== fill) {
                    this._fill = fill;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DDynamicTextStyle.prototype.onChange = function () {
            this._id += 1;
            this._onChange();
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "fillApproved", {
            get: function () {
                return this._fillApproved;
            },
            enumerable: true,
            configurable: true
        });
        DDynamicTextStyle.prototype.approve = function () {
            this.update();
            this._idApproved = this._id;
            this._fontIdApproved = this._fontId;
            this._fillApproved = this._fill;
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "fontFamily", {
            get: function () {
                return this._fontFamily;
            },
            set: function (fontFamily) {
                if (this._fontFamily !== fontFamily) {
                    this._fontFamily = fontFamily;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontSize", {
            get: function () {
                return this._fontSize;
            },
            set: function (fontSize) {
                if (this._fontSize !== fontSize) {
                    this._fontSize = fontSize;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontStyle", {
            get: function () {
                return this._fontStyle;
            },
            set: function (fontStyle) {
                if (this._fontStyle !== fontStyle) {
                    this._fontStyle = fontStyle;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontVariant", {
            get: function () {
                return this._fontVariant;
            },
            set: function (fontVariant) {
                if (this._fontVariant !== fontVariant) {
                    this._fontVariant = fontVariant;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontWeight", {
            get: function () {
                return this._fontWeight;
            },
            set: function (fontWeight) {
                if (this._fontWeight !== fontWeight) {
                    this._fontWeight = fontWeight;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DDynamicTextStyle.prototype.update = function () {
            if (this._fontIdId !== this._id) {
                this._fontIdId = this._id;
                this._fontId = this.newFontId();
            }
        };
        DDynamicTextStyle.prototype.newFontId = function () {
            return this._fontStyle + " " + this._fontVariant + " " + this._fontWeight + " " + this._fontSize + "px " + this._fontFamily;
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "clipping", {
            get: function () {
                return this._clipping;
            },
            set: function (clipping) {
                if (this._clipping !== clipping) {
                    this._clipping = clipping;
                    this.onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DDynamicTextStyle.FONT = null;
        return DDynamicTextStyle;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicText = /** @class */ (function (_super) {
        __extends(DDynamicText, _super);
        function DDynamicText(text, options) {
            var _this = _super.call(this, new DDynamicTextGeometry(), new pixi_js.MeshMaterial(pixi_js.Texture.EMPTY)) || this;
            _this._style = new DDynamicTextStyle(options, function () {
                _this._isDirty = true;
                _this._isGeometryDirty = true;
                _this._atlas = null;
                _this.update_();
            });
            _this._text = text;
            _this._textApproved = "";
            _this._isDirty = true;
            _this._isGeometryDirty = true;
            _this._atlas = null;
            _this._atlasRevisionUpdated = 0;
            _this._width = 0;
            _this._height = 0;
            _this._clippingWidthDelta = 0;
            _this.update_();
            return _this;
        }
        DDynamicText.prototype.update_ = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var style = this._style;
                if (this._isDirty) {
                    this._isDirty = false;
                    var text = this._text;
                    var textApproved = this._textApproved;
                    this._textApproved = text;
                    var fontId = style.fontId;
                    var fontIdApproved = style.fontIdApproved;
                    var fontSize = style.fontSize;
                    var fill = style.fill;
                    var fillApproved = style.fillApproved;
                    style.approve();
                    var atlases = layer.getDynamicFontAtlases();
                    if (text !== textApproved || fontId !== fontIdApproved || fill !== fillApproved) {
                        atlases.add(fontId, fontSize, fill, text);
                        atlases.remove(fontIdApproved, fillApproved, textApproved);
                    }
                }
            }
        };
        Object.defineProperty(DDynamicText.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                if (this._text !== text) {
                    this._text = text;
                    this._isDirty = true;
                    this._isGeometryDirty = true;
                    this.update_();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "width", {
            get: function () {
                this.update();
                return Math.abs(this.scale.x) * this.geometry.width;
            },
            set: function (width) {
                this.update();
                var geometryWidth = this.geometry.width;
                if (+1e-4 < geometryWidth) {
                    var newScale = width / geometryWidth;
                    this.scale.x = (0 <= this.scale.x ? +newScale : -newScale);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "height", {
            get: function () {
                this.update();
                return Math.abs(this.scale.y) * this.geometry.height;
            },
            set: function (height) {
                this.update();
                var geometryHeight = this.geometry.height;
                if (+1e-4 < geometryHeight) {
                    var newScale = height / geometryHeight;
                    this.scale.y = (0 <= this.scale.y ? +newScale : -newScale);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "clipped", {
            get: function () {
                return this.geometry.clipped;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "style", {
            get: function () {
                return this._style;
            },
            enumerable: true,
            configurable: true
        });
        DDynamicText.prototype.update = function () {
            this.update_();
            var atlas = this._atlas;
            if (atlas == null) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var style = this._style;
                    atlas = layer.getDynamicFontAtlases().get(style.fontId, style.fill);
                    if (atlas != null) {
                        this._atlasRevisionUpdated = atlas.getRevisionUpdate();
                        this._atlas = atlas;
                        this.texture = atlas.texture;
                        this._isGeometryDirty = true;
                    }
                }
            }
            else {
                var revisionUpdate = atlas.getRevisionUpdate();
                if (revisionUpdate !== this._atlasRevisionUpdated) {
                    this._atlasRevisionUpdated = revisionUpdate;
                    this._isGeometryDirty = true;
                }
            }
            var clippingWidth = this._clippingWidth;
            var newClippingWidth = this.getClippingWidth();
            if (clippingWidth !== newClippingWidth) {
                this._clippingWidth = newClippingWidth;
                this._isGeometryDirty = true;
            }
            if (this._isGeometryDirty) {
                this._isGeometryDirty = false;
                this.geometry.update(this._text, atlas, newClippingWidth);
            }
        };
        DDynamicText.prototype.getClippingWidth = function () {
            if (this._style.clipping) {
                var parent_1 = this.parent;
                if (parent_1 instanceof DBase) {
                    return parent_1.width - parent_1.padding.getLeft() - parent_1.padding.getRight() - this._clippingWidthDelta;
                }
            }
            return undefined;
        };
        DDynamicText.prototype.setClippingWidthDelta = function (width) {
            this._clippingWidthDelta = width;
        };
        DDynamicText.prototype._calculateBounds = function () {
            this.update();
            _super.prototype._calculateBounds.call(this);
        };
        DDynamicText.prototype._render = function (renderer) {
            this.update();
            _super.prototype._render.call(this, renderer);
        };
        return DDynamicText;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignHorizontal;
    (function (DAlignHorizontal) {
        DAlignHorizontal[DAlignHorizontal["LEFT"] = 0] = "LEFT";
        DAlignHorizontal[DAlignHorizontal["CENTER"] = 1] = "CENTER";
        DAlignHorizontal[DAlignHorizontal["RIGHT"] = 2] = "RIGHT";
    })(DAlignHorizontal || (DAlignHorizontal = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignVertical;
    (function (DAlignVertical) {
        DAlignVertical[DAlignVertical["TOP"] = 0] = "TOP";
        DAlignVertical[DAlignVertical["MIDDLE"] = 1] = "MIDDLE";
        DAlignVertical[DAlignVertical["BOTTOM"] = 2] = "BOTTOM";
    })(DAlignVertical || (DAlignVertical = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignWith;
    (function (DAlignWith) {
        DAlignWith[DAlignWith["TEXT"] = 0] = "TEXT";
        DAlignWith[DAlignWith["PADDING"] = 1] = "PADDING";
        DAlignWith[DAlignWith["BORDER"] = 2] = "BORDER";
    })(DAlignWith || (DAlignWith = {}));

    var DImageBaseThemeWrapperSecondary = /** @class */ (function () {
        function DImageBaseThemeWrapperSecondary(theme) {
            this._theme = theme;
        }
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignHorizontal = function () {
            return this._theme.getSecondaryImageAlignHorizontal();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignVertical = function () {
            return this._theme.getSecondaryImageAlignVertical();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignWith = function () {
            return this._theme.getSecondaryImageAlignWith();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageMarginHorizontal = function () {
            return this._theme.getSecondaryImageMarginHorizontal();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageMarginVertial = function () {
            return this._theme.getSecondaryImageMarginVertial();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageTintColor = function (state) {
            return this._theme.getSecondaryImageTintColor(state);
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageTintAlpha = function (state) {
            return this._theme.getSecondaryImageTintAlpha(state);
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageSource = function (state) {
            return this._theme.getSecondaryImageSource(state);
        };
        return DImageBaseThemeWrapperSecondary;
    }());

    var DImageBaseThemeWrapperTertiary = /** @class */ (function () {
        function DImageBaseThemeWrapperTertiary(theme) {
            this._theme = theme;
        }
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignHorizontal = function () {
            return this._theme.getTertiaryImageAlignHorizontal();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignVertical = function () {
            return this._theme.getTertiaryImageAlignVertical();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignWith = function () {
            return this._theme.getTertiaryImageAlignWith();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageMarginHorizontal = function () {
            return this._theme.getTertiaryImageMarginHorizontal();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageMarginVertial = function () {
            return this._theme.getTertiaryImageMarginVertial();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageTintColor = function (state) {
            return this._theme.getTertiaryImageTintColor(state);
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageTintAlpha = function (state) {
            return this._theme.getTertiaryImageTintAlpha(state);
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageSource = function (state) {
            return this._theme.getTertiaryImageSource(state);
        };
        return DImageBaseThemeWrapperTertiary;
    }());

    var toImageAlign = function (theme, options) {
        var align = options && options.align;
        if (align) {
            var alignWith = (align.with != null ?
                (isString(align.with) ? DAlignWith[align.with] : align.with) :
                theme.getImageAlignWith());
            var alignVertical = (align.vertical != null ?
                (isString(align.vertical) ? DAlignVertical[align.vertical] : align.vertical) :
                theme.getImageAlignVertical());
            var alignHorizontal = (align.horizontal != null ?
                (isString(align.horizontal) ? DAlignHorizontal[align.horizontal] : align.horizontal) :
                theme.getImageAlignHorizontal());
            return {
                with: alignWith,
                vertical: alignVertical,
                horizontal: alignHorizontal
            };
        }
        return {
            with: theme.getImageAlignWith(),
            vertical: theme.getImageAlignVertical(),
            horizontal: theme.getImageAlignHorizontal()
        };
    };
    var toImageMargin = function (theme, options) {
        var margin = options && options.margin;
        if (margin) {
            var vertical = (margin.vertical != null ?
                margin.vertical : theme.getImageMarginVertial());
            var horizontal = (margin.horizontal != null ?
                margin.horizontal : theme.getImageMarginHorizontal());
            return {
                vertical: vertical,
                horizontal: horizontal
            };
        }
        return {
            vertical: theme.getImageMarginVertial(),
            horizontal: theme.getImageMarginHorizontal()
        };
    };
    var toImageTint = function (theme, options) {
        if (options && options.tint != null) {
            return options.tint;
        }
        return undefined;
    };
    var DImagePiece = /** @class */ (function () {
        function DImagePiece(parent, theme, options, textAlign, onChange, applyMask) {
            this._image = null;
            this._align = toImageAlign(theme, options);
            this._margin = toImageMargin(theme, options);
            this._tint = toImageTint(theme, options);
            this._bound = new pixi_js.Rectangle();
            this._point = new pixi_js.Point();
            this._source = (options && options.source);
            this._computed = null;
            this._parent = parent;
            this._theme = theme;
            this._textAlign = textAlign;
            this._onChange = onChange;
            this._applyMask = applyMask;
        }
        Object.defineProperty(DImagePiece.prototype, "image", {
            get: function () {
                return this._image;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "align", {
            get: function () {
                return this._align;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "bound", {
            get: function () {
                return this._bound;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "source", {
            get: function () {
                return this._source;
            },
            set: function (source) {
                if (this._source !== source) {
                    this._source = source;
                    this._onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        DImagePiece.prototype.computeSource = function () {
            var source = this._source;
            if (source !== undefined) {
                if (isFunction(source)) {
                    var result = source(this._parent.state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return source;
                }
            }
            return this._theme.getImageSource(this._parent.state);
        };
        DImagePiece.prototype.onStateChange = function (newState, oldState) {
            this.updateTint();
        };
        DImagePiece.prototype.updateBound = function () {
            var bound = this._bound;
            var image = this._image;
            if (image != null) {
                image.updateTransform();
                image.getLocalBounds(bound);
                var bl = bound.left;
                var bt = bound.top;
                var br = bound.right;
                var bb = bound.bottom;
                var localTransform = image.localTransform;
                var a = localTransform.a;
                var b = localTransform.b;
                var c = localTransform.c;
                var d = localTransform.d;
                var x0 = a * bl + c * bt;
                var y0 = b * bl + d * bt;
                var x1 = a * br + c * bt;
                var y1 = b * br + d * bt;
                var x2 = a * br + c * bb;
                var y2 = b * br + d * bb;
                var x3 = a * bl + c * bb;
                var y3 = b * bl + d * bb;
                var xmin = Math.min(x0, x1, x2, x3);
                var xmax = Math.max(x0, x1, x2, x3);
                var ymin = Math.min(y0, y1, y2, y3);
                var ymax = Math.max(y0, y1, y2, y3);
                bound.x = xmin + localTransform.tx;
                bound.y = ymin + localTransform.ty;
                bound.width = xmax - xmin;
                bound.height = ymax - ymin;
            }
            else {
                bound.x = 0;
                bound.y = 0;
                bound.width = 0;
                bound.height = 0;
            }
        };
        DImagePiece.prototype.isTintAware = function (target) {
            return (target != null && "tint" in target);
        };
        DImagePiece.prototype.toTintColor = function (theme, state) {
            var tint = this._tint;
            if (tint) {
                var color = tint.color;
                if (color !== undefined) {
                    if (isFunction(color)) {
                        var result = color(state);
                        if (result !== undefined) {
                            return result;
                        }
                    }
                    else {
                        return color;
                    }
                }
            }
            return theme.getImageTintColor(state);
        };
        DImagePiece.prototype.toTintAlpha = function (theme, state) {
            var tint = this._tint;
            if (tint) {
                var alpha = tint.alpha;
                if (alpha !== undefined) {
                    if (isFunction(alpha)) {
                        var result = alpha(state);
                        if (result !== undefined) {
                            return result;
                        }
                    }
                    else {
                        return alpha;
                    }
                }
            }
            return theme.getImageTintAlpha(state);
        };
        /**
         * Updates the tint.
         *
         * @returns True if the tint is changed.
         */
        DImagePiece.prototype.updateTint = function () {
            var image = this._image;
            if (image) {
                if (this.isTintAware(image)) {
                    var theme = this._theme;
                    var state = this._parent.state;
                    var color = this.toTintColor(theme, state);
                    if (color != null) {
                        var result = false;
                        if (image.tint !== color) {
                            image.tint = color;
                            result = true;
                        }
                        var alpha = this.toTintAlpha(theme, state);
                        if (image.alpha !== alpha) {
                            image.alpha = alpha;
                            result = true;
                        }
                        return result;
                    }
                }
            }
            return false;
        };
        /**
         * Updates the computed source.
         *
         * @returns True if the computed source is changed
         */
        DImagePiece.prototype.updateSource = function () {
            var newComputed = this.computeSource();
            var oldComputed = this._computed;
            if (newComputed !== oldComputed) {
                this._computed = newComputed;
                var parent_1 = this._parent;
                var oldImage = this._image;
                if (newComputed instanceof pixi_js.Texture) {
                    if (oldComputed instanceof pixi_js.Texture) {
                        oldComputed.off("update", this._onChange);
                        if (oldImage instanceof pixi_js.Sprite) {
                            oldImage.texture = newComputed;
                            newComputed.on("update", this._onChange);
                        }
                    }
                    else {
                        if (oldImage != null) {
                            parent_1.removeChild(oldImage);
                        }
                        var newImage = new pixi_js.Sprite(newComputed);
                        this._applyMask(newImage);
                        newComputed.on("update", this._onChange);
                        parent_1.addChild(newImage);
                        this._image = newImage;
                    }
                }
                else {
                    if (oldComputed instanceof pixi_js.Texture) {
                        oldComputed.off("update", this._onChange);
                        if (oldImage != null) {
                            parent_1.removeChild(oldImage);
                            oldImage.destroy();
                        }
                    }
                    else if (oldImage != null) {
                        parent_1.removeChild(oldImage);
                    }
                    if (newComputed != null) {
                        this._applyMask(newComputed);
                        parent_1.addChild(newComputed);
                    }
                    this._image = newComputed;
                }
                return true;
            }
            return false;
        };
        DImagePiece.prototype.isRefitable = function (target) {
            return (target != null && target === this._image);
        };
        DImagePiece.prototype.destroy = function () {
            var image = this._image;
            if (image) {
                this._image = null;
                var computed = this._computed;
                if (computed instanceof pixi_js.Texture) {
                    computed.off("update", this._onChange, this);
                    image.destroy();
                }
            }
        };
        return DImagePiece;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOverflowMaskSimple = /** @class */ (function (_super) {
        __extends(DBaseOverflowMaskSimple, _super);
        function DBaseOverflowMaskSimple(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            return _this;
        }
        DBaseOverflowMaskSimple.prototype.render = function (renderer) {
            this.updateTransform();
            _super.prototype.render.call(this, renderer);
        };
        DBaseOverflowMaskSimple.prototype.onReflow = function (base, width, height) {
            this.clear();
            this.beginFill(0xFFFFFF, 1);
            this.drawRect(0, 0, width, height);
            this.endFill();
        };
        return DBaseOverflowMaskSimple;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Option parser
    var isOverflowMaskEnabled$1 = function (theme, options) {
        if (options && options.mask != null) {
            return options.mask;
        }
        return theme.isOverflowMaskEnabled();
    };
    var toTextValue = function (theme, options) {
        if (options && options.text && options.text.value !== undefined) {
            return options.text.value;
        }
        return theme.newTextValue();
    };
    var toTextStyle = function (theme, options, state) {
        if (options && options.text && options.text.style != null) {
            var style = options.text.style;
            var fill = style.fill != null ? style.fill : theme.getColor(state);
            var fontSize = style.fontSize != null ? style.fontSize : theme.getFontSize();
            var fontFamily = style.fontFamily != null ? style.fontFamily : theme.getFontFamilly();
            var fontWeight = style.fontWeight != null ? style.fontWeight : theme.getFontWeight();
            var fontStyle = style.fontStyle != null ? style.fontStyle : theme.getFontStyle();
            var fontVariant = style.fontVariant != null ? style.fontVariant : theme.getFontVariant();
            var clipping = style.clipping != null ? style.clipping : theme.getTextStyleClipping();
            return {
                fill: fill,
                fontSize: fontSize,
                fontFamily: fontFamily,
                fontWeight: fontWeight,
                fontStyle: fontStyle,
                fontVariant: fontVariant,
                clipping: clipping
            };
        }
        return {
            fill: theme.getColor(state),
            fontSize: theme.getFontSize(),
            fontFamily: theme.getFontFamilly(),
            fontWeight: theme.getFontWeight(),
            fontStyle: theme.getFontStyle(),
            fontVariant: theme.getFontVariant(),
            clipping: theme.getTextStyleClipping()
        };
    };
    var toTextAlign = function (theme, options) {
        if (options && options.text && options.text.align) {
            var align = options.text.align;
            var vertical = (align.vertical != null ?
                (isString(align.vertical) ? DAlignVertical[align.vertical] : align.vertical) :
                theme.getTextAlignVertical());
            var horizontal = (align.horizontal != null ?
                (isString(align.horizontal) ? DAlignHorizontal[align.horizontal] : align.horizontal) :
                theme.getTextAlignHorizontal());
            return {
                vertical: vertical,
                horizontal: horizontal
            };
        }
        return {
            vertical: theme.getTextAlignVertical(),
            horizontal: theme.getTextAlignHorizontal()
        };
    };
    var toTextFormatter = function (theme, options) {
        if (options && options.text && options.text.formatter) {
            return options.text.formatter;
        }
        return theme.getTextFormatter();
    };
    var toTextDynamic = function (theme, options) {
        if (options && options.text && options.text.dynamic != null) {
            return options.text.dynamic;
        }
        return theme.isTextDynamic();
    };
    var DTextBase = /** @class */ (function (_super) {
        __extends(DTextBase, _super);
        function DTextBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTextBase.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._text = null;
            var theme = this.theme;
            this._textValue = toTextValue(theme, options);
            this._textValueComputed = this.computeTextValue();
            this._textColor = (options && options.text && options.text.color);
            this._textAlpha = (options && options.text && options.text.alpha);
            this._textStyle = toTextStyle(theme, options, this.state);
            this._textAlign = toTextAlign(theme, options);
            this._textFormatter = toTextFormatter(theme, options);
            this._textDynamic = toTextDynamic(theme, options);
            this._isOverflowMaskEnabled = isOverflowMaskEnabled$1(theme, options);
            this._overflowMask = null;
            this.onTextChange();
            this.createOrUpdateText();
        };
        Object.defineProperty(DTextBase.prototype, "text", {
            get: function () {
                return this._textValue;
            },
            set: function (text) {
                if (this._textValue !== text) {
                    this._textValue = text;
                    this.updateTextValue();
                }
            },
            enumerable: true,
            configurable: true
        });
        DTextBase.prototype.onTextChange = function () {
            // DO NOTHING
        };
        DTextBase.prototype.computeTextValue = function () {
            var textValue = this._textValue;
            if (textValue !== undefined) {
                if (isFunction(textValue)) {
                    var result = textValue(this.state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return textValue;
                }
            }
            return this.theme.getTextValue(this.state);
        };
        DTextBase.prototype.createOrUpdateText = function () {
            var formatted = this._textFormatter(this._textValueComputed, this);
            if (this._text == null) {
                if (0 < formatted.length) {
                    var text = this.createText(formatted);
                    this._text = text;
                    this.addChild(text);
                    this.updateTextPosition(text);
                    if (this._isOverflowMaskEnabled) {
                        text.mask = this.getOrCreateOverflowMask();
                    }
                    this.toDirty();
                    DApplications.update(this);
                }
            }
            else {
                this._text.text = formatted;
                this.toDirty();
                DApplications.update(this);
            }
        };
        DTextBase.prototype.createText = function (formatted) {
            return (this._textDynamic ?
                new DDynamicText(formatted, this._textStyle) :
                new pixi_js.Text(formatted, this._textStyle));
        };
        DTextBase.prototype.getOrCreateOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMaskSimple(this);
                this.addReflowable(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        DTextBase.prototype.updateTextPosition = function (text) {
            var align = this._textAlign;
            var padding = this._padding;
            var toRounded = this.toRounded;
            switch (align.horizontal) {
                case DAlignHorizontal.LEFT:
                    text.x = toRounded(padding.getLeft());
                    break;
                case DAlignHorizontal.CENTER:
                    text.x = toRounded((this.width - text.width) * 0.5);
                    break;
                case DAlignHorizontal.RIGHT:
                    text.x = toRounded(this.width - text.width - padding.getRight());
                    break;
            }
            switch (align.vertical) {
                case DAlignVertical.TOP:
                    text.y = toRounded(padding.getTop());
                    break;
                case DAlignVertical.MIDDLE:
                    text.y = toRounded((this.height - text.height) * 0.5);
                    break;
                case DAlignVertical.BOTTOM:
                    text.y = toRounded(this.height - text.height - padding.getBottom());
                    break;
            }
        };
        DTextBase.prototype.toRounded = function (value) {
            return Math.round(value);
        };
        DTextBase.prototype.getTextColor = function (theme, state) {
            var color = this._textColor;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return theme.getColor(state);
        };
        DTextBase.prototype.getTextAlpha = function (theme, state) {
            var alpha = this._textAlpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return theme.getAlpha(state);
        };
        DTextBase.prototype.updateTextColor = function (text) {
            var theme = this.theme;
            var state = this.state;
            text.style.fill = this.getTextColor(theme, state);
            text.alpha = this.getTextAlpha(theme, state);
        };
        DTextBase.prototype.updateTextValue = function () {
            var newTextValueComputed = this.computeTextValue();
            if (this._textValueComputed !== newTextValueComputed) {
                this._textValueComputed = newTextValueComputed;
                this.onTextChange();
                this.createOrUpdateText();
            }
        };
        DTextBase.prototype.updateText = function () {
            var text = this._text;
            if (text != null) {
                this.updateTextValue();
                this.updateTextPosition(text);
                this.updateTextColor(text);
            }
        };
        DTextBase.prototype.onReflow = function () {
            _super.prototype.onReflow.call(this);
            this.updateText();
        };
        DTextBase.prototype.isRefitable = function (target) {
            return _super.prototype.isRefitable.call(this, target) ||
                (target != null && target === this._text);
        };
        DTextBase.prototype.applyTitle = function () {
            var text = this._text;
            if (this._title.length <= 0 && text && ("clipped" in text) && text.clipped) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.view.title = text.text;
                }
            }
            else {
                _super.prototype.applyTitle.call(this);
            }
        };
        DTextBase.prototype.getType = function () {
            return "DTextBase";
        };
        DTextBase.prototype.destroy = function () {
            // Text
            var text = this._text;
            if (text != null) {
                this._text = null;
                text.destroy();
            }
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            _super.prototype.destroy.call(this);
        };
        return DTextBase;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hasSecondaryImageSource = function (theme) {
        return !!theme.getSecondaryImageSource;
    };
    var hasTertiaryImageSource = function (theme) {
        return !!theme.getTertiaryImageSource;
    };
    var DImageBase = /** @class */ (function (_super) {
        __extends(DImageBase, _super);
        function DImageBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImageBase.prototype.init = function (options) {
            var _this = this;
            this._onChangeBound = function () {
                _this.toDirty();
                DApplications.update(_this);
            };
            this._applyMaskBound = function (target) {
                if (_this._isOverflowMaskEnabled) {
                    target.mask = _this.getOrCreateOverflowMask();
                }
            };
            this._images = this.newImages(this.theme, options);
            _super.prototype.init.call(this, options);
        };
        DImageBase.prototype.newImages = function (theme, options) {
            var images = [];
            images.push(this.newImage(theme, this.toImageOptions(theme, options && options.image)));
            if (hasSecondaryImageSource(theme)) {
                images.push(this.newImage(new DImageBaseThemeWrapperSecondary(theme)));
            }
            if (hasTertiaryImageSource(theme)) {
                images.push(this.newImage(new DImageBaseThemeWrapperTertiary(theme)));
            }
            return images;
        };
        DImageBase.prototype.toImageOptions = function (theme, options) {
            return options;
        };
        DImageBase.prototype.newImage = function (theme, options) {
            return new DImagePiece(this, theme, options, this._textAlign, this._onChangeBound, this._applyMaskBound);
        };
        Object.defineProperty(DImageBase.prototype, "image", {
            get: function () {
                return this._images[0].source;
            },
            set: function (imageSource) {
                this._images[0].source = imageSource;
            },
            enumerable: true,
            configurable: true
        });
        DImageBase.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            var images = this._images;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                images[i].onStateChange(newState, oldState);
            }
        };
        DImageBase.prototype.updateText = function () {
            this.updateTextValue();
            this.updateTextAndImage();
        };
        DImageBase.prototype.updateTextAndImage = function () {
            var text = this._text;
            var images = this._images;
            var padding = this._padding;
            var toRounded = this.toRounded;
            var width = this.width;
            var height = this.height;
            var pl = padding.getLeft();
            var pr = padding.getRight();
            var pt = padding.getTop();
            var pb = padding.getBottom();
            var noText = text == null;
            var textLeftFirst = noText;
            var textTopFirst = noText;
            var textRightLastMargin = 0;
            var textBottomLastMargin = 0;
            var textLeft = 0;
            var textRight = 0;
            var textTop = 0;
            var textBottom = 0;
            var paddingLeft = pl;
            var paddingRight = width - pr;
            var paddingTop = pt;
            var paddingBottom = height - pb;
            var borderLeft = 0;
            var borderRight = width;
            var borderTop = 0;
            var borderBottom = height;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                var image = images[i];
                image.updateSource();
                image.updateTint();
                image.updateBound();
                var imageImage = image.image;
                if (imageImage) {
                    var imageBound = image.bound;
                    var imageBoundWidth = imageBound.width;
                    var imageBoundHeight = imageBound.height;
                    var imageMargin = image.margin;
                    var imageMarginHorizontal = imageMargin.horizontal;
                    var imageMarginVertical = imageMargin.vertical;
                    // Text
                    if (image.align.with === DAlignWith.TEXT) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.LEFT:
                                imageImage.x = textLeft;
                                textLeft += imageBoundWidth;
                                if (textLeftFirst) {
                                    textLeftFirst = false;
                                }
                                else {
                                    textLeft += imageMarginHorizontal;
                                }
                                break;
                            case DAlignHorizontal.CENTER:
                                // DO NOTHING
                                break;
                            case DAlignHorizontal.RIGHT:
                                textRight -= imageBoundWidth;
                                imageImage.x = textRight;
                                textRight -= imageMarginHorizontal;
                                textRightLastMargin = imageMarginHorizontal;
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.TOP:
                                imageImage.y = textTop;
                                textTop += imageBoundHeight;
                                if (textTopFirst) {
                                    textTopFirst = false;
                                }
                                else {
                                    textTop += imageMarginVertical;
                                }
                                break;
                            case DAlignVertical.MIDDLE:
                                // DO NOTHING
                                break;
                            case DAlignVertical.BOTTOM:
                                textBottom -= imageBoundHeight;
                                imageImage.y = textBottom;
                                textBottom -= imageMarginVertical;
                                textBottomLastMargin = imageMarginVertical;
                                break;
                        }
                    }
                    // Padding
                    if (image.align.with === DAlignWith.PADDING) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.LEFT:
                                paddingLeft += imageMarginHorizontal;
                                imageImage.x = toRounded(paddingLeft);
                                paddingLeft += imageBoundWidth;
                                break;
                            case DAlignHorizontal.CENTER:
                                // DO NOTHING
                                break;
                            case DAlignHorizontal.RIGHT:
                                paddingRight -= imageBoundWidth + imageMarginHorizontal;
                                imageImage.x = toRounded(paddingRight);
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.TOP:
                                paddingTop += imageMarginVertical;
                                imageImage.y = toRounded(paddingTop);
                                paddingTop += imageBoundHeight;
                                break;
                            case DAlignVertical.MIDDLE:
                                // DO NOTHING
                                break;
                            case DAlignVertical.BOTTOM:
                                paddingBottom -= imageBoundHeight + imageMarginVertical;
                                imageImage.y = toRounded(paddingBottom);
                                break;
                        }
                    }
                    // Border
                    if (image.align.with === DAlignWith.BORDER) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.LEFT:
                                borderLeft += imageMarginHorizontal;
                                imageImage.x = toRounded(borderLeft);
                                borderLeft += imageBoundWidth;
                                break;
                            case DAlignHorizontal.CENTER:
                                // DO NOTHING
                                break;
                            case DAlignHorizontal.RIGHT:
                                borderRight -= imageBoundWidth + imageMarginHorizontal;
                                imageImage.x = toRounded(borderRight);
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.TOP:
                                borderTop += imageMarginVertical;
                                imageImage.y = toRounded(borderTop);
                                borderTop += imageBoundHeight;
                                break;
                            case DAlignVertical.MIDDLE:
                                // DO NOTHING
                                break;
                            case DAlignVertical.BOTTOM:
                                borderBottom -= imageBoundHeight + imageMarginVertical;
                                imageImage.y = toRounded(borderBottom);
                                break;
                        }
                    }
                }
            }
            if (noText) {
                textRight += textRightLastMargin;
                textBottom += textBottomLastMargin;
            }
            // Text
            var textLeftAdjust = 0;
            var textCenterAdjust = 0;
            var textRightAdjust = 0;
            var textTopAdjust = 0;
            var textMiddleAdjust = 0;
            var textBottomAdjust = 0;
            if (text != null) {
                this.updateTextColor(text);
                if (text instanceof DDynamicText) {
                    text.setClippingWidthDelta(textLeft - textRight);
                }
                var textAlign = this._textAlign;
                var textWidth = text.width;
                var textHeight = text.height;
                switch (textAlign.horizontal) {
                    case DAlignHorizontal.LEFT:
                        textLeftAdjust = pl;
                        textRightAdjust = textLeftAdjust + textLeft + textWidth - textRight;
                        break;
                    case DAlignHorizontal.CENTER:
                        textLeftAdjust = (width - textLeft + textRight - textWidth) * 0.5;
                        textRightAdjust = textLeftAdjust + textLeft + textWidth - textRight;
                        break;
                    case DAlignHorizontal.RIGHT:
                        textRightAdjust = width - pr;
                        textLeftAdjust = textRightAdjust + textRight - textWidth - textLeft;
                        break;
                }
                text.x = toRounded(textLeftAdjust + textLeft);
                textCenterAdjust = textLeftAdjust + textLeft + textWidth * 0.5;
                switch (textAlign.vertical) {
                    case DAlignVertical.TOP:
                        textTopAdjust = pt;
                        textBottomAdjust = textTopAdjust + textTop + textHeight - textBottom;
                        break;
                    case DAlignVertical.MIDDLE:
                        textTopAdjust = (height - textTop + textBottom - textHeight) * 0.5;
                        textBottomAdjust = textTopAdjust + textTop + textHeight - textBottom;
                        break;
                    case DAlignVertical.BOTTOM:
                        textBottomAdjust = height - pb;
                        textTopAdjust = textBottomAdjust + textBottom - textHeight - textTop;
                        break;
                }
                text.y = toRounded(textTopAdjust + textTop);
                textMiddleAdjust = textTopAdjust + textTop + textHeight * 0.5;
            }
            else {
                textLeftAdjust = (width - textLeft + textRight) * 0.5;
                textRightAdjust = textLeftAdjust + textLeft - textRight;
                textCenterAdjust = textLeftAdjust + textLeft;
                textTopAdjust = (height - textTop + textBottom) * 0.5;
                textBottomAdjust = textTopAdjust + textTop - textBottom;
                textMiddleAdjust = textTopAdjust + textTop;
            }
            var paddingCenterAdjust = width * 0.5;
            var paddingMiddleAdjust = height * 0.5;
            var borderCenterAdjust = width * 0.5;
            var borderMiddleAdjust = height * 0.5;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                var image = images[i];
                var imageImage = image.image;
                if (imageImage) {
                    var imageBound = image.bound;
                    var imageBoundWidth = imageBound.width;
                    var imageBoundHeight = imageBound.height;
                    // Text
                    if (image.align.with === DAlignWith.TEXT) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.LEFT:
                                imageImage.x = toRounded(imageImage.x + textLeftAdjust);
                                break;
                            case DAlignHorizontal.CENTER:
                                imageImage.x = toRounded(textCenterAdjust - imageBoundWidth * 0.5);
                                break;
                            case DAlignHorizontal.RIGHT:
                                imageImage.x = toRounded(imageImage.x + textRightAdjust);
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.TOP:
                                imageImage.y = toRounded(imageImage.y + textTopAdjust);
                                break;
                            case DAlignVertical.MIDDLE:
                                imageImage.y = toRounded(textMiddleAdjust - imageBoundHeight * 0.5);
                                break;
                            case DAlignVertical.BOTTOM:
                                imageImage.y = toRounded(imageImage.y + textBottomAdjust);
                                break;
                        }
                    }
                    // Padding
                    if (image.align.with === DAlignWith.PADDING) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.CENTER:
                                imageImage.x = toRounded(paddingCenterAdjust - imageBoundWidth * 0.5);
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.MIDDLE:
                                imageImage.y = toRounded(paddingMiddleAdjust - imageBoundHeight * 0.5);
                                break;
                        }
                    }
                    // Border
                    if (image.align.with === DAlignWith.BORDER) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.CENTER:
                                imageImage.x = toRounded(borderCenterAdjust - imageBoundWidth * 0.5);
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.MIDDLE:
                                imageImage.y = toRounded(borderMiddleAdjust - imageBoundHeight * 0.5);
                                break;
                        }
                    }
                }
            }
        };
        DImageBase.prototype.isRefitable = function (target) {
            if (_super.prototype.isRefitable.call(this, target)) {
                return true;
            }
            var images = this._images;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                if (images[i].isRefitable(target)) {
                    return true;
                }
            }
            return false;
        };
        DImageBase.prototype.getType = function () {
            return "DImageBase";
        };
        DImageBase.prototype.destroy = function () {
            var images = this._images;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                images[i].destroy();
            }
            _super.prototype.destroy.call(this);
        };
        return DImageBase;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DImage = /** @class */ (function (_super) {
        __extends(DImage, _super);
        function DImage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImage.prototype.getType = function () {
            return "DImage";
        };
        return DImage;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Option parser
    var toValue = function (options) {
        return (options != null && options.value != null ?
            options.value : null);
    };
    var DListItem = /** @class */ (function (_super) {
        __extends(DListItem, _super);
        function DListItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DListItem.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.buttonMode = true;
            this._value = toValue(options);
        };
        Object.defineProperty(DListItem.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        DListItem.prototype.hasSelection = function (target) {
            return (target && target.selection && target.selection.add);
        };
        DListItem.prototype.getSelection = function () {
            var parent = this.parent;
            while (parent) {
                if (this.hasSelection(parent)) {
                    return parent.selection;
                }
                parent = parent.parent;
            }
            return null;
        };
        DListItem.prototype.onSelect = function (e) {
            this.emit("select", this);
            var selection = this.getSelection();
            if (selection) {
                selection.add(this);
            }
        };
        DListItem.prototype.onKeyDown = function (e) {
            if (this.isActionable() && this.isFocused() && UtilKeyboardEvent.isActivateKey(e)) {
                this.onSelect(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DListItem.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            this.buttonMode = DBaseStates.isActionable(newState);
        };
        DListItem.prototype.getType = function () {
            return "DListItem";
        };
        return DListItem;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItem = /** @class */ (function (_super) {
        __extends(DMenuItem, _super);
        function DMenuItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItem.prototype.getContext = function () {
            var parent = this.parent;
            while (parent) {
                if (parent.getContext) {
                    return parent.getContext();
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItem.prototype.getCloseable = function () {
            var parent = this.parent;
            while (parent) {
                if (parent.getCloseable) {
                    return parent.getCloseable();
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItem.prototype.getType = function () {
            return "DMenuItem";
        };
        return DMenuItem;
    }(DListItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemText = /** @class */ (function (_super) {
        __extends(DMenuItemText, _super);
        function DMenuItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemText.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.initOnClick(options);
            this.initOnOver(options);
            this.initShortcuts(options);
        };
        DMenuItemText.prototype.initOnClick = function (options) {
            var _this = this;
            UtilPointerEvent.onClick(this, function (e) {
                if (_this.isActionable()) {
                    _this.onSelect(e);
                }
            });
        };
        DMenuItemText.prototype.initOnOver = function (options) {
            var _this = this;
            this.on(UtilPointerEvent.over, function () {
                var context = _this.getContext();
                if (context != null) {
                    var parent_1 = _this.parent;
                    if (parent_1 instanceof DBase) {
                        context.trim(_this.getCloseable());
                    }
                }
            });
        };
        DMenuItemText.prototype.initShortcuts = function (options) {
            var shortcuts = this._shortcuts;
            this._shortcutMargin = this.theme.getShortcutTextMargin();
            if (shortcuts != null && 0 < shortcuts.length) {
                var shortcut = shortcuts[0];
                var shortcutTextValue = UtilKeyboardEvent.toString(shortcut);
                this._shortcutText = (this._textDynamic ?
                    new DDynamicText(shortcutTextValue, this._textStyle) :
                    new pixi_js.Text(shortcutTextValue, this._textStyle));
                this.appendRenderable(this._shortcutText, true);
            }
            else {
                this._shortcutText = null;
            }
        };
        DMenuItemText.prototype.updateShortcutText = function () {
            var text = this._shortcutText;
            if (text != null) {
                var toRounded = this.toRounded;
                text.position.set(toRounded(this.width - this._shortcutMargin - text.width), toRounded((this.height - text.height) * 0.5));
            }
        };
        DMenuItemText.prototype.updateTextColor = function (text) {
            _super.prototype.updateTextColor.call(this, text);
            var shortcutText = this._shortcutText;
            if (shortcutText != null) {
                var theme = this.theme;
                var state = this.state;
                shortcutText.style.fill = theme.getColor(state);
                shortcutText.alpha = theme.getAlpha(state);
            }
        };
        DMenuItemText.prototype.updateText = function () {
            _super.prototype.updateText.call(this);
            this.updateShortcutText();
        };
        DMenuItemText.prototype.getType = function () {
            return "DMenuItemText";
        };
        DMenuItemText.prototype.onSelect = function (e) {
            _super.prototype.onSelect.call(this, e);
            var closeable = this.getCloseable();
            if (closeable != null) {
                closeable.emit("select", this.value, this, closeable);
            }
        };
        DMenuItemText.prototype.onShortcut = function (e) {
            _super.prototype.onShortcut.call(this, e);
            this.onSelect(e);
        };
        return DMenuItemText;
    }(DMenuItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemCheck = /** @class */ (function (_super) {
        __extends(DMenuItemCheck, _super);
        function DMenuItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemCheck.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            if (options && options.check) {
                this.setActive(true);
            }
        };
        DMenuItemCheck.prototype.getType = function () {
            return "DMenuItemCheck";
        };
        DMenuItemCheck.prototype.onSelect = function (e) {
            this.setActive(!this.isActive());
            _super.prototype.onSelect.call(this, e);
        };
        DMenuItemCheck.isCompatible = function (options) {
            return "check" in options;
        };
        return DMenuItemCheck;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkMenuItemId;
    (function (DLinkMenuItemId) {
        DLinkMenuItemId[DLinkMenuItemId["OPEN_LINK_IN_NEW_WINDOW"] = 0] = "OPEN_LINK_IN_NEW_WINDOW";
        DLinkMenuItemId[DLinkMenuItemId["COPY_LINK_ADDRESS"] = 1] = "COPY_LINK_ADDRESS";
    })(DLinkMenuItemId || (DLinkMenuItemId = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkTarget;
    (function (DLinkTarget) {
        DLinkTarget[DLinkTarget["AUTO"] = 0] = "AUTO";
        DLinkTarget[DLinkTarget["THIS_WINDOW"] = 1] = "THIS_WINDOW";
        DLinkTarget[DLinkTarget["NEW_WINDOW"] = 2] = "NEW_WINDOW";
    })(DLinkTarget || (DLinkTarget = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenus = /** @class */ (function () {
        function DMenus() {
        }
        DMenus.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenus.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenus.setMenuCreator = function (creator) {
            this.MENU_CREATOR = creator;
        };
        DMenus.newItemOf = function (creators, creatorDefault, options, sticky) {
            for (var i = 0, imax = creators.length; i < imax; ++i) {
                var created = creators[i](options, sticky);
                if (created != null) {
                    return created;
                }
            }
            if (creatorDefault) {
                return creatorDefault(options, sticky);
            }
            return null;
        };
        DMenus.newItem = function (options, sticky) {
            return this.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky);
        };
        DMenus.newItemsOf = function (creator, parent, items, sticky) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (item instanceof pixi_js.DisplayObject) {
                    parent.addChild(item);
                }
                else if (item != null) {
                    var created = creator.newItem(item, sticky);
                    if (created != null) {
                        parent.addChild(created);
                    }
                    else {
                        throw new Error("No matching menu item creator found: " + JSON.stringify(item));
                    }
                }
            }
        };
        DMenus.newItems = function (parent, items, sticky) {
            this.newItemsOf(this, parent, items, sticky);
        };
        DMenus.newMenu = function (options) {
            if (this.MENU_CREATOR != null) {
                return this.MENU_CREATOR(options);
            }
            else {
                throw new Error("Missing DMenu creator.");
            }
        };
        DMenus.CREATORS = [];
        DMenus.CREATOR_DEFAULT = null;
        return DMenus;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLink = /** @class */ (function () {
        function DLink(theme, options) {
            if (options) {
                this._url = options.url;
                this._target = options.target;
                this._checker = options.checker;
                this._menuOptions = options.menu;
            }
            this._theme = theme;
        }
        Object.defineProperty(DLink.prototype, "url", {
            get: function () {
                var url = this._url;
                if (isString(url)) {
                    return url;
                }
                else if (url == null) {
                    return null;
                }
                else {
                    return url();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "target", {
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "menu", {
            get: function () {
                var _this = this;
                var menu = this._menu;
                if (menu == null) {
                    var options = this._menuOptions || this._theme.getLinkMenuOptions();
                    menu = this.toMenu(options);
                    this._menu = menu;
                    menu.on("select", function (value, item, closeable) {
                        _this.onMenuSelect(value, item, closeable);
                    });
                }
                return menu;
            },
            enumerable: true,
            configurable: true
        });
        DLink.prototype.toMenu = function (options) {
            if (options instanceof pixi_js.DisplayObject) {
                return options;
            }
            return this.newMenu(options);
        };
        DLink.prototype.newMenu = function (options) {
            return DMenus.newMenu(options);
        };
        DLink.prototype.onMenuSelect = function (value, item, closeable) {
            var _this = this;
            switch (value) {
                case DLinkMenuItemId.OPEN_LINK_IN_NEW_WINDOW:
                    this.open(true);
                    break;
                case DLinkMenuItemId.COPY_LINK_ADDRESS:
                    var url = this.url;
                    if (url != null) {
                        if (isString(url)) {
                            this.copy(url);
                        }
                        else {
                            url.then(function (resolved) {
                                if (resolved != null) {
                                    _this.copy(resolved);
                                }
                            });
                        }
                    }
                    break;
            }
        };
        DLink.prototype.copy = function (url) {
            var a = document.createElement("a");
            a.href = url;
            UtilClipboard.copy(a.href);
        };
        DLink.prototype.apply = function (target, onSelect) {
            var _this = this;
            var onClick = function (e) {
                if (target.isActionable()) {
                    onSelect(e);
                }
            };
            var onLongClick = function (e) {
                if (target.isActionable()) {
                    var menu = _this.menu;
                    if (menu.isHidden()) {
                        menu.open(target);
                    }
                }
            };
            if (this._target === DLinkTarget.NEW_WINDOW) {
                UtilPointerEvent.onClick(target, onClick);
            }
            else {
                UtilPointerEvent.onLongClick(target, onClick, onLongClick);
            }
        };
        DLink.prototype.open = function (inNewWindow) {
            var _this = this;
            var url = this.url;
            if (url != null) {
                if (isString(url)) {
                    this.check(url, inNewWindow);
                }
                else {
                    url.then(function (resolved) {
                        if (resolved) {
                            _this.check(resolved, inNewWindow);
                        }
                    });
                }
            }
        };
        DLink.prototype.check = function (url, inNewWindow) {
            var _this = this;
            var checker = this._checker;
            if (checker) {
                var checked = checker();
                if (checked === true) {
                    this.exec(url, inNewWindow);
                }
                else if (checked === false) ;
                else {
                    checked.then(function (resolved) {
                        if (resolved) {
                            _this.exec(url, inNewWindow);
                        }
                    });
                }
            }
            else {
                this.exec(url, inNewWindow);
            }
        };
        DLink.prototype.exec = function (url, inNewWindow) {
            if (inNewWindow) {
                var a_1 = document.createElement("a");
                a_1.href = url;
                a_1.target = "_blank";
                a_1.style.display = "none";
                a_1.rel = "noopener noreferrer";
                document.body.appendChild(a_1);
                a_1.click();
                setTimeout(function () {
                    document.body.removeChild(a_1);
                }, 100);
            }
            else {
                window.location.href = url;
            }
        };
        DLink.prototype.inNewWindow = function (e) {
            if (this._target === DLinkTarget.NEW_WINDOW) {
                return true;
            }
            else if (e != null) {
                var oe = (e instanceof pixi_js.interaction.InteractionEvent ? e.data.originalEvent : e);
                return ((oe.ctrlKey || oe.shiftKey || oe.altKey || oe.metaKey) ||
                    ("button" in oe && oe.button !== 0));
            }
            else {
                return false;
            }
        };
        return DLink;
    }());

    var DMenuItemLinkState = {
        NEW_WINDOW: DBaseState.CUSTOM
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemLink = /** @class */ (function (_super) {
        __extends(DMenuItemLink, _super);
        function DMenuItemLink(options) {
            return _super.call(this, options) || this;
        }
        DMenuItemLink.prototype.toLinkOptions = function (options) {
            if (options) {
                return {
                    url: this.toUrl(options.url),
                    target: options.target,
                    checker: this.toChecker(options.checker),
                    menu: options.menu
                };
            }
            return undefined;
        };
        DMenuItemLink.prototype.toUrl = function (url) {
            var _this = this;
            if (isString(url) || url == null) {
                return url;
            }
            else {
                return function () {
                    return url(_this);
                };
            }
        };
        DMenuItemLink.prototype.toChecker = function (checker) {
            var _this = this;
            if (checker != null) {
                return function () {
                    return checker(_this);
                };
            }
            return undefined;
        };
        DMenuItemLink.prototype.init = function (options) {
            if (options && options.target === DLinkTarget.NEW_WINDOW) {
                options.state = (options.state || DBaseState.NONE) || DMenuItemLinkState.NEW_WINDOW;
            }
            this._link = new DLink(this.theme, this.toLinkOptions(options));
            _super.prototype.init.call(this, options);
        };
        Object.defineProperty(DMenuItemLink.prototype, "url", {
            get: function () {
                return this._link.url;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DMenuItemLink.prototype, "menu", {
            get: function () {
                return this._link.menu;
            },
            enumerable: true,
            configurable: true
        });
        DMenuItemLink.prototype.initOnClick = function (options) {
            var _this = this;
            this._link.apply(this, function (e) { return _this.onSelect(e); });
        };
        DMenuItemLink.prototype.getType = function () {
            return "DMenuItemLink";
        };
        DMenuItemLink.prototype.onSelect = function (e) {
            _super.prototype.onSelect.call(this, e);
            this.open(this._link.inNewWindow(e));
        };
        DMenuItemLink.prototype.open = function (inNewWindow) {
            this._link.open(inNewWindow);
        };
        DMenuItemLink.prototype.onShortcut = function (e) {
            _super.prototype.onShortcut.call(this, e);
            this.onSelect(e);
        };
        DMenuItemLink.isCompatible = function (options) {
            return "url" in options;
        };
        return DMenuItemLink;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuAlign = UtilAttachAlign;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemMenu = /** @class */ (function (_super) {
        __extends(DMenuItemMenu, _super);
        function DMenuItemMenu(options) {
            return _super.call(this, options) || this;
        }
        DMenuItemMenu.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            UtilPointerEvent.onClick(this, function () {
                if (_this.isActionable()) {
                    _this.open();
                }
            });
            this.initHover(options);
            var menu = this.toMenu(options);
            this._menu = menu;
            menu.on("select", function (value, item, closeable) {
                _this.onMenuSelect(value, item, closeable);
            });
        };
        DMenuItemMenu.prototype.initHover = function (options) {
            var _this = this;
            this.on(UtilPointerEvent.over, function () {
                if (_this.isActionable()) {
                    _this.open();
                }
            });
        };
        DMenuItemMenu.prototype.toMenu = function (options) {
            var menu = options.menu;
            if (menu instanceof pixi_js.DisplayObject) {
                return menu;
            }
            return this.newMenu(menu);
        };
        DMenuItemMenu.prototype.newMenu = function (options) {
            return DMenus.newMenu(options);
        };
        Object.defineProperty(DMenuItemMenu.prototype, "menu", {
            get: function () {
                return this._menu;
            },
            enumerable: true,
            configurable: true
        });
        DMenuItemMenu.prototype.getType = function () {
            return "DMenuItemMenu";
        };
        DMenuItemMenu.prototype.open = function () {
            var menu = this._menu;
            if (menu.isHidden()) {
                this.onOpen(menu);
            }
        };
        DMenuItemMenu.prototype.onOpen = function (menu) {
            var context = this.getContext();
            if (context != null) {
                menu.open(this, this.getCloseable(), context);
            }
        };
        DMenuItemMenu.prototype.close = function () {
            this._menu.close();
        };
        DMenuItemMenu.prototype.toggle = function () {
            var menu = this._menu;
            if (menu.isHidden()) {
                this.onOpen(menu);
            }
            else {
                menu.close();
            }
        };
        DMenuItemMenu.prototype.onSelect = function (e) {
            this.open();
            _super.prototype.onSelect.call(this, e);
        };
        DMenuItemMenu.prototype.onMenuSelect = function (value, item, closeable) {
            var next = this.getCloseable();
            if (next != null) {
                next.emit("select", value, item, closeable);
            }
        };
        DMenuItemMenu.isCompatible = function (options) {
            return "menu" in options;
        };
        DMenuItemMenu.toSubMenuOptions = function (options, sticky) {
            var menu = options.menu;
            if (!(menu instanceof pixi_js.DisplayObject)) {
                if (menu.sticky == null) {
                    menu.sticky = sticky;
                }
                if (menu.align == null) {
                    menu.align = DMenuAlign.RIGHT;
                }
            }
            return options;
        };
        return DMenuItemMenu;
    }(DMenuItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListItemSeparatorReflowable = /** @class */ (function (_super) {
        __extends(DListItemSeparatorReflowable, _super);
        function DListItemSeparatorReflowable(base) {
            var _this = _super.call(this) || this;
            base.appendRenderable(_this, true);
            base.addReflowable(_this);
            return _this;
        }
        DListItemSeparatorReflowable.prototype.onReflow = function (base, width, height) {
            var state = base.state;
            var border = base.border;
            var borderWidth = border.getWidth(state);
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                var borderAlign = border.getAlign(state);
                var padding = base.padding;
                var middle = height * 0.5;
                this.clear();
                this.lineStyle(borderWidth, borderColor, borderAlpha, borderAlign);
                this.moveTo(padding.getLeft(), middle);
                this.lineTo(width - padding.getRight(), middle);
                this.visible = true;
            }
            else {
                this.clear();
                this.visible = false;
            }
        };
        return DListItemSeparatorReflowable;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListItemSeparator = /** @class */ (function (_super) {
        __extends(DListItemSeparator, _super);
        function DListItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DListItemSeparator.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.interactive = false;
            this.buttonMode = false;
            this.setState(DBaseState.UNFOCUSABLE, true);
        };
        DListItemSeparator.prototype.initReflowable = function () {
            new DListItemSeparatorReflowable(this);
        };
        DListItemSeparator.prototype.getType = function () {
            return "DListItemSeparator";
        };
        return DListItemSeparator;
    }(DListItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuItemSeparator, _super);
        function DMenuItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemSeparator.prototype.getType = function () {
            return "DMenuItemSeparator";
        };
        DMenuItemSeparator.isCompatible = function (options) {
            return "separator" in options;
        };
        return DMenuItemSeparator;
    }(DListItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutSpace = /** @class */ (function (_super) {
        __extends(DLayoutSpace, _super);
        function DLayoutSpace(options) {
            var _this = _super.call(this, options) || this;
            _this.visible = false;
            _this.setState(DBaseState.UNFOCUSABLE, true);
            return _this;
        }
        DLayoutSpace.prototype.getType = function () {
            return "DLayoutSpace";
        };
        return DLayoutSpace;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSpace = /** @class */ (function (_super) {
        __extends(DMenuItemSpace, _super);
        function DMenuItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemSpace.prototype.getType = function () {
            return "DMenuItemSpace";
        };
        DMenuItemSpace.isCompatible = function (options) {
            return "space" in options;
        };
        return DMenuItemSpace;
    }(DLayoutSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItem = function () {
        DMenus.addItemCreator(function (options) {
            if (DMenuItemCheck.isCompatible(options)) {
                return new DMenuItemCheck(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemLink.isCompatible(options)) {
                return new DMenuItemLink(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options, sticky) {
            if (DMenuItemMenu.isCompatible(options)) {
                return new DMenuItemMenu(DMenuItemMenu.toSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemSeparator.isCompatible(options)) {
                return new DMenuItemSeparator(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemSpace.isCompatible(options)) {
                return new DMenuItemSpace(options);
            }
            return null;
        });
        DMenus.setItemCreatorDefault(function (options) {
            return new DMenuItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutDirection;
    (function (DLayoutDirection) {
        DLayoutDirection[DLayoutDirection["VERTICAL"] = 0] = "VERTICAL";
        DLayoutDirection[DLayoutDirection["HORIZONTAL"] = 1] = "HORIZONTAL";
    })(DLayoutDirection || (DLayoutDirection = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isVisible = function (child) {
        return child instanceof DBase && (child.visible || child instanceof DLayoutSpace);
    };
    var toMultiplicity = function (theme, options) {
        if (options) {
            if (options.row != null) {
                return options.row;
            }
            if (options.column != null) {
                return options.column;
            }
        }
        return theme.getMultiplicity();
    };
    var toMargin = function (theme, options) {
        if (options && options.margin != null) {
            var margin = options.margin;
            if (isNumber(margin)) {
                return {
                    horizontal: margin,
                    vertical: margin
                };
            }
            else {
                var themeMargin = theme.getMargin();
                return {
                    horizontal: (margin.horizontal != null ? margin.horizontal : themeMargin),
                    vertical: (margin.vertical != null ? margin.vertical : themeMargin)
                };
            }
        }
        else {
            var themeMargin = theme.getMargin();
            return {
                horizontal: themeMargin,
                vertical: themeMargin
            };
        }
    };
    var toDirection = function (theme, options) {
        if (options && options.direction != null) {
            var direction = options.direction;
            if (isString(direction)) {
                return DLayoutDirection[direction];
            }
            else {
                return direction;
            }
        }
        return theme.getDirection();
    };
    var toCornerAdjust = function (theme, options) {
        if (options && options.corner != null && !isNumber(options.corner) && options.corner.adjust != null) {
            return options.corner.adjust;
        }
        return theme.getCornerAdjust();
    };
    var toReverse = function (theme, options) {
        if (options && options.reverse != null) {
            return options.reverse;
        }
        return theme.getReverse();
    };
    var DLayout = /** @class */ (function (_super) {
        __extends(DLayout, _super);
        function DLayout(options) {
            return _super.call(this, options) || this;
        }
        DLayout.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.UNFOCUSABLE, true);
            var theme = this.theme;
            this._margin = toMargin(theme, options);
            this._direction = toDirection(theme, options);
            this._cornerAdjust = toCornerAdjust(theme, options);
            this._multiplicity = toMultiplicity(theme, options);
            this._reverse = toReverse(theme, options);
        };
        DLayout.prototype.getWeightTotal = function () {
            var children = this.children;
            var result = 0;
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            for (var i = 0, imax = children.length; i < imax;) {
                var weight = -1;
                var j = 0;
                for (; j < multiplicity && i + j < imax; ++j) {
                    var child = children[reverse ? imax - 1 - (i + j) : i + j];
                    if (isVisible(child)) {
                        var clearType = child.getClearType();
                        if (j !== 0 && (clearType & DLayoutClearType.BEFORE)) {
                            break;
                        }
                        else {
                            weight = Math.max(weight, child.weight);
                            if (clearType && DLayoutClearType.AFTER) {
                                j += 1;
                                break;
                            }
                        }
                    }
                    else {
                        i += 1;
                        j -= 1;
                    }
                }
                i += j;
                if (0 <= weight) {
                    result += weight;
                }
            }
            return result;
        };
        DLayout.prototype.getSpaceLeft = function (baseSize, margin) {
            var children = this.children;
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            if (this._direction === DLayoutDirection.VERTICAL) {
                var result = baseSize;
                var marginNext = 0;
                for (var i = 0, imax = children.length; i < imax;) {
                    var height = 0;
                    var weight = -1;
                    var j = 0;
                    for (; j < multiplicity && i + j < imax; ++j) {
                        var child = children[reverse ? imax - 1 - (i + j) : i + j];
                        if (isVisible(child)) {
                            var clearType = child.getClearType();
                            if (j !== 0 && (clearType & DLayoutClearType.BEFORE)) {
                                break;
                            }
                            else {
                                weight = Math.max(weight, child.weight);
                                if (weight < 0) {
                                    height = Math.max(height, child.height + marginNext);
                                }
                                else {
                                    height = marginNext;
                                }
                                if (clearType & DLayoutClearType.AFTER) {
                                    j += 1;
                                    break;
                                }
                            }
                        }
                        else {
                            i += 1;
                            j -= 1;
                        }
                    }
                    i += j;
                    result -= height;
                    marginNext = margin;
                }
                return Math.max(0, result);
            }
            else {
                var result = baseSize;
                var marginNext = 0;
                for (var i = 0, imax = children.length; i < imax;) {
                    var width = 0;
                    var weight = -1;
                    var j = 0;
                    for (; j < multiplicity && i + j < imax; ++j) {
                        var child = children[reverse ? imax - 1 - (i + j) : i + j];
                        if (isVisible(child)) {
                            var clearType = child.getClearType();
                            if (j !== 0 && (clearType & DLayoutClearType.BEFORE)) {
                                break;
                            }
                            else {
                                weight = Math.max(weight, child.weight);
                                if (weight < 0) {
                                    width = Math.max(width, child.width + marginNext);
                                }
                                else {
                                    width = marginNext;
                                }
                                if (clearType & DLayoutClearType.AFTER) {
                                    j += 1;
                                    break;
                                }
                            }
                        }
                        else {
                            i += 1;
                            j -= 1;
                        }
                    }
                    i += j;
                    result -= width;
                    marginNext = margin;
                }
                return Math.max(0, result);
            }
        };
        DLayout.prototype.onRefit = function () {
            var children = this.children;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            var paddingRight = padding.getRight();
            var margin = this._margin;
            var marginVertical = margin.vertical;
            var marginHorizontal = margin.horizontal;
            var weightTotal = this.getWeightTotal();
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            var cornerAdjustWork = null;
            if (this._cornerAdjust) {
                var requiredSize = 4 + (children.length << 1);
                if (DLayout.CORNER_ADJUST_WORK == null || DLayout.CORNER_ADJUST_WORK.length < requiredSize) {
                    DLayout.CORNER_ADJUST_WORK = new Float32Array(requiredSize);
                }
                cornerAdjustWork = DLayout.CORNER_ADJUST_WORK;
                cornerAdjustWork[0] = -2;
                cornerAdjustWork[1] = -2;
                cornerAdjustWork[requiredSize - 2] = -3;
                cornerAdjustWork[requiredSize - 1] = -3;
            }
            if (this._direction === DLayoutDirection.VERTICAL) {
                var irow = 0;
                var y = paddingTop - marginVertical;
                if (0 < weightTotal) {
                    var weightTotalInverse = 1 / weightTotal;
                    var baseSize = this.height - paddingTop - paddingBottom;
                    var spaceLeft = this.getSpaceLeft(baseSize, marginVertical);
                    for (var i = 0, imax = children.length; i < imax;) {
                        var x = paddingLeft - marginHorizontal;
                        var height = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && (clearType & DLayoutClearType.BEFORE)) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.height = spaceLeft * (weight * weightTotalInverse);
                                    }
                                    x += marginHorizontal + child.width;
                                    height = Math.max(height, child.height);
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = j - 1;
                                    cornerAdjustWork[k + 1] = irow;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        y += marginVertical + height;
                        i += j;
                        irow += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var icolumn0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findRowIndexPrevious(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        icolumn0 = cornerAdjustWork[i0];
                                    }
                                }
                                var icolumn2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findRowIndexNext(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        icolumn2 = cornerAdjustWork[i2];
                                    }
                                }
                                var ncolumn = this.countColumn(i1, irow1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskColumn(icolumn0, icolumn1, icolumn2, ncolumn);
                            }
                        }
                    }
                }
                else {
                    for (var i = 0, imax = children.length; i < imax;) {
                        var x = paddingLeft - marginHorizontal;
                        var height = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && (clearType & DLayoutClearType.BEFORE)) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.height = 0;
                                    }
                                    x += marginHorizontal + child.width;
                                    height = Math.max(height, child.height);
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = j - 1;
                                    cornerAdjustWork[k + 1] = irow;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        y += marginVertical + height;
                        i += j;
                        irow += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var icolumn0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findRowIndexPrevious(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        icolumn0 = cornerAdjustWork[i0];
                                    }
                                }
                                var icolumn2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findRowIndexNext(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        icolumn2 = cornerAdjustWork[i2];
                                    }
                                }
                                var ncolumn = this.countColumn(i1, irow1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskColumn(icolumn0, icolumn1, icolumn2, ncolumn);
                            }
                        }
                    }
                }
            }
            else {
                var icolumn = 0;
                var x = paddingLeft - marginHorizontal;
                if (0 < weightTotal) {
                    var weightTotalInverse = 1 / weightTotal;
                    var baseSize = this.width - paddingLeft - paddingRight;
                    var spaceLeft = this.getSpaceLeft(baseSize, marginHorizontal);
                    for (var i = 0, imax = children.length; i < imax;) {
                        var y = paddingTop - marginVertical;
                        var width = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && (clearType & DLayoutClearType.BEFORE)) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.width = spaceLeft * (weight * weightTotalInverse);
                                    }
                                    width = Math.max(width, child.width);
                                    y += marginVertical + child.height;
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = icolumn;
                                    cornerAdjustWork[k + 1] = j - 1;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        x += marginHorizontal + width;
                        i += j;
                        icolumn += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var irow0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findColumnIndexPrevious(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        irow0 = cornerAdjustWork[i0 + 1];
                                    }
                                }
                                var irow2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findColumnIndexNext(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        irow2 = cornerAdjustWork[i2 + 1];
                                    }
                                }
                                var nrow = this.countRow(i1, icolumn1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskRow(irow0, irow1, irow2, nrow);
                            }
                        }
                    }
                }
                else {
                    for (var i = 0, imax = children.length; i < imax;) {
                        var y = paddingTop - marginVertical;
                        var width = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && (clearType & DLayoutClearType.BEFORE)) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.width = 0;
                                    }
                                    width = Math.max(width, child.width);
                                    y += marginVertical + child.height;
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = icolumn;
                                    cornerAdjustWork[k + 1] = j - 1;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        x += marginHorizontal + width;
                        i += j;
                        icolumn += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var irow0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findColumnIndexPrevious(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        irow0 = cornerAdjustWork[i0 + 1];
                                    }
                                }
                                var irow2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findColumnIndexNext(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        irow2 = cornerAdjustWork[i2 + 1];
                                    }
                                }
                                var nrow = this.countRow(i1, icolumn1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskRow(irow0, irow1, irow2, nrow);
                            }
                        }
                    }
                }
            }
            _super.prototype.onRefit.call(this);
        };
        DLayout.prototype.hasClearTypeBefore = function (children, index) {
            return this.hasClearType(children, index, DLayoutClearType.BEFORE);
        };
        DLayout.prototype.hasClearTypeAfter = function (children, index) {
            return this.hasClearType(children, index, DLayoutClearType.AFTER);
        };
        DLayout.prototype.hasClearType = function (children, index, clearType) {
            if (2 <= index) {
                var i = (index - 2) >> 1;
                if (0 <= i && i < children.length) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        return !!(child.getClearType() & clearType);
                    }
                }
            }
            return false;
        };
        DLayout.prototype.findColumnIndexPrevious = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart - 2; 0 <= i; i -= 2) {
                if (cornerAdjustWork[i] !== icolumn) {
                    return i;
                }
            }
            return 0;
        };
        DLayout.prototype.findColumnIndexNext = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var icolumn2 = cornerAdjustWork[i];
                if (icolumn2 !== icolumn) {
                    for (var j = i + 2; j < imax; j += 2) {
                        if (cornerAdjustWork[j] !== icolumn2) {
                            return j - 2;
                        }
                    }
                    return i;
                }
            }
            return cornerAdjustWork.length - 2;
        };
        DLayout.prototype.countRow = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var icolumn2 = cornerAdjustWork[i];
                if (icolumn2 !== icolumn) {
                    return cornerAdjustWork[i - 2 + 1] + 1;
                }
            }
            return 0;
        };
        DLayout.prototype.findRowIndexPrevious = function (istart, irow, cornerAdjustWork) {
            for (var i = istart - 2; 0 <= i; i -= 2) {
                if (cornerAdjustWork[i + 1] !== irow) {
                    return i;
                }
            }
            return 0;
        };
        DLayout.prototype.findRowIndexNext = function (istart, irow, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var irow2 = cornerAdjustWork[i + 1];
                if (irow2 !== irow) {
                    for (var j = i + 2; j < imax; j += 2) {
                        if (cornerAdjustWork[j + 1] !== irow2) {
                            return j - 2;
                        }
                    }
                    return i;
                }
            }
            return cornerAdjustWork.length - 2;
        };
        DLayout.prototype.countColumn = function (istart, irow, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var irow2 = cornerAdjustWork[i + 1];
                if (irow2 !== irow) {
                    return cornerAdjustWork[i - 2 + 0] + 1;
                }
            }
            return 0;
        };
        DLayout.prototype.toCornerMaskColumn = function (i0, i1, i2, n) {
            var result = DCornerMask.NONE;
            if (i0 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_LEFT;
            }
            if (i2 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.BOTTOM_LEFT;
            }
            if (i0 < i1 && i1 + 1 === n) {
                result |= DCornerMask.TOP_RIGHT;
            }
            if (i2 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_RIGHT;
            }
            return DCornerMask.ALL & (~result);
        };
        DLayout.prototype.toCornerMaskRow = function (i0, i1, i2, n) {
            var result = DCornerMask.NONE;
            if (i0 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_LEFT;
            }
            if (i2 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_RIGHT;
            }
            if (i0 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_LEFT;
            }
            if (i2 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_RIGHT;
            }
            return DCornerMask.ALL & (~result);
        };
        DLayout.prototype.addSpace = function (options) {
            return this.addChild(new DLayoutSpace(options));
        };
        DLayout.prototype.getType = function () {
            return "DLayout";
        };
        DLayout.CORNER_ADJUST_WORK = null;
        return DLayout;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutVertical = /** @class */ (function (_super) {
        __extends(DLayoutVertical, _super);
        function DLayoutVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayoutVertical.prototype.getType = function () {
            return "DLayoutVertical";
        };
        return DLayoutVertical;
    }(DLayout));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableBody = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableBody, _super);
        function DMenuItemExpandableBody(options) {
            return _super.call(this, options) || this;
        }
        DMenuItemExpandableBody.prototype.getType = function () {
            return "DMenuItemExpandableBody";
        };
        return DMenuItemExpandableBody;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableHeader = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableHeader, _super);
        function DMenuItemExpandableHeader() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableHeader.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.on(UtilPointerEvent.down, function (e) {
                if (_this.isActionable()) {
                    _this.onSelect(e);
                }
            });
        };
        DMenuItemExpandableHeader.prototype.getSelection = function () {
            return null;
        };
        DMenuItemExpandableHeader.prototype.getType = function () {
            return "DMenuItemExpandableHeader";
        };
        return DMenuItemExpandableHeader;
    }(DListItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandables = /** @class */ (function () {
        function DMenuItemExpandables() {
        }
        DMenuItemExpandables.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuItemExpandables.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuItemExpandables.newItem = function (options, sticky) {
            return DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenus.newItem(options, sticky);
        };
        DMenuItemExpandables.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuItemExpandables.CREATORS = [];
        DMenuItemExpandables.CREATOR_DEFAULT = null;
        return DMenuItemExpandables;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandable = /** @class */ (function (_super) {
        __extends(DMenuItemExpandable, _super);
        function DMenuItemExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandable.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            // Header
            var theme = this.theme;
            var header = this.toHeader(theme, options);
            this._header = header;
            header.on("select", function () {
                _this.toggle();
            });
            this.addChild(header);
            // Body
            var body = this.toBody(theme, options);
            this._body = body;
            var sticky = (options && options.sticky != null ? options.sticky : false);
            this.newItems(body, sticky, theme, options);
            this.addChild(body);
            //
            if (this.isActive()) {
                this.onActivated();
            }
            else {
                this.onDeactivated();
            }
        };
        DMenuItemExpandable.prototype.newItems = function (body, sticky, theme, options) {
            if (options != null && options.items != null) {
                DMenuItemExpandables.newItems(body, options.items, sticky);
            }
        };
        DMenuItemExpandable.prototype.toHeader = function (theme, options) {
            if (options) {
                if (options.header instanceof pixi_js.DisplayObject) {
                    return options.header;
                }
                else {
                    return this.newHeader(theme, options.header);
                }
            }
            return this.newHeader(theme);
        };
        DMenuItemExpandable.prototype.newHeader = function (theme, options) {
            return new DMenuItemExpandableHeader(options);
        };
        DMenuItemExpandable.prototype.toBody = function (theme, options) {
            if (options && options.body) {
                if (options.body instanceof pixi_js.DisplayObject) {
                    return options.body;
                }
                else {
                    return this.newBody(theme, options.body);
                }
            }
            return this.newBody(theme);
        };
        DMenuItemExpandable.prototype.newBody = function (theme, options) {
            return new DMenuItemExpandableBody(options);
        };
        DMenuItemExpandable.prototype.open = function () {
            this.setActive(true);
        };
        DMenuItemExpandable.prototype.close = function () {
            this.setActive(false);
        };
        DMenuItemExpandable.prototype.toggle = function () {
            this.setActive(!this.isActive());
        };
        DMenuItemExpandable.prototype.onActivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.show();
            }
            else {
                body.visible = true;
            }
        };
        DMenuItemExpandable.prototype.onDeactivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.hide();
            }
            else {
                body.visible = false;
            }
        };
        DMenuItemExpandable.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (DBaseStates.isActive(newState)) {
                if (!DBaseStates.isActive(oldState)) {
                    this.onActivated();
                }
            }
            else {
                if (DBaseStates.isActive(oldState)) {
                    this.onDeactivated();
                }
            }
        };
        DMenuItemExpandable.prototype.getType = function () {
            return "DMenuItemExpandable";
        };
        DMenuItemExpandable.isCompatible = function (options) {
            return "header" in options;
        };
        return DMenuItemExpandable;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemCheck = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemCheck, _super);
        function DMenuItemExpandableItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemCheck.prototype.getType = function () {
            return "DMenuItemExpandableItemCheck";
        };
        return DMenuItemExpandableItemCheck;
    }(DMenuItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemLink = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemLink, _super);
        function DMenuItemExpandableItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemLink.prototype.getType = function () {
            return "DMenuItemExpandableItemLink";
        };
        return DMenuItemExpandableItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemSeparator, _super);
        function DMenuItemExpandableItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemSeparator.prototype.getType = function () {
            return "DMenuItemExpandableItemSeparator";
        };
        return DMenuItemExpandableItemSeparator;
    }(DMenuItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemSpace = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemSpace, _super);
        function DMenuItemExpandableItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemSpace.prototype.getType = function () {
            return "DMenuItemExpandableItemSpace";
        };
        return DMenuItemExpandableItemSpace;
    }(DMenuItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemText = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemText, _super);
        function DMenuItemExpandableItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemText.prototype.getType = function () {
            return "DMenuItemExpandableItemText";
        };
        return DMenuItemExpandableItemText;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItemExpandable = function () {
        DMenus.addItemCreator(function (options) {
            if (DMenuItemExpandable.isCompatible(options)) {
                return new DMenuItemExpandable(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemCheck.isCompatible(options)) {
                return new DMenuItemExpandableItemCheck(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemLink.isCompatible(options)) {
                return new DMenuItemExpandableItemLink(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSeparator.isCompatible(options)) {
                return new DMenuItemExpandableItemSeparator(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSpace.isCompatible(options)) {
                return new DMenuItemExpandableItemSpace(options);
            }
            return null;
        });
        DMenuItemExpandables.setItemCreatorDefault(function (options) {
            return new DMenuItemExpandableItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemCheck = /** @class */ (function (_super) {
        __extends(DMenuSidedItemCheck, _super);
        function DMenuSidedItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemCheck.prototype.getType = function () {
            return "DMenuSidedItemCheck";
        };
        return DMenuSidedItemCheck;
    }(DMenuItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemLink = /** @class */ (function (_super) {
        __extends(DMenuSidedItemLink, _super);
        function DMenuSidedItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemLink.prototype.getSelection = function () {
            return null;
        };
        DMenuSidedItemLink.prototype.getType = function () {
            return "DMenuSidedItemLink";
        };
        return DMenuSidedItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemMenu = /** @class */ (function (_super) {
        __extends(DMenuSidedItemMenu, _super);
        function DMenuSidedItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemMenu.prototype.initHover = function (options) {
            // DO NOTHING
        };
        DMenuSidedItemMenu.prototype.onMenuSelect = function (value, item, closeable) {
            _super.prototype.onMenuSelect.call(this, value, item, closeable);
            var selection = this.getSelection();
            if (selection) {
                selection.add(item);
            }
        };
        DMenuSidedItemMenu.prototype.onOpen = function (menu) {
            menu.open(this, this);
        };
        DMenuSidedItemMenu.prototype.getType = function () {
            return "DMenuSidedItemMenu";
        };
        return DMenuSidedItemMenu;
    }(DMenuItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuSidedItemSeparator, _super);
        function DMenuSidedItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemSeparator.prototype.getType = function () {
            return "DMenuSidedItemSeparator";
        };
        return DMenuSidedItemSeparator;
    }(DMenuItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemSpace = /** @class */ (function (_super) {
        __extends(DMenuSidedItemSpace, _super);
        function DMenuSidedItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemSpace.prototype.getType = function () {
            return "DMenuSidedItemSpace";
        };
        return DMenuSidedItemSpace;
    }(DMenuItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemText = /** @class */ (function (_super) {
        __extends(DMenuSidedItemText, _super);
        function DMenuSidedItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemText.prototype.getType = function () {
            return "DMenuSidedItemText";
        };
        return DMenuSidedItemText;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSideds = /** @class */ (function () {
        function DMenuSideds() {
        }
        DMenuSideds.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuSideds.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuSideds.newItem = function (options, sticky) {
            return DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenus.newItem(options, sticky);
        };
        DMenuSideds.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuSideds.CREATORS = [];
        DMenuSideds.CREATOR_DEFAULT = null;
        return DMenuSideds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuSidedItem = function () {
        DMenuSideds.setItemCreatorDefault(function (options) {
            return new DMenuSidedItemText(options);
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemSpace.isCompatible(options)) {
                return new DMenuSidedItemSpace(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemSeparator.isCompatible(options)) {
                return new DMenuSidedItemSeparator(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options, sticky) {
            if (DMenuItemMenu.isCompatible(options)) {
                return new DMenuSidedItemMenu(DMenuItemMenu.toSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemLink.isCompatible(options)) {
                return new DMenuSidedItemLink(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemCheck.isCompatible(options)) {
                return new DMenuSidedItemCheck(options);
            }
            return null;
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandables = /** @class */ (function () {
        function DMenuSidedItemExpandables() {
        }
        DMenuSidedItemExpandables.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuSidedItemExpandables.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuSidedItemExpandables.newItem = function (options, sticky) {
            return DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenuSideds.newItem(options, sticky);
        };
        DMenuSidedItemExpandables.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuSidedItemExpandables.CREATORS = [];
        DMenuSidedItemExpandables.CREATOR_DEFAULT = null;
        return DMenuSidedItemExpandables;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandable = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandable, _super);
        function DMenuSidedItemExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandable.prototype.newItems = function (body, sticky, theme, options) {
            if (options != null && options.items != null) {
                DMenuSidedItemExpandables.newItems(body, options.items, sticky);
            }
        };
        DMenuSidedItemExpandable.prototype.getType = function () {
            return "DMenuSidedItemExpandable";
        };
        return DMenuSidedItemExpandable;
    }(DMenuItemExpandable));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemCheck = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemCheck, _super);
        function DMenuSidedItemExpandableItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemCheck.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemCheck";
        };
        return DMenuSidedItemExpandableItemCheck;
    }(DMenuItemExpandableItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemLink = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemLink, _super);
        function DMenuSidedItemExpandableItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemLink.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemLink";
        };
        return DMenuSidedItemExpandableItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemMenu = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemMenu, _super);
        function DMenuItemExpandableItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemMenu.prototype.getType = function () {
            return "DMenuItemExpandableItemMenu";
        };
        return DMenuItemExpandableItemMenu;
    }(DMenuItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemMenu = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemMenu, _super);
        function DMenuSidedItemExpandableItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemMenu.prototype.onOpen = function (menu) {
            menu.open(this, this);
        };
        DMenuSidedItemExpandableItemMenu.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemMenu";
        };
        return DMenuSidedItemExpandableItemMenu;
    }(DMenuItemExpandableItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemSeparator, _super);
        function DMenuSidedItemExpandableItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemSeparator.prototype.getType = function () {
            return "DMenuSidedItemSeparator";
        };
        return DMenuSidedItemExpandableItemSeparator;
    }(DMenuItemExpandableItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemSpace = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemSpace, _super);
        function DMenuSidedItemExpandableItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemSpace.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemSpace";
        };
        return DMenuSidedItemExpandableItemSpace;
    }(DMenuItemExpandableItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemText = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemText, _super);
        function DMenuSidedItemExpandableItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemText.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemText";
        };
        return DMenuSidedItemExpandableItemText;
    }(DMenuItemExpandableItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuSidedItemExpandable = function () {
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemExpandable.isCompatible(options)) {
                return new DMenuSidedItemExpandable(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemCheck.isCompatible(options)) {
                return new DMenuSidedItemExpandableItemCheck(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemLink.isCompatible(options)) {
                return new DMenuSidedItemExpandableItemLink(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options, sticky) {
            if (DMenuItemMenu.isCompatible(options)) {
                return new DMenuSidedItemExpandableItemMenu(DMenuItemMenu.toSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSeparator.isCompatible(options)) {
                return new DMenuSidedItemExpandableItemSeparator(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSpace.isCompatible(options)) {
                return new DMenuSidedItemExpandableItemSpace(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.setItemCreatorDefault(function (options) {
            return new DMenuSidedItemExpandableItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItemAll = function () {
        loadMenuItem();
        loadMenuItemExpandable();
        loadMenuSidedItem();
        loadMenuSidedItemExpandable();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadAll = function () {
        loadMenuItemAll();
        loadShapeAll();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImageSdf = function (dataUrl, convertToSdf) {
        if (convertToSdf) {
            return EShapeImageElements.toImageElement(dataUrl)
                .then(function (imageElement) {
                var generator = DynamicSDFFontGenerator.getInstance().init();
                generator.updateTexture(imageElement);
                generator.render();
                var canvas = document.createElement("canvas");
                generator.read(canvas);
                return createImageSdf(canvas.toDataURL(), false);
            });
        }
        else {
            return EShapeImageElements.toImageElement(dataUrl)
                .then(function (imageElement) {
                return new EShapeImageSdf(imageElement);
            });
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImage = function (dataUrl) {
        return EShapeImageElements.toImageElement(dataUrl).then(function (imageElement) {
            return new EShapeImage(imageElement);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLine = function (points, segments, strokeWidth, style) {
        return new EShapeLine(points, segments, strokeWidth, style);
    };
    var toLineStrokeWidth = function (index, resources) {
        if (0 <= index && index < resources.length) {
            try {
                return JSON.parse(resources[index])[3];
            }
            catch (e) {
                //
            }
        }
        return 8;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupFillViewer = /** @class */ (function () {
        function EShapeGroupFillViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupFillViewer.prototype, "enable", {
            get: function () {
                return true;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillViewer.prototype, "color", {
            get: function () {
                return 0xffffff;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupFillViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupFillViewer.prototype.set = function (enable, color, alpha) {
            // DO NOTHING
        };
        EShapeGroupFillViewer.prototype.clone = function () {
            return new EShapeGroupFillViewer();
        };
        EShapeGroupFillViewer.prototype.toObject = function () {
            return {
                enable: true,
                color: 0xffffff,
                alpha: 1.0
            };
        };
        EShapeGroupFillViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupFillViewer.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupFillViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupStrokeViewer = /** @class */ (function () {
        function EShapeGroupStrokeViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "enable", {
            get: function () {
                return false;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "color", {
            get: function () {
                return 0xffffff;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "width", {
            get: function () {
                return 1.0;
            },
            set: function (width) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "align", {
            get: function () {
                return 0.0;
            },
            set: function (width) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "side", {
            get: function () {
                return EShapeStrokeSide.NONE;
            },
            set: function (side) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupStrokeViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupStrokeViewer.prototype.set = function (enable, color, alpha, width, side) {
            // DO NOTHING
        };
        EShapeGroupStrokeViewer.prototype.clone = function () {
            return new EShapeGroupStrokeViewer();
        };
        EShapeGroupStrokeViewer.prototype.toObject = function () {
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0,
                align: 0.0,
                side: EShapeStrokeSide.NONE
            };
        };
        EShapeGroupStrokeViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupStrokeViewer.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupStrokeViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextAlignViewer = /** @class */ (function () {
        function EShapeGroupTextAlignViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupTextAlignViewer.prototype, "horizontal", {
            get: function () {
                return EShapeTextAlignHorizontal.CENTER;
            },
            set: function (horizontal) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextAlignViewer.prototype, "vertical", {
            get: function () {
                return EShapeTextAlignVertical.MIDDLE;
            },
            set: function (vertical) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextAlignViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupTextAlignViewer.prototype.set = function (horizontal, vertical) {
            // DO NOTHING
        };
        EShapeGroupTextAlignViewer.prototype.toObject = function () {
            return {
                horizontal: EShapeTextAlignHorizontal.CENTER,
                vertical: EShapeTextAlignVertical.MIDDLE
            };
        };
        EShapeGroupTextAlignViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextAlignViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextAlignViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextOffsetViewer = /** @class */ (function () {
        function EShapeGroupTextOffsetViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupTextOffsetViewer.prototype, "horizontal", {
            get: function () {
                return 0;
            },
            set: function (horizontal) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOffsetViewer.prototype, "vertical", {
            get: function () {
                return 0;
            },
            set: function (vertical) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextOffsetViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupTextOffsetViewer.prototype.set = function (horizontal, vertical) {
            // DO NOTHING
        };
        EShapeGroupTextOffsetViewer.prototype.toObject = function () {
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextOffsetViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextOffsetViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextOffsetViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextOutlineViewer = /** @class */ (function () {
        function EShapeGroupTextOutlineViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupTextOutlineViewer.prototype, "enable", {
            get: function () {
                return false;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineViewer.prototype, "color", {
            get: function () {
                return 0xffffff;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineViewer.prototype, "width", {
            get: function () {
                return 1.0;
            },
            set: function (width) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextOutlineViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupTextOutlineViewer.prototype.set = function (enable, color, alpha, width) {
            // DO NOTHING
        };
        EShapeGroupTextOutlineViewer.prototype.clone = function () {
            return new EShapeGroupTextOutlineViewer();
        };
        EShapeGroupTextOutlineViewer.prototype.toObject = function () {
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0
            };
        };
        EShapeGroupTextOutlineViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextOutlineViewer.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupTextOutlineViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextPaddingViewer = /** @class */ (function () {
        function EShapeGroupTextPaddingViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupTextPaddingViewer.prototype, "horizontal", {
            get: function () {
                return 0;
            },
            set: function (horizontal) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextPaddingViewer.prototype, "vertical", {
            get: function () {
                return 0;
            },
            set: function (vertical) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextPaddingViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupTextPaddingViewer.prototype.set = function (horizontal, vertical) {
            // DO NOTHING
        };
        EShapeGroupTextPaddingViewer.prototype.toObject = function () {
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextPaddingViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextPaddingViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextPaddingViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextSpacingViewer = /** @class */ (function () {
        function EShapeGroupTextSpacingViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupTextSpacingViewer.prototype, "horizontal", {
            get: function () {
                return 0;
            },
            set: function (horizontal) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextSpacingViewer.prototype, "vertical", {
            get: function () {
                return 0;
            },
            set: function (vertical) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextSpacingViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupTextSpacingViewer.prototype.set = function (horizontal, vertical) {
            // DO NOTHING
        };
        EShapeGroupTextSpacingViewer.prototype.toObject = function () {
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextSpacingViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextSpacingViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextSpacingViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextViewer = /** @class */ (function () {
        function EShapeGroupTextViewer() {
            this.align = new EShapeGroupTextAlignViewer();
            this.offset = new EShapeGroupTextOffsetViewer();
            this.outline = new EShapeGroupTextOutlineViewer();
            this.spacing = new EShapeGroupTextSpacingViewer();
            this.padding = new EShapeGroupTextPaddingViewer();
        }
        Object.defineProperty(EShapeGroupTextViewer.prototype, "enable", {
            get: function () {
                return true;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "value", {
            get: function () {
                return "";
            },
            set: function (value) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "color", {
            get: function () {
                return 0x000000;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "family", {
            get: function () {
                return "auto";
            },
            set: function (family) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "size", {
            get: function () {
                return 24;
            },
            set: function (size) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "weight", {
            get: function () {
                return EShapeTextWeight.NORMAL;
            },
            set: function (weight) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "style", {
            get: function () {
                return EShapeTextStyle.NORMAL;
            },
            set: function (style) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "direction", {
            get: function () {
                return EShapeTextDirection.LEFT_TO_RIGHT;
            },
            set: function (direction) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "clipping", {
            get: function () {
                return false;
            },
            set: function (clipping) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        EShapeGroupTextViewer.prototype.copy = function (target) {
            return this;
        };
        EShapeGroupTextViewer.prototype.set = function (value, color, alpha, family, size, weight, style, direction, clipping) {
            return this;
        };
        EShapeGroupTextViewer.prototype.toObject = function () {
            return {
                value: "",
                color: 0x000000,
                alpha: 1.0,
                family: "auto",
                size: 24,
                weight: EShapeTextWeight.NORMAL,
                align: this.align.toObject(),
                offset: this.offset.toObject(),
                style: EShapeTextStyle.NORMAL,
                outline: this.outline.toObject(),
                spacing: this.spacing.toObject(),
                direction: EShapeTextDirection.LEFT_TO_RIGHT,
                padding: this.padding.toObject(),
                clipping: false
            };
        };
        EShapeGroupTextViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextViewer.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupTextViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBufferUnit = /** @class */ (function () {
        function EShapeBufferUnit(texture, indexOffset) {
            this.texture = texture;
            this.indexOffset = indexOffset;
        }
        return EShapeBufferUnit;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBufferUnitBuilder = /** @class */ (function () {
        function EShapeBufferUnitBuilder() {
            this.index = 0;
            this.baseTexture = null;
            this.units = [];
        }
        EShapeBufferUnitBuilder.prototype.begin = function () {
            this.index = 0;
            this.baseTexture = null;
        };
        EShapeBufferUnitBuilder.prototype.push = function (texture, indexOffset) {
            if (this.index < this.units.length) {
                var unit = this.units[this.index];
                unit.texture = texture;
                unit.indexOffset = indexOffset;
            }
            else {
                this.units.push(new EShapeBufferUnit(texture, indexOffset));
            }
            this.index += 1;
        };
        EShapeBufferUnitBuilder.prototype.end = function () {
            if (this.units.length !== this.index) {
                this.units.length = this.index;
            }
        };
        EShapeBufferUnitBuilder.prototype.destroy = function () {
            this.units.length = 0;
        };
        return EShapeBufferUnitBuilder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBuffer = /** @class */ (function () {
        function EShapeBuffer(ntriangles, renderer) {
            var nindices = ntriangles * 3;
            var nvertices = nindices;
            this.vertices = new Float32Array(nvertices * 2);
            this._vertexCapacity = nvertices;
            this._vertexCount = 0;
            this._vertexBuffer = null;
            this.clippings = new Float32Array(nvertices * 3);
            this._clippingBuffer = null;
            this.steps = new Float32Array(nvertices * 6);
            this._stepBuffer = null;
            this.colorFills = new Float32Array(nvertices * 4);
            this._colorFillBuffer = null;
            this.colorStrokes = new Float32Array(nvertices * 4);
            this._colorStrokeBuffer = null;
            this.uvs = new Float32Array(nvertices * 2);
            this._uvBuffer = null;
            var isIndicesShort = (nvertices <= 65535);
            this.indices = (isIndicesShort ? new Uint16Array(nindices) : new Uint32Array(nindices));
            this._indexCapacity = ntriangles;
            this._indexCount = 0;
            this.indexCountRequested = 0;
            this._indexBuffer = null;
            this._renderer = renderer;
            this._builder = new EShapeBufferUnitBuilder();
            this._geometry = null;
        }
        EShapeBuffer.prototype.updateVertices = function () {
            var vertexBuffer = this._vertexBuffer;
            if (vertexBuffer) {
                vertexBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateClippings = function () {
            var clippingBuffer = this._clippingBuffer;
            if (clippingBuffer) {
                clippingBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateSteps = function () {
            var stepBuffer = this._stepBuffer;
            if (stepBuffer) {
                stepBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateColorFills = function () {
            var colorFillBuffer = this._colorFillBuffer;
            if (colorFillBuffer) {
                colorFillBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateColorStrokes = function () {
            var colorStrokeBuffer = this._colorStrokeBuffer;
            if (colorStrokeBuffer) {
                colorStrokeBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateUvs = function () {
            var uvBuffer = this._uvBuffer;
            if (uvBuffer) {
                uvBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateIndices = function () {
            var indexBuffer = this._indexBuffer;
            if (indexBuffer) {
                indexBuffer.update();
            }
        };
        EShapeBuffer.prototype.getGeometry = function () {
            var result = this._geometry;
            if (result == null) {
                this._vertexBuffer = new pixi_js.Buffer(this.vertices, false, false);
                this._clippingBuffer = new pixi_js.Buffer(this.clippings, false, false);
                this._stepBuffer = new pixi_js.Buffer(this.steps, false, false);
                this._colorFillBuffer = new pixi_js.Buffer(this.colorFills, false, false);
                this._colorStrokeBuffer = new pixi_js.Buffer(this.colorStrokes, false, false);
                this._uvBuffer = new pixi_js.Buffer(this.uvs, false, false);
                this._indexBuffer = new pixi_js.Buffer(this.indices, false, true);
                this._geometry = result = new pixi_js.Geometry()
                    .addIndex(this._indexBuffer)
                    .addAttribute("aPosition", this._vertexBuffer, 2)
                    .addAttribute("aClipping", this._clippingBuffer, 3)
                    .addAttribute("aStep", this._stepBuffer, 2)
                    .addAttribute("aAntialias", this._stepBuffer, 4)
                    .addAttribute("aColorFill", this._colorFillBuffer, 4)
                    .addAttribute("aColorStroke", this._colorStrokeBuffer, 4)
                    .addAttribute("aUv", this._uvBuffer, 2);
            }
            return result;
        };
        EShapeBuffer.prototype.upload = function () {
            this._renderer.geometry.bind(this.getGeometry());
        };
        EShapeBuffer.prototype.render = function (shader) {
            var renderer = this._renderer;
            renderer.geometry.bind(this.getGeometry());
            var units = this._builder.units;
            var unitCount = units.length;
            if (0 < unitCount) {
                var type = pixi_js.DRAW_MODES.TRIANGLES;
                var unit0 = null;
                var unit1 = units[0];
                var ioffset0 = 0;
                var ioffset1 = unit1.indexOffset * 3;
                var vcount = 0;
                var texture = pixi_js.Texture.WHITE;
                for (var i = 0, imax = unitCount - 1; i < imax; ++i) {
                    unit0 = unit1;
                    unit1 = units[i + 1];
                    ioffset0 = ioffset1;
                    ioffset1 = unit1.indexOffset * 3;
                    vcount = ioffset1 - ioffset0;
                    texture = unit0.texture || pixi_js.Texture.WHITE;
                    if (0 < vcount && texture.valid) {
                        shader.uniforms.sampler = renderer.texture.bind(texture);
                        renderer.geometry.draw(type, vcount, ioffset0);
                    }
                }
                vcount = this._indexCount * 3 - ioffset1;
                texture = unit1.texture || pixi_js.Texture.WHITE;
                if (0 < vcount && texture.valid) {
                    shader.uniforms.sampler = renderer.texture.bind(texture);
                    renderer.geometry.draw(type, vcount, ioffset1);
                }
            }
        };
        EShapeBuffer.prototype.isCompatible = function (shape, uploaded, vindex, iindex) {
            return (uploaded.getBuffer() === this &&
                uploaded.getVertexOffset() === vindex &&
                uploaded.getIndexOffset() === iindex &&
                uploaded.isCompatible(shape));
        };
        EShapeBuffer.prototype.update = function (iterator, antialiasWeight, noMoreThanOne) {
            var builder = this._builder;
            builder.begin();
            var vindex = 0;
            var iindex = 0;
            var shape = iterator.get();
            for (; shape != null; shape = iterator.next()) {
                var uploaded = shape.uploaded;
                if (uploaded == null || !this.isCompatible(shape, uploaded, vindex, iindex)) {
                    break;
                }
                uploaded.update(shape);
                uploaded.buildUnit(builder);
                vindex += uploaded.getVertexCount();
                iindex += uploaded.getIndexCount();
                if (noMoreThanOne) {
                    iterator.next();
                    builder.end();
                    this._vertexCount = vindex;
                    this._indexCount = iindex;
                    return 0 < builder.units.length;
                }
            }
            for (; shape != null; shape = iterator.next()) {
                var creater = EShapeUploadeds[shape.type] || EShapeUploadeds[EShapeType.GROUP];
                if (creater == null) {
                    break;
                }
                var uploaded = creater(this, shape, vindex, iindex, antialiasWeight);
                if (uploaded == null) {
                    break;
                }
                uploaded.buildUnit(builder);
                vindex += uploaded.getVertexCount();
                iindex += uploaded.getIndexCount();
                if (noMoreThanOne) {
                    iterator.next();
                    break;
                }
            }
            builder.end();
            this._vertexCount = vindex;
            this._indexCount = iindex;
            return 0 < builder.units.length;
        };
        EShapeBuffer.prototype.check = function (vindex, ioffset, vcount, icount) {
            this.indexCountRequested = icount;
            return vindex + vcount <= this._vertexCapacity && ioffset + icount <= this._indexCapacity;
        };
        EShapeBuffer.prototype.destroy = function () {
            var geometry = this._geometry;
            if (geometry) {
                geometry.destroy();
            }
            this._builder.destroy();
        };
        return EShapeBuffer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DUMMY_SHAPES = [];
    var EShapeRendererIteratorDatum = /** @class */ (function () {
        function EShapeRendererIteratorDatum() {
            this.index = 0;
            this.shapes = DUMMY_SHAPES;
        }
        EShapeRendererIteratorDatum.prototype.reset = function (shapes) {
            this.index = -1;
            this.shapes = shapes;
        };
        EShapeRendererIteratorDatum.prototype.next = function () {
            var index = this.index = this.index + 1;
            var shapes = this.shapes;
            if (index < shapes.length) {
                return shapes[index];
            }
            return null;
        };
        return EShapeRendererIteratorDatum;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRendererIterator = /** @class */ (function () {
        function EShapeRendererIterator() {
            this._index = -1;
            this._datum = new EShapeRendererIteratorDatum();
            this._data = [this._datum];
            this._current = null;
        }
        EShapeRendererIterator.prototype.reset = function (shapes) {
            this._index = 0;
            var current = this._datum = this._data[0];
            current.reset(shapes);
            this._current = null;
            return this.next();
        };
        EShapeRendererIterator.prototype.get = function () {
            return this._current;
        };
        EShapeRendererIterator.prototype.next = function () {
            var datum = this._datum;
            var shape = datum.next();
            if (shape != null) {
                this._current = shape;
                var children = shape.children;
                if (0 < children.length) {
                    var datumIndex = this._index = this._index + 1;
                    var data = this._data;
                    if (datumIndex < data.length) {
                        var newDatum = data[datumIndex];
                        newDatum.reset(children);
                        this._datum = newDatum;
                    }
                    else {
                        var newDatum = new EShapeRendererIteratorDatum();
                        data.push(newDatum);
                        newDatum.reset(children);
                        this._datum = newDatum;
                    }
                }
                return shape;
            }
            else {
                var datumIndex = this._index = this._index - 1;
                var data = this._data;
                if (0 <= datumIndex) {
                    this._datum = data[datumIndex];
                    this._current = null;
                    return this.next();
                }
                else {
                    this._current = null;
                    return null;
                }
            }
        };
        return EShapeRendererIterator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER$1 = "\nattribute vec2 aPosition;\nattribute vec3 aClipping;\nattribute vec2 aStep;\nattribute vec4 aAntialias;\nattribute vec4 aColorFill;\nattribute vec4 aColorStroke;\nattribute vec2 aUv;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mediump float pixelScale;\nuniform mediump float antialiasWeight;\n\nvarying mediump vec3 vClipping;\nvarying mediump vec2 vStep;\nvarying mediump vec4 vAntialias;\nvarying mediump vec4 vColorFill;\nvarying mediump vec4 vColorStroke;\nvarying mediump vec2 vUv;\n\nvec2 toInverse( in vec2 v ) {\n\treturn vec2( -v.y, v.x );\n}\n\nvec2 toTransformedPosition( in vec2 v ) {\n\treturn (projectionMatrix * translationMatrix * vec3(v, 1.0)).xy;\n}\n\nvec4 toAntialias01( in vec4 antialias, in float scale ) {\n\t// Taylor series of 1 / ( 1 - a ) = 1 + a + a^2 + ....\n\treturn 1.0 + min( vec4( 1.0 ), antialias * scale );\n}\n\nvec4 toAntialias2( in vec2 step, in vec4 antialias, in float scale ) {\n\tfloat x = min( 0.4, step.x * scale );\n\tfloat y = 0.5 - antialias.x;\n\tfloat z = 0.5 - antialias.x - step.y;\n\treturn vec4( y, z, y - max( 0.01, y - x ), z - max( 0.01, z - x ) );\n}\n\nvec2 toPosition3456( in float type, in vec2 p, in vec2 pprev, in vec2 pnext, in float strokeWidth, out float shift ) {\n\tvec2 d0 = p - pprev;\n\tvec2 d1 = pnext - p;\n\tfloat l0 = dot( d0, d0 );\n\tfloat l1 = dot( d1, d1 );\n\tvec2 nd0 = normalize( toInverse( d0 ) );\n\tvec2 nd1 = normalize( toInverse( d1 ) );\n\tvec2 n0 = 0.00001 < l0 ? nd0 : nd1;\n\tvec2 n1 = 0.00001 < l1 ? nd1 : nd0;\n\tvec2 n0i = toInverse( n0 );\n\tvec2 n1i = toInverse( n1 );\n\tfloat direction = sign( 4.5 - type );\n\n\t// Offset\n\tfloat cross = dot( n0i, n1 );\n\tfloat crossInverse = ( 0.00001 < abs( cross ) ? 1.0 / cross : 0.0 );\n\tfloat b = dot(n1 - n0, n0) * crossInverse;\n\tfloat offsetSize = direction * strokeWidth * 0.5;\n\tvec2 offset = n1 + n1i * b;\n\n\t// Miter\n\tvec2 pmiter = p + offsetSize * offset;\n\tfloat miterAngle0 = dot( n0i, pmiter - pprev );\n\tfloat miterAngle1 = dot( n1i, pmiter - pnext );\n\tfloat miterLength = dot( offset, offset );\n\tfloat miterSide = direction * cross;\n\n\t// Bevel\n\tvec2 n = ( type == 4.0 || type == 6.0 ? n1 : n0 );\n\tvec2 pbevel = p + offsetSize * n;\n\n\t//\n\tvec2 presult = (\n\t\t0.0 <= miterAngle0 || miterAngle1 < 0.0 || miterSide < 0.0 ?\n\t\tpbevel : pmiter\n\t);\n\t/*\n\tvec2 presult = (\n\t\tmiterAngle0 < 0.0 && 0.0 <= miterAngle1 && miterLength < 50.0 ?\n\t\tpmiter : pbevel\n\t);\n\t*/\n\tvec2 ni = ( type == 4.0 || type == 6.0 ? n1i : n0i );\n\tshift = dot( ni, p - presult );\n\treturn toTransformedPosition( presult );\n}\n\nvec2 toStep3456( in float type ) {\n\treturn ( type < 4.5 ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 ) );\n}\n\nvec4 toAntialias3456( in float strokeWidth, in float scale ) {\n\tfloat a = antialiasWeight / max( 0.0001, strokeWidth );\n\treturn toAntialias01( vec4( a, a, a, a ), scale );\n}\n\nfloat toDotAndDashScale( in float scale, in float strokeWidthScale ) {\n\treturn (\n\t\tscale == 4.0 || scale == 5.0 || scale == 6.0 || scale == 7.0 ?\n\t\tstrokeWidthScale : 1.0\n\t);\n}\n\nvec4 toColorStroke3456( in float shift, in float scale ) {\n\tfloat x = aColorFill.x + shift;\n\tfloat y = scale * aColorFill.y;\n\tfloat z = scale * aColorFill.z;\n\tfloat w = aColorFill.w;\n\treturn vec4( x, y, z, w );\n}\n\nfloat toStrokeWidthScale( in float scale ) {\n\treturn (\n\t\tscale == 3.0 || scale == 7.0 ?\n\t\tpixelScale : (\n\t\t\tscale == 1.0 || scale == 5.0 ?\n\t\t\tmin( 1.0, pixelScale ) : (\n\t\t\t\tscale == 2.0 || scale == 6.0 ?\n\t\t\t\tmax( 1.0, pixelScale ) : 1.0\n\t\t\t)\n\t\t)\n\t);\n}\n\nvoid main(void) {\n\tvec2 p012 = toTransformedPosition( aPosition );\n\n\tfloat type = aClipping.z;\n\n\t// type === 0 or 1\n\tvec4 a01 = toAntialias01( aAntialias, pixelScale );\n\n\t// type === 2\n\tvec4 a2 = toAntialias2( aStep, aAntialias, pixelScale );\n\n\t// type === 3, 4, 5 or 6\n\tfloat shift3456 = 0.0;\n\tfloat strokeWidthScale = toStrokeWidthScale( aStep.y );\n\tfloat strokeWidth = strokeWidthScale * aStep.x;\n\tvec2 p3456 = toPosition3456( type, aPosition, aAntialias.xy, aAntialias.zw, strokeWidth, shift3456 );\n\tvec2 step3456 = toStep3456( type );\n\tvec4 a3456 = toAntialias3456( strokeWidth, pixelScale );\n\tvec4 colorStroke3456 = toColorStroke3456( shift3456, toDotAndDashScale( aStep.y, strokeWidthScale ) );\n\n\t//\n\tgl_Position = vec4( ( 2.5 < type ? p3456 : p012 ), 0.0, 1.0 );\n\tvAntialias = ( 1.5 < type ? ( 2.5 < type ? a3456 : a2 ) : a01 );\n\tvClipping = aClipping;\n\tvStep = ( 2.5 < type ? step3456 : aStep );\n\tvColorFill = ( 2.5 < type ? aColorStroke : aColorFill );\n\tvColorStroke = ( 2.5 < type ? colorStroke3456 : aColorStroke );\n\tvUv = aUv;\n}";
    var FRAGMENT_SHADER$1 = "\nvarying mediump vec3 vClipping;\nvarying mediump vec2 vStep;\nvarying mediump vec4 vAntialias;\nvarying mediump vec4 vColorFill;\nvarying mediump vec4 vColorStroke;\nvarying mediump vec2 vUv;\n\nuniform sampler2D sampler;\nuniform mediump float pixelScale;\n\nvoid main(void) {\n\tvec4 texture = texture2D(sampler, vUv);\n\tfloat type = vClipping.z;\n\tvec2 v0 = vStep;\n\tvec2 v1 = vClipping.xy;\n\tvec2 v2 = v0 * vAntialias.xy;\n\tvec2 v3 = v1 * vAntialias.zw;\n\tvec2 d01 = ( v0.x < v0.y ? vec2( v0.y, v2.y ) : vec2( v0.x, v2.x ) );\n\tvec2 d02 = ( v1.x < v1.y ? vec2( v1.y, v3.y ) : vec2( v1.x, v3.x ) );\n\tvec4 d0 = vec4( d01.x, d02.x, d01.y, d02.y );\n\tvec4 d1 = vec4( dot( v0, v0 ), dot( v1, v1 ), dot( v2, v2 ), dot( v3, v3 ) );\n\tvec4 d = ( type == 1.0 ? d1 : d0 );\n\tvec2 s = smoothstep( 1.0 - (d.zw - d.xy), vec2( 1.0 ), d.xy );\n\tvec4 color01 = texture * (vColorStroke * (s.x - s.y) + vColorFill * (1.0 - s.x));\n\n\tfloat l = vColorStroke.x;\n\tfloat lp0 = vColorStroke.y;\n\tfloat lp1 = vColorStroke.z;\n\tfloat lt = vColorStroke.w;\n\tfloat ld = 0.5 * pixelScale;\n\tfloat lm = mod( l, lp0 + lp1 );\n\tfloat ls0 = smoothstep( 0.0, 0.0 + ld, lm );\n\tfloat ls1 = smoothstep( lp0, lp0 + ld, lm );\n\tfloat ls2 = ( 0.0 <= lt ? 1.0 - smoothstep( lt - ld, lt, l ) : 1.0 );\n\tvec4 color3456 = color01 * ( ls0 - ls1 ) * ls2;\n\n\tvec2 a0 = vAntialias.xy;\n\tvec2 a1 = vAntialias.zw;\n\tvec2 a2 = vec2( texture.a );\n\tvec2 a = smoothstep( a0 - a1, a0 + a1, a2 );\n\tvec4 color2 = a.x * vColorFill + ( a.y - a.x ) * vColorStroke;\n\tgl_FragColor = ( type == 2.0 ? color2 : (2.5 < type ? color3456 : color01) );\n}";
    var EShapeRenderer = /** @class */ (function (_super) {
        __extends(EShapeRenderer, _super);
        function EShapeRenderer(renderer) {
            var _this = _super.call(this, renderer) || this;
            EShapeRenderer.SHADER = EShapeRenderer.SHADER || pixi_js.Shader.from(VERTEX_SHADER$1, FRAGMENT_SHADER$1);
            _this._shader = EShapeRenderer.SHADER;
            _this._iterator = new EShapeRendererIterator();
            _this._bufferSizeMax = _this.getBufferSizeMax(renderer);
            return _this;
        }
        EShapeRenderer.prototype.getBufferSizeMax = function (renderer) {
            var context = renderer.context;
            var extensions = context.extensions;
            if (1 < context.webGLVersion || !!extensions.uint32ElementIndex) {
                return 1431655765; // 2^32 / 3
            }
            return 21845; // 2^16 / 3
        };
        EShapeRenderer.prototype.updateAtlas = function (shape, atlas, fontAtlases, defaultTexture, baseTexture) {
            // Texture
            // Do not access the shape.image.src here.
            // It slows down the rendering speed significantly.
            var imageSrc = shape.imageSrc;
            if (imageSrc != null) {
                var textureItem = atlas.get(imageSrc);
                if (textureItem != null) {
                    shape.texture = textureItem.texture;
                }
                else {
                    var newTextureItem = new DynamicAtlasItemImage(shape.image, baseTexture);
                    shape.texture = newTextureItem.texture;
                    atlas.set(newTextureItem.id, newTextureItem);
                }
            }
            else {
                shape.texture = defaultTexture;
            }
            // Font texture atlas
            var text = shape.text;
            var textValue = text.value;
            if (0 < textValue.length) {
                fontAtlases.add(text.family, textValue);
            }
        };
        EShapeRenderer.prototype.updateAtlases = function (shapes, atlas, fontAtlases, defaultTexture, baseTexture) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                this.updateAtlas(shape, atlas, fontAtlases, defaultTexture, baseTexture);
                var children = shape.children;
                for (var j = 0, jmax = children.length; j < jmax; ++j) {
                    var child = children[j];
                    this.updateAtlas(child, atlas, fontAtlases, defaultTexture, baseTexture);
                    this.updateAtlases(child.children, atlas, fontAtlases, defaultTexture, baseTexture);
                }
            }
        };
        EShapeRenderer.prototype.updateFontAtlas = function (shape, atlas, fontAtlases, defaultTexture) {
            var text = shape.text;
            var fontAtlas = fontAtlases.get(text.family);
            if (fontAtlas != null) {
                var textureItem = atlas.get(fontAtlas.id);
                if (textureItem != null) {
                    text.atlas = fontAtlas;
                    text.texture = textureItem.texture;
                }
                else {
                    text.atlas = undefined;
                    text.texture = defaultTexture;
                }
            }
            else {
                text.atlas = undefined;
                text.texture = defaultTexture;
            }
        };
        EShapeRenderer.prototype.updateFontAtlases = function (shapes, atlas, fontAtlases, defaultTexture) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                this.updateFontAtlas(shape, atlas, fontAtlases, defaultTexture);
                var children = shape.children;
                for (var j = 0, jmax = children.length; j < jmax; ++j) {
                    var child = children[j];
                    this.updateFontAtlas(child, atlas, fontAtlases, defaultTexture);
                    this.updateFontAtlases(child.children, atlas, fontAtlases, defaultTexture);
                }
            }
        };
        EShapeRenderer.prototype.render_ = function (container, shapes, isDirty) {
            var renderer = this.renderer;
            var shader = this._shader;
            if (shader != null && 0 < shapes.length) {
                var resolution = renderer.resolution;
                var buffers = container.getBuffers();
                var antialiasWeight = container.getAntialiasWeight(resolution);
                // Update textures
                if (isDirty) {
                    // Atlases
                    var atlas = container.getAtlas(resolution);
                    var fontAtlases = container.getFontAtlases();
                    atlas.begin();
                    fontAtlases.begin();
                    var defaultTexture = atlas.getDefaultTexture();
                    var baseTexture = atlas.getBaseTexture();
                    this.updateAtlases(shapes, atlas, fontAtlases, defaultTexture, baseTexture);
                    fontAtlases.end();
                    fontAtlases.update(atlas);
                    this.updateFontAtlases(shapes, atlas, fontAtlases, defaultTexture);
                    atlas.end();
                    atlas.repack();
                    // Update buffers
                    this.updateBuffers(shapes, buffers, renderer, antialiasWeight);
                }
                // Render buffers
                shader.uniforms.pixelScale = container.toPixelScale(resolution);
                shader.uniforms.antialiasWeight = antialiasWeight;
                shader.uniforms.translationMatrix = container.worldTransform.toArray(true);
                renderer.shader.bind(shader, false);
                renderer.state.setBlendMode(pixi_js.utils.correctBlendMode(pixi_js.BLEND_MODES.NORMAL, true));
                var buffersLength = buffers.length;
                if (1 < buffersLength) {
                    for (var i = 0; i < buffersLength; ++i) {
                        buffers[i].upload();
                    }
                }
                for (var i = 0; i < buffersLength; ++i) {
                    buffers[i].render(shader);
                }
            }
        };
        EShapeRenderer.prototype.updateBuffers = function (shapes, buffers, renderer, antialiasWeight) {
            var iterator = this._iterator;
            iterator.reset(shapes);
            var ib = 0;
            var bufferSize = 0;
            var bufferSizeBase = 5000;
            var bufferSizeMax = this._bufferSizeMax;
            while (iterator.get() != null) {
                var buffer = null;
                var noMoreThanOne = false;
                if (0 < bufferSize) {
                    buffer = new EShapeBuffer(bufferSize, renderer);
                    buffers.splice(ib, 0, buffer);
                    noMoreThanOne = true;
                }
                else if (ib < buffers.length) {
                    buffer = buffers[ib];
                    noMoreThanOne = false;
                }
                else {
                    buffer = new EShapeBuffer(bufferSizeBase, renderer);
                    buffers.push(buffer);
                    noMoreThanOne = false;
                }
                if (buffer.update(iterator, antialiasWeight, noMoreThanOne)) {
                    bufferSize = 0;
                    ib += 1;
                }
                else {
                    bufferSize = buffer.indexCountRequested;
                    if (bufferSize <= bufferSizeMax) {
                        bufferSize = Math.ceil(bufferSize / bufferSizeBase) * bufferSizeBase;
                        bufferSize = Math.min(bufferSize, bufferSizeMax);
                    }
                    else {
                        // No way to render
                        break;
                    }
                }
            }
            if (ib < buffers.length) {
                for (var jb = ib, ibmax = buffers.length; jb < ibmax; ++jb) {
                    buffers[jb].destroy();
                }
                buffers.length = ib;
            }
        };
        EShapeRenderer.SHADER = null;
        return EShapeRenderer;
    }(pixi_js.ObjectRenderer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeContainer = /** @class */ (function (_super) {
        __extends(EShapeContainer, _super);
        function EShapeContainer() {
            var _this = _super.call(this) || this;
            _this._shapeRenderer = null;
            _this.children = [];
            _this._childrenId = 0;
            _this._childrenIdRendered = -1;
            _this._atlas = null;
            _this._fontAtlases = new DynamicSDFFontAtlases();
            _this._pixelScale = 1;
            _this._pixelScaleId = NaN;
            _this._work = new pixi_js.Point();
            _this._buffers = [];
            return _this;
        }
        EShapeContainer.prototype.calculateBounds = function () {
            this._bounds.clear();
        };
        EShapeContainer.prototype.onChildTransformChange = function () {
            // DO NOTHING
        };
        EShapeContainer.prototype.toDirty = function () {
            return this._childrenId += 1;
        };
        EShapeContainer.prototype.isDirty = function () {
            return this._childrenIdRendered < this._childrenId;
        };
        EShapeContainer.prototype.render = function (renderer) {
            if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
                return;
            }
            var childrenId = this._childrenId;
            var childrenIdRendered = this._childrenIdRendered;
            this._childrenIdRendered = childrenId;
            var isChildrenDirty = childrenIdRendered < childrenId;
            var children = this.children;
            var shapeRenderer = this._shapeRenderer;
            if (shapeRenderer == null) {
                shapeRenderer = this._shapeRenderer = new EShapeRenderer(renderer);
            }
            renderer.batch.setObjectRenderer(shapeRenderer);
            var mask = this.mask;
            if (mask) {
                renderer.mask.push(this, mask);
                shapeRenderer.render_(this, children, isChildrenDirty);
                renderer.mask.pop(this);
            }
            else {
                shapeRenderer.render_(this, children, isChildrenDirty);
            }
        };
        EShapeContainer.prototype.containsPoint = function (point) {
            return false;
        };
        EShapeContainer.prototype.getFontAtlases = function () {
            return this._fontAtlases;
        };
        EShapeContainer.prototype.getAtlas = function (resolution) {
            var atlas = this._atlas;
            if (atlas == null) {
                atlas = new DynamicAtlas(resolution);
                this._atlas = atlas;
            }
            return atlas;
        };
        EShapeContainer.prototype.getBuffers = function () {
            return this._buffers;
        };
        EShapeContainer.prototype.toPixelScale = function (resolution) {
            this.updateTransform();
            var transform = this.transform;
            var worldID = transform._worldID;
            if (worldID !== this._pixelScaleId) {
                this._pixelScaleId = worldID;
                var worldTransform = transform.worldTransform;
                var a = worldTransform.a;
                var b = worldTransform.b;
                var scale = Math.sqrt(a * a + b * b);
                this._pixelScale = 1 / (resolution * scale);
            }
            return this._pixelScale;
        };
        EShapeContainer.prototype.getPixelScale = function () {
            return this._pixelScale;
        };
        EShapeContainer.prototype.getAntialiasWeight = function (resolution) {
            return 1.25 / resolution;
        };
        EShapeContainer.prototype.hitTest = function (global, handler) {
            var work = this._work;
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                if (child.visible) {
                    var childLocal = child.toLocal(global, undefined, work);
                    var childResult = child.contains(childLocal);
                    if (childResult != null) {
                        if (handler == null || handler(childResult)) {
                            return childResult;
                        }
                    }
                }
            }
            return null;
        };
        EShapeContainer.prototype.hitTestBBox = function (global, handler) {
            var work = this._work;
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                if (child.visible) {
                    var childLocal = child.toLocal(global, undefined, work);
                    if (child.containsBBox(childLocal)) {
                        if (handler == null || handler(child)) {
                            return child;
                        }
                    }
                }
            }
            return null;
        };
        EShapeContainer.prototype.destroy = function () {
            // Buffer
            var buffers = this._buffers;
            if (buffers != null) {
                for (var i = 0, imax = buffers.length; i < imax; ++i) {
                    buffers[i].destroy();
                }
            }
            this._buffers.length = 0;
            // Shapes
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
            //
            _super.prototype.destroy.call(this);
        };
        return EShapeContainer;
    }(pixi_js.DisplayObject));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeSearch = /** @class */ (function () {
        function EShapeSearch() {
        }
        EShapeSearch.toIndices = function (shapes) {
            var result = [];
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                result.push(shapes[i].index);
            }
            return result;
        };
        EShapeSearch.toDepth = function (shape) {
            var result = 0;
            var parent = shape.parent;
            while (parent instanceof EShapeBase) {
                result += 1;
                parent = parent.parent;
            }
            return result;
        };
        EShapeSearch.toSharedParent = function (first, shape) {
            var depthA = this.toDepth(first);
            var depthB = this.toDepth(shape);
            if (depthA < depthB) {
                var parent_1 = first.parent;
                while (parent_1 instanceof EShapeBase) {
                    if (this.isParent(shape, parent_1)) {
                        return parent_1;
                    }
                    parent_1 = parent_1.parent;
                }
                return parent_1;
            }
            else {
                var parent_2 = shape.parent;
                while (parent_2 instanceof EShapeBase) {
                    if (this.isParent(first, parent_2)) {
                        return parent_2;
                    }
                    parent_2 = parent_2.parent;
                }
                return parent_2;
            }
        };
        EShapeSearch.toOfParent = function (shape, parent) {
            var shapeParent = shape.parent;
            while (shapeParent !== parent && shapeParent instanceof EShapeBase) {
                shape = shapeParent;
                shapeParent = shapeParent.parent;
            }
            return shape;
        };
        EShapeSearch.isParent = function (shape, target) {
            var parent = shape.parent;
            while (parent instanceof EShapeBase) {
                if (parent === target) {
                    return true;
                }
                parent = parent.parent;
            }
            return false;
        };
        EShapeSearch.toSelected = function (shape) {
            var target = shape;
            while (target instanceof EShapeBase) {
                if (target.selected) {
                    return target;
                }
                target = target.parent;
            }
            return null;
        };
        EShapeSearch.findChildById = function (shape, id, recursively) {
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child.id === id) {
                    return child;
                }
                if (recursively === true) {
                    var result = EShapeSearch.findChildById(child, id, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        EShapeSearch.findChildByType = function (shape, type, recursively) {
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child.type === type) {
                    return child;
                }
                if (recursively === true) {
                    var result = EShapeSearch.findChildByType(child, type, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        EShapeSearch.findChild = function (shape, matcher, recursively) {
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (matcher(child)) {
                    return child;
                }
                if (recursively === true) {
                    var result = EShapeSearch.findChild(child, matcher, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        EShapeSearch.findChildrenByType = function (shape, type, recursively, result) {
            result = result || [];
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child.type === type) {
                    result.push(child);
                }
                if (recursively === true) {
                    EShapeSearch.findChildrenByType(child, type, recursively, result);
                }
            }
            return result;
        };
        EShapeSearch.findChildren = function (shape, matcher, recursively, result) {
            result = result || [];
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (matcher(child)) {
                    result.push(child);
                }
                if (recursively === true) {
                    EShapeSearch.findChildren(child, matcher, recursively, result);
                }
            }
            return result;
        };
        EShapeSearch.COMPARATOR_INDEX = function (a, b) {
            return a.index - b.index;
        };
        return EShapeSearch;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDeleter = /** @class */ (function () {
        function EShapeDeleter() {
        }
        EShapeDeleter.delete = function (parent, shapes, generateListOfDetachedShapes) {
            var children = parent.children;
            var length = children.length;
            // Update indices
            for (var i = 0; i < length; ++i) {
                var child = children[i];
                if (child.selected) {
                    child.index = length + i;
                }
                else {
                    child.index = i;
                }
            }
            // Sort
            children.sort(EShapeSearch.COMPARATOR_INDEX);
            // Detach
            if (generateListOfDetachedShapes === true) {
                for (var i = length - 1; 0 <= i; --i) {
                    var child = children[i];
                    if (child.selected) {
                        child.index -= length;
                        child.parent = null;
                        child.selected = false;
                        child.uploaded = undefined;
                    }
                    else {
                        var size = children.length - (i + 1);
                        if (0 < size) {
                            var result = children.splice(i + 1, size);
                            if (shapes != null) {
                                shapes.length = 0;
                            }
                            parent.onChildTransformChange();
                            parent.toDirty();
                            return result;
                        }
                        else {
                            if (shapes != null) {
                                shapes.length = 0;
                            }
                            return null;
                        }
                    }
                }
                if (0 < children.length) {
                    var result = children.splice(0, children.length);
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    parent.onChildTransformChange();
                    parent.toDirty();
                    return result;
                }
                else {
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    return null;
                }
            }
            else {
                for (var i = length - 1; 0 <= i; --i) {
                    var child = children[i];
                    if (child.selected) {
                        child.parent = null;
                        child.selected = false;
                        child.uploaded = undefined;
                    }
                    else {
                        children.length = i + 1;
                        if (shapes != null) {
                            shapes.length = 0;
                        }
                        parent.onChildTransformChange();
                        parent.toDirty();
                        return null;
                    }
                }
                if (0 < children.length) {
                    children.length = 0;
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    parent.onChildTransformChange();
                    parent.toDirty();
                }
                else {
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                }
                return null;
            }
        };
        return EShapeDeleter;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeResourceManagerSerialization = /** @class */ (function () {
        function EShapeResourceManagerSerialization() {
            this.resources = [];
            this.resourceToIndex = new Map();
        }
        EShapeResourceManagerSerialization.prototype.add = function (resource) {
            var resources = this.resources;
            var resourceToIndex = this.resourceToIndex;
            var result = resourceToIndex.get(resource);
            if (result != null) {
                return result;
            }
            var index = resources.length;
            resources.push(resource);
            resourceToIndex.set(resource, index);
            return index;
        };
        EShapeResourceManagerSerialization.prototype.serialize = function () {
            return this.resources;
        };
        return EShapeResourceManagerSerialization;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRuntimes = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperGrid = /** @class */ (function (_super) {
        __extends(ESnapperGrid, _super);
        function ESnapperGrid() {
            var _this = _super.call(this) || this;
            _this._isEnabled = true;
            _this._size = 10;
            return _this;
        }
        ESnapperGrid.prototype.toggle = function () {
            this._isEnabled = !this._isEnabled;
            this.emit("change", this);
            return this._isEnabled;
        };
        ESnapperGrid.prototype.enable = function () {
            if (this._isEnabled !== true) {
                this._isEnabled = true;
                this.emit("change", this);
            }
        };
        ESnapperGrid.prototype.disable = function () {
            if (this._isEnabled !== false) {
                this._isEnabled = false;
                this.emit("change", this);
            }
        };
        ESnapperGrid.prototype.isEnabled = function () {
            return this._isEnabled;
        };
        Object.defineProperty(ESnapperGrid.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                if (this._size !== size) {
                    this._size = size;
                    this.emit("change", size, this);
                }
            },
            enumerable: true,
            configurable: true
        });
        ESnapperGrid.prototype.snap = function (value, result) {
            if (this._isEnabled) {
                var size = this._size;
                result.set(value, Math.round(value / size) * size);
            }
        };
        ESnapperGrid.prototype.reset = function () {
            this._isEnabled = true;
            this._size = 10;
            this.emit("change", this);
        };
        ESnapperGrid.prototype.serialize = function () {
            return [
                (this._isEnabled ? 1 : 0),
                this._size
            ];
        };
        ESnapperGrid.prototype.deserialize = function (serialized) {
            if (serialized[0] !== 0) {
                this.enable();
            }
            else {
                this.disable();
            }
            this.size = serialized[1];
        };
        return ESnapperGrid;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperResultScale = /** @class */ (function () {
        function ESnapperResultScale() {
            this.distance = NaN;
            this.scale = new pixi_js.Point();
        }
        return ESnapperResultScale;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperResult = /** @class */ (function () {
        function ESnapperResult() {
            this.distance = NaN;
            this.result = 0;
            this.threshold = 10;
        }
        ESnapperResult.prototype.reset = function (value, scale) {
            this.distance = NaN;
            this.result = value;
            this.threshold = (0.0001 < scale ? 10 / scale : 10);
        };
        ESnapperResult.prototype.set = function (value, snapped) {
            var newDistance = Math.abs(snapped - value);
            if (newDistance <= this.threshold) {
                var oldDistance = this.distance;
                if (oldDistance !== oldDistance || newDistance < oldDistance) {
                    this.distance = newDistance;
                    this.result = snapped;
                }
            }
        };
        return ESnapperResult;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperTargetValueType;
    (function (ESnapperTargetValueType) {
        ESnapperTargetValueType[ESnapperTargetValueType["HORIZONTAL"] = 0] = "HORIZONTAL";
        ESnapperTargetValueType[ESnapperTargetValueType["VERTICAL"] = 1] = "VERTICAL";
    })(ESnapperTargetValueType || (ESnapperTargetValueType = {}));
    var ESnapperTargetValue = /** @class */ (function () {
        function ESnapperTargetValue(type, position) {
            this.type = type;
            this.position = position;
        }
        ESnapperTargetValue.prototype.serialize = function () {
            return [this.type, this.position];
        };
        return ESnapperTargetValue;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperTarget = /** @class */ (function (_super) {
        __extends(ESnapperTarget, _super);
        function ESnapperTarget() {
            var _this = _super.call(this) || this;
            _this.values = [];
            _this._isVisible = true;
            _this._isEnabled = true;
            return _this;
        }
        ESnapperTarget.prototype.isEnabled = function () {
            return this._isEnabled;
        };
        ESnapperTarget.prototype.toggle = function () {
            this._isEnabled = !this._isEnabled;
            this.emit("change", this);
            return this._isEnabled;
        };
        ESnapperTarget.prototype.enable = function () {
            if (this._isEnabled !== true) {
                this._isEnabled = true;
                this.emit("change", this);
            }
        };
        ESnapperTarget.prototype.disable = function () {
            if (this._isEnabled !== false) {
                this._isEnabled = false;
                this.emit("change", this);
            }
        };
        ESnapperTarget.prototype.add = function (target, index) {
            if (index != null) {
                this.values.splice(index, 0, target);
            }
            else {
                this.values.push(target);
            }
            this.emit("change", this);
        };
        ESnapperTarget.prototype.remove = function (index) {
            var values = this.values;
            if (0 <= index && index < values.length) {
                values.splice(index, 1);
                this.emit("change", this);
            }
        };
        ESnapperTarget.prototype.size = function () {
            return this.values.length;
        };
        ESnapperTarget.prototype.replace = function (index, value) {
            var values = this.values;
            if (0 <= index && index < values.length) {
                var result = values[index];
                values[index] = value;
                this.emit("change", this);
                return result;
            }
            return null;
        };
        ESnapperTarget.prototype.swap = function (indexA, indexB) {
            if (indexA !== indexB) {
                var values = this.values;
                var valueA = values[indexA];
                values[indexA] = values[indexB];
                values[indexB] = valueA;
            }
        };
        Object.defineProperty(ESnapperTarget.prototype, "visible", {
            get: function () {
                return this._isVisible;
            },
            set: function (visible) {
                if (this._isVisible !== visible) {
                    this._isVisible = visible;
                    this.emit("change", this);
                }
            },
            enumerable: true,
            configurable: true
        });
        ESnapperTarget.prototype.snap = function (px, py, x, y) {
            if (this._isEnabled) {
                var values = this.values;
                for (var i = 0, imax = values.length; i < imax; ++i) {
                    var value = values[i];
                    if (value.type === ESnapperTargetValueType.VERTICAL) {
                        x.set(px, value.position);
                    }
                    else {
                        y.set(py, value.position);
                    }
                }
            }
        };
        ESnapperTarget.prototype.reset = function () {
            this._isEnabled = true;
            this._isVisible = true;
            this.values.length = 0;
            this.emit("change", this);
        };
        ESnapperTarget.prototype.serialize = function () {
            var targets = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                targets.push(values[i].serialize());
            }
            return [
                (this._isEnabled ? 1 : 0),
                (this._isVisible ? 1 : 0),
                targets
            ];
        };
        ESnapperTarget.prototype.deserialize = function (serialized) {
            // Availability
            this._isEnabled = (serialized[0] !== 0);
            // Visibility
            this._isVisible = (serialized[1] !== 0);
            // Values
            var sources = serialized[2];
            var values = this.values;
            values.length = 0;
            for (var i = 0, imax = sources.length; i < imax; ++i) {
                var source = sources[i];
                values.push(new ESnapperTargetValue(source[0], source[1]));
            }
            this.emit("change", this);
        };
        return ESnapperTarget;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EPSILON = 0.00001;
    var ESnapperModifierAnchor;
    (function (ESnapperModifierAnchor) {
        ESnapperModifierAnchor[ESnapperModifierAnchor["NONE"] = 0] = "NONE";
        ESnapperModifierAnchor[ESnapperModifierAnchor["TOP_LEFT"] = 1] = "TOP_LEFT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["TOP_CENTER"] = 2] = "TOP_CENTER";
        ESnapperModifierAnchor[ESnapperModifierAnchor["TOP_RIGHT"] = 3] = "TOP_RIGHT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["MIDDLE_LEFT"] = 4] = "MIDDLE_LEFT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["MIDDLE_RIGHT"] = 5] = "MIDDLE_RIGHT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["BOTTOM_LEFT"] = 6] = "BOTTOM_LEFT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["BOTTOM_CENTER"] = 7] = "BOTTOM_CENTER";
        ESnapperModifierAnchor[ESnapperModifierAnchor["BOTTOM_RIGHT"] = 8] = "BOTTOM_RIGHT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["ROTATION"] = 9] = "ROTATION";
    })(ESnapperModifierAnchor || (ESnapperModifierAnchor = {}));
    var ESnapper = /** @class */ (function (_super) {
        __extends(ESnapper, _super);
        function ESnapper(parent) {
            var _this = _super.call(this) || this;
            _this._points = [
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point() // Center
            ];
            _this._normals = [
                new pixi_js.Point(),
                new pixi_js.Point()
            ];
            _this._lengths = [
                1,
                1
            ];
            _this._workScale = new pixi_js.Point();
            _this._workSnapResultX = new ESnapperResult();
            _this._workSnapResultY = new ESnapperResult();
            _this._workScaleResult = {
                distance: 0,
                scale: new pixi_js.Point()
            };
            _this._workTranslate = new pixi_js.Point();
            _this._workSnapRectangle = new pixi_js.Rectangle();
            _this._workSnap = new pixi_js.Point();
            // Grid
            _this.grid = new ESnapperGrid();
            // Target
            _this.target = new ESnapperTarget();
            //
            _this._parent = parent;
            _this._isEnabled = true;
            return _this;
        }
        ESnapper.prototype.isEnabled = function () {
            return this._isEnabled;
        };
        ESnapper.prototype.toggle = function () {
            this._isEnabled = !this._isEnabled;
            this.emit("change", this);
            return this._isEnabled;
        };
        ESnapper.prototype.enable = function () {
            if (this._isEnabled !== true) {
                this._isEnabled = true;
                this.emit("change", this);
            }
        };
        ESnapper.prototype.disable = function () {
            if (this._isEnabled !== false) {
                this._isEnabled = false;
                this.emit("change", this);
            }
        };
        ESnapper.prototype.prepare = function (modifier) {
            modifier.updateTransform();
            var localTransform = modifier.transform.localTransform;
            var sx = modifier.width;
            var sy = modifier.height;
            var points = this._points;
            points[0].set(0, 0);
            points[1].set(sx, 0);
            points[2].set(sx, sy);
            points[3].set(0, sy);
            points[4].set(sx * 0.5, sy * 0.5);
            localTransform.apply(points[0], points[0]);
            localTransform.apply(points[1], points[1]);
            localTransform.apply(points[2], points[2]);
            localTransform.apply(points[3], points[3]);
            localTransform.apply(points[4], points[4]);
        };
        ESnapper.prototype.prepareForTranslate = function (modifier) {
            if (this._isEnabled) {
                this.prepare(modifier);
            }
        };
        ESnapper.prototype.snap = function (point, result) {
            var px = point.x;
            var py = point.y;
            var canvas = this._parent.canvas;
            var x = this._workSnapResultX;
            var y = this._workSnapResultY;
            // Canvas
            if (canvas != null) {
                var scale = Math.max(canvas.scale.x, canvas.scale.y);
                x.reset(px, scale);
                y.reset(py, scale);
                x.set(px, 0);
                x.set(px, canvas.width);
                y.set(py, 0);
                y.set(py, canvas.height);
            }
            else {
                x.reset(px, 1);
                y.reset(py, 1);
            }
            // Target
            this.target.snap(px, py, x, y);
            // Grid
            this.grid.snap(px, x);
            this.grid.snap(py, y);
            //
            result.x = (isNaN(x.distance) ? NaN : x.result);
            result.y = (isNaN(y.distance) ? NaN : y.result);
            return result;
        };
        ESnapper.prototype.toSnapped = function (point, result) {
            var px = point.x;
            var py = point.y;
            if (this._isEnabled) {
                this.snap(point, result);
                var x = result.x;
                var y = result.y;
                result.set(isNaN(x) ? px : x, isNaN(y) ? py : y);
            }
            else {
                result.set(px, py);
            }
            return result;
        };
        ESnapper.prototype.toTranslationSnapped = function (delta, result) {
            var dx = delta.x;
            var dy = delta.y;
            var x = NaN;
            var y = NaN;
            if (this._isEnabled) {
                var workTranslate = this._workTranslate;
                var points = this._points;
                for (var i = 0, imax = points.length; i < imax; ++i) {
                    var point = points[i];
                    workTranslate.set(point.x + dx, point.y + dy);
                    this.snap(workTranslate, workTranslate);
                    // X
                    if (!isNaN(workTranslate.x)) {
                        var newDx = workTranslate.x - point.x;
                        if (isNaN(x) || Math.abs(newDx - dx) < Math.abs(x - dx)) {
                            x = newDx;
                        }
                    }
                    // Y
                    if (!isNaN(workTranslate.y)) {
                        var newDy = workTranslate.y - point.y;
                        if (isNaN(y) || Math.abs(newDy - dy) < Math.abs(y - dy)) {
                            y = newDy;
                        }
                    }
                }
            }
            result.x = (isNaN(x) ? dx : x);
            result.y = (isNaN(y) ? dy : y);
            return result;
        };
        ESnapper.prototype.prepareForRotate = function (modifier) {
            //
        };
        ESnapper.prototype.getGridSizeRotation = function () {
            return 5;
        };
        ESnapper.prototype.toRadian = function (value) {
            return value / 180 * Math.PI;
        };
        ESnapper.prototype.toDegree = function (value) {
            return value / Math.PI * 180;
        };
        ESnapper.prototype.toRotationSnapped = function (baseRotation, deltaRotation) {
            if (this._isEnabled) {
                var gridSize = this.getGridSizeRotation();
                var newRotation = baseRotation + deltaRotation;
                var newRotationDegree = Math.round(this.toDegree(newRotation));
                var newRotationDegreeResidual = newRotationDegree % 90;
                if (Math.abs(newRotationDegreeResidual) <= gridSize) {
                    return this.toRadian(newRotationDegree - newRotationDegreeResidual) - baseRotation;
                }
                else {
                    if (90 - gridSize <= newRotationDegreeResidual) {
                        return this.toRadian(newRotationDegree + (90 - newRotationDegreeResidual)) - baseRotation;
                    }
                    else if (newRotationDegreeResidual <= -90 + gridSize) {
                        return this.toRadian(newRotationDegree - (90 + newRotationDegreeResidual)) - baseRotation;
                    }
                    else {
                        return deltaRotation;
                    }
                }
            }
            return deltaRotation;
        };
        ESnapper.prototype.calcNormalizedVector = function (p0, p1, result) {
            var dx = p1.x - p0.x;
            var dy = p1.y - p0.y;
            var l = Math.sqrt(dx * dx + dy * dy);
            if (EPSILON < l) {
                var d = 1 / l;
                result.x = dx * d;
                result.y = dy * d;
            }
            else {
                result.x = 1;
                result.y = 0;
            }
            return l;
        };
        ESnapper.prototype.prepareForScale = function (modifier, anchor) {
            if (this._isEnabled) {
                this.prepare(modifier);
                var points = this._points;
                var normals = this._normals;
                var lengths = this._lengths;
                switch (anchor) {
                    case ESnapperModifierAnchor.TOP_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[1], points[0], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[3], points[0], normals[1]);
                        break;
                    case ESnapperModifierAnchor.TOP_CENTER:
                        lengths[0] = this.calcNormalizedVector(points[3], points[0], normals[0]);
                        break;
                    case ESnapperModifierAnchor.TOP_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[0], points[1], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[2], points[1], normals[1]);
                        break;
                    case ESnapperModifierAnchor.MIDDLE_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[1], points[0], normals[0]);
                        break;
                    case ESnapperModifierAnchor.NONE:
                        break;
                    case ESnapperModifierAnchor.MIDDLE_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[0], points[1], normals[0]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[2], points[3], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[0], points[3], normals[1]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_CENTER:
                        lengths[0] = this.calcNormalizedVector(points[0], points[3], normals[0]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[3], points[2], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[1], points[2], normals[1]);
                        break;
                }
            }
        };
        ESnapper.prototype.setScaleSnappedResult = function (distance, length, move, axis, // true => x axis, false y axis
        result) {
            if (EPSILON < length) {
                if (isNaN(result.distance) || distance < result.distance) {
                    result.distance = distance;
                    var newScale = 1 + move / length;
                    if (axis) {
                        result.scale.x = newScale;
                    }
                    else {
                        result.scale.y = newScale;
                    }
                }
            }
        };
        ESnapper.prototype.calcScaleSnapped1D = function (transform, point, normal, length, axis, result) {
            var work = this._workScale;
            transform.apply(point, work);
            var tx = work.x;
            var ty = work.y;
            this.snap(work, work);
            var x = work.x;
            var y = work.y;
            // X coordinate
            if (!isNaN(x)) {
                var nx = Math.abs(normal.x);
                if (EPSILON < nx) {
                    var dx = (x - tx) / normal.x;
                    var distance = Math.abs(dx);
                    var mx = (x - point.x) / normal.x;
                    this.setScaleSnappedResult(distance, length, mx, axis, result);
                }
            }
            // Y coordinate
            if (!isNaN(y)) {
                var ny = Math.abs(normal.y);
                if (EPSILON < ny) {
                    var dy = (y - ty) / normal.y;
                    var distance = Math.abs(dy);
                    var my = (y - point.y) / normal.y;
                    this.setScaleSnappedResult(distance, length, my, axis, result);
                }
            }
        };
        ESnapper.prototype.calcScaleSnappedX = function (transform, point, normal, length, result) {
            this.calcScaleSnapped1D(transform, point, normal, length, true, result);
        };
        ESnapper.prototype.calcScaleSnappedY = function (transform, point, normal, length, result) {
            this.calcScaleSnapped1D(transform, point, normal, length, false, result);
        };
        ESnapper.prototype.calcScaleSnapped2D = function (transform, point, normals, lengths, result) {
            var work = this._workScale;
            transform.apply(point, work);
            var tx = work.x;
            var ty = work.y;
            this.snap(work, work);
            var x = work.x;
            var y = work.y;
            if (isNaN(x)) {
                if (isNaN(y)) {
                    return;
                }
                else {
                    x = tx;
                }
            }
            else {
                if (isNaN(y)) {
                    y = ty;
                }
            }
            // (x, y) = (tx, ty) + normalA * a + normalB * b
            // dx = x - tx
            // dy = y - ty
            // V = ( a, b )^T
            // D = ( dx, dy )^T
            // A = | normalA.x normalB.x |
            //     | normalA.y normalB.y |
            // A V = D
            // det A = normalA.x * normalB.y - normalB.x * normalA.y
            // A^-1 = |  normalB.y -normalB.x | / det A
            //        | -normalA.y  normalA.x |
            var detA = normals[0].x * normals[1].y - normals[1].x * normals[0].y;
            if (EPSILON < Math.abs(detA)) {
                var dx = x - tx;
                var dy = y - ty;
                var distance = Math.abs(dx * dx + dy * dy);
                if (isNaN(result.distance) || distance < result.distance) {
                    result.distance = distance;
                    var mdx = x - point.x;
                    var mdy = y - point.y;
                    var mx = (+normals[1].y * mdx - normals[1].x * mdy) / detA;
                    var my = (-normals[0].y * mdx + normals[0].x * mdy) / detA;
                    result.scale.set(1 + mx / lengths[0], 1 + my / lengths[1]);
                }
            }
        };
        ESnapper.prototype.calcScaleSnappedXY = function (transform, pointO, pointX, pointY, normals, lengths, result) {
            this.calcScaleSnapped2D(transform, pointO, normals, lengths, result);
            this.calcScaleSnappedX(transform, pointY, normals[0], lengths[0], result);
            this.calcScaleSnappedY(transform, pointX, normals[1], lengths[1], result);
        };
        ESnapper.prototype.toScaleSnapped = function (transform, anchor, keepRatio, scale) {
            if (this._isEnabled) {
                var points = this._points;
                var normals = this._normals;
                var lengths = this._lengths;
                var work = this._workScaleResult;
                work.distance = NaN;
                work.scale.set(scale.x, scale.y);
                switch (anchor) {
                    case ESnapperModifierAnchor.TOP_LEFT:
                        this.calcScaleSnappedXY(transform, points[0], points[1], points[3], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.TOP_CENTER:
                        this.calcScaleSnappedY(transform, points[0], normals[0], lengths[0], work);
                        this.calcScaleSnappedY(transform, points[1], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.TOP_RIGHT:
                        this.calcScaleSnappedXY(transform, points[1], points[0], points[2], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.MIDDLE_LEFT:
                        this.calcScaleSnappedX(transform, points[0], normals[0], lengths[0], work);
                        this.calcScaleSnappedX(transform, points[3], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.NONE:
                        break;
                    case ESnapperModifierAnchor.MIDDLE_RIGHT:
                        this.calcScaleSnappedX(transform, points[1], normals[0], lengths[0], work);
                        this.calcScaleSnappedX(transform, points[2], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_LEFT:
                        this.calcScaleSnappedXY(transform, points[3], points[2], points[0], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_CENTER:
                        this.calcScaleSnappedY(transform, points[2], normals[0], lengths[0], work);
                        this.calcScaleSnappedY(transform, points[3], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_RIGHT:
                        this.calcScaleSnappedXY(transform, points[2], points[3], points[1], normals, lengths, work);
                        break;
                }
                if (!isNaN(work.distance)) {
                    scale.copyFrom(work.scale);
                    if (keepRatio) {
                        switch (anchor) {
                            case ESnapperModifierAnchor.TOP_LEFT:
                            case ESnapperModifierAnchor.TOP_RIGHT:
                            case ESnapperModifierAnchor.BOTTOM_LEFT:
                            case ESnapperModifierAnchor.BOTTOM_RIGHT:
                                scale.x = scale.y = Math.max(scale.x, scale.y);
                                break;
                            case ESnapperModifierAnchor.TOP_CENTER:
                            case ESnapperModifierAnchor.BOTTOM_CENTER:
                                scale.x = scale.y;
                                break;
                            case ESnapperModifierAnchor.MIDDLE_LEFT:
                            case ESnapperModifierAnchor.MIDDLE_RIGHT:
                                scale.y = scale.x;
                                break;
                            case ESnapperModifierAnchor.NONE:
                                break;
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        ESnapper.prototype.reset = function () {
            this.enable();
            this.target.reset();
            this.grid.reset();
        };
        ESnapper.prototype.serialize = function () {
            return [
                (this._isEnabled ? 1 : 0),
                this.target.serialize(),
                this.grid.serialize()
            ];
        };
        ESnapper.prototype.deserialize = function (serialized) {
            if (serialized[0] !== 0) {
                this.enable();
            }
            else {
                this.disable();
            }
            this.target.deserialize(serialized[1]);
            this.grid.deserialize(serialized[2]);
        };
        return ESnapper;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationEmpty = /** @class */ (function (_super) {
        __extends(DAnimationEmpty, _super);
        function DAnimationEmpty(options) {
            var _this = _super.call(this) || this;
            _this._target = (options && options.target != null ? options.target : null);
            _this._reverse = false;
            _this._isStarted = false;
            _this._onTime = options && options.onTime;
            _this._onStart = options && options.onStart;
            _this._onEnd = options && options.onEnd;
            return _this;
        }
        Object.defineProperty(DAnimationEmpty.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DAnimationEmpty.prototype, "duration", {
            get: function () {
                return 0;
            },
            set: function (duration) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        DAnimationEmpty.prototype.start = function (reverse) {
            if (reverse === void 0) { reverse = false; }
            this.stop();
            this._isStarted = true;
            this._reverse = reverse;
            // onStart
            this.onStart(reverse);
            if (!this._isStarted) {
                return;
            }
            // onTime
            this.onTime(reverse ? 1 : 0, reverse, 0);
            if (!this._isStarted) {
                return;
            }
            this.onTime(reverse ? 0 : 1, reverse, 0);
            if (this._isStarted) {
                return;
            }
            // OnEnd
            this.onEnd(reverse);
        };
        DAnimationEmpty.prototype.onStart = function (isReverse) {
            var onStart = this._onStart;
            if (onStart != null) {
                onStart(isReverse, this);
            }
            this.emit("start", isReverse, this);
        };
        DAnimationEmpty.prototype.onTime = function (time, isReverse, elapsedTime) {
            var onTime = this._onTime;
            if (onTime != null) {
                onTime(time, isReverse, elapsedTime, this);
            }
            this.emit("time", time, isReverse, elapsedTime, this);
        };
        DAnimationEmpty.prototype.onEnd = function (isReverse) {
            var onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(isReverse, this);
            }
            this.emit("end", isReverse, this);
        };
        DAnimationEmpty.prototype.isStarted = function () {
            return this._isStarted;
        };
        DAnimationEmpty.prototype.isReverse = function () {
            return this._reverse;
        };
        DAnimationEmpty.prototype.stop = function () {
            this._isStarted = false;
        };
        DAnimationEmpty.prototype.end = function () {
            var isStarted = this._isStarted;
            if (isStarted) {
                this._isStarted = false;
                // OnTime
                var reverse = this._reverse;
                var time = (reverse ? 0 : 1);
                this.onTime(time, reverse, 0);
                // OnEnd
                this.onEnd(reverse);
            }
        };
        return DAnimationEmpty;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationFadeIn = /** @class */ (function (_super) {
        __extends(DAnimationFadeIn, _super);
        function DAnimationFadeIn(options) {
            var _this = _super.call(this, options) || this;
            _this._storedX = 0;
            _this._storedY = 0;
            _this._storedAlpha = 0;
            _this._storedTime = 0;
            _this._storedTarget = null;
            _this._layer = null;
            // Shifts
            if (options != null && options.shift != null) {
                var shift = options.shift;
                _this._shiftX = (shift.x != null ? shift.x : 0);
                _this._shiftY = (shift.y != null ? shift.y : 15);
            }
            else {
                _this._shiftX = 0;
                _this._shiftY = 15;
            }
            _this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            _this._onPostrenderBound = function () {
                _this.onPostrender();
            };
            return _this;
        }
        DAnimationFadeIn.prototype.stop = function () {
            this._storedTime = 0;
            this.removeEventListeners();
            _super.prototype.stop.call(this);
        };
        DAnimationFadeIn.prototype.addEventListeners = function (target) {
            var layer = DApplications.getLayer(target);
            if (layer) {
                this._layer = layer;
                var renderer = layer.renderer;
                renderer.on("prerender", this._onPrerenderBound);
                renderer.on("postrender", this._onPostrenderBound);
            }
        };
        DAnimationFadeIn.prototype.removeEventListeners = function () {
            var layer = this._layer;
            if (layer) {
                this._layer = null;
                var renderer = layer.renderer;
                renderer.off("prerender", this._onPrerenderBound);
                renderer.off("postrender", this._onPostrenderBound);
            }
        };
        DAnimationFadeIn.prototype.onStart = function (isReverse) {
            var target = this._storedTarget = this._target;
            if (target != null) {
                this._storedTime = 0;
                this.removeEventListeners();
                this.addEventListeners(target);
                if (!isReverse) {
                    target.visible = true;
                }
                _super.prototype.onStart.call(this, isReverse);
            }
        };
        DAnimationFadeIn.prototype.onTime = function (time, isReverse, elapsedTime) {
            var target = this._storedTarget;
            if (target != null) {
                var layer = this._layer;
                if (layer) {
                    layer.disallowUpdate();
                    this._storedTime = time;
                    _super.prototype.onTime.call(this, time, isReverse, elapsedTime);
                    layer.allowUpdate();
                    layer.render();
                }
                else {
                    this._storedTime = time;
                    _super.prototype.onTime.call(this, time, isReverse, elapsedTime);
                }
            }
        };
        DAnimationFadeIn.prototype.onEnd = function (isReverse) {
            var target = this._storedTarget;
            if (target != null) {
                this.removeEventListeners();
                if (isReverse) {
                    target.visible = false;
                }
                _super.prototype.onEnd.call(this, isReverse);
            }
        };
        DAnimationFadeIn.prototype.onPrerender = function () {
            var target = this._storedTarget;
            if (target != null) {
                var storedTime = this._storedTime;
                // Position
                var position = target.unsafe.position;
                this._storedX = position.x;
                this._storedY = position.y;
                position.set(position.x - this._shiftX * (1 - storedTime), position.y - this._shiftY * (1 - storedTime));
                // Alpha
                this._storedAlpha = target.alpha;
                target.alpha = storedTime;
            }
        };
        DAnimationFadeIn.prototype.onPostrender = function () {
            var target = this._storedTarget;
            if (target != null) {
                // Position
                var position = target.unsafe.position;
                position.set(this._storedX, this._storedY);
                // Alpha
                target.alpha = this._storedAlpha;
            }
        };
        return DAnimationFadeIn;
    }(DAnimationBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DApplicationPadding = /** @class */ (function () {
        function DApplicationPadding(top, right, bottom, left) {
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        DApplicationPadding.prototype.getTheme = function () {
            throw new Error("Not supported");
        };
        DApplicationPadding.prototype.setTheme = function (theme) {
            throw new Error("Not supported");
        };
        DApplicationPadding.prototype.getTop = function () {
            return this.left;
        };
        DApplicationPadding.prototype.getRight = function () {
            return this.right;
        };
        DApplicationPadding.prototype.getBottom = function () {
            return this.bottom;
        };
        DApplicationPadding.prototype.getLeft = function () {
            return this.left;
        };
        DApplicationPadding.prototype.set = function (top, right, bottom, left) {
            if (right == null) {
                this.top = top;
                this.right = top;
                this.bottom = top;
                this.left = top;
            }
            else if (bottom == null) {
                this.top = top;
                this.right = right;
                this.bottom = top;
                this.left = right;
            }
            else if (left == null) {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = right;
            }
            else {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = left;
            }
        };
        return DApplicationPadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * DApplicationLayer options
     */
    var DApplicationLayerOptions = /** @class */ (function () {
        function DApplicationLayerOptions(options) {
            // Root
            var root = this._root = options.root;
            // Overlay mode or not
            this._overlay = options.overlay;
            // Padding
            var padding = options && options.padding;
            if (isNumber(padding)) {
                this._padding = new DApplicationPadding(padding, padding, padding, padding);
            }
            else if (padding != null) {
                this._padding = new DApplicationPadding(padding.top || 0, padding.right || 0, padding.bottom || 0, padding.left || 0);
            }
            else {
                this._padding = new DApplicationPadding(6, 6, 6, 6);
            }
            // Width & height
            var width = 100;
            var height = 100;
            if (options) {
                if (options.width != null) {
                    width = options.width;
                    if (options.height != null) {
                        height = options.height;
                    }
                    else {
                        height = root.getBoundingClientRect().height;
                    }
                }
                else if (options.height != null) {
                    width = root.getBoundingClientRect().width;
                    height = options.height;
                }
                else {
                    var bbox = root.getBoundingClientRect();
                    width = bbox.width;
                    height = bbox.height;
                }
            }
            else {
                var bbox = root.getBoundingClientRect();
                width = bbox.width;
                height = bbox.height;
            }
            // Background color
            var background = options && options.background;
            var backgroundColor = 0;
            var transparent = true;
            if (background != null) {
                var color = background.color;
                if (color != null) {
                    backgroundColor = color;
                    transparent = false;
                }
            }
            // Resolution
            var resolution = options.resolution;
            // Antialias
            var antialias = (options && options.antialias != null ? options.antialias : false);
            // Pixi
            this._pixi = {
                width: width,
                height: height,
                autoStart: false,
                backgroundColor: backgroundColor,
                transparent: transparent,
                resolution: resolution,
                antialias: antialias
            };
        }
        /**
         * Returns a root element.
         * `HTMLCanvasElement` and other DOM elements are created in this element.
         * The default root element is `document.body`.
         */
        DApplicationLayerOptions.prototype.getRootElement = function () {
            return this._root;
        };
        /**
         * Sets a root element and updates the canvas width and height
         * if `updateWidthAndHeight` is not false.
         *
         * @param root new root element
         * @param updateWidthAndHeight false to preserve the canvas width / height
         */
        DApplicationLayerOptions.prototype.setRootElement = function (root, updateWidthAndHeight) {
            if (this._root !== root) {
                this._root = root;
                if (updateWidthAndHeight !== false) {
                    var bbox = root.getBoundingClientRect();
                    var pixi = this._pixi;
                    pixi.width = bbox.width;
                    pixi.height = bbox.height;
                }
            }
            return this;
        };
        /**
         * Returns a canvas width.
         */
        DApplicationLayerOptions.prototype.getWidth = function () {
            return this._pixi.width;
        };
        /**
         * Sets a canvas width.
         *
         * @param width new canvas width
         */
        DApplicationLayerOptions.prototype.setWidth = function (width) {
            this._pixi.width = width;
            return this;
        };
        /**
         * Returns a canvas height.
         */
        DApplicationLayerOptions.prototype.getHeight = function () {
            return this._pixi.height;
        };
        /**
         * Sets a canvas height.
         *
         * @param height new canvas height
         */
        DApplicationLayerOptions.prototype.setHeight = function (height) {
            this._pixi.height = height;
            return this;
        };
        /**
         * Returns padding sizes.
         * The default padding size is 6.
         */
        DApplicationLayerOptions.prototype.getPadding = function () {
            return this._padding;
        };
        /**
         * Sets padding sizes.
         *
         * @param left new left padding
         * @param top new top padding
         * @param right new right padding
         * @param bottom new bottom padding
         * @asse getPadding
         */
        DApplicationLayerOptions.prototype.setPadding = function (left, top, right, bottom) {
            var padding = this._padding;
            padding.left = left;
            padding.top = top;
            padding.right = right;
            padding.bottom = bottom;
            return this;
        };
        /**
         * Returns a background color.
         */
        DApplicationLayerOptions.prototype.getBackgroundColor = function () {
            return this._pixi.backgroundColor;
        };
        /**
         * Sets a background color.
         *
         * @param color new background color
         */
        DApplicationLayerOptions.prototype.setBackgroundColor = function (color) {
            this._pixi.backgroundColor = color;
            return this;
        };
        /**
         * Returns an antialias setting.
         * The default antialias setting is false.
         */
        DApplicationLayerOptions.prototype.getAntialias = function () {
            return this._pixi.antialias;
        };
        /**
         * Sets an antialias setting.
         *
         * @param antialias new antialias setting
         */
        DApplicationLayerOptions.prototype.setAntialias = function (antialias) {
            this._pixi.antialias = antialias;
            return this;
        };
        /**
         * Returns true if a layer is supposed to be an overlay layer.
         */
        DApplicationLayerOptions.prototype.isOverlay = function () {
            return this._overlay;
        };
        DApplicationLayerOptions.prototype.getPixiApplicationOptions = function () {
            return this._pixi;
        };
        return DApplicationLayerOptions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isFocusable = function (target) {
        return (target != null && ("setState" in target));
    };
    var isFocusableContainer = function (target) {
        return (target != null && "children" in target);
    };
    var DControllerDefaultFocus = /** @class */ (function () {
        function DControllerDefaultFocus() {
            this._focused = null;
        }
        DControllerDefaultFocus.prototype.setFocused = function (focusable, isFocused, select) {
            if (isFocused) {
                var previous = this._focused;
                if (previous !== focusable) {
                    if (previous != null) {
                        previous.setState(DBaseState.FOCUSED, false);
                    }
                    this._focused = focusable;
                    if (focusable != null && this.isFocusable(focusable)) {
                        focusable.setState(DBaseState.FOCUSED, true);
                    }
                    return previous;
                }
                else {
                    return null;
                }
            }
            else {
                if (focusable != null && this._focused === focusable) {
                    this._focused = null;
                    focusable.setState(DBaseState.FOCUSED, false);
                    return focusable;
                }
                else {
                    return null;
                }
            }
        };
        DControllerDefaultFocus.prototype.getFocused = function () {
            return this._focused;
        };
        DControllerDefaultFocus.prototype.findFocusableParent = function (mightBeFocusable) {
            var current = mightBeFocusable;
            while (current != null) {
                if (this.isFocusable(current)) {
                    return current;
                }
                else {
                    current = current.parent;
                }
            }
            return null;
        };
        DControllerDefaultFocus.prototype.isFocusable = function (target) {
            return (isFocusable(target) &&
                !target.hasState(DBaseState.DISABLED | DBaseState.UNFOCUSABLE) &&
                target.visible);
        };
        DControllerDefaultFocus.prototype.isFocusRoot = function (target) {
            return (isFocusable(target) &&
                target.hasState(DBaseState.FOCUS_ROOT) &&
                target.visible);
        };
        DControllerDefaultFocus.prototype.findFocusable = function (target, includesTarget, includesTargetChildren, direction) {
            if (direction) {
                var result = this.findFocusableNext(target, includesTarget, includesTargetChildren);
                if (result != null) {
                    return result;
                }
                var parent_1 = target.parent;
                if (parent_1 != null) {
                    var children = parent_1.children;
                    var index = children.indexOf(target);
                    if (0 <= index) {
                        // Siblings
                        for (var i = index + 1, imax = children.length; i < imax; ++i) {
                            var found = this.findFocusableNext(children[i], true, true);
                            if (found != null) {
                                return found;
                            }
                        }
                        if (this.isFocusRoot(parent_1)) {
                            for (var i = 0, imax = index + 1; i < imax; ++i) {
                                var found = this.findFocusableNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                        // Parent
                        return this.findFocusable(parent_1, false, false, true);
                    }
                }
            }
            else {
                var result = this.findFocusablePrevious(target, includesTarget, includesTargetChildren);
                if (result != null) {
                    return result;
                }
                var parent_2 = target.parent;
                if (parent_2 != null) {
                    var children = parent_2.children;
                    var index = children.indexOf(target);
                    if (0 <= index) {
                        // Siblings
                        for (var i = index - 1; 0 <= i; --i) {
                            var found = this.findFocusablePrevious(children[i], true, true);
                            if (found != null) {
                                return found;
                            }
                        }
                        if (this.isFocusRoot(parent_2)) {
                            for (var i = children.length - 1; index <= i; --i) {
                                var found = this.findFocusablePrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            return parent_2;
                        }
                        // Parent
                        return this.findFocusable(parent_2, true, false, false);
                    }
                }
            }
            return null;
        };
        DControllerDefaultFocus.prototype.findFocusableNext = function (target, includesTarget, includesTargetChildren) {
            // Target itself
            if (includesTarget) {
                if (this.isFocusable(target)) {
                    return target;
                }
            }
            // Target children
            if (includesTargetChildren && isFocusableContainer(target) && target.visible) {
                var children = target.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var found = this.findFocusableNext(children[i], true, true);
                    if (found != null) {
                        return found;
                    }
                }
            }
            // Siblings
            if (this.isFocusRoot(target)) {
                return target;
            }
            // Found nothing
            return null;
        };
        DControllerDefaultFocus.prototype.findFocusablePrevious = function (target, includesTarget, includesTargetChildren) {
            // Target children
            if (includesTargetChildren && isFocusableContainer(target) && target.visible) {
                var children = target.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var found = this.findFocusablePrevious(children[i], true, true);
                    if (found != null) {
                        return found;
                    }
                }
            }
            // Target itself
            if (includesTarget) {
                if (this.isFocusable(target)) {
                    return target;
                }
            }
            // Siblings
            if (this.isFocusRoot(target)) {
                return target;
            }
            // Found nothing
            return null;
        };
        return DControllerDefaultFocus;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandFlag;
    (function (DCommandFlag) {
        DCommandFlag[DCommandFlag["NONE"] = 0] = "NONE";
        /**
         * Commands with a `UNSTORABLE` flag will not be queued to the `done` queue.
         */
        DCommandFlag[DCommandFlag["UNSTORABLE"] = 1] = "UNSTORABLE";
        /**
         * Commands with a `CLEAR` flag clears the command queue.
         */
        DCommandFlag[DCommandFlag["CLEAR"] = 2] = "CLEAR";
    })(DCommandFlag || (DCommandFlag = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandClear = /** @class */ (function () {
        function DCommandClear() {
        }
        DCommandClear.prototype.execute = function () {
            return true;
        };
        DCommandClear.prototype.redo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandClear.prototype.undo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandClear.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandClear.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE | DCommandFlag.CLEAR;
        };
        return DCommandClear;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandRedo = /** @class */ (function () {
        function DCommandRedo() {
        }
        DCommandRedo.prototype.execute = function () {
            throw new Error("Not supported");
        };
        DCommandRedo.prototype.redo = function () {
            throw new Error("Not supported");
        };
        DCommandRedo.prototype.undo = function () {
            throw new Error("Not supported");
        };
        DCommandRedo.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandRedo.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE;
        };
        return DCommandRedo;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandUndo = /** @class */ (function () {
        function DCommandUndo() {
        }
        DCommandUndo.prototype.execute = function () {
            throw new Error("Not supported");
        };
        DCommandUndo.prototype.redo = function () {
            throw new Error("Not supported");
        };
        DCommandUndo.prototype.undo = function () {
            throw new Error("Not supported");
        };
        DCommandUndo.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandUndo.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE;
        };
        return DCommandUndo;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isCommandStorable = function (command) {
        return (command.getFlag() & DCommandFlag.UNSTORABLE) === 0;
    };
    var isCommandClear = function (command) {
        return (command.getFlag() & DCommandFlag.CLEAR) !== 0;
    };
    var DControllerDefaultCommand = /** @class */ (function (_super) {
        __extends(DControllerDefaultCommand, _super);
        function DControllerDefaultCommand() {
            var _this = _super.call(this) || this;
            _this._position = 0;
            _this._done = [];
            _this._waiting = [];
            _this._executing = null;
            return _this;
        }
        DControllerDefaultCommand.prototype.last = function () {
            var done = this._done;
            var waiting = this._waiting;
            if (waiting.length <= 0) {
                if (0 < done.length) {
                    return done[done.length - 1];
                }
                else {
                    return null;
                }
            }
            else {
                return waiting[waiting.length - 1];
            }
        };
        DControllerDefaultCommand.prototype.push = function (command) {
            var waiting = this._waiting;
            waiting.push(command);
            this.next();
        };
        DControllerDefaultCommand.prototype.next = function () {
            var _this = this;
            if (this._executing == null) {
                var waiting = this._waiting;
                if (0 < waiting.length) {
                    var command_1 = waiting.shift();
                    if (command_1 != null) {
                        if (command_1 instanceof DCommandUndo) {
                            var done = this._done;
                            if (this._position < done.length) {
                                var current = done[done.length - 1 - this._position];
                                this._position += 1;
                                this.emit("change", this);
                                var result = current.undo();
                                if (result === true) {
                                    this.onSuccess(command_1);
                                }
                                else if (result === false) {
                                    this.onFail(command_1);
                                }
                                else {
                                    this._executing = result.then(function () {
                                        _this.onSuccess(command_1);
                                    }, function () {
                                        _this.onFail(command_1);
                                    });
                                }
                            }
                        }
                        else if (command_1 instanceof DCommandRedo) {
                            var done = this._done;
                            if (0 < this._position) {
                                var current = done[done.length - this._position];
                                this._position -= 1;
                                this.emit("change", this);
                                var result = current.redo();
                                if (result === true) {
                                    this.onSuccess(command_1);
                                }
                                else if (result === false) {
                                    this.onFail(command_1);
                                }
                                else {
                                    this._executing = result.then(function () {
                                        _this.onSuccess(command_1);
                                    }, function () {
                                        _this.onFail(command_1);
                                    });
                                }
                            }
                        }
                        else {
                            var isClear = isCommandClear(command_1);
                            var isStorable = isCommandStorable(command_1);
                            if (isClear || isStorable) {
                                var size = (isClear ? this._done.length : this._position);
                                if (0 < size) {
                                    this.remove(size);
                                    this._position = 0;
                                    this.emit("change", this);
                                }
                                this.cleanup();
                            }
                            var result = command_1.execute();
                            if (result === true) {
                                this.onSuccess(command_1);
                            }
                            else if (result === false) {
                                this.onFail(command_1);
                            }
                            else {
                                this._executing = result.then(function () {
                                    _this.onSuccess(command_1);
                                }, function () {
                                    _this.onFail(command_1);
                                });
                            }
                        }
                    }
                }
            }
        };
        DControllerDefaultCommand.prototype.cleanup = function () {
            var done = this._done;
            var size = done.length - 100;
            if (0 < size) {
                for (var i = 0; i < size; ++i) {
                    done[i].destroy();
                    done.shift();
                }
            }
        };
        DControllerDefaultCommand.prototype.remove = function (size) {
            var done = this._done;
            if (0 < size) {
                var ifrom = Math.max(0, done.length - size);
                size = done.length - ifrom;
                if (0 < size) {
                    for (var i = ifrom, imax = done.length; i < imax; ++i) {
                        done[i].destroy();
                    }
                    done.splice(ifrom, done.length - ifrom);
                    return true;
                }
            }
            return false;
        };
        DControllerDefaultCommand.prototype.onSuccess = function (command) {
            this._executing = null;
            if (isCommandStorable(command)) {
                this._done.push(command);
                this.emit("dirty", this);
            }
            else if (command instanceof DCommandUndo || command instanceof DCommandRedo) {
                this.emit("dirty", this);
            }
            this.emit("change", this);
            this.next();
        };
        DControllerDefaultCommand.prototype.onFail = function (command) {
            this._executing = null;
            var waiting = this._waiting;
            command.destroy();
            for (var i = 0, imax = waiting.length; i < imax; ++i) {
                waiting[i].destroy();
            }
            waiting.length = 0;
            this.emit("change", this);
        };
        DControllerDefaultCommand.prototype.size = function () {
            return this._done.length;
        };
        DControllerDefaultCommand.prototype.clear = function () {
            this.push(new DCommandClear());
        };
        DControllerDefaultCommand.prototype.redo = function () {
            if (this.isRedoable()) {
                this._waiting.push(new DCommandRedo());
                this.next();
            }
        };
        DControllerDefaultCommand.prototype.undo = function () {
            if (this.isUndoable()) {
                this._waiting.push(new DCommandUndo());
                this.next();
            }
        };
        DControllerDefaultCommand.prototype.isRedoable = function () {
            return (0 < this._position && this._executing == null);
        };
        DControllerDefaultCommand.prototype.isUndoable = function () {
            return (this._position < this._done.length && this._executing == null);
        };
        return DControllerDefaultCommand;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllerKeyboard = /** @class */ (function (_super) {
        __extends(DControllerKeyboard, _super);
        function DControllerKeyboard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DControllerKeyboard.prototype.init = function (element, stage, focusController) {
            var _this = this;
            element.addEventListener("keydown", function (e) {
                _this.emit("keydown", e);
                var focused = focusController.getFocused();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (_this.hasOnKeyDown(current)) {
                            if (current.onKeyDown(e)) {
                                return;
                            }
                        }
                        current = current.parent;
                    }
                }
                if (UtilKeyboardEvent.isFocusKey(e)) {
                    var direction = UtilKeyboardEvent.getFocusDirection(e);
                    var next = (focused != null ?
                        focusController.findFocusable(focused, false, focused.hasState(DBaseState.FOCUS_ROOT) || direction, direction) :
                        focusController.findFocusable(stage, false, true, direction));
                    if (next != null) {
                        focusController.setFocused(next, true, true);
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                }
            });
            element.addEventListener("keyup", function (e) {
                _this.emit("keyup", e);
                var focused = focusController.getFocused();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (_this.hasOnKeyUp(current)) {
                            if (current.onKeyUp(e)) {
                                return;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        };
        DControllerKeyboard.prototype.hasOnKeyDown = function (target) {
            return "onKeyDown" in target;
        };
        DControllerKeyboard.prototype.hasOnKeyUp = function (target) {
            return "onKeyUp" in target;
        };
        return DControllerKeyboard;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllers = /** @class */ (function () {
        function DControllers() {
        }
        // Keyboard
        DControllers.getKeyboardController = function () {
            if (this.KEYBOARD == null) {
                this.KEYBOARD = new DControllerKeyboard();
            }
            return this.KEYBOARD;
        };
        DControllers.setKeyboardController = function (instance) {
            var result = this.KEYBOARD;
            this.KEYBOARD = instance;
            return result;
        };
        // Command
        DControllers.getCommandController = function () {
            if (this.COMMAND == null) {
                this.COMMAND = new DControllerDefaultCommand();
            }
            return this.COMMAND;
        };
        DControllers.setCommandController = function (instance) {
            var result = this.COMMAND;
            this.COMMAND = instance;
            return result;
        };
        // Document
        DControllers.getDocumentController = function () {
            if (this.DOCUMENT == null) {
                throw new Error("Not supported");
            }
            return this.DOCUMENT;
        };
        DControllers.setDocumentController = function (instance) {
            var result = this.DOCUMENT;
            this.DOCUMENT = instance;
            return result;
        };
        return DControllers;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isDblClickable = function (target) {
        return target != null && target.onDblClick != null;
    };
    var isWheelable = function (target) {
        return target != null && target.onWheel != null;
    };
    var DApplicationLayer = /** @class */ (function (_super) {
        __extends(DApplicationLayer, _super);
        function DApplicationLayer(application, options) {
            var _this = _super.call(this, options.getPixiApplicationOptions()) || this;
            _this._renderId = null;
            _this._dynamicFontAtlases = null;
            _this.application = application;
            var stageAny = _this.stage;
            stageAny.layer = _this;
            stageAny.application = application;
            _this._options = options;
            _this._isUpdateAllowed = true;
            _this._refitLimit = 5;
            _this._reflowLimit = 5;
            _this._isVisible = true;
            _this._renderBound = function () {
                if (_this._renderId != null) {
                    _this.render();
                }
            };
            // Canvas initialization
            var rootElement = options.getRootElement();
            var elementContainer = document.createElement("div");
            elementContainer.setAttribute("style", "position: absolute; top: 0; left: 0; width: 0; height: 0;" +
                "margin: 0; padding: 0; outline: none;");
            _this._elementContainer = elementContainer;
            var children = rootElement.children;
            if (options.isOverlay()) {
                if (3 <= children.length) {
                    var thirdChild = children[2];
                    rootElement.insertBefore(_this.view, thirdChild);
                    rootElement.insertBefore(elementContainer, thirdChild);
                }
                else {
                    rootElement.appendChild(_this.view);
                    rootElement.appendChild(elementContainer);
                }
                var oldOnChildrenChange_1 = stageAny.onChildrenChange;
                stageAny.onChildrenChange = function () {
                    _this.updateVisibility();
                    oldOnChildrenChange_1.call(stageAny);
                };
            }
            else {
                if (0 < children.length) {
                    var firstChild = children[0];
                    rootElement.insertBefore(_this.view, firstChild);
                    rootElement.insertBefore(elementContainer, firstChild);
                }
                else {
                    rootElement.appendChild(_this.view);
                    rootElement.appendChild(elementContainer);
                }
            }
            var rootElementStyle = rootElement.style;
            if (rootElement !== document.body) {
                var rootElementStylePosition = window.getComputedStyle(rootElement).position;
                if (rootElementStylePosition === "static") {
                    rootElementStyle.position = "relative";
                }
            }
            rootElementStyle.margin = "0";
            rootElementStyle.padding = "0";
            rootElementStyle.overflow = "hidden";
            var viewStyle = _this.view.style;
            viewStyle.position = "absolute";
            viewStyle.top = "0";
            viewStyle.left = "0";
            viewStyle.width = "100%";
            viewStyle.height = "100%";
            viewStyle.display = "block";
            viewStyle.outline = "none";
            // Focus handling
            var hasFocus = false;
            var focusController = _this.getFocusController();
            var onBlurBound = function () {
                if (!hasFocus) {
                    focusController.setFocused(null, true, false);
                }
            };
            rootElement.addEventListener("focus", function (e) {
                hasFocus = true;
            }, true);
            rootElement.addEventListener("blur", function (e) {
                hasFocus = false;
                setTimeout(onBlurBound, 0);
            }, true);
            _this.view.setAttribute("tabindex", "0");
            DControllers.getKeyboardController().init(_this.view, _this.stage, focusController);
            var interactionManager = _this.renderer.plugins.interaction;
            interactionManager.on(UtilPointerEvent.down, function (e) {
                if (e.target == null) {
                    focusController.setFocused(null, true, false);
                }
            });
            // Resize handling
            var onResize = function () {
                var bbox = options.getRootElement().getBoundingClientRect();
                _this.renderer.resize(bbox.width, bbox.height);
                _this.resizeChildren(bbox.width, bbox.height, options.getPadding());
                _this.update();
            };
            window.addEventListener("resize", onResize);
            window.addEventListener("orientationchange", onResize);
            // Mouse wheel handling
            var wheelGlobal = new pixi_js.Point();
            var wheelEventUtil = UtilWheelEvent.getInstance();
            wheelEventUtil.on(_this.view, function (e) {
                var wheelEvent = e;
                UtilPointerEvent.toGlobal(wheelEvent, interactionManager, wheelGlobal);
                var current = interactionManager.hitTest(wheelGlobal);
                var deltas = wheelEventUtil.normalize(e);
                if (deltas != null) {
                    while (current != null) {
                        if (isWheelable(current)) {
                            if (current.onWheel(wheelEvent, deltas, wheelGlobal)) {
                                wheelEvent.preventDefault();
                                break;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
            // Double click handling
            UtilPointerEvent.onDblClick(_this.view, function (e) {
                var focused = focusController.getFocused();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (isDblClickable(current)) {
                            if (current.onDblClick(e, interactionManager)) {
                                break;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
            //
            _this.stage.interactive = true;
            return _this;
        }
        DApplicationLayer.prototype.disallowUpdate = function () {
            this._isUpdateAllowed = false;
        };
        DApplicationLayer.prototype.allowUpdate = function () {
            this._isUpdateAllowed = true;
        };
        DApplicationLayer.prototype.update = function () {
            if (this._isUpdateAllowed && this._renderId == null) {
                this._renderId = requestAnimationFrame(this._renderBound);
            }
        };
        DApplicationLayer.prototype.updateVisibility = function () {
            if (this._options.isOverlay()) {
                if (0 < this.stage.children.length) {
                    if (!this._isVisible) {
                        this._isVisible = true;
                        this.view.style.display = "block";
                    }
                }
                else {
                    if (this._isVisible) {
                        this._isVisible = false;
                        this.view.style.display = "none";
                    }
                }
            }
        };
        DApplicationLayer.prototype.render = function () {
            this.refit();
            this.reflow();
            // Please note why the following line is here.
            //
            // Before this line, the update method does not enque a rendering task
            // because `this._renderId` is not null. As a result, this prevents
            // an unintentional rendering loop caused by the refit or the reflow.
            //
            // After this line, the update method enques a rendering task.
            // Namely, in the DisplayObject#render(Renderer) method, allowed to enque
            // a rendering task. For instance, please refer to the DDiagramShape#update().
            this._renderId = null;
            // Render
            _super.prototype.render.call(this);
        };
        Object.defineProperty(DApplicationLayer.prototype, "width", {
            get: function () {
                return this.screen.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DApplicationLayer.prototype, "height", {
            get: function () {
                return this.screen.height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DApplicationLayer.prototype, "padding", {
            get: function () {
                return this._options.getPadding();
            },
            enumerable: true,
            configurable: true
        });
        DApplicationLayer.prototype.resizeChildren = function (width, height, padding) {
            var children = this.stage.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentResize(width, height, padding);
                }
            }
        };
        DApplicationLayer.prototype.refit = function () {
            var children = this.stage.children;
            for (var ilimit = 0, limit = this._refitLimit; ilimit < limit; ++ilimit) {
                var isChildrenDirty = false;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.refit();
                        isChildrenDirty = isChildrenDirty || child.isChildrenDirty();
                    }
                }
                // If DBases are changed during the `refit` process, need to refit again.
                if (!isChildrenDirty) {
                    break;
                }
            }
        };
        DApplicationLayer.prototype.reflow = function () {
            var children = this.stage.children;
            for (var ilimit = 0, limit = this._refitLimit; ilimit < limit; ++ilimit) {
                var isDirty = false;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.reflow();
                        isDirty = isDirty || child.isDirty() || child.hasDirty();
                    }
                }
                // If DBases are changed during the `reflow` process, need to reflow again.
                if (!isDirty) {
                    break;
                }
            }
        };
        DApplicationLayer.prototype.getFocusController = function () {
            if (this._focus == null) {
                this._focus = new DControllerDefaultFocus();
            }
            return this._focus;
        };
        DApplicationLayer.prototype.getElementContainer = function () {
            return this._elementContainer;
        };
        DApplicationLayer.prototype.getDynamicFontAtlases = function () {
            if (this._dynamicFontAtlases == null) {
                this._dynamicFontAtlases = new DynamicFontAtlases(this);
            }
            return this._dynamicFontAtlases;
        };
        return DApplicationLayer;
    }(pixi_js.Application));

    var DApplication = /** @class */ (function () {
        function DApplication(options) {
            DApplications.add(this);
            // Root
            this._root = this.toRootElement(options);
            // Resolution
            var resolution = (options && options.resolution != null ?
                options.resolution : (window.devicePixelRatio || 1));
            this._resolution = resolution;
            // Remove the accessibility plugin
            delete pixi_js.Renderer.__plugins.accessibility;
            // Options
            this._options = options;
            // Base layer
            var base = this._base = this.newLayerBase(options);
            // Overlay layer
            this._isOverlayEnabled = !!(options && options.overlay);
            if (!this._isOverlayEnabled) {
                this._overlay = base;
            }
        }
        Object.defineProperty(DApplication.prototype, "stage", {
            get: function () {
                return this._base.stage;
            },
            enumerable: true,
            configurable: true
        });
        DApplication.prototype.getRootElement = function () {
            return this._root;
        };
        DApplication.prototype.getResolution = function () {
            return this._resolution;
        };
        DApplication.prototype.toRootElement = function (options) {
            var root = options && options.root;
            if (root != null) {
                if (isString(root)) {
                    var found = document.querySelector(root);
                    if (found) {
                        return found;
                    }
                }
                else {
                    return root;
                }
            }
            return document.body;
        };
        DApplication.prototype.toLayerBaseOptions = function (options) {
            var root = this._root;
            var resolution = this._resolution;
            if (options) {
                return new DApplicationLayerOptions({
                    root: root,
                    padding: options.padding,
                    width: options.width,
                    height: options.height,
                    background: options.background,
                    resolution: resolution,
                    antialias: options.antialias,
                    overlay: false
                });
            }
            return new DApplicationLayerOptions({
                root: root,
                resolution: resolution,
                overlay: false
            });
        };
        DApplication.prototype.newLayerBase = function (options) {
            return new DApplicationLayer(this, this.toLayerBaseOptions(options));
        };
        DApplication.prototype.getLayerBase = function () {
            return this._base;
        };
        DApplication.prototype.toLayerOverlayOptions = function (options) {
            var root = this._root;
            var resolution = this._resolution;
            if (options) {
                return new DApplicationLayerOptions({
                    root: root,
                    padding: options.padding,
                    width: options.width,
                    height: options.height,
                    background: {
                        color: null
                    },
                    resolution: resolution,
                    antialias: options.antialias,
                    overlay: true
                });
            }
            return new DApplicationLayerOptions({
                root: root,
                resolution: resolution,
                overlay: true
            });
        };
        DApplication.prototype.newLayerOverlay = function (options) {
            return new DApplicationLayer(this, this.toLayerOverlayOptions(options));
        };
        DApplication.prototype.getLayerOverlay = function () {
            if (this._isOverlayEnabled) {
                if (this._overlay == null) {
                    this._overlay = this.newLayerOverlay(this._options);
                }
                return this._overlay;
            }
            else {
                return this._base;
            }
        };
        DApplication.prototype.update = function () {
            if (this._isOverlayEnabled) {
                var base = this._base;
                base.update();
                var overlay = this._overlay;
                if (overlay) {
                    overlay.update();
                }
            }
            else {
                return this._base.update();
            }
        };
        DApplication.prototype.render = function () {
            if (this._isOverlayEnabled) {
                var base = this._base;
                base.render();
                var overlay = this._overlay;
                if (overlay) {
                    overlay.render();
                }
            }
            else {
                return this._base.render();
            }
        };
        return DApplication;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBoard = /** @class */ (function (_super) {
        __extends(DBoard, _super);
        function DBoard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DBoard.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
        };
        DBoard.prototype.getType = function () {
            return "DBoard";
        };
        return DBoard;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Option parser
    var isToggle = function (theme, options) {
        if (options != null && options.toggle != null) {
            return options.toggle;
        }
        return theme.isToggle();
    };
    var DButtonBase = /** @class */ (function (_super) {
        __extends(DButtonBase, _super);
        function DButtonBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonBase.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.buttonMode = true;
            this._isToggle = isToggle(this.theme, options);
            // Event handlers
            this.initOnClick(options);
            if (!this._isToggle) {
                this.initOnPress(options);
            }
            // Group
            var group = options && options.group;
            if (group) {
                group.add(this);
            }
        };
        DButtonBase.prototype.onShortcut = function (e) {
            _super.prototype.onShortcut.call(this, e);
            this.onClick(e);
        };
        DButtonBase.prototype.isToggle = function () {
            return this._isToggle;
        };
        DButtonBase.prototype.initOnClick = function (options) {
            var _this = this;
            UtilPointerEvent.onClick(this, function (e) {
                _this.onClick(e);
            });
        };
        DButtonBase.prototype.initOnPress = function (options) {
            var _this = this;
            var interactionManager = null;
            var onUp = function () {
                _this.setPressed(false);
                if (interactionManager != null) {
                    interactionManager.off(UtilPointerEvent.up, onUp);
                    interactionManager = null;
                }
            };
            this.on(UtilPointerEvent.down, function () {
                _this.setPressed(true);
                var layer = DApplications.getLayer(_this);
                if (layer) {
                    interactionManager = layer.renderer.plugins.interaction;
                    interactionManager.on(UtilPointerEvent.up, onUp);
                }
            });
        };
        DButtonBase.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            this.buttonMode = DBaseStates.isActionable(newState);
        };
        DButtonBase.prototype.getType = function () {
            return "DButton";
        };
        DButtonBase.prototype.onClick = function (e) {
            if (this.isActionable()) {
                if (this.isToggle()) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
                else {
                    this.onActivate(e);
                }
            }
        };
        DButtonBase.prototype.onActivate = function (e) {
            this.emit("active", this);
        };
        DButtonBase.prototype.toggle = function () {
            if (this.isActionable()) {
                if (this.isToggle()) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
            }
        };
        DButtonBase.prototype.onToggleStart = function () {
            this.setActive(!this.isActive());
        };
        DButtonBase.prototype.onToggleEnd = function () {
            this.emit(this.isActive() ? "active" : "inactive", this);
        };
        DButtonBase.prototype.onActivateKeyDown = function (e) {
            if (this.isActionable()) {
                if (this.isToggle()) {
                    this.onToggleStart();
                }
                else {
                    this.setPressed(true);
                }
            }
        };
        DButtonBase.prototype.onActivateKeyUp = function (e) {
            if (this.isActionable()) {
                if (this.isToggle()) {
                    this.onToggleEnd();
                }
                else {
                    if (this.isPressed()) {
                        this.onActivate(e);
                    }
                    this.setPressed(false);
                }
            }
        };
        DButtonBase.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DButtonBase.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DButtonBase.prototype.destroy = function () {
            // Group
            var options = this._options;
            if (options != null && options.group != null) {
                options.group.remove(this);
            }
            _super.prototype.destroy.call(this);
        };
        return DButtonBase;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButton = /** @class */ (function (_super) {
        __extends(DButton, _super);
        function DButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButton.prototype.getType = function () {
            return "DButton";
        };
        return DButton;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonAmbient = /** @class */ (function (_super) {
        __extends(DButtonAmbient, _super);
        function DButtonAmbient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonAmbient.prototype.getType = function () {
            return "DButtonAmbient";
        };
        return DButtonAmbient;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonCheck = /** @class */ (function (_super) {
        __extends(DButtonCheck, _super);
        function DButtonCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonCheck.prototype.getType = function () {
            return "DButtonCheck";
        };
        return DButtonCheck;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonCheckRight = /** @class */ (function (_super) {
        __extends(DButtonCheckRight, _super);
        function DButtonCheckRight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonCheckRight.prototype.getType = function () {
            return "DButtonCheckRight";
        };
        return DButtonCheckRight;
    }(DButtonCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonPrimary = /** @class */ (function (_super) {
        __extends(DButtonPrimary, _super);
        function DButtonPrimary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonPrimary.prototype.getType = function () {
            return "DButtonPrimary";
        };
        return DButtonPrimary;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogCloseOn;
    (function (DDialogCloseOn) {
        DDialogCloseOn[DDialogCloseOn["NONE"] = 0] = "NONE";
        DDialogCloseOn[DDialogCloseOn["ESC"] = 1] = "ESC";
        DDialogCloseOn[DDialogCloseOn["CLICK_OUTSIDE"] = 2] = "CLICK_OUTSIDE";
    })(DDialogCloseOn || (DDialogCloseOn = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class for dialogs.
     *
     * If multiple application instances are there, better to set
     * the constructor option `parent` to an `application.stage`
     * so that the dialog picks a right application.
     *
     * By default, the dialog assumes the last created application is
     * the one it belongs to at the time when it is created.
     */
    var DDialog = /** @class */ (function (_super) {
        __extends(DDialog, _super);
        function DDialog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialog.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.visible = false;
            this.setState(DBaseState.FOCUS_ROOT, true);
            this._focusable = null;
            this._isOpened = false;
            // Animation
            var animation = this._animation = (options && options.animation ?
                options.animation : new DAnimationFadeIn());
            animation.target = this;
            animation.on("end", function (isReverse) {
                _this.onAnimationEnd(isReverse);
            });
            // Close-on
            var closeOn = this._closeOn = (options && options.closeOn != null ?
                options.closeOn : this.theme.closeOn());
            if (closeOn & DDialogCloseOn.CLICK_OUTSIDE) {
                UtilClickOutside.apply(this, function () {
                    _this.onCloseOn();
                });
            }
            this._overlay = new UtilOverlay();
        };
        DDialog.prototype.onAnimationEnd = function (isReverse) {
            if (isReverse) {
                var parent_1 = this.parent;
                if (parent_1) {
                    parent_1.removeChild(this);
                }
            }
            else {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var focusController = layer.getFocusController();
                    this._focusable = focusController.getFocused();
                    var firstFocusable = focusController.findFocusable(this, false, true, true);
                    focusController.setFocused(firstFocusable || this, true, true);
                }
            }
        };
        DDialog.prototype.open = function () {
            if (!this._isOpened) {
                var layer = this._overlay.pick(this);
                this._isOpened = true;
                layer.stage.addChild(this);
                this.onOpen();
            }
        };
        DDialog.prototype.onOpen = function () {
            this.emit("open", this);
            // Animation
            this._animation.start();
        };
        DDialog.prototype.isOpened = function () {
            return this._isOpened;
        };
        DDialog.prototype.close = function () {
            if (this._isOpened) {
                this._isOpened = false;
                this.onClose();
            }
        };
        DDialog.prototype.onClose = function () {
            // Focus
            var focusable = this._focusable;
            if (focusable != null) {
                this._focusable = null;
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.getFocusController().setFocused(focusable, true, false);
                }
            }
            // Animation
            this._animation.start(true);
            this.emit("close", this);
        };
        DDialog.prototype.getType = function () {
            return "DDialog";
        };
        DDialog.prototype.onKeyDown = function (e) {
            var closeOn = this._closeOn;
            if (closeOn & DDialogCloseOn.ESC) {
                if (UtilKeyboardEvent.isCancelKey(e)) {
                    this.onCloseOn();
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDialog.prototype.onCloseOn = function () {
            this.close();
        };
        DDialog.prototype.containsGlobalPoint = function (point) {
            return true;
        };
        return DDialog;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutHorizontal = /** @class */ (function (_super) {
        __extends(DLayoutHorizontal, _super);
        function DLayoutHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayoutHorizontal.prototype.getType = function () {
            return "DLayoutHorizontal";
        };
        return DLayoutHorizontal;
    }(DLayout));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogCommand = /** @class */ (function (_super) {
        __extends(DDialogCommand, _super);
        function DDialogCommand() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._promise = null;
            _this._resolve = null;
            _this._reject = null;
            return _this;
        }
        DDialogCommand.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            var layout = new DLayoutVertical({
                parent: this,
                x: theme.getLayoutX(),
                y: theme.getLayoutY(),
                width: theme.getLayoutWidth(),
                height: theme.getLayoutHeight()
            });
            this.onInit(layout, options);
            // Buttons
            var ok = (options && options.ok || theme.getOk());
            var cancel = (options && options.cancel || theme.getCancel());
            if (ok != null || cancel != null) {
                var buttonLayout = new DLayoutHorizontal({
                    parent: layout,
                    width: "padding", height: "auto",
                    padding: {
                        top: this.padding.getTop()
                    }
                });
                this._buttonLayout = buttonLayout;
                new DLayoutSpace({
                    parent: buttonLayout,
                    weight: 1
                });
                if (ok != null && cancel != null) {
                    this._buttonCancel = new DButtonPrimary({
                        parent: buttonLayout,
                        text: {
                            value: cancel
                        },
                        on: {
                            active: function () {
                                _this.onCancel();
                            }
                        }
                    });
                    this._buttonOk = new DButton({
                        parent: buttonLayout,
                        text: {
                            value: ok
                        },
                        on: {
                            active: function () {
                                _this.onOk();
                            }
                        }
                    });
                }
                else if (ok != null) {
                    this._buttonOk = new DButtonPrimary({
                        parent: buttonLayout,
                        text: {
                            value: ok
                        },
                        on: {
                            active: function () {
                                _this.onOk();
                            }
                        }
                    });
                }
                else if (cancel != null) {
                    this._buttonCancel = new DButtonPrimary({
                        parent: buttonLayout,
                        text: {
                            value: cancel
                        },
                        on: {
                            active: function () {
                                _this.onCancel();
                            }
                        }
                    });
                }
                new DLayoutSpace({
                    parent: buttonLayout,
                    weight: 1
                });
            }
        };
        DDialogCommand.prototype.onInit = function (layout, options) {
            // OVERRIDE THIS
        };
        DDialogCommand.prototype.open = function () {
            _super.prototype.open.call(this);
            return this._promise;
        };
        DDialogCommand.prototype.onOpen = function () {
            var _this = this;
            _super.prototype.onOpen.call(this);
            if (this._promise == null) {
                this._promise = new Promise(function (resolve, reject) {
                    _this._resolve = resolve;
                    _this._reject = reject;
                });
            }
        };
        DDialogCommand.prototype.onClose = function () {
            _super.prototype.onClose.call(this);
            var reject = this._reject;
            this._promise = null;
            this._resolve = null;
            this._reject = null;
            if (reject != null) {
                reject();
            }
        };
        DDialogCommand.prototype.onOk = function () {
            var resolve = this._resolve;
            this._promise = null;
            this._resolve = null;
            this._reject = null;
            this.close();
            if (resolve != null) {
                resolve();
            }
            this.emit("ok", this);
        };
        DDialogCommand.prototype.onCancel = function () {
            var reject = this._reject;
            this._promise = null;
            this._resolve = null;
            this._reject = null;
            this.close();
            if (reject != null) {
                reject();
            }
            this.emit("cancel", this);
        };
        DDialogCommand.prototype.getType = function () {
            return "DDialogCommand";
        };
        return DDialogCommand;
    }(DDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DHtmlElementWhen;
    (function (DHtmlElementWhen) {
        DHtmlElementWhen[DHtmlElementWhen["FOCUSED"] = 0] = "FOCUSED";
        DHtmlElementWhen[DHtmlElementWhen["ALWAYS"] = 1] = "ALWAYS";
    })(DHtmlElementWhen || (DHtmlElementWhen = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DHtmlElement = /** @class */ (function (_super) {
        __extends(DHtmlElement, _super);
        function DHtmlElement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DHtmlElement.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._workPoint = null;
            var theme = this.theme;
            var clipper = options && options.clipper;
            var clipperCreator = (clipper && clipper.creator) || theme.getClipperCreator();
            this._clipper = null;
            this._clipperCreator = clipperCreator;
            this._clipperRect = null;
            var element = options && options.element;
            var elementCreator = (element && element.creator) || theme.getElementCreator();
            this._element = null;
            this._elementCreator = elementCreator;
            this._elementStyle = element && element.style;
            this._elementRect = null;
            this._isElementShown = false;
            this._onElementFocusedBound = function (e) {
                _this.onElementFocused(e);
            };
            var before = options && options.before;
            this._before = null;
            this._beforeCreator = (before && before.creator) || theme.getBeforeCreator();
            this._beforeStyle = before && before.style;
            this._onBeforeFocusedBound = function (e) {
                _this.onBeforeFocused(e);
            };
            var after = options && options.after;
            this._after = null;
            this._afterCreator = (after && after.creator) || theme.getAfterCreator();
            this._afterStyle = after && after.style;
            this._onAfterFocusedBound = function (e) {
                _this.onAfterFocused(e);
            };
            this._isStarted = false;
            this._select = (options && options.select != null ?
                options.select : theme.getSelect());
            this._doSelectBound = function () {
                _this.doSelect();
            };
            var when = (options && options.when != null ?
                (isString(options.when) ? DHtmlElementWhen[options.when] : options.when) :
                theme.getWhen());
            this._when = when;
            this._isStartRequested = (when === DHtmlElementWhen.ALWAYS);
        };
        Object.defineProperty(DHtmlElement.prototype, "element", {
            get: function () {
                return this._element;
            },
            enumerable: true,
            configurable: true
        });
        DHtmlElement.prototype.onDownThis = function (e) {
            var wasStarted = this._isStarted;
            _super.prototype.onDownThis.call(this, e);
            if (!wasStarted && this._isStarted) {
                e.data.originalEvent.preventDefault();
            }
        };
        DHtmlElement.prototype.onFocused = function () {
            _super.prototype.onFocused.call(this);
            if (this._when === DHtmlElementWhen.FOCUSED) {
                this.start();
            }
            else {
                var element = this._element;
                if (element) {
                    element.focus();
                }
            }
        };
        DHtmlElement.prototype.onBlured = function () {
            _super.prototype.onBlured.call(this);
            if (this._when === DHtmlElementWhen.FOCUSED) {
                this.onEndByBlured();
                this.cancel();
            }
            else {
                var element = this._element;
                if (element) {
                    element.blur();
                }
            }
        };
        DHtmlElement.prototype.isStartable = function () {
            if (this._when === DHtmlElementWhen.FOCUSED) {
                return this.isActionable();
            }
            return true;
        };
        DHtmlElement.prototype.start = function () {
            if (!this._isStarted && this.isStartable()) {
                this._isStarted = true;
                this.doStart();
                DApplications.update(this);
            }
        };
        DHtmlElement.prototype.render = function (renderer) {
            if (this._isStartRequested) {
                this._isStartRequested = false;
                this.doStart();
            }
            if (this._isStarted) {
                this._isStarted = false;
            }
            _super.prototype.render.call(this, renderer);
            if (this._isElementShown) {
                this.updateElement(renderer);
            }
        };
        DHtmlElement.prototype.doStart = function (renderer) {
            if (!this._isElementShown) {
                this._isElementShown = true;
                this.onStart();
                var clipper = this.getClipper();
                if (clipper) {
                    var before = this.getBefore(clipper);
                    var element = this.getElement(clipper);
                    var after = this.getAfter(clipper);
                    if (element) {
                        var resolution = 1;
                        if (renderer == null) {
                            var layer = DApplications.getLayer(this);
                            if (layer) {
                                resolution = layer.renderer.resolution;
                            }
                        }
                        else {
                            resolution = renderer.resolution;
                        }
                        var elementRect = this.getElementRect(resolution);
                        var clipperRect = this.getClipperRect(elementRect, resolution);
                        var theme = this.theme;
                        var state = this.state;
                        var padding = this._padding;
                        this.setClipperStyle(clipper, state, theme, padding, elementRect, clipperRect);
                        this.setElementStyle(element, state, theme, padding, elementRect, clipperRect);
                        if (before) {
                            this.setBeforeStyle(before, theme);
                        }
                        if (after) {
                            this.setAfterStyle(after, theme);
                        }
                        this.onElementAttached(element, before, after);
                        // Show HTML elements
                        clipper.style.display = "";
                        if (this.isFocused()) {
                            element.focus();
                        }
                        clipper.scrollTop = 0;
                        clipper.scrollLeft = 0;
                        // Select the element if required.
                        if (this._select) {
                            setTimeout(this._doSelectBound, 0);
                        }
                    }
                }
            }
        };
        DHtmlElement.prototype.doSelect = function () {
            var element = this._element;
            if (element) {
                if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
                    // The following does not work on mobile devices.
                    // I think selecting texts on a tap is annoying.
                    // Though I leave this untouched.
                    element.select();
                }
            }
        };
        DHtmlElement.prototype.createText = function (formatted) {
            var result = _super.prototype.createText.call(this, formatted);
            if (this._isElementShown) {
                this.onStart();
            }
            return result;
        };
        /**
         * Please note that this method does not update transforms.
         *
         * @param elementRect
         * @param resolution
         */
        DHtmlElement.prototype.getClipperRect = function (elementRect, resolution) {
            var point = this._workPoint = (this._workPoint || new pixi_js.Point(0, 0));
            var rect = this._clipperRect = (this._clipperRect || new pixi_js.Rectangle());
            var x0 = elementRect.x;
            var y0 = elementRect.y;
            var x1 = x0 + elementRect.width;
            var y1 = y0 + elementRect.height;
            var current = this.parent;
            while (current instanceof DBase) {
                current.getClippingRect(this, rect);
                point.set(rect.x, rect.y);
                current.toGlobal(point, point, false);
                var x = ((point.x * resolution) | 0) / resolution;
                var y = ((point.y * resolution) | 0) / resolution;
                point.set(rect.x + rect.width, rect.y + rect.height);
                current.toGlobal(point, point, true);
                var w = point.x - x;
                var h = point.y - y;
                x0 = Math.min(Math.max(x0, x), x + w);
                y0 = Math.min(Math.max(y0, y), y + h);
                x1 = Math.min(Math.max(x1, x), x + w);
                y1 = Math.min(Math.max(y1, y), y + h);
                current = current.parent;
            }
            rect.x = x0;
            rect.y = y0;
            rect.width = x1 - x0;
            rect.height = y1 - y0;
            return rect;
        };
        /**
         * Please note that this method does not update transforms.
         *
         * @param resolution
         */
        DHtmlElement.prototype.getElementRect = function (resolution) {
            var point = this._workPoint = (this._workPoint || new pixi_js.Point(0, 0));
            var rect = this._elementRect = (this._elementRect != null ? this._elementRect : new pixi_js.Rectangle());
            point.set(0, 0);
            this.toGlobal(point, point, false);
            rect.x = point.x;
            rect.y = point.y;
            point.set(this.width, this.height);
            this.toGlobal(point, point, true);
            rect.width = point.x - rect.x;
            rect.height = point.y - rect.y;
            // Rounds pixels as Pixi.js does
            rect.x = ((rect.x * resolution) | 0) / resolution;
            rect.y = ((rect.y * resolution) | 0) / resolution;
            return rect;
        };
        DHtmlElement.prototype.cancel = function () {
            if (this._isElementShown) {
                this._isElementShown = false;
                this.onCancel();
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var view = layer.view;
                    if (this._when === DHtmlElementWhen.FOCUSED && document.activeElement === this._element) {
                        view.focus();
                    }
                    var interactionManager = layer.renderer.plugins.interaction;
                    if (this.containsPoint(interactionManager.mouse.global) && !this.isHovered()) {
                        this.setHovered(true);
                        view.style.cursor = this.cursor;
                    }
                    layer.update();
                }
                var element = this._element;
                if (element != null) {
                    this.onElementDetached(element, this._before, this._after);
                }
                var clipper = this._clipper;
                if (clipper != null) {
                    clipper.style.display = "none";
                }
            }
        };
        DHtmlElement.prototype.onStart = function () {
            // DO NOTHING
        };
        DHtmlElement.prototype.onCancel = function () {
            // DO NOTHING
        };
        DHtmlElement.prototype.onElementAttached = function (element, before, after) {
            if (before) {
                before.addEventListener("focus", this._onBeforeFocusedBound);
            }
            if (after) {
                after.addEventListener("focus", this._onAfterFocusedBound);
            }
            element.addEventListener("focus", this._onElementFocusedBound, true);
        };
        DHtmlElement.prototype.onElementDetached = function (element, before, after) {
            if (before) {
                before.removeEventListener("focus", this._onBeforeFocusedBound);
            }
            if (after) {
                after.removeEventListener("focus", this._onAfterFocusedBound);
            }
            element.removeEventListener("focus", this._onElementFocusedBound, true);
        };
        DHtmlElement.prototype.getElement = function (clipper) {
            var result = this._element;
            if (result == null) {
                var creator = this._elementCreator;
                if (creator) {
                    result = creator(clipper);
                    this._element = result;
                }
            }
            return result;
        };
        DHtmlElement.prototype.getClipper = function () {
            var result = this._clipper;
            if (result == null) {
                var creator = this._clipperCreator;
                var layer = DApplications.getLayer(this);
                if (creator && layer) {
                    result = creator(layer.getElementContainer());
                    this._clipper = result;
                }
            }
            return result;
        };
        DHtmlElement.prototype.getBefore = function (clipper) {
            var result = this._before;
            if (result == null) {
                var creator = this._beforeCreator;
                if (creator) {
                    result = creator(clipper);
                    this._before = result;
                }
            }
            return result;
        };
        DHtmlElement.prototype.getAfter = function (clipper) {
            var result = this._after;
            if (result == null) {
                var creator = this._afterCreator;
                if (creator) {
                    result = creator(clipper);
                    this._after = result;
                }
            }
            return result;
        };
        DHtmlElement.prototype.setElementStyle = function (target, state, theme, padding, elementRect, clipperRect) {
            var style = this._elementStyle;
            if (style) {
                return style(target, state, theme, padding, elementRect, clipperRect);
            }
            else {
                return this.theme.setElementStyle(target, state, padding, elementRect, clipperRect);
            }
        };
        DHtmlElement.prototype.setClipperStyle = function (target, state, theme, padding, elementRect, clipperRect) {
            var style = this._clipperStyle;
            if (style) {
                return style(target, state, theme, padding, elementRect, clipperRect);
            }
            else {
                return this.theme.setClipperStyle(target, state, padding, elementRect, clipperRect);
            }
        };
        DHtmlElement.prototype.setBeforeStyle = function (target, theme) {
            var style = this._beforeStyle;
            if (style) {
                return style(target, theme);
            }
            else {
                return this.theme.setBeforeStyle(target);
            }
        };
        DHtmlElement.prototype.setAfterStyle = function (target, theme) {
            var style = this._afterStyle;
            if (style) {
                return style(target, theme);
            }
            else {
                return this.theme.setAfterStyle(target);
            }
        };
        DHtmlElement.prototype.onBeforeFocused = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var focusController = layer.getFocusController();
                var focusable = focusController.findFocusable(this, false, false, false);
                layer.view.focus();
                focusController.setFocused(focusable, true, true);
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        };
        DHtmlElement.prototype.onAfterFocused = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var focusController = layer.getFocusController();
                var focusable = focusController.findFocusable(this, false, false, true);
                layer.view.focus();
                focusController.setFocused(focusable, true, true);
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        };
        DHtmlElement.prototype.onElementFocused = function (e) {
            if (this._when === DHtmlElementWhen.ALWAYS) {
                if (!this.isFocused()) {
                    this.focus();
                }
            }
        };
        DHtmlElement.prototype.onEndByBlured = function () {
            this.onEnd();
        };
        DHtmlElement.prototype.onEnd = function () {
            // DO NOTHING
        };
        DHtmlElement.prototype.end = function () {
            this.onEnd();
            this.cancel();
        };
        DHtmlElement.prototype.select = function () {
            if (this._isElementShown && this._select) {
                this.doSelect();
            }
            return this;
        };
        DHtmlElement.prototype.updateElement = function (renderer) {
            if (this._isElementShown) {
                if (this.worldVisible) {
                    var element = this._element;
                    var clipper = this._clipper;
                    if (element && clipper) {
                        var resolution = renderer.resolution;
                        var elementRect = this.getElementRect(resolution);
                        var clipperRect = this.getClipperRect(elementRect, resolution);
                        var theme = this.theme;
                        var state = this.state;
                        var padding = this._padding;
                        this.setClipperStyle(clipper, state, theme, padding, elementRect, clipperRect);
                        this.setElementStyle(element, state, theme, padding, elementRect, clipperRect);
                    }
                }
                else {
                    this.cancel();
                }
            }
        };
        DHtmlElement.prototype.getType = function () {
            return "DHtmlElement";
        };
        return DHtmlElement;
    }(DImageBase));

    var DInput = /** @class */ (function (_super) {
        __extends(DInput, _super);
        function DInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInput.prototype.init = function (options) {
            var _this = this;
            this._editingValidationResult = null;
            this._editingValidator = (options && options.editing && options.editing.validator) ||
                this.theme.getEditingValidator();
            _super.prototype.init.call(this, options);
            this._description = (options && options.description) || "";
            this._editingFormatter = (options && options.editing && options.editing.formatter) ||
                (options && options.text && options.text.formatter) ||
                this.theme.getEditingFormatter();
            this._editingUnformatter = (options && options.editing && options.editing.unformatter) ||
                this.theme.getEditingUnformatter();
            this._onInputKeyDownBound = function (e) {
                _this.onInputKeyDown(e);
            };
            this._onInputChangeBound = function () {
                _this.onInputChange();
            };
            this._onInputInputBound = function (e) {
                _this.onInputInput(e);
            };
        };
        Object.defineProperty(DInput.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: true,
            configurable: true
        });
        DInput.prototype.onTextChange = function () {
            _super.prototype.onTextChange.call(this);
            this.validate();
        };
        DInput.prototype.validate = function () {
            var result = this._editingValidator(this._textValueComputed, this);
            if (this._editingValidationResult !== result) {
                this._editingValidationResult = result;
                this.setInvalid(result != null);
                if (this.isHovered()) {
                    this.applyTitle();
                }
            }
            return result;
        };
        DInput.prototype.applyTitle = function () {
            var editingValidationResult = this._editingValidationResult;
            if (isString(editingValidationResult)) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.view.title = editingValidationResult;
                }
            }
            else {
                _super.prototype.applyTitle.call(this);
            }
        };
        DInput.prototype.onStart = function () {
            _super.prototype.onStart.call(this);
            var text = this._text;
            if (text != null) {
                text.visible = false;
            }
        };
        DInput.prototype.onCancel = function () {
            _super.prototype.onCancel.call(this);
            var text = this._text;
            if (text != null) {
                text.visible = true;
            }
        };
        DInput.prototype.onEnd = function () {
            _super.prototype.onEnd.call(this);
            this.onInputChange();
        };
        DInput.prototype.onElementAttached = function (element, before, after) {
            _super.prototype.onElementAttached.call(this, element, before, after);
            element.type = this.getInputType();
            element.value = this._editingFormatter(this._textValueComputed, this);
            element.addEventListener("keydown", this._onInputKeyDownBound);
            element.addEventListener("change", this._onInputChangeBound);
            element.addEventListener("input", this._onInputInputBound);
        };
        DInput.prototype.onElementDetached = function (element, before, after) {
            _super.prototype.onElementDetached.call(this, element, before, after);
            element.removeEventListener("keydown", this._onInputKeyDownBound);
            element.removeEventListener("change", this._onInputChangeBound);
            element.removeEventListener("input", this._onInputInputBound);
        };
        DInput.prototype.onInputKeyDown = function (e) {
            if (UtilKeyboardEvent.isOkKey(e)) {
                this.end();
                this.emit("enter", this);
            }
            else if (UtilKeyboardEvent.isCancelKey(e)) {
                this.cancel();
            }
        };
        DInput.prototype.onInputChange = function () {
            if (this._isElementShown) {
                var element = this._element;
                if (element != null) {
                    var newValue = this.toValue(element.value);
                    var oldValue = this._textValueComputed;
                    if (oldValue !== newValue) {
                        this.text = newValue;
                        this.emit("change", newValue, oldValue, this);
                    }
                }
            }
        };
        DInput.prototype.onInputInput = function (e) {
            if (e.target instanceof HTMLInputElement) {
                this.emit("input", this.toValue(e.target.value), this);
            }
        };
        DInput.prototype.onDownThis = function (e) {
            if (this.isFocused()) {
                this.start();
            }
            _super.prototype.onDownThis.call(this, e);
        };
        DInput.prototype.getType = function () {
            return "DInput";
        };
        return DInput;
    }(DHtmlElement));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Option parser
    var toStep$1 = function (theme, options) {
        if (options != null) {
            return (options.step != null ? options.step : theme.getStep());
        }
        return null;
    };
    var toMin = function (theme, options) {
        if (options != null) {
            return (options.min != null ? options.min : theme.getMin());
        }
        return null;
    };
    var toMax = function (theme, options) {
        if (options != null) {
            return (options.max != null ? options.max : theme.getMax());
        }
        return null;
    };
    var DInputNumber = /** @class */ (function (_super) {
        __extends(DInputNumber, _super);
        function DInputNumber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputNumber.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            this._step = toStep$1(theme, options);
            this._min = toMin(theme, options);
            this._max = toMax(theme, options);
        };
        Object.defineProperty(DInputNumber.prototype, "step", {
            get: function () {
                return this._step;
            },
            set: function (step) {
                if (this._step !== step) {
                    this._step = step;
                    this.updateInputStep();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DInputNumber.prototype, "min", {
            get: function () {
                return this._min;
            },
            set: function (min) {
                if (this._min !== min) {
                    this._min = min;
                    this.updateInputMin();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DInputNumber.prototype, "max", {
            get: function () {
                return this._max;
            },
            set: function (max) {
                if (this._max !== max) {
                    this._max = max;
                    this.updateInputMax();
                }
            },
            enumerable: true,
            configurable: true
        });
        DInputNumber.prototype.toValue = function (valueAsString) {
            var result = this._editingUnformatter(valueAsString, this);
            if (result === result /* NaN Check */) {
                if (this._min != null && result < this._min) {
                    return this._min;
                }
                if (this._max != null && this._max < result) {
                    return this._max;
                }
                return result;
            }
            return this.value;
        };
        DInputNumber.prototype.updateInputStep = function () {
            if (this._isElementShown) {
                var element = this._element;
                if (element) {
                    this.initInputStep(element);
                }
            }
        };
        DInputNumber.prototype.updateInputMin = function () {
            if (this._isElementShown) {
                var element = this._element;
                if (element) {
                    this.initInputMin(element);
                }
            }
        };
        DInputNumber.prototype.updateInputMax = function () {
            if (this._isElementShown) {
                var element = this._element;
                if (element) {
                    this.initInputMax(element);
                }
            }
        };
        DInputNumber.prototype.initInputStep = function (input) {
            if (this._step != null) {
                input.step = String(this._step);
            }
            else {
                input.removeAttribute("step");
            }
        };
        DInputNumber.prototype.initInputMin = function (input) {
            if (this._min != null) {
                input.min = "" + this._min;
            }
            else {
                input.removeAttribute("min");
            }
        };
        DInputNumber.prototype.initInputMax = function (input) {
            if (this._max != null) {
                input.max = "" + this._max;
            }
            else {
                input.removeAttribute("max");
            }
        };
        DInputNumber.prototype.onElementAttached = function (element, before, after) {
            _super.prototype.onElementAttached.call(this, element, before, after);
            this.initInputStep(element);
            this.initInputMin(element);
            this.initInputMax(element);
        };
        DInputNumber.prototype.getInputType = function () {
            return "number";
        };
        return DInputNumber;
    }(DInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputReal = /** @class */ (function (_super) {
        __extends(DInputReal, _super);
        function DInputReal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputReal.prototype.getType = function () {
            return "DInputReal";
        };
        return DInputReal;
    }(DInputNumber));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DText = /** @class */ (function (_super) {
        __extends(DText, _super);
        function DText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DText.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.UNFOCUSABLE, true);
        };
        DText.prototype.getType = function () {
            return "DText";
        };
        return DText;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputLabel = /** @class */ (function (_super) {
        __extends(DInputLabel, _super);
        function DInputLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputLabel.prototype.getType = function () {
            return "DInputLabel";
        };
        return DInputLabel;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputAndLabel = /** @class */ (function (_super) {
        __extends(DInputAndLabel, _super);
        function DInputAndLabel(options) {
            var _this = _super.call(this, options) || this;
            _this.addChild(_this._label = new DInputLabel(options != null ? options.label : undefined));
            _this.addChild(_this._input = _this.createInput(options != null ? options.input : undefined));
            if (options != null && options.space != null) {
                _this.addChild(new DLayoutSpace(options.space));
            }
            return _this;
        }
        Object.defineProperty(DInputAndLabel.prototype, "input", {
            get: function () {
                return this._input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DInputAndLabel.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: true,
            configurable: true
        });
        DInputAndLabel.prototype.getType = function () {
            return "DInputAndLabel";
        };
        return DInputAndLabel;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputRealAndLabel = /** @class */ (function (_super) {
        __extends(DInputRealAndLabel, _super);
        function DInputRealAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputRealAndLabel.prototype.createInput = function (options) {
            return new DInputReal(options);
        };
        return DInputRealAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputText = /** @class */ (function (_super) {
        __extends(DInputText, _super);
        function DInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputText.prototype.toValue = function (valueAsString) {
            return this._editingUnformatter(valueAsString, this);
        };
        DInputText.prototype.getInputType = function () {
            return "text";
        };
        DInputText.prototype.getType = function () {
            return "DInputText";
        };
        return DInputText;
    }(DInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputTextAndLabel = /** @class */ (function (_super) {
        __extends(DInputTextAndLabel, _super);
        function DInputTextAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputTextAndLabel.prototype.createInput = function (options) {
            return new DInputText(options);
        };
        return DInputTextAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorAndAlpha = /** @class */ (function () {
        function DPickerColorAndAlpha(colorAndAlpha, onColorChange, onAlphaChange) {
            this._colorAndAlpha = colorAndAlpha;
            this._onColorChange = onColorChange;
            this._onAlphaChange = onAlphaChange;
        }
        Object.defineProperty(DPickerColorAndAlpha.prototype, "color", {
            get: function () {
                return this._colorAndAlpha.color;
            },
            set: function (color) {
                if (this._colorAndAlpha.color !== color) {
                    var callback = this._onColorChange;
                    if (callback != null) {
                        callback(color);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerColorAndAlpha.prototype, "alpha", {
            get: function () {
                return this._colorAndAlpha.alpha;
            },
            set: function (alpha) {
                if (this._colorAndAlpha.alpha !== alpha) {
                    var callback = this._onAlphaChange;
                    if (callback != null) {
                        callback(alpha);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        return DPickerColorAndAlpha;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorRecent = /** @class */ (function (_super) {
        __extends(DPickerColorRecent, _super);
        function DPickerColorRecent(recents, capacity) {
            var _this = _super.call(this) || this;
            _this._recents = recents;
            _this._capacity = capacity;
            return _this;
        }
        DPickerColorRecent.prototype.get = function (index) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                return recents[recents.length - 1 - index];
            }
            return null;
        };
        DPickerColorRecent.prototype.set = function (index, colorAndAlpha) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                var result = recents[recents.length - 1 - index];
                recents[recents.length - 1 - index] = {
                    color: colorAndAlpha.color,
                    alpha: colorAndAlpha.alpha
                };
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorRecent.prototype.contains = function (colorAndAlpha) {
            var recents = this._recents;
            for (var i = 0, imax = recents.length; i < imax; ++i) {
                var recent = recents[i];
                if (recent.color === colorAndAlpha.color && recent.alpha === colorAndAlpha.alpha) {
                    return true;
                }
            }
            return false;
        };
        DPickerColorRecent.prototype.add = function (colorAndAlpha) {
            var recents = this._recents;
            recents.push({
                color: colorAndAlpha.color,
                alpha: colorAndAlpha.alpha
            });
            if (this._capacity < recents.length) {
                recents.shift();
            }
            this.emit("change", this);
            return this;
        };
        DPickerColorRecent.prototype.pop = function () {
            var recents = this._recents;
            var result = recents.shift();
            if (result != null) {
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorRecent.prototype.size = function () {
            return this._recents.length;
        };
        return DPickerColorRecent;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColor = /** @class */ (function (_super) {
        __extends(DPickerColor, _super);
        function DPickerColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DPickerColor.prototype, "current", {
            get: function () {
                return this._currentPicker;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerColor.prototype, "new", {
            get: function () {
                return this._newPicker;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerColor.prototype, "recent", {
            get: function () {
                return this._recent;
            },
            enumerable: true,
            configurable: true
        });
        DPickerColor.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.UNFOCUSABLE, true);
            this._base = 0xff0000;
            this._new = { color: 0xffffff, alpha: 1 };
            this._newPicker = new DPickerColorAndAlpha(this._new, function (color) {
                _this.setColorNew(color);
            }, function (alpha) {
                _this.setAlphaNew(alpha);
            });
            this._current = { color: 0xffffff, alpha: 1 };
            this._currentPicker = new DPickerColorAndAlpha(this._current, function (color) {
                _this.setColorCurrent(color);
            }, function (alpha) {
                _this.setAlphaCurrent(alpha);
            });
            var theme = this.theme;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingRight = padding.getRight();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            this._pointerPoint = new pixi_js.Point();
            // Main
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var mainBaseSprite = this._mainBaseSprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
            mainBaseSprite.x = paddingLeft;
            mainBaseSprite.y = paddingTop;
            mainBaseSprite.width = mainWidth;
            mainBaseSprite.height = mainHeight;
            mainBaseSprite.interactive = true;
            this.addChild(mainBaseSprite);
            var mainSprite = this._mainSprite = new pixi_js.Sprite(theme.getMainTexture());
            mainSprite.x = paddingLeft;
            mainSprite.y = paddingTop;
            mainSprite.tint = this._base;
            mainSprite.interactive = false;
            this.addChild(mainSprite);
            // Main event handling
            this._onMainMoveBound = function (e) {
                _this.onMainMove(e);
            };
            this._onMainUpBound = function (e) {
                _this.onMainUp(e);
            };
            mainBaseSprite.on(UtilPointerEvent.down, function (e) {
                _this.onMainDown(e);
            });
            // Base color picker
            var baseSprite = this._baseSprite = new pixi_js.Sprite(theme.getBaseTexture());
            baseSprite.x = paddingLeft;
            baseSprite.y = mainBaseSprite.y + mainBaseSprite.height + theme.getBaseMargin();
            baseSprite.interactive = true;
            this.addChild(baseSprite);
            // Base event
            this._onBaseMoveBound = function (e) {
                _this.onBaseMove(e);
            };
            this._onBaseUpBound = function (e) {
                _this.onBaseUp(e);
            };
            baseSprite.on(UtilPointerEvent.down, function (e) {
                _this.onBaseDown(e);
            });
            // Alpha picker
            var alphaCheckerboardSprite = this._alphaCheckerboardSprite =
                new pixi_js.Sprite(theme.getAlphaCheckerboardTexture());
            alphaCheckerboardSprite.x = padding.getLeft();
            alphaCheckerboardSprite.y = baseSprite.y + theme.getBaseHeight() + theme.getBaseMargin();
            alphaCheckerboardSprite.interactive = false;
            this.addChild(alphaCheckerboardSprite);
            var alphaSprite = new pixi_js.Sprite(theme.getAlphaTexture());
            alphaSprite.tint = this._new.color;
            alphaSprite.interactive = true;
            alphaCheckerboardSprite.addChild(alphaSprite);
            // Alpha event
            this._onAlphaMoveBound = function (e) {
                _this.onAlphaMove(e);
            };
            this._onAlphaUpBound = function (e) {
                _this.onAlphaUp(e);
            };
            alphaSprite.on(UtilPointerEvent.down, function (e) {
                _this.onAlphaDown(e);
            });
            // Pointers
            var mainPointerSprite = this._mainPointerSprite = new pixi_js.Sprite(theme.getMainPointerTexture());
            mainPointerSprite.x = paddingLeft;
            mainPointerSprite.y = paddingTop;
            mainPointerSprite.anchor.x = 0.5;
            mainPointerSprite.anchor.y = 0.5;
            mainPointerSprite.tint = theme.getMainPointerColor();
            mainPointerSprite.alpha = theme.getMainPointerAlpha();
            mainPointerSprite.interactive = false;
            this.addChild(mainPointerSprite);
            var alphaPointerSprite = this._alphaPointerSprite = new pixi_js.Sprite(theme.getAlphaPointerTexture());
            alphaPointerSprite.x = mainWidth;
            alphaPointerSprite.y = alphaCheckerboardSprite.height * 0.5;
            alphaPointerSprite.tint = theme.getAlphaPointerColor();
            alphaPointerSprite.alpha = theme.getAlphaPointerAlpha();
            alphaPointerSprite.anchor.set(0.5, 0.5);
            alphaPointerSprite.interactive = false;
            alphaCheckerboardSprite.addChild(alphaPointerSprite);
            var basePointerSprite = this._basePointerSprite = new pixi_js.Sprite(theme.getBasePointerTexture());
            basePointerSprite.x = 0;
            basePointerSprite.y = baseSprite.height * 0.5;
            basePointerSprite.tint = theme.getBasePointerColor();
            basePointerSprite.alpha = theme.getBasePointerAlpha();
            basePointerSprite.anchor.set(0.5, 0.5);
            basePointerSprite.interactive = false;
            baseSprite.addChild(basePointerSprite);
            // Recently used
            this._recentColorSprites = [];
            var recentColorSprites = this._recentColorSprites;
            var recentColorCount = theme.getRecentColorCount();
            var recentColorWidth = theme.getRecentColorWidth();
            var recentColorHeight = theme.getRecentColorHeight();
            var recentColorWidthHalf = recentColorWidth * 0.5;
            var recentColorHeightHalf = recentColorHeight * 0.5;
            var recentColorMargin = theme.getRecentColorMargin();
            var recentColorY = alphaCheckerboardSprite.y + theme.getAlphaHeight() + theme.getRecentMargin();
            var recentCheckerboardTexture = theme.getRecentCheckerboardTexture();
            if (DPickerColor.RECENT_COLORS == null) {
                DPickerColor.RECENT_COLORS = new DPickerColorRecent(theme.getRecents().slice(0), recentColorCount);
            }
            var recent = this._recent = DPickerColor.RECENT_COLORS;
            recent.on("change", function () {
                _this.onRecentChange();
            });
            var onRecentClick = function (e) {
                var checkerboardSprite = e.currentTarget;
                if (checkerboardSprite instanceof pixi_js.Container) {
                    var sprite = checkerboardSprite.children[0];
                    if (sprite instanceof pixi_js.Sprite) {
                        _this.setColorNew(sprite.tint);
                        _this.setAlphaNew(sprite.alpha);
                    }
                }
            };
            for (var i = 0; i < recentColorCount; ++i) {
                var x = paddingLeft + i * (recentColorWidth + recentColorMargin);
                var checkerboardSprite = new pixi_js.Sprite(recentCheckerboardTexture);
                checkerboardSprite.x = x + recentColorWidthHalf;
                checkerboardSprite.y = recentColorY + recentColorHeightHalf;
                checkerboardSprite.anchor.x = 0.5;
                checkerboardSprite.anchor.y = 0.5;
                checkerboardSprite.buttonMode = true;
                checkerboardSprite.interactive = true;
                UtilPointerEvent.onClick(checkerboardSprite, onRecentClick);
                this.addChild(checkerboardSprite);
                var sprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
                var recentColorAndAlpha = recent.get(i);
                if (recentColorAndAlpha != null) {
                    sprite.tint = recentColorAndAlpha.color;
                    sprite.alpha = recentColorAndAlpha.alpha;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0;
                }
                sprite.width = recentColorWidth;
                sprite.height = recentColorHeight;
                sprite.anchor.x = 0.5;
                sprite.anchor.y = 0.5;
                sprite.interactive = false;
                checkerboardSprite.addChild(sprite);
                recentColorSprites.push(sprite);
            }
            // Input color
            var inputMargin = theme.getInputMargin();
            var inputY = recentColorY + recentColorHeight + inputMargin;
            var inputWidth = mainWidth * 0.5;
            var inputAndLabelColor = this._inputAndLabelColor = new DInputTextAndLabel({
                parent: this,
                x: paddingLeft,
                y: inputY,
                width: inputWidth,
                label: {
                    width: theme.getInputLabelWidth(),
                    text: {
                        value: "#"
                    }
                },
                input: {
                    weight: 1,
                    text: {
                        value: "FFFFFF"
                    },
                    on: {
                        input: function (code) {
                            var color = UtilRgb.fromCode(code);
                            if (color != null) {
                                _this.setColorNew(color);
                            }
                        }
                    }
                }
            });
            var inputAndLabelAlpha = this._inputAndLabelAlpha = new DInputRealAndLabel({
                parent: this,
                x: paddingLeft,
                y: inputY + inputAndLabelColor.height + inputMargin,
                width: inputWidth,
                label: {
                    width: theme.getInputLabelWidth(),
                    text: {
                        value: "A"
                    }
                },
                input: {
                    weight: 1,
                    text: {
                        value: 1
                    },
                    min: 0,
                    max: 1,
                    on: {
                        input: function (value) {
                            _this.setAlphaNew(value);
                        }
                    }
                }
            });
            // Samples
            var sampleWidth = theme.getSampleWidth();
            var sampleHeight = theme.getSampleHeight();
            var sampleX = paddingLeft + mainWidth * 0.75 - sampleWidth;
            var sampleY = inputY + (inputAndLabelColor.height + inputMargin + inputAndLabelAlpha.height - sampleHeight) * 0.5;
            var sampleCurrentCheckerboardSprite = this._sampleCurrentCheckerboardSprite =
                new pixi_js.Sprite(theme.getSampleCheckerboardTexture());
            sampleCurrentCheckerboardSprite.x = sampleX;
            sampleCurrentCheckerboardSprite.y = sampleY;
            sampleCurrentCheckerboardSprite.width = sampleWidth;
            sampleCurrentCheckerboardSprite.height = sampleHeight;
            sampleCurrentCheckerboardSprite.interactive = false;
            this.addChild(sampleCurrentCheckerboardSprite);
            var current = this._current;
            var sampleCurrentSprite = this._sampleCurrentSprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
            sampleCurrentSprite.x = sampleX;
            sampleCurrentSprite.y = sampleY;
            sampleCurrentSprite.tint = current.color;
            sampleCurrentSprite.alpha = current.alpha;
            sampleCurrentSprite.width = sampleWidth;
            sampleCurrentSprite.height = sampleHeight;
            sampleCurrentSprite.interactive = true;
            sampleCurrentSprite.buttonMode = true;
            UtilPointerEvent.onClick(sampleCurrentSprite, function () {
                _this.setColorNew(current.color);
                _this.setAlphaNew(current.alpha);
            });
            this.addChild(sampleCurrentSprite);
            var sampleNewCheckerboardSprite = this._sampleNewCheckerboardSprite =
                new pixi_js.Sprite(theme.getSampleCheckerboardTexture());
            sampleNewCheckerboardSprite.x = sampleX + sampleWidth;
            sampleNewCheckerboardSprite.y = sampleY;
            sampleNewCheckerboardSprite.width = sampleWidth;
            sampleNewCheckerboardSprite.height = sampleHeight;
            sampleNewCheckerboardSprite.interactive = false;
            this.addChild(sampleNewCheckerboardSprite);
            var sampleNewSprite = this._sampleNewSprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
            sampleNewSprite.x = sampleX + sampleWidth;
            sampleNewSprite.y = sampleY;
            sampleNewSprite.tint = this._new.color;
            sampleNewSprite.alpha = this._new.alpha;
            sampleNewSprite.width = sampleWidth;
            sampleNewSprite.height = sampleHeight;
            sampleNewSprite.interactive = false;
            this.addChild(sampleNewSprite);
            // Width
            if (options == null || options.width == null) {
                this.width = paddingLeft + mainWidth + paddingRight;
            }
            // Height
            if (options == null || options.height == null) {
                this.height = inputY + inputAndLabelColor.height + inputMargin + inputAndLabelAlpha.height + paddingBottom;
            }
        };
        DPickerColor.prototype.onMainDown = function (e) {
            this.onMainPick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onMainMoveBound);
                stage.on(UtilPointerEvent.up, this._onMainUpBound);
            }
        };
        DPickerColor.prototype.onMainMove = function (e) {
            this.onMainPick(e.data.global);
        };
        DPickerColor.prototype.onMainUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onMainMoveBound);
                stage.off(UtilPointerEvent.up, this._onMainUpBound);
            }
        };
        DPickerColor.prototype.toMainHex = function (b, w0, w1, shift) {
            return Math.max(0, Math.min(255, w0 * 255 + w1 * ((b >> shift) & 0xff))) << shift;
        };
        DPickerColor.prototype.toMainColor = function (base, tx, ty, width, height) {
            var hw = width * 0.5;
            var ux = Math.max(0, Math.min(1, ((tx - hw) * (1 - ty / height) + hw) / width));
            var uy = Math.max(0, Math.min(1, ty / height));
            var w1 = Math.abs(0.5 * uy - ux);
            var w0 = 1 - w1 - uy;
            var r = this.toMainHex(base, w0, w1, 16);
            var g = this.toMainHex(base, w0, w1, 8);
            var b = this.toMainHex(base, w0, w1, 0);
            return r | g | b;
        };
        DPickerColor.prototype.onMainPick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var paddingLeft = padding.getLeft();
            var paddingTop = padding.getTop();
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - paddingLeft));
            var y = Math.max(0, Math.min(mainHeight, point.y - paddingTop));
            var mainPointerSprite = this._mainPointerSprite;
            mainPointerSprite.position.set(paddingLeft + x, paddingTop + y);
            this.onColorNew(this.toMainColor(this._base, x, y, mainWidth, mainHeight));
        };
        DPickerColor.prototype.setColorCurrent = function (color) {
            this._sampleCurrentSprite.tint = this._current.color = color;
        };
        DPickerColor.prototype.setAlphaCurrent = function (alpha) {
            this._sampleCurrentSprite.alpha = this._current.alpha = alpha;
        };
        DPickerColor.prototype.setColorNew = function (color) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var padding = this._padding;
            // Base color
            var hsv = UtilHsv.fromRgb(color);
            this._mainSprite.tint = this._base = UtilHsv.toRgb(hsv[0], 255, 255);
            // Move the base pointer
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = Math.max(0, Math.min(1, hsv[0] / 360)) * mainWidth;
            // Move the main pointer
            var ns = Math.max(0, Math.min(1, hsv[1] / 255));
            var nv = Math.max(0, Math.min(1, 1 - hsv[2] / 255));
            var mainPointerSprite = this._mainPointerSprite;
            mainPointerSprite.tint = (nv < 0.45 ? theme.getMainPointerColor() : 0xffffff);
            mainPointerSprite.position.set(padding.getLeft() + ns * mainWidth, padding.getTop() + nv * mainHeight);
            // New color
            this.onColorNew(color);
        };
        DPickerColor.prototype.onColorNew = function (color) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.disallowUpdate();
            }
            this._sampleNewSprite.tint = this._new.color = color;
            this._inputAndLabelColor.input.value = UtilRgb.toCode(color);
            this.emit("newcolorchange", color, this);
            if (layer) {
                layer.allowUpdate();
                layer.update();
            }
        };
        DPickerColor.prototype.onBaseDown = function (e) {
            this.onBasePick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onBaseMoveBound);
                stage.on(UtilPointerEvent.up, this._onBaseUpBound);
            }
        };
        DPickerColor.prototype.onBaseMove = function (e) {
            this.onBasePick(e.data.global);
        };
        DPickerColor.prototype.onBaseUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onBaseMoveBound);
                stage.off(UtilPointerEvent.up, this._onBaseUpBound);
            }
        };
        DPickerColor.prototype.toBaseHex = function (t, shift) {
            return Math.max(0, Math.min(255, t * 6 * 255)) << shift;
        };
        DPickerColor.prototype.toBaseColor = function (t) {
            if (t <= 0.167) {
                return 0xff0000 + this.toBaseHex(t, 8);
            }
            else if (t <= 0.333) {
                t = 0.333 - t;
                return 0x00ff00 + this.toBaseHex(t, 16);
            }
            else if (t <= 0.5) {
                t -= 0.333;
                return 0x00ff00 + this.toBaseHex(t, 0);
            }
            else if (t < 0.667) {
                t = 0.667 - t;
                return 0x0000ff + this.toBaseHex(t, 8);
            }
            else if (t < 0.883) {
                t -= 0.667;
                return 0x0000ff + this.toBaseHex(t, 16);
            }
            else {
                t = 0.883 - t;
                return 0xff0000 + this.toBaseHex(t, 0);
            }
        };
        DPickerColor.prototype.onBasePick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - padding.getLeft()));
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = x;
            this.onColorBase(this.toBaseColor(x / mainWidth));
        };
        DPickerColor.prototype.setColorBase = function (h) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = Math.max(0, Math.min(1, h / 360)) * mainWidth;
            this.onColorBase(UtilHsv.toRgb(h, 255, 255));
        };
        DPickerColor.prototype.onColorBase = function (color) {
            this._mainSprite.tint = this._base = color;
            var mainPointerSprite = this._mainPointerSprite;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var padding = this._padding;
            this.onColorNew(this.toMainColor(this._base, mainPointerSprite.x - padding.getLeft(), mainPointerSprite.y - padding.getTop(), mainWidth, mainHeight));
        };
        DPickerColor.prototype.onAlphaDown = function (e) {
            this.onAlphaPick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onAlphaMoveBound);
                stage.on(UtilPointerEvent.up, this._onAlphaUpBound);
            }
        };
        DPickerColor.prototype.onAlphaMove = function (e) {
            this.onAlphaPick(e.data.global);
        };
        DPickerColor.prototype.onAlphaUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onAlphaMoveBound);
                stage.off(UtilPointerEvent.up, this._onAlphaUpBound);
            }
        };
        DPickerColor.prototype.onAlphaPick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - padding.getLeft()));
            this._alphaPointerSprite.x = x;
            this.onAlphaNew(x / mainWidth);
        };
        DPickerColor.prototype.setAlphaNew = function (alpha) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this._alphaPointerSprite.x = Math.max(0, Math.min(1, alpha)) * mainWidth;
            this.onAlphaNew(alpha);
        };
        DPickerColor.prototype.onAlphaNew = function (alpha) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.disallowUpdate();
            }
            this._sampleNewSprite.alpha = this._new.alpha = alpha;
            this._inputAndLabelAlpha.input.value = Number(alpha.toFixed(2));
            this.emit("newalphachange", alpha, this);
            if (layer) {
                layer.allowUpdate();
                layer.update();
            }
        };
        DPickerColor.prototype.onRecentChange = function () {
            var sprites = this._recentColorSprites;
            var recent = this._recent;
            for (var i = 0, imax = sprites.length; i < imax; ++i) {
                var sprite = sprites[i];
                var colorAndAlpha = recent.get(i);
                if (colorAndAlpha != null) {
                    sprite.tint = colorAndAlpha.color;
                    sprite.alpha = colorAndAlpha.alpha;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0;
                }
            }
        };
        DPickerColor.prototype.getType = function () {
            return "DPickerColor";
        };
        DPickerColor.RECENT_COLORS = null;
        return DPickerColor;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorGradientPoint = /** @class */ (function () {
        function DPickerColorGradientPoint(color, alpha, position, selected, callback) {
            this._color = color;
            this._alpha = alpha;
            this._position = position;
            this._callback = callback;
            this._selected = selected;
        }
        DPickerColorGradientPoint.prototype.set = function (color, alpha, position, selected) {
            if (this._color !== color || this._alpha !== alpha || this._position !== position || this._selected !== selected) {
                this._color = color;
                this._alpha = alpha;
                this._position = position;
                this._selected = selected;
                this._callback(this);
            }
        };
        Object.defineProperty(DPickerColorGradientPoint.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._callback(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerColorGradientPoint.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._callback(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerColorGradientPoint.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                if (this._position !== position) {
                    this._position = position;
                    this._callback(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerColorGradientPoint.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            set: function (selected) {
                if (this._selected !== selected) {
                    this._selected = selected;
                    this._callback(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        DPickerColorGradientPoint.prototype.toObject = function () {
            return {
                color: this._color,
                alpha: this._alpha,
                position: this._position
            };
        };
        return DPickerColorGradientPoint;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var POINT_SORTER = function (a, b) {
        return a.position - b.position;
    };
    var DPickerColorGradientData = /** @class */ (function (_super) {
        __extends(DPickerColorGradientData, _super);
        function DPickerColorGradientData() {
            var _this = _super.call(this) || this;
            _this._onChangeBound = function (target) {
                _this.onChange(target);
            };
            var first = new DPickerColorGradientPoint(0xffffff, 1, 0, false, _this._onChangeBound);
            var second = new DPickerColorGradientPoint(0x808080, 1, 1, true, _this._onChangeBound);
            _this._points = [first, second];
            _this._direction = -90;
            _this._selected = second;
            _this._workColor = [0, 0, 0];
            return _this;
        }
        DPickerColorGradientData.prototype.onChange = function (target) {
            var isSelectionChanged = (target.selected && this._selected !== target);
            if (isSelectionChanged) {
                var selected = this._selected;
                if (selected != null) {
                    selected._selected = false;
                }
                this._selected = target;
            }
            this._points.sort(POINT_SORTER);
            if (isSelectionChanged) {
                this.emit("selectionchange", this._selected, this);
            }
            this.emit("change", this);
        };
        Object.defineProperty(DPickerColorGradientData.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerColorGradientData.prototype, "direction", {
            get: function () {
                return this._direction;
            },
            set: function (direction) {
                if (this._direction !== direction) {
                    this._direction = direction;
                    this.emit("directionchange", direction, this);
                    this.emit("change", this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerColorGradientData.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            enumerable: true,
            configurable: true
        });
        DPickerColorGradientData.prototype.size = function () {
            return this._points.length;
        };
        DPickerColorGradientData.prototype.get = function (index) {
            var points = this._points;
            if (0 <= index && index < points.length) {
                return points[index];
            }
            return null;
        };
        DPickerColorGradientData.prototype.addAt = function (position) {
            var points = this._points;
            var previous = null;
            for (var i = 0, imax = points.length; i < imax; ++i) {
                var point = points[i];
                if (position <= point.position) {
                    if (previous != null) {
                        var span = point.position - previous.position;
                        if (0.001 < span) {
                            var rgb0 = pixi_js.utils.hex2rgb(point.color, this._workColor);
                            var r0 = rgb0[0];
                            var g0 = rgb0[1];
                            var b0 = rgb0[2];
                            var rgb1 = pixi_js.utils.hex2rgb(previous.color, this._workColor);
                            var r1 = rgb1[0];
                            var g1 = rgb1[1];
                            var b1 = rgb1[2];
                            var ratio = (position - previous.position) / span;
                            var r = r0 * ratio + r1 * (1 - ratio);
                            var g = g0 * ratio + g1 * (1 - ratio);
                            var b = b0 * ratio + b1 * (1 - ratio);
                            var rgb = this._workColor;
                            rgb[0] = r;
                            rgb[1] = g;
                            rgb[2] = b;
                            var color = pixi_js.utils.rgb2hex(rgb);
                            var alpha = point.alpha * ratio + previous.alpha * (1 - ratio);
                            return this.add(color, alpha, position, true);
                        }
                    }
                    else {
                        return this.add(point.color, point.alpha, position, true);
                    }
                }
                previous = point;
            }
            if (previous != null) {
                return this.add(previous.color, previous.alpha, position, true);
            }
            else {
                return this.add(0xffffff, 1.0, position, true);
            }
        };
        DPickerColorGradientData.prototype.add = function (color, alpha, position, selected) {
            var result = new DPickerColorGradientPoint(color, alpha, position, selected, this._onChangeBound);
            this._points.push(result);
            this._onChangeBound(result);
            return result;
        };
        DPickerColorGradientData.prototype.remove = function (point) {
            var points = this._points;
            if (2 < points.length) {
                for (var i = 0, imax = points.length; i < imax; ++i) {
                    if (points[i] === point) {
                        points.splice(i, 1);
                        var isSelectionChanged = (this._selected === point);
                        if (isSelectionChanged) {
                            if (i + 1 < imax) {
                                this._selected = points[i];
                            }
                            else {
                                this._selected = points[i - 1];
                            }
                        }
                        if (isSelectionChanged) {
                            this.emit("selectionchange", this._selected, this);
                        }
                        this.emit("change", this);
                        return true;
                    }
                }
            }
            return false;
        };
        DPickerColorGradientData.prototype.reset = function () {
            var oldDirection = this._direction;
            this._direction = -90;
            var points = this._points;
            var oldSelected = this._selected;
            var index = (oldSelected ? points.indexOf(oldSelected) : -1);
            points.length = 0;
            points.push(new DPickerColorGradientPoint(0xffffff, 0, 0, false, this._onChangeBound));
            points.push(new DPickerColorGradientPoint(0xffffff, 0, 1, false, this._onChangeBound));
            if (0 <= index && index < points.length) {
                var point = points[index];
                point._selected = true;
                this._selected = point;
            }
            else if (0 < points.length) {
                var point = points[points.length - 1];
                point._selected = true;
                this._selected = point;
            }
            else {
                this._selected = null;
            }
            if (oldSelected !== this._selected) {
                this.emit("selectionchange", this._selected, this);
            }
            if (oldDirection !== this._direction) {
                this.emit("directionchange", this._direction, this);
            }
            this.emit("change", this);
        };
        DPickerColorGradientData.prototype.toObject = function () {
            var pointsCopy = [];
            var points = this._points;
            for (var i = 0, imax = points.length; i < imax; ++i) {
                pointsCopy.push(points[i].toObject());
            }
            return {
                points: pointsCopy,
                direction: this._direction
            };
        };
        DPickerColorGradientData.prototype.fromObject = function (data) {
            var oldDirection = this._direction;
            this._direction = data.direction;
            var points = this._points;
            var oldSelected = this._selected;
            var index = (oldSelected ? points.indexOf(oldSelected) : -1);
            points.length = 0;
            for (var i = 0, imax = data.points.length; i < imax; ++i) {
                var pointLike = data.points[i];
                var point = new DPickerColorGradientPoint(pointLike.color, pointLike.alpha, pointLike.position, false, this._onChangeBound);
                points.push(point);
            }
            points.sort(POINT_SORTER);
            if (0 <= index && index < points.length) {
                var point = points[index];
                point._selected = true;
                this._selected = point;
            }
            else if (0 < points.length) {
                var point = points[points.length - 1];
                point._selected = true;
                this._selected = point;
            }
            else {
                this._selected = null;
            }
            if (oldSelected !== this._selected) {
                this.emit("selectionchange", this._selected, this);
            }
            if (oldDirection !== this._direction) {
                this.emit("directionchange", this._direction, this);
            }
            this.emit("change", this);
        };
        return DPickerColorGradientData;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER$2 = "\nattribute vec2 aPosition;\nattribute vec2 aUv;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\n\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nvoid main(void) {\n\tvec3 position = vec3(aPosition.x, aPosition.y, 1.0);\n\tgl_Position = vec4((projectionMatrix * translationMatrix * position).xy, 0.0, 1.0);\n\tvUv = aUv;\n\tvColor = aColor;\n}\n";
    var FRAGMENT_SHADER$2 = "\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void) {\n\tvec4 texture = texture2D(uSampler, vUv);\n\tfloat cy = step( 1.0, mod( gl_FragCoord.y / 10.0, 2.0 ) );\n\tfloat cx = step( 1.0, mod( gl_FragCoord.x / 10.0 + cy, 2.0 ) );\n\tfloat c = mix( 0.75, 0.65, cx );\n\tgl_FragColor = texture * vec4( mix( vec3( c ), vColor.xyz, vColor.a ), 1.0 );\n}";
    var DPickerColorGradientDataView = /** @class */ (function (_super) {
        __extends(DPickerColorGradientDataView, _super);
        function DPickerColorGradientDataView(nPointsPerData, vertices, uvs, colors, indices, parts, geometry, shader) {
            var _this = _super.call(this, geometry, shader) || this;
            _this.interactive = true;
            _this.interactiveChildren = false;
            _this.cursor = "pointer";
            _this._nPointsPerData = nPointsPerData;
            _this._vertices = vertices;
            _this._uvs = uvs;
            _this._colors = colors;
            _this._indices = indices;
            _this._lastHitIndex = -1;
            _this._workColor = [0, 0, 0];
            _this._workPoint = new pixi_js.Point();
            _this._parts = parts;
            shader.uniforms.uSampler.on("update", function () {
                _this.update();
                DApplications.update(_this);
            });
            _this.update();
            return _this;
        }
        DPickerColorGradientDataView.prototype.getRectangle = function (index) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                return parts[index].rect;
            }
            return null;
        };
        DPickerColorGradientDataView.prototype.setRectangle = function (index, x, y, width, height) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                var rect = parts[index].rect;
                rect.x = x;
                rect.y = y;
                rect.width = width;
                rect.height = height;
            }
        };
        DPickerColorGradientDataView.prototype.getData = function (index) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                return parts[index].data;
            }
            return null;
        };
        DPickerColorGradientDataView.prototype.setData = function (index, data) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                parts[index].data = data;
            }
        };
        DPickerColorGradientDataView.prototype.getLastHitIndex = function () {
            return this._lastHitIndex;
        };
        DPickerColorGradientDataView.prototype.setColors = function (ic, colors, rgb, alpha) {
            colors[ic + 0] = rgb[0];
            colors[ic + 1] = rgb[1];
            colors[ic + 2] = rgb[2];
            colors[ic + 3] = alpha;
            colors[ic + 4] = rgb[0];
            colors[ic + 5] = rgb[1];
            colors[ic + 6] = rgb[2];
            colors[ic + 7] = alpha;
        };
        DPickerColorGradientDataView.prototype.setColorsHex = function (ic, colors, color, alpha) {
            var rgb = pixi_js.utils.hex2rgb(color, this._workColor);
            this.setColors(ic, colors, rgb, alpha);
        };
        DPickerColorGradientDataView.prototype.setColorsWhite = function (ic, colors) {
            var rgb = this._workColor;
            rgb[0] = 1;
            rgb[1] = 1;
            rgb[2] = 1;
            this.setColors(ic, colors, rgb, 0);
        };
        DPickerColorGradientDataView.prototype.setColorsPoint = function (ic, data, index, colors) {
            var point = data.points[index];
            if (point != null) {
                this.setColorsHex(ic, colors, point.color, point.alpha);
            }
            else {
                this.setColorsWhite(ic, colors);
            }
        };
        DPickerColorGradientDataView.prototype.setVertices = function (iv, vertices, position, rect) {
            var y = rect.y + rect.height * position;
            vertices[iv + 0] = rect.x;
            vertices[iv + 1] = y;
            vertices[iv + 2] = rect.x + rect.width;
            vertices[iv + 3] = y;
        };
        DPickerColorGradientDataView.prototype.setUvs = function (iv, uvs, position, textureUvs) {
            var x0 = textureUvs.x0 + (textureUvs.x3 - textureUvs.x0) * position;
            var y0 = textureUvs.y0 + (textureUvs.y3 - textureUvs.y0) * position;
            var x1 = textureUvs.x1 + (textureUvs.x2 - textureUvs.x1) * position;
            var y1 = textureUvs.y1 + (textureUvs.y2 - textureUvs.y1) * position;
            uvs[iv + 0] = x0;
            uvs[iv + 1] = y0;
            uvs[iv + 2] = x1;
            uvs[iv + 3] = y1;
        };
        DPickerColorGradientDataView.prototype.newIndices = function (ii, iv, size, indices) {
            for (var i = 0; i < size; ++i) {
                indices[ii + 0] = iv + 0;
                indices[ii + 1] = iv + 1;
                indices[ii + 2] = iv + 2;
                indices[ii + 3] = iv + 2;
                indices[ii + 4] = iv + 1;
                indices[ii + 5] = iv + 3;
                ii += 6;
                iv += 2;
            }
            return indices;
        };
        DPickerColorGradientDataView.prototype._calculateBounds = function () {
            var rect = this._parts[0].rect;
            var bounds = this._bounds;
            var work = this._workPoint;
            work.set(rect.x, rect.y);
            bounds.addPoint(work);
            work.set(rect.x + rect.width, rect.y + rect.height);
            bounds.addPoint(work);
        };
        DPickerColorGradientDataView.prototype.update = function () {
            var vertices = this._vertices;
            var uvs = this._uvs;
            var colors = this._colors;
            var indices = this._indices;
            var texture = this.shader.uniforms.uSampler;
            if (texture._uvs == null) {
                texture.updateUvs();
            }
            var textureUvs = texture._uvs;
            var iv = 0;
            var nv = 0;
            var ic = 0;
            var ii = 0;
            var parts = this._parts;
            for (var i = 0, imax = parts.length; i < imax; ++i) {
                var data = parts[i].data;
                var rect = parts[i].rect;
                if (data == null) {
                    this.setVertices(iv, vertices, 0, rect);
                    this.setUvs(iv, uvs, 0, textureUvs);
                    this.setColorsWhite(ic, colors);
                    this.setVertices(iv + 4, vertices, 1, rect);
                    this.setUvs(iv, uvs, 1, textureUvs);
                    this.setColorsWhite(ic + 8, colors);
                    this.newIndices(ii, nv, 1, indices);
                    iv += 4 * 2;
                    ic += 4 * 4;
                    nv += 4;
                    ii += 6;
                }
                else {
                    this.setVertices(iv, vertices, 0, rect);
                    this.setUvs(iv, uvs, 0, textureUvs);
                    this.setColorsPoint(ic, data, 0, colors);
                    iv += 2 * 2;
                    ic += 2 * 4;
                    var pointSize = data.points.length;
                    for (var j = 0, jmax = Math.min(pointSize, this._nPointsPerData); j < jmax; ++j) {
                        var point = data.points[j];
                        this.setVertices(iv, vertices, point.position, rect);
                        this.setUvs(iv, uvs, point.position, textureUvs);
                        this.setColorsHex(ic, colors, point.color, point.alpha);
                        iv += 2 * 2;
                        ic += 2 * 4;
                    }
                    this.setVertices(iv, vertices, 1, rect);
                    this.setUvs(iv, uvs, 1, textureUvs);
                    this.setColorsPoint(ic, data, pointSize - 1, colors);
                    iv += 2 * 2;
                    ic += 2 * 4;
                    this.newIndices(ii, nv, pointSize + 1, indices);
                    ii += (pointSize + 1) * 6;
                    nv += (pointSize + 2) * 2;
                }
            }
            this.size = ii;
            var geometry = this.geometry;
            geometry.getBuffer("aPosition").update();
            geometry.getBuffer("aUv").update();
            geometry.getBuffer("aColor").update();
            geometry.getIndex().update();
        };
        DPickerColorGradientDataView.prototype.containsPoint = function (point) {
            var local = this.toLocal(point, undefined, this._workPoint);
            var parts = this._parts;
            for (var i = 0, imax = parts.length; i < imax; ++i) {
                var rect = parts[i].rect;
                if (rect.contains(local.x, local.y)) {
                    this._lastHitIndex = i;
                    return true;
                }
            }
            return false;
        };
        DPickerColorGradientDataView.from = function (size, nPointsPerData, texture) {
            if (texture === void 0) { texture = pixi_js.Texture.WHITE; }
            var vertices = new Float32Array(size * (nPointsPerData + 2) * 2 * 2);
            var uvs = new Float32Array(size * (nPointsPerData + 2) * 2 * 2);
            var colors = new Float32Array(size * (nPointsPerData + 2) * 2 * 4);
            var indices = new Uint16Array(size * (nPointsPerData + 1) * 6);
            var parts = [];
            for (var i = 0; i < size; ++i) {
                parts.push({
                    data: null,
                    rect: new pixi_js.Rectangle()
                });
            }
            var geometry = new pixi_js.Geometry()
                .addIndex(new pixi_js.Buffer(indices, false, true))
                .addAttribute("aPosition", new pixi_js.Buffer(vertices, false, false), 2)
                .addAttribute("aUv", new pixi_js.Buffer(uvs, false, false), 2)
                .addAttribute("aColor", new pixi_js.Buffer(colors, false, false), 4);
            var shader = pixi_js.Shader.from(VERTEX_SHADER$2, FRAGMENT_SHADER$2, { uSampler: texture });
            return new DPickerColorGradientDataView(nPointsPerData, vertices, uvs, colors, indices, parts, geometry, shader);
        };
        return DPickerColorGradientDataView;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isEqual = function (a, b) {
        if (a.direction !== b.direction) {
            return false;
        }
        var ap = a.points;
        var bp = b.points;
        if (ap.length !== bp.length) {
            return false;
        }
        for (var j = 0, jmax = ap.length; j < jmax; ++j) {
            var apj = ap[j];
            var bpj = bp[j];
            if (apj.color !== bpj.color || apj.alpha !== bpj.alpha || apj.position !== bpj.position) {
                return false;
            }
        }
        return true;
    };
    var DPickerColorGradientRecent = /** @class */ (function (_super) {
        __extends(DPickerColorGradientRecent, _super);
        function DPickerColorGradientRecent(recents, capacity) {
            var _this = _super.call(this) || this;
            _this._recents = recents;
            _this._capacity = capacity;
            return _this;
        }
        DPickerColorGradientRecent.prototype.getCapacity = function () {
            return this._capacity;
        };
        DPickerColorGradientRecent.prototype.get = function (index) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                return recents[recents.length - 1 - index];
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.set = function (index, points) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                var result = recents[recents.length - 1 - index];
                recents[recents.length - 1 - index] = points;
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.contains = function (points) {
            var recents = this._recents;
            for (var i = 0, imax = recents.length; i < imax; ++i) {
                if (isEqual(recents[i], points)) {
                    return true;
                }
            }
            return false;
        };
        DPickerColorGradientRecent.prototype.add = function (points) {
            var recents = this._recents;
            recents.push(points);
            if (this._capacity < recents.length) {
                recents.shift();
            }
            this.emit("change", this);
            return this;
        };
        DPickerColorGradientRecent.prototype.pop = function () {
            var recents = this._recents;
            var result = recents.shift();
            if (result != null) {
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.size = function () {
            return this._recents.length;
        };
        return DPickerColorGradientRecent;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorGradient = /** @class */ (function (_super) {
        __extends(DPickerColorGradient, _super);
        function DPickerColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerColorGradient.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.UNFOCUSABLE, true);
            var theme = this.theme;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingRight = padding.getRight();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            this._work = new pixi_js.Point();
            // Picker
            var gradientPointsWidth = theme.getGradientPointsWidth();
            var gradientPointsMargin = theme.getGradientPointsMargin();
            var picker = this._picker = new DPickerColor({
                x: paddingLeft + gradientPointsWidth + gradientPointsMargin,
                y: paddingTop
            });
            picker.on("newcolorchange", function (color) {
                _this.onAnchorColorChange(color);
            });
            picker.on("newalphachange", function (alpha) {
                _this.onAnchorAlphaChange(alpha);
            });
            this.addChild(picker);
            // Points view
            var view = this._view = DPickerColorGradientDataView.from(17, 10);
            view.setRectangle(0, paddingLeft, paddingTop, gradientPointsWidth, picker.height);
            this.addChild(view);
            view.on(UtilPointerEvent.down, function (e) {
                if (view.getLastHitIndex() === 0) {
                    _this.onViewDown(e);
                }
            });
            // Anchor
            this._onAnchorDownBound = function (e) {
                _this.onAnchorDown(e);
            };
            this._onAnchorMoveBound = function (e) {
                _this.onAnchorMove(e);
            };
            this._onAnchorUpBound = function (e) {
                _this.onAnchorUp(e);
            };
            this._anchors = [];
            //
            var inputLabelWidth = picker.theme.getInputLabelWidth();
            var inputWidth = picker.theme.getMainWidth() * 0.5;
            var inputMargin = 5;
            var inputDirectionMargin = theme.getGradientDirectionMargin();
            var inputDirectionTexture = theme.getGradientDirectionTexture();
            var inputLeft = picker.x + picker.width + inputDirectionMargin;
            var inputDirection = new DInputReal({
                parent: this,
                x: inputLeft + inputLabelWidth + inputMargin,
                y: paddingTop,
                width: inputWidth - inputLabelWidth - inputMargin,
                step: 1,
                image: {
                    source: inputDirectionTexture,
                    align: {
                        with: DAlignWith.BORDER
                    },
                    margin: {
                        horizontal: -inputDirectionTexture.width - inputMargin
                    }
                },
                on: {
                    change: function (value) {
                        _this._data._direction = value;
                    }
                }
            });
            // Recent gradients
            var recentColumn = theme.getGradientRecentColumn();
            var recentWidth = theme.getGradientRecentWidth();
            var recentMargin = theme.getGradientRecentMargin();
            var recentWidthAndMargin = recentWidth + recentMargin;
            var x0 = inputLeft;
            var y0 = inputDirection.y + inputDirection.height + inputDirectionMargin;
            if (DPickerColorGradient.RECENT_COLOR_GRADIENT == null) {
                DPickerColorGradient.RECENT_COLOR_GRADIENT = new DPickerColorGradientRecent(theme.getGradientRecents(), theme.getGradientRecentCount());
            }
            this._recent = DPickerColorGradient.RECENT_COLOR_GRADIENT;
            var recent = this._recent;
            for (var i = 0, imax = recent.getCapacity(); i < imax; ++i) {
                var ix = i % recentColumn;
                var x = x0 + ix * recentWidthAndMargin;
                var iy = (i / recentColumn) | 0;
                var y = y0 + iy * recentWidthAndMargin;
                view.setRectangle(1 + i, x, y, recentWidth, recentWidth);
            }
            recent.on("change", function () {
                _this.onRecentUpdate();
            });
            UtilPointerEvent.onClick(view, function (e) {
                var lastHitIndex = view.getLastHitIndex();
                if (1 <= lastHitIndex) {
                    _this.onRecentClick(view.getData(lastHitIndex));
                }
            });
            // Points
            var data = this._data = new DPickerColorGradientData();
            data.on("change", function () {
                _this.updateAnchors();
                view.update();
            });
            data.on("selectionchange", function (point) {
                _this.onAnchorSelect(point);
            });
            data.on("directionchange", function (value) {
                inputDirection.value = value;
            });
            view.setData(0, data);
            view.update();
            inputDirection.value = data.direction;
            this.updateAnchors();
            var selected = data.selected;
            if (selected != null) {
                this.onAnchorSelect(selected);
            }
            // Width
            if (options == null || options.width == null) {
                this.width = paddingLeft + gradientPointsWidth + gradientPointsMargin +
                    picker.width + inputDirectionMargin + (recentColumn - 1) * recentMargin +
                    recentColumn * recentWidth + paddingRight;
            }
            // Height
            if (options == null || options.height == null) {
                this.height = paddingTop + picker.height + paddingBottom;
            }
        };
        Object.defineProperty(DPickerColorGradient.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerColorGradient.prototype, "recent", {
            get: function () {
                return this._recent;
            },
            enumerable: true,
            configurable: true
        });
        DPickerColorGradient.prototype.onRecentClick = function (recentData) {
            var data = this._data;
            if (recentData != null) {
                data.fromObject(recentData);
            }
            else {
                data.reset();
            }
        };
        DPickerColorGradient.prototype.onRecentUpdate = function () {
            var recent = this._recent;
            var view = this._view;
            for (var i = 0, imax = recent.size(); i < imax; ++i) {
                view.setData(1 + i, recent.get(i));
            }
            view.update();
            DApplications.update(this);
        };
        DPickerColorGradient.prototype.toAnchorPosition = function (e) {
            var local = this.toLocal(e.data.global, undefined, this._work);
            return Math.max(0, Math.min(1, (local.y - this.padding.getTop()) / this._picker.height));
        };
        DPickerColorGradient.prototype.onViewDown = function (e) {
            this._data.addAt(this.toAnchorPosition(e));
            this.onAnchorDragStart();
        };
        DPickerColorGradient.prototype.onAnchorDown = function (e) {
            var target = e.target;
            if (target instanceof pixi_js.Sprite) {
                var data = this._data;
                var index = this._anchors.indexOf(target);
                if (0 <= index && index < data.points.length) {
                    data.points[index].selected = true;
                    this.onAnchorDragStart();
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorSelect = function (point) {
            var picker = this._picker;
            picker.current.color = point.color;
            picker.current.alpha = point.alpha;
            picker.new.color = point.color;
            picker.new.alpha = point.alpha;
        };
        DPickerColorGradient.prototype.onAnchorColorChange = function (color) {
            var points = this._data;
            if (points != null) {
                var selected = points.selected;
                if (selected != null) {
                    selected.color = color;
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorAlphaChange = function (alpha) {
            var points = this._data;
            if (points != null) {
                var selected = points.selected;
                if (selected != null) {
                    selected.alpha = alpha;
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorDragStart = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onAnchorMoveBound);
                stage.on(UtilPointerEvent.up, this._onAnchorUpBound);
            }
        };
        DPickerColorGradient.prototype.onAnchorMove = function (e) {
            var points = this._data;
            if (points != null) {
                var selected = points.selected;
                if (selected != null) {
                    selected.position = this.toAnchorPosition(e);
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onAnchorMoveBound);
                stage.off(UtilPointerEvent.up, this._onAnchorUpBound);
            }
        };
        DPickerColorGradient.prototype.updateAnchors = function () {
            var theme = this.theme;
            var anchorTexture = theme.getGradientAnchorTexture();
            var anchorOutlinedTexture = theme.getGradientAnchorOutlinedTexture();
            var gradientPointsWidth = theme.getGradientPointsWidth();
            var data = this._data;
            var pointSize = data.points.length;
            var anchors = this._anchors;
            var anchorSize = anchors.length;
            for (var i = anchorSize; i < pointSize; ++i) {
                var newAnchor = new pixi_js.Sprite(anchorTexture);
                newAnchor.anchor.set(0.5, 0.5);
                newAnchor.cursor = "pointer";
                newAnchor.interactive = true;
                newAnchor.on(UtilPointerEvent.down, this._onAnchorDownBound);
                anchors.push(newAnchor);
                this.addChild(newAnchor);
            }
            for (var i = anchorSize - 1; pointSize <= i; --i) {
                var oldAnchor = anchors[i];
                oldAnchor.off(UtilPointerEvent.down, this._onAnchorDownBound);
                oldAnchor.destroy();
            }
            anchors.length = pointSize;
            var y = this.padding.getTop();
            var right = this.padding.getLeft() + gradientPointsWidth;
            var height = this._picker.height;
            for (var i = 0; i < pointSize; ++i) {
                var point = data.points[i];
                var anchor = anchors[i];
                anchor.tint = point.color;
                anchor.position.set(right, y + height * point.position);
                anchor.texture = (point.selected ? anchorOutlinedTexture : anchorTexture);
            }
            DApplications.update(this);
        };
        DPickerColorGradient.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isDeleteKey(e)) {
                var points = this._data;
                if (points != null) {
                    var selected = points.selected;
                    if (selected != null) {
                        points.remove(selected);
                        _super.prototype.onKeyDown.call(this, e);
                        return true;
                    }
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DPickerColorGradient.prototype.getType = function () {
            return "DPickerColorGradient";
        };
        DPickerColorGradient.RECENT_COLOR_GRADIENT = null;
        return DPickerColorGradient;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogColorGradient = /** @class */ (function (_super) {
        __extends(DDialogColorGradient, _super);
        function DDialogColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogColorGradient.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            var picker = new DPickerColorGradient(options && options.picker);
            this._picker = picker;
            layout.addChild(picker);
            this.on("ok", function () {
                var data = picker.data;
                var recent = picker.recent;
                if (!recent.contains(data)) {
                    recent.add(data.toObject());
                }
            });
        };
        Object.defineProperty(DDialogColorGradient.prototype, "data", {
            get: function () {
                return this._picker.data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogColorGradient.prototype, "recent", {
            get: function () {
                return this._picker.recent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogColorGradient.prototype, "picker", {
            get: function () {
                return this._picker;
            },
            enumerable: true,
            configurable: true
        });
        DDialogColorGradient.prototype.onKeyDown = function (e) {
            this._picker.onKeyDown(e);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDialogColorGradient.prototype.getType = function () {
            return "DDialogColorGradient";
        };
        return DDialogColorGradient;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonColorGradient = /** @class */ (function (_super) {
        __extends(DButtonColorGradient, _super);
        function DButtonColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonColorGradient.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var data = this._textValueComputed;
            this._dialogOptions = options && options.dialog;
            if (options == null || options.image == null || options.image.source === undefined) {
                var texture = this.theme.getViewBaseTexture();
                if (texture instanceof pixi_js.Texture) {
                    var view = this._view = DPickerColorGradientDataView.from(1, 10, texture);
                    view.setRectangle(0, 0, 0, texture.width, texture.height);
                    view.setData(0, data);
                    view.update();
                    this.image = view;
                }
            }
            this.on("active", function () {
                var dialog = _this.dialog;
                dialog.data.fromObject(data);
                dialog.open().then(function () {
                    var newValue = dialog.data;
                    var oldValue = data.toObject();
                    data.fromObject(newValue);
                    var view = _this._view;
                    if (view != null) {
                        view.update();
                    }
                    _this.onTextChange();
                    _this.createOrUpdateText();
                    DApplications.update(_this);
                    _this.emit("change", newValue, oldValue, _this);
                });
            });
        };
        Object.defineProperty(DButtonColorGradient.prototype, "dialog", {
            get: function () {
                var dialog = this._dialog;
                if (dialog == null) {
                    var dialogOptions = this._dialogOptions;
                    if (dialogOptions != null) {
                        dialog = new DDialogColorGradient(this._dialogOptions);
                    }
                    else {
                        if (DButtonColorGradient.DIALOG == null) {
                            DButtonColorGradient.DIALOG = new DDialogColorGradient();
                        }
                        dialog = DButtonColorGradient.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DButtonColorGradient.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            enumerable: true,
            configurable: true
        });
        DButtonColorGradient.prototype.getType = function () {
            return "DButtonColorGradient";
        };
        return DButtonColorGradient;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogColor = /** @class */ (function (_super) {
        __extends(DDialogColor, _super);
        function DDialogColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogColor.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            var picker = new DPickerColor(options && options.picker);
            this._picker = picker;
            layout.addChild(picker);
            this.on("ok", function () {
                var recent = picker.recent;
                if (!recent.contains(picker.new)) {
                    recent.add(picker.new);
                }
            });
        };
        Object.defineProperty(DDialogColor.prototype, "current", {
            get: function () {
                return this._picker.current;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "new", {
            get: function () {
                return this._picker.new;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "recent", {
            get: function () {
                return this._picker.recent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "picker", {
            get: function () {
                return this._picker;
            },
            enumerable: true,
            configurable: true
        });
        DDialogColor.prototype.getType = function () {
            return "DDialogColor";
        };
        return DDialogColor;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonColor = /** @class */ (function (_super) {
        __extends(DButtonColor, _super);
        function DButtonColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonColor.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var colorAndAlpha = this._textValueComputed;
            this._value = new DPickerColorAndAlpha(colorAndAlpha, function (color) {
                colorAndAlpha.color = color;
                _this.onColorChange();
            }, function (alpha) {
                colorAndAlpha.alpha = alpha;
                _this.updateTextForcibly();
            });
            this.on("active", function () {
                var dialog = _this.dialog;
                dialog.current.color = colorAndAlpha.color;
                dialog.current.alpha = colorAndAlpha.alpha;
                dialog.new.color = colorAndAlpha.color;
                dialog.new.alpha = colorAndAlpha.alpha;
                dialog.open().then(function () {
                    var dialogNew = dialog.new;
                    var dialogCurrent = dialog.current;
                    colorAndAlpha.color = dialogNew.color;
                    colorAndAlpha.alpha = dialogNew.alpha;
                    _this.onColorChange();
                    _this.emit("change", dialogNew, dialogCurrent, _this);
                });
            });
        };
        DButtonColor.prototype.toImageTintOptions = function (tint) {
            var _this = this;
            var color = function () { return _this._textValueComputed.color; };
            if (tint) {
                return {
                    color: tint.color || color,
                    alpha: tint.alpha
                };
            }
            return {
                color: color
            };
        };
        DButtonColor.prototype.toImageOptions = function (theme, options) {
            if (options) {
                return {
                    source: options.source,
                    tint: this.toImageTintOptions(options.tint),
                    align: options.align,
                    margin: options.margin
                };
            }
            return {
                tint: this.toImageTintOptions()
            };
        };
        DButtonColor.prototype.onColorChange = function () {
            if (this._images[0].updateTint()) {
                DApplications.update(this);
            }
            this.updateTextForcibly();
        };
        DButtonColor.prototype.updateTextForcibly = function () {
            this.onTextChange();
            this.createOrUpdateText();
        };
        Object.defineProperty(DButtonColor.prototype, "dialog", {
            get: function () {
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = this._options;
                    var dialogOptions = options && options.dialog;
                    if (dialogOptions != null) {
                        dialog = new DDialogColor(dialogOptions);
                    }
                    else {
                        if (DButtonColor.DIALOG == null) {
                            DButtonColor.DIALOG = new DDialogColor();
                        }
                        dialog = DButtonColor.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DButtonColor.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        DButtonColor.prototype.getType = function () {
            return "DButtonColor";
        };
        return DButtonColor;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDanger = /** @class */ (function (_super) {
        __extends(DButtonDanger, _super);
        function DButtonDanger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDanger.prototype.getType = function () {
            return "DButtonDanger";
        };
        return DButtonDanger;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonBack = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonBack, _super);
        function DPickerDatetimeButtonBack() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonBack.prototype.getType = function () {
            return "DPickerDatetimeButtonBack";
        };
        return DPickerDatetimeButtonBack;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonDate = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonDate, _super);
        function DPickerDatetimeButtonDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonDate.prototype.onToggleStart = function () {
            if (!this.isActive()) {
                this.setActive(true);
            }
        };
        DPickerDatetimeButtonDate.prototype.onToggleEnd = function () {
            this.emit(this.isActive() ? "active" : "inactive", this);
        };
        DPickerDatetimeButtonDate.prototype.getType = function () {
            return "DPickerDatetimeButtonDate";
        };
        return DPickerDatetimeButtonDate;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonNext = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonNext, _super);
        function DPickerDatetimeButtonNext() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonNext.prototype.getType = function () {
            return "DPickerDatetimeButtonNext";
        };
        return DPickerDatetimeButtonNext;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeLabel = /** @class */ (function (_super) {
        __extends(DPickerDatetimeLabel, _super);
        function DPickerDatetimeLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeLabel.prototype.getType = function () {
            return "DPickerDatetimeLabel";
        };
        return DPickerDatetimeLabel;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeLabelDate = /** @class */ (function (_super) {
        __extends(DPickerDatetimeLabelDate, _super);
        function DPickerDatetimeLabelDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeLabelDate.prototype.getType = function () {
            return "DPickerDatetimeLabelDate";
        };
        return DPickerDatetimeLabelDate;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeSpace = /** @class */ (function (_super) {
        __extends(DPickerDatetimeSpace, _super);
        function DPickerDatetimeSpace(options) {
            var _this = _super.call(this, options) || this;
            _this.setState(DBaseState.UNFOCUSABLE, true);
            _this.renderable = false;
            return _this;
        }
        DPickerDatetimeSpace.prototype.getType = function () {
            return "DPickerDatetimeSpace";
        };
        return DPickerDatetimeSpace;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputInteger = /** @class */ (function (_super) {
        __extends(DInputInteger, _super);
        function DInputInteger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputInteger.prototype.getType = function () {
            return "DInputInteger";
        };
        return DInputInteger;
    }(DInputNumber));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeMask;
    (function (DPickerDatetimeMask) {
        DPickerDatetimeMask[DPickerDatetimeMask["NONE"] = 0] = "NONE";
        DPickerDatetimeMask[DPickerDatetimeMask["DATE"] = 1] = "DATE";
        DPickerDatetimeMask[DPickerDatetimeMask["HOURS"] = 2] = "HOURS";
        DPickerDatetimeMask[DPickerDatetimeMask["MINUTES"] = 4] = "MINUTES";
        DPickerDatetimeMask[DPickerDatetimeMask["SECONDS"] = 8] = "SECONDS";
        DPickerDatetimeMask[DPickerDatetimeMask["ALL"] = 15] = "ALL";
    })(DPickerDatetimeMask || (DPickerDatetimeMask = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBound = /** @class */ (function () {
        function DPickerTimeBound(options, onChange) {
            this._date = (options && options.date !== undefined ? options.date : null);
            this._inclusive = (options && options.inclusive !== undefined ? options.inclusive : false);
            this._onChange = onChange;
        }
        Object.defineProperty(DPickerTimeBound.prototype, "date", {
            get: function () {
                return this._date;
            },
            set: function (date) {
                if (this._date !== date) {
                    this._date = date;
                    this._onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerTimeBound.prototype, "inclusive", {
            get: function () {
                return this._inclusive;
            },
            set: function (inclusive) {
                if (this._inclusive !== inclusive) {
                    this._inclusive = inclusive;
                    this._onChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        return DPickerTimeBound;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundHours = /** @class */ (function () {
        function DPickerTimeBoundHours(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundHours.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.hour.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.hour.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.hour.min;
                    }
                }
                var lowerDateHours = lowerDate.getHours();
                if (lower.inclusive) {
                    return lowerDateHours;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (lowerDate.getSeconds() < constant.second.max) {
                            return lowerDateHours;
                        }
                    }
                    if (mask & DPickerDatetimeMask.MINUTES) {
                        if (lowerDate.getMinutes() < constant.minute.max) {
                            return lowerDateHours;
                        }
                    }
                    return lowerDateHours + 1;
                }
            }
            return constant.hour.min;
        };
        DPickerTimeBoundHours.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.hour.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.hour.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.hour.max;
                    }
                }
                var upperDateHours = upperDate.getHours();
                if (upper.inclusive) {
                    return upperDateHours;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (constant.second.min < upperDate.getSeconds()) {
                            return upperDateHours;
                        }
                    }
                    if (mask & DPickerDatetimeMask.MINUTES) {
                        if (constant.minute.min < upperDate.getMinutes()) {
                            return upperDateHours;
                        }
                    }
                    return upperDateHours - 1;
                }
            }
            return constant.hour.max;
        };
        return DPickerTimeBoundHours;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundMinutes = /** @class */ (function () {
        function DPickerTimeBoundMinutes(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundMinutes.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.minute.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.minute.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.minute.min;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (lowerDate.getHours() < date.getHours()) {
                        return constant.minute.min;
                    }
                }
                var lowerDateMinutes = lowerDate.getMinutes();
                if (lower.inclusive) {
                    return lowerDateMinutes;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (lowerDate.getSeconds() < constant.second.max) {
                            return lowerDateMinutes;
                        }
                    }
                    return lowerDateMinutes + 1;
                }
            }
            return constant.minute.min;
        };
        DPickerTimeBoundMinutes.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.minute.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.minute.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.minute.max;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (date.getHours() < upperDate.getHours()) {
                        return constant.minute.max;
                    }
                }
                var upperDateMinutes = upperDate.getMinutes();
                if (upper.inclusive) {
                    return upperDateMinutes;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (constant.second.min < upperDate.getSeconds()) {
                            return upperDateMinutes;
                        }
                    }
                    return upperDateMinutes - 1;
                }
            }
            return constant.minute.max;
        };
        return DPickerTimeBoundMinutes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundSeconds = /** @class */ (function () {
        function DPickerTimeBoundSeconds(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundSeconds.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.second.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.second.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.second.min;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (lowerDate.getHours() < date.getHours()) {
                        return constant.second.min;
                    }
                }
                if (mask & DPickerDatetimeMask.MINUTES) {
                    if (lowerDate.getMinutes() < date.getMinutes()) {
                        return constant.second.min;
                    }
                }
                return lowerDate.getSeconds() + (lower.inclusive ? 0 : 1);
            }
            return constant.second.min;
        };
        DPickerTimeBoundSeconds.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.second.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.second.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.second.max;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (date.getHours() < upperDate.getHours()) {
                        return constant.second.max;
                    }
                }
                if (mask & DPickerDatetimeMask.MINUTES) {
                    if (date.getMinutes() < upperDate.getMinutes()) {
                        return constant.second.max;
                    }
                }
                return upperDate.getSeconds() - (upper.inclusive ? 0 : 1);
            }
            return constant.second.max;
        };
        return DPickerTimeBoundSeconds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBounds = /** @class */ (function () {
        function DPickerTimeBounds(options, onChange) {
            this.constant = this.newConstant();
            this.lower = new DPickerTimeBound(options && options.lower, onChange);
            this.upper = new DPickerTimeBound(options && options.upper, onChange);
            this.mask = DPickerDatetimeMask.ALL;
            this.hours = new DPickerTimeBoundHours(this);
            this.minutes = new DPickerTimeBoundMinutes(this);
            this.seconds = new DPickerTimeBoundSeconds(this);
        }
        DPickerTimeBounds.prototype.newConstant = function () {
            return {
                second: {
                    min: 0,
                    max: 59
                },
                minute: {
                    min: 0,
                    max: 59
                },
                hour: {
                    min: 0,
                    max: 23
                }
            };
        };
        DPickerTimeBounds.prototype.adjust = function (date) {
            var result = this.test(date);
            if (result < 0) {
                var lower = this.lower;
                var lowerDate = lower.date;
                if (lowerDate) {
                    date.setTime(lowerDate.getTime());
                    if (!lower.inclusive) {
                        var mask = this.mask;
                        if (mask & DPickerDatetimeMask.SECONDS) {
                            date.setSeconds(lowerDate.getSeconds() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.MINUTES) {
                            date.setMinutes(lowerDate.getMinutes() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.HOURS) {
                            date.setHours(lowerDate.getHours() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.DATE) {
                            date.setDate(lowerDate.getDate() + 1);
                        }
                    }
                    return true;
                }
            }
            else if (0 < result) {
                var upper = this.upper;
                var upperDate = upper.date;
                if (upperDate) {
                    date.setTime(upperDate.getTime());
                    if (!upper.inclusive) {
                        var mask = this.mask;
                        if (mask & DPickerDatetimeMask.SECONDS) {
                            date.setSeconds(upperDate.getSeconds() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.MINUTES) {
                            date.setMinutes(upperDate.getMinutes() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.HOURS) {
                            date.setHours(upperDate.getHours() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.DATE) {
                            date.setDate(upperDate.getDate() - 1);
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        DPickerTimeBounds.prototype.compare = function (a, b) {
            var mask = this.mask;
            if (mask & DPickerDatetimeMask.DATE) {
                var ay = a.getFullYear();
                var by = b.getFullYear();
                if (ay !== by) {
                    return (ay < by ? -1 : +1);
                }
                var am = a.getMonth();
                var bm = b.getMonth();
                if (am !== bm) {
                    return (am < bm ? -1 : +1);
                }
                var ad = a.getDate();
                var bd = b.getDate();
                if (ad !== bd) {
                    return (ad < bd ? -1 : +1);
                }
            }
            if (mask & DPickerDatetimeMask.HOURS) {
                var ah = a.getHours();
                var bh = b.getHours();
                if (ah !== bh) {
                    return (ah < bh ? -1 : +1);
                }
            }
            if (mask & DPickerDatetimeMask.MINUTES) {
                var am = a.getMinutes();
                var bm = b.getMinutes();
                if (am !== bm) {
                    return (am < bm ? -1 : +1);
                }
            }
            if (mask & DPickerDatetimeMask.SECONDS) {
                var ad = a.getSeconds();
                var bd = b.getSeconds();
                if (ad !== bd) {
                    return (ad < bd ? -1 : +1);
                }
            }
            return 0;
        };
        DPickerTimeBounds.prototype.test = function (date) {
            // Lower bound
            var lower = this.lower;
            var lowerDate = lower.date;
            if (lowerDate != null) {
                var result = this.compare(lowerDate, date);
                if (lower.inclusive) {
                    return (result <= 0 ? 0 : -1);
                }
                else {
                    return (result < 0 ? 0 : -1);
                }
            }
            // Upper bound
            var upper = this.upper;
            var upperDate = upper.date;
            if (upperDate != null) {
                var result = this.compare(date, upperDate);
                if (upper.inclusive) {
                    return (result <= 0 ? 0 : +1);
                }
                else {
                    return (result < 0 ? 0 : +1);
                }
            }
            return 0;
        };
        DPickerTimeBounds.prototype.contains = function (date) {
            return this.test(date) === 0;
        };
        return DPickerTimeBounds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toBoundOptions = function (options, date, inclusive) {
        if (options) {
            return {
                date: (options.date !== undefined ? options.date : date),
                inclusive: (options.inclusive !== undefined ? options.inclusive : inclusive)
            };
        }
        return {
            date: date,
            inclusive: inclusive
        };
    };
    var toBoundsOptions = function (theme, options) {
        if (options) {
            return {
                lower: toBoundOptions(options.lower, theme.getLowerBound(), theme.isLowerBoundInclusive()),
                upper: toBoundOptions(options.upper, theme.getUpperBound(), theme.isUpperBoundInclusive())
            };
        }
        return {
            lower: {
                date: theme.getLowerBound(),
                inclusive: theme.isLowerBoundInclusive()
            },
            upper: {
                date: theme.getUpperBound(),
                inclusive: theme.isUpperBoundInclusive()
            }
        };
    };
    var DPickerTime = /** @class */ (function (_super) {
        __extends(DPickerTime, _super);
        function DPickerTime(options) {
            var _this = _super.call(this, options) || this;
            _this.onNewChanged();
            return _this;
        }
        DPickerTime.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.UNFOCUSABLE, true);
            var theme = this.theme;
            this._dateCurrent = new Date();
            var dateCurrentTime = this._dateCurrent.getTime();
            this._dateNew = new Date(dateCurrentTime);
            this._dateBounds = new DPickerTimeBounds(toBoundsOptions(theme, options && options.bounds), function () { _this.onNewChanged(); });
            var margin = (options && options.margin != null ?
                options.margin : theme.getMargin());
            new DLayoutVertical({
                parent: this,
                x: "padding", y: "padding",
                width: "auto", height: "auto",
                margin: margin,
                children: this.newChildren(theme, options, margin)
            });
        };
        Object.defineProperty(DPickerTime.prototype, "current", {
            get: function () {
                return this._dateCurrent;
            },
            set: function (dateCurrent) {
                if (this._dateCurrent.getTime() !== dateCurrent.getTime()) {
                    this._dateCurrent = dateCurrent;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerTime.prototype, "new", {
            get: function () {
                return this._dateNew;
            },
            set: function (dateNew) {
                if (this._dateNew.getTime() !== dateNew.getTime()) {
                    this._dateNew = dateNew;
                    this.onNewChanged();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPickerTime.prototype, "bounds", {
            get: function () {
                return this._dateBounds;
            },
            enumerable: true,
            configurable: true
        });
        DPickerTime.prototype.hasHours = function () {
            return this._inputHours != null;
        };
        DPickerTime.prototype.hasMinutes = function () {
            return this._inputMinutes != null;
        };
        DPickerTime.prototype.hasSeconds = function () {
            return this._inputSeconds != null;
        };
        DPickerTime.prototype.reset = function () {
            var currentTime = this._dateCurrent.getTime();
            this._dateNew.setTime(currentTime);
            this.onReset();
        };
        DPickerTime.prototype.onReset = function () {
            this.onNewChanged();
        };
        DPickerTime.prototype.onNewChanged = function () {
            var dateNew = this._dateNew;
            var dateBounds = this._dateBounds;
            dateBounds.adjust(this._dateNew);
            var inputHours = this._inputHours;
            if (inputHours) {
                var hours = dateBounds.hours;
                inputHours.value = dateNew.getHours();
                inputHours.min = hours.min(dateNew);
                inputHours.max = hours.max(dateNew);
            }
            var inputMinutes = this._inputMinutes;
            if (inputMinutes) {
                var minutes = dateBounds.minutes;
                inputMinutes.value = dateNew.getMinutes();
                inputMinutes.min = minutes.min(dateNew);
                inputMinutes.max = minutes.max(dateNew);
            }
            var inputSeconds = this._inputSeconds;
            if (inputSeconds) {
                var seconds = dateBounds.seconds;
                inputSeconds.value = dateNew.getSeconds();
                inputSeconds.min = seconds.min(dateNew);
                inputSeconds.max = seconds.max(dateNew);
            }
        };
        DPickerTime.prototype.newChildren = function (theme, options, margin) {
            var mask = ((options && options.mask != null) ? options.mask : theme.getMask());
            this._dateBounds.mask = mask;
            this._inputHours = ((mask & DPickerDatetimeMask.HOURS) ? this.newInputHours(theme, options) : null);
            this._inputMinutes = ((mask & DPickerDatetimeMask.MINUTES) ? this.newInputMinutes(theme, options) : null);
            this._inputSeconds = ((mask & DPickerDatetimeMask.SECONDS) ? this.newInputSeconds(theme, options) : null);
            return [
                this.newTimeLayout(this._inputHours, this._inputMinutes, this._inputSeconds, margin)
            ];
        };
        DPickerTime.prototype.newTimeLayout = function (hours, minutes, seconds, margin) {
            var children = this.newTimeLayoutChildren(hours, minutes, seconds);
            if (0 < children.length) {
                return new DLayoutHorizontal({
                    width: this.getTimeLayoutWidth(),
                    height: this.getTimeLayoutHeight(),
                    margin: margin,
                    children: children
                });
            }
            return null;
        };
        DPickerTime.prototype.getTimeLayoutWidth = function () {
            return "auto";
        };
        DPickerTime.prototype.getTimeLayoutHeight = function () {
            return "auto";
        };
        DPickerTime.prototype.newTimeLayoutChildren = function (hours, minutes, seconds) {
            var result = [];
            if (hours != null) {
                result.push(hours);
            }
            if (minutes != null) {
                if (0 < result.length) {
                    result.push(this.newMinuteSeparator());
                }
                result.push(minutes);
            }
            if (seconds != null) {
                if (0 < result.length) {
                    result.push(this.newSecondSeparator());
                }
                result.push(seconds);
            }
            return result;
        };
        DPickerTime.prototype.newMinuteSeparator = function () {
            return new DText({
                width: "auto",
                text: {
                    value: this.getMinuteSeparator()
                }
            });
        };
        DPickerTime.prototype.getMinuteSeparator = function () {
            return ":";
        };
        DPickerTime.prototype.newSecondSeparator = function () {
            return new DText({
                width: "auto",
                text: {
                    value: this.getSecondSeparator()
                }
            });
        };
        DPickerTime.prototype.getSecondSeparator = function () {
            return ":";
        };
        DPickerTime.prototype.adjustInputOptions = function (theme, options, max) {
            if (options.step == null) {
                options.step = 1;
            }
            if (options.min == null) {
                options.min = 0;
            }
            if (options.max == null) {
                options.max = max;
            }
            return options;
        };
        DPickerTime.prototype.newInputHours = function (theme, options) {
            var _this = this;
            var inputOptions = (options && options.hours) || theme.getHoursOptions();
            var max = this._dateBounds.constant.hour.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onHoursChanged(value);
            });
            return input;
        };
        DPickerTime.prototype.onHoursChanged = function (value) {
            var dateNew = this._dateNew;
            dateNew.setHours(value);
            this.onNewChanged();
        };
        DPickerTime.prototype.newInputMinutes = function (theme, options) {
            var _this = this;
            var inputOptions = (options && options.minutes) || theme.getMinutesOptions();
            var max = this._dateBounds.constant.minute.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onMinutesChanged(value);
            });
            return input;
        };
        DPickerTime.prototype.onMinutesChanged = function (value) {
            var dateNew = this._dateNew;
            dateNew.setMinutes(value);
            this.onNewChanged();
        };
        DPickerTime.prototype.newInputSeconds = function (theme, options) {
            var _this = this;
            var inputOptions = (options && options.seconds) || theme.getSecondsOptions();
            var max = this._dateBounds.constant.second.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onSecondsChanged(value);
            });
            return input;
        };
        DPickerTime.prototype.onSecondsChanged = function (value) {
            this._dateNew.setSeconds(value);
        };
        DPickerTime.prototype.getType = function () {
            return "DPickerTime";
        };
        return DPickerTime;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetime = /** @class */ (function (_super) {
        __extends(DPickerDatetime, _super);
        function DPickerDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetime.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._datePage = new Date(this._dateCurrent.getTime());
        };
        DPickerDatetime.prototype.newChildren = function (theme, options, margin) {
            this._dateButtons = this.newDateButtons(theme, options);
            this._dateDecorator = (options && options.date && options.date.decorator) ||
                theme.getDateDecorator();
            this._label = this.newLabel(theme, options);
            var result = _super.prototype.newChildren.call(this, theme, options, margin);
            result.unshift(new DLayoutHorizontal({
                width: "100%", height: "auto",
                children: [
                    this.newBackButton(theme, options),
                    this._label,
                    this.newNextButton(theme, options)
                ]
            }), new DLayoutHorizontal({
                width: "auto", height: "auto",
                margin: margin,
                children: this.newDateLabels(theme, options)
            }), new DLayoutVertical({
                width: "auto", height: "auto",
                margin: margin,
                column: 7,
                children: this._dateButtons
            }));
            return result;
        };
        Object.defineProperty(DPickerDatetime.prototype, "page", {
            get: function () {
                return this._datePage;
            },
            set: function (datePage) {
                if (this._datePage.getTime() !== datePage.getTime()) {
                    this._datePage = datePage;
                    this.onPageChanged();
                }
            },
            enumerable: true,
            configurable: true
        });
        DPickerDatetime.prototype.onReset = function () {
            this._datePage.setTime(this._dateCurrent.getTime());
            _super.prototype.onReset.call(this);
        };
        DPickerDatetime.prototype.next = function () {
            var work = this._datePage;
            work.setFullYear(work.getFullYear(), work.getMonth() + 1, 1);
            work.setHours(0, 0, 0, 0);
            this.onPageChanged();
        };
        DPickerDatetime.prototype.back = function () {
            var work = this._datePage;
            work.setFullYear(work.getFullYear(), work.getMonth() - 1, 1);
            work.setHours(0, 0, 0, 0);
            this.onPageChanged();
        };
        DPickerDatetime.prototype.onNewChanged = function () {
            this._dateBounds.adjust(this._datePage);
            _super.prototype.onNewChanged.call(this);
            this.onPageChanged();
        };
        DPickerDatetime.prototype.onPageChanged = function () {
            var buttons = this._dateButtons;
            var bounds = this._dateBounds;
            var datePage = this._datePage;
            var dateNew = this._dateNew;
            var tmp = new Date(datePage.getTime());
            tmp.setDate(1);
            tmp.setHours(0, 0, 0, 0);
            // Spaces
            var theme = this.theme;
            var spaceCount = (tmp.getDay() - theme.getDayStart() + 7) % 7;
            for (var i = 0; i < spaceCount; ++i) {
                buttons[i].show();
            }
            for (var i = spaceCount; i < 7; ++i) {
                buttons[i].hide();
            }
            // Date buttons
            var dateDecorator = this._dateDecorator;
            tmp.setFullYear(tmp.getFullYear(), tmp.getMonth() + 1, 0);
            var dateCount = tmp.getDate();
            var dateNewDate = (dateNew.getFullYear() === tmp.getFullYear() &&
                dateNew.getMonth() === tmp.getMonth() ? dateNew.getDate() : 0);
            for (var i = 0; i < dateCount; ++i) {
                tmp.setDate(i + 1);
                var button = buttons[i + 7];
                button.setActive(dateNewDate === i + 1);
                button.setDisabled(!bounds.contains(tmp));
                button.show();
                dateDecorator(tmp, button);
            }
            for (var i = dateCount; i < 31; ++i) {
                var button = buttons[i + 7];
                button.setActive(false);
                button.hide();
            }
            // Label
            tmp.setTime(datePage.getTime());
            this._label.text = tmp;
        };
        DPickerDatetime.prototype.adjustInputOptions = function (theme, options, max) {
            if (options.weight == null) {
                options.weight = 1;
            }
            return _super.prototype.adjustInputOptions.call(this, theme, options, max);
        };
        DPickerDatetime.prototype.getTimeLayoutWidth = function () {
            return "100%";
        };
        DPickerDatetime.prototype.toLabelOptions = function (theme, options) {
            var result = (options && options.label) || {};
            if (result.weight === undefined) {
                result.weight = 1;
            }
            if (result.padding === undefined) {
                result.padding = 0;
            }
            var labelText = result.text = result.text || {};
            var labelTextAlign = labelText.align = labelText.align || {};
            if (labelTextAlign.horizontal === undefined) {
                labelTextAlign.horizontal = "CENTER";
            }
            if (labelText.formatter === undefined) {
                labelText.formatter = theme.getLabelFormatter();
            }
            return result;
        };
        DPickerDatetime.prototype.newLabel = function (theme, options) {
            return new DPickerDatetimeLabel(this.toLabelOptions(theme, options));
        };
        DPickerDatetime.prototype.newBackButton = function (theme, options) {
            var _this = this;
            var buttonOptions = (options && options.back !== undefined ?
                options.back : theme.getBackButtonOptions());
            if (buttonOptions != null) {
                var button = new DPickerDatetimeButtonBack(buttonOptions);
                button.on("active", function () {
                    _this.back();
                });
                return button;
            }
            return null;
        };
        DPickerDatetime.prototype.newNextButton = function (theme, options) {
            var _this = this;
            var buttonOptions = (options && options.next !== undefined ?
                options.next : theme.getNextButtonOptions());
            if (buttonOptions != null) {
                var button = new DPickerDatetimeButtonNext(buttonOptions);
                button.on("active", function () {
                    _this.next();
                });
                return button;
            }
            return null;
        };
        DPickerDatetime.prototype.newDateLabels = function (theme, options) {
            var dateLabels = theme.getDayLabels();
            var dayStart = theme.getDayStart();
            var result = [];
            for (var i = 0; i < 7; ++i) {
                var label = dateLabels[(dayStart + i) % 7];
                result.push(this.newDateLabel(theme, options, label));
            }
            return result;
        };
        DPickerDatetime.prototype.newDateLabel = function (theme, options, label) {
            return new DPickerDatetimeLabelDate({
                text: {
                    value: label
                }
            });
        };
        DPickerDatetime.prototype.newDateButtons = function (theme, options) {
            var result = [];
            for (var i = 0; i < 7; ++i) {
                result.push(this.newSpace(theme, options));
            }
            for (var i = 1; i <= 31; ++i) {
                result.push(this.newDateButton(theme, options, i));
            }
            return result;
        };
        DPickerDatetime.prototype.newSpace = function (theme, options) {
            return new DPickerDatetimeSpace();
        };
        DPickerDatetime.prototype.newDateButton = function (theme, options, date) {
            var _this = this;
            return new DPickerDatetimeButtonDate({
                text: {
                    value: String(date)
                },
                on: {
                    active: function () {
                        _this.onDateButtonClicked(date);
                    }
                }
            });
        };
        DPickerDatetime.prototype.onDateButtonClicked = function (date) {
            var dateNew = this._dateNew;
            if (dateNew.getDate() !== date) {
                var datePage = this._datePage;
                dateNew.setFullYear(datePage.getFullYear());
                dateNew.setMonth(datePage.getMonth());
                dateNew.setDate(date);
                this.onNewChanged();
            }
        };
        DPickerDatetime.prototype.getType = function () {
            return "DPickerDatetime";
        };
        return DPickerDatetime;
    }(DPickerTime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDate = /** @class */ (function (_super) {
        __extends(DPickerDate, _super);
        function DPickerDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDate.prototype.getType = function () {
            return "DPickerDate";
        };
        return DPickerDate;
    }(DPickerDatetime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDate = /** @class */ (function (_super) {
        __extends(DDialogDate, _super);
        function DDialogDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogDate.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            var picker = new DPickerDate(options && options.picker);
            this._picker = picker;
            layout.addChild(picker);
        };
        Object.defineProperty(DDialogDate.prototype, "current", {
            get: function () {
                return this._picker.current;
            },
            set: function (dateCurrent) {
                this._picker.current = dateCurrent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "new", {
            get: function () {
                return this._picker.new;
            },
            set: function (dateNew) {
                this._picker.new = dateNew;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "page", {
            get: function () {
                return this._picker.new;
            },
            set: function (datePage) {
                this._picker.page = datePage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "picker", {
            get: function () {
                return this._picker;
            },
            enumerable: true,
            configurable: true
        });
        DDialogDate.prototype.getType = function () {
            return "DDialogDate";
        };
        return DDialogDate;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDates = /** @class */ (function () {
        function DDialogDates() {
        }
        DDialogDates.getInstance = function () {
            if (DDialogDates.INSTANCE == null) {
                DDialogDates.INSTANCE = new DDialogDate();
            }
            return DDialogDates.INSTANCE;
        };
        return DDialogDates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDate = /** @class */ (function (_super) {
        __extends(DButtonDate, _super);
        function DButtonDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDate.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._dialogOptions = options && options.dialog;
            this.on("active", function () {
                var currentTime = _this._textValueComputed.getTime();
                var dialog = _this.dialog;
                dialog.current = new Date(currentTime);
                dialog.new = new Date(currentTime);
                dialog.page = new Date(currentTime);
                dialog.open().then(function () {
                    var dateNew = dialog.new;
                    var dateCurrent = dialog.current;
                    _this.text = new Date(dateNew.getTime());
                    _this.emit("change", dateNew, dateCurrent, _this);
                });
            });
        };
        Object.defineProperty(DButtonDate.prototype, "dialog", {
            get: function () {
                var dialog = this._dialog;
                if (dialog == null) {
                    var dialogOptions = this._dialogOptions;
                    if (dialogOptions != null) {
                        dialog = new DDialogDate(this._dialogOptions);
                    }
                    else {
                        dialog = DDialogDates.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DButtonDate.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            set: function (value) {
                if (this._textValueComputed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        DButtonDate.prototype.getType = function () {
            return "DButtonDate";
        };
        return DButtonDate;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDatetime = /** @class */ (function (_super) {
        __extends(DDialogDatetime, _super);
        function DDialogDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogDatetime.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            var picker = new DPickerDatetime(options && options.picker);
            this._picker = picker;
            layout.addChild(picker);
        };
        Object.defineProperty(DDialogDatetime.prototype, "current", {
            get: function () {
                return this._picker.current;
            },
            set: function (dateCurrent) {
                this._picker.current = dateCurrent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "new", {
            get: function () {
                return this._picker.new;
            },
            set: function (dateNew) {
                this._picker.new = dateNew;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "page", {
            get: function () {
                return this._picker.new;
            },
            set: function (datePage) {
                this._picker.page = datePage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "picker", {
            get: function () {
                return this._picker;
            },
            enumerable: true,
            configurable: true
        });
        DDialogDatetime.prototype.getType = function () {
            return "DDialogDatetime";
        };
        return DDialogDatetime;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDatetimes = /** @class */ (function () {
        function DDialogDatetimes() {
        }
        DDialogDatetimes.getInstance = function () {
            if (DDialogDatetimes.INSTANCE == null) {
                DDialogDatetimes.INSTANCE = new DDialogDatetime();
            }
            return DDialogDatetimes.INSTANCE;
        };
        return DDialogDatetimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDates = /** @class */ (function () {
        function DPickerDates() {
        }
        DPickerDates.format = function (date) {
            var y = toPadded(String(date.getFullYear()), 4, "0");
            var M = toPadded(String(date.getMonth() + 1), 2, "0");
            var S = toPadded(String(date.getDate()), 2, "0");
            return y + "/" + M + "/" + S;
        };
        return DPickerDates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimes = /** @class */ (function () {
        function DPickerTimes() {
        }
        DPickerTimes.format = function (date, mask) {
            var result = "";
            if (mask & DPickerDatetimeMask.HOURS) {
                result += toPadded(String(date.getHours()), 2, "0");
            }
            if (mask & DPickerDatetimeMask.MINUTES) {
                if (0 < result.length) {
                    result += ":";
                }
                result += toPadded(String(date.getMinutes()), 2, "0");
            }
            if (mask & DPickerDatetimeMask.SECONDS) {
                if (0 < result.length) {
                    result += ":";
                }
                result += toPadded(String(date.getSeconds()), 2, "0");
            }
            return result;
        };
        DPickerTimes.toMask = function (options) {
            return (options && options.mask != null ? options.mask :
                DThemes.getInstance().get("DPickerTime").getMask());
        };
        return DPickerTimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimes = /** @class */ (function () {
        function DPickerDatetimes() {
        }
        DPickerDatetimes.format = function (date, mask) {
            var hms = DPickerTimes.format(date, mask);
            if (0 < hms.length) {
                return DPickerDates.format(date) + " " + hms;
            }
            else {
                return "" + DPickerDates.format(date);
            }
        };
        DPickerDatetimes.toMask = function (options) {
            return (options && options.mask != null ? options.mask :
                DThemes.getInstance().get("DPickerDatetime").getMask());
        };
        return DPickerDatetimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDatetime = /** @class */ (function (_super) {
        __extends(DButtonDatetime, _super);
        function DButtonDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDatetime.prototype.init = function (options) {
            var _this = this;
            this._dialogOptions = options && options.dialog;
            this._datetimeMask = DPickerDatetimes.toMask(options && options.dialog && options.dialog.picker);
            _super.prototype.init.call(this, options);
            this.on("active", function () {
                var currentTime = _this._textValueComputed.getTime();
                var dialog = _this.dialog;
                dialog.current = new Date(currentTime);
                dialog.new = new Date(currentTime);
                dialog.page = new Date(currentTime);
                dialog.open().then(function () {
                    var dateNew = dialog.new;
                    var dateCurrent = dialog.current;
                    _this.text = new Date(dateNew.getTime());
                    _this.emit("change", dateNew, dateCurrent, _this);
                });
            });
        };
        DButtonDatetime.prototype.getDatetimeMask = function () {
            return this._datetimeMask;
        };
        Object.defineProperty(DButtonDatetime.prototype, "dialog", {
            get: function () {
                var dialog = this._dialog;
                if (dialog == null) {
                    var dialogOptions = this._dialogOptions;
                    if (dialogOptions != null) {
                        dialog = new DDialogDatetime(this._dialogOptions);
                    }
                    else {
                        dialog = DDialogDatetimes.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DButtonDatetime.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            set: function (value) {
                if (this._textValueComputed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        DButtonDatetime.prototype.getType = function () {
            return "DButtonDatetime";
        };
        return DButtonDatetime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonFileAs = UtilFileAs;
    var DButtonFile = /** @class */ (function (_super) {
        __extends(DButtonFile, _super);
        function DButtonFile() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonFile.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._checker = (options != null && options.checker != null ? options.checker : undefined);
            var as = (options != null && options.as != null ?
                (isString(options.as) ? DButtonFileAs[options.as] : options.as) :
                DButtonFileAs.TEXT);
            var opener = new UtilFileOpener(as, this);
            this._opener = opener;
            this.on("active", function () {
                var result = _this.onOpening();
                if (result === true) {
                    opener.open();
                }
                else if (result === false) ;
                else {
                    result.then(function () {
                        opener.open();
                    });
                }
            });
        };
        DButtonFile.prototype.onOpening = function () {
            var checker = this._checker;
            if (checker != null) {
                return checker();
            }
            return true;
        };
        DButtonFile.prototype.open = function () {
            this._opener.open();
        };
        DButtonFile.prototype.getType = function () {
            return "DButtonFile";
        };
        return DButtonFile;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonGroup = /** @class */ (function (_super) {
        __extends(DButtonGroup, _super);
        function DButtonGroup(options) {
            var _this = _super.call(this) || this;
            _this._buttons = [];
            _this._active = null;
            _this._stateOn = DBaseState.NONE;
            _this._stateOff = DBaseState.NONE;
            _this._onActiveBound = function (button) {
                _this.onActive(button);
            };
            // Events
            if (options != null) {
                var on = options.on;
                if (on != null) {
                    for (var name_1 in on) {
                        _this.on(name_1, on[name_1]);
                    }
                }
            }
            // Done
            _this.emit("init", _this);
            return _this;
        }
        DButtonGroup.prototype.add = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            if (index < 0) {
                this._buttons.push(button);
                button.setState(this._stateOn, true);
                button.setState(this._stateOff, false);
                button.on("active", this._onActiveBound);
                if (button.isActive()) {
                    this.onActive(button);
                }
            }
        };
        Object.defineProperty(DButtonGroup.prototype, "active", {
            get: function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        DButtonGroup.prototype.onActive = function (active) {
            if (active.isToggle()) {
                this._active = active;
                var buttons = this._buttons;
                for (var i = 0, imax = buttons.length; i < imax; ++i) {
                    var button = buttons[i];
                    if (button !== active && button.isToggle() && button.isActive()) {
                        button.toggle();
                    }
                }
            }
        };
        DButtonGroup.prototype.remove = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            if (0 <= index) {
                buttons.splice(index, 1);
                button.off("active", this._onActiveBound);
            }
        };
        DButtonGroup.prototype.contains = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            return (0 <= index);
        };
        DButtonGroup.prototype.setHovered = function (isHovered) {
            return this.setState(DBaseState.HOVERED, isHovered);
        };
        DButtonGroup.prototype.setActive = function (isActive) {
            return this.setState(DBaseState.ACTIVE, isActive);
        };
        DButtonGroup.prototype.setReadOnly = function (isReadOnly) {
            return this.setState(DBaseState.READ_ONLY, isReadOnly);
        };
        DButtonGroup.prototype.setDisabled = function (isDisabled) {
            return this.setState(DBaseState.DISABLED, isDisabled);
        };
        DButtonGroup.prototype.setDragging = function (isDragging) {
            return this.setState(DBaseState.DRAGGING, isDragging);
        };
        DButtonGroup.prototype.isHovered = function () {
            return this.hasState(DBaseState.HOVERED);
        };
        DButtonGroup.prototype.isActive = function () {
            return this.hasState(DBaseState.ACTIVE);
        };
        DButtonGroup.prototype.isReadOnly = function () {
            return this.hasState(DBaseState.READ_ONLY);
        };
        DButtonGroup.prototype.isDisabled = function () {
            return this.hasState(DBaseState.DISABLED);
        };
        DButtonGroup.prototype.isDragging = function () {
            return this.hasState(DBaseState.DRAGGING);
        };
        DButtonGroup.prototype.isFocused = function () {
            return this.hasState(DBaseState.FOCUSED);
        };
        DButtonGroup.prototype.isUnfocusable = function () {
            return this.hasState(DBaseState.UNFOCUSABLE);
        };
        DButtonGroup.prototype.setState = function (state, isOn) {
            if (isOn) {
                this._stateOn |= state;
                this._stateOff &= ~state;
            }
            else {
                this._stateOff |= state;
                this._stateOn &= ~state;
            }
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                var button = buttons[i];
                button.setState(state, isOn);
            }
            return this;
        };
        DButtonGroup.prototype.hasState = function (state) {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                if (buttons[i].hasState(state)) {
                    return true;
                }
            }
            return false;
        };
        DButtonGroup.prototype.clear = function () {
            this._buttons.length = 0;
        };
        DButtonGroup.prototype.destroy = function () {
            this.clear();
        };
        return DButtonGroup;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonLink = /** @class */ (function (_super) {
        __extends(DButtonLink, _super);
        function DButtonLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonLink.prototype.initOnClick = function (options) {
            var _this = this;
            var link = new DLink(this.theme, options);
            this._link = link;
            link.apply(this, function (e) {
                _this.onClick(e);
            });
        };
        DButtonLink.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.open(this._link.inNewWindow(e));
        };
        DButtonLink.prototype.open = function (inNewWindow) {
            this._link.open(inNewWindow);
        };
        DButtonLink.prototype.getType = function () {
            return "DButtonLink";
        };
        return DButtonLink;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRadio = /** @class */ (function (_super) {
        __extends(DButtonRadio, _super);
        function DButtonRadio() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonRadio.prototype.getType = function () {
            return "DButtonRadio";
        };
        return DButtonRadio;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRadioRight = /** @class */ (function (_super) {
        __extends(DButtonRadioRight, _super);
        function DButtonRadioRight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonRadioRight.prototype.getType = function () {
            return "DButtonRadioRight";
        };
        return DButtonRadioRight;
    }(DButtonRadio));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRedo = /** @class */ (function (_super) {
        __extends(DButtonRedo, _super);
        function DButtonRedo(options) {
            var _this = _super.call(this, options) || this;
            var commandController = DControllers.getCommandController();
            _this.setState(DBaseState.DISABLED, !commandController.isRedoable());
            commandController.on("change", function () {
                _this.setState(DBaseState.DISABLED, !commandController.isRedoable());
            });
            _this.on("active", function () {
                commandController.redo();
            });
            return _this;
        }
        return DButtonRedo;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonSecondary = /** @class */ (function (_super) {
        __extends(DButtonSecondary, _super);
        function DButtonSecondary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonSecondary.prototype.getType = function () {
            return "DButtonSecondary";
        };
        return DButtonSecondary;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListSelectionMode;
    (function (DListSelectionMode) {
        DListSelectionMode[DListSelectionMode["NONE"] = 0] = "NONE";
        DListSelectionMode[DListSelectionMode["SINGLE"] = 1] = "SINGLE";
        DListSelectionMode[DListSelectionMode["MULTIPLE"] = 2] = "MULTIPLE";
    })(DListSelectionMode || (DListSelectionMode = {}));
    var DListSelection = /** @class */ (function (_super) {
        __extends(DListSelection, _super);
        function DListSelection(content, options) {
            var _this = _super.call(this) || this;
            _this._content = content;
            _this._isDirty = false;
            _this._indices = [];
            _this._mode = (options && options.mode != null ? options.mode : DListSelectionMode.SINGLE);
            // Events
            var on = options && options.on;
            if (on) {
                for (var name_1 in on) {
                    _this.on(name_1, on[name_1]);
                }
            }
            return _this;
        }
        DListSelection.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DListSelection.prototype.update = function () {
            if (this._isDirty) {
                this._isDirty = false;
                var indices = this._indices;
                indices.length = 0;
                var content = this._content;
                var children = content.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        if (child.isActive()) {
                            indices.push(i);
                        }
                    }
                }
            }
        };
        DListSelection.prototype.size = function () {
            this.update();
            return this._indices.length;
        };
        DListSelection.prototype.isEmpty = function () {
            return this.size() <= 0;
        };
        DListSelection.prototype.first = function () {
            return this.get(0);
        };
        DListSelection.prototype.get = function (index) {
            this.update();
            var indices = this._indices;
            if (0 <= index && index < indices.length) {
                var content = this._content;
                var child = content.children[indices[index]];
                if (child != null) {
                    return child;
                }
            }
            return null;
        };
        DListSelection.prototype.getIndex = function (index) {
            this.update();
            var indices = this._indices;
            if (0 <= index && index < indices.length) {
                return indices[index];
            }
            return null;
        };
        DListSelection.prototype.clear = function () {
            this.update();
            var indices = this._indices;
            if (0 < indices.length) {
                var content = this._content;
                var children = content.children;
                for (var i = 0, imax = indices.length; i < imax; ++i) {
                    var child = children[indices[i]];
                    if (child instanceof DBase) {
                        child.setActive(false);
                    }
                }
                indices.length = 0;
                this.emit("change", this);
            }
        };
        DListSelection.prototype.add = function (target) {
            var mode = this._mode;
            var content = this._content;
            if (mode === DListSelectionMode.SINGLE) {
                if (!target.isActive()) {
                    this.update();
                    // Remove the existing
                    var indices = this._indices;
                    var children = content.children;
                    for (var i = 0, imax = indices.length; i < imax; ++i) {
                        var child = children[indices[i]];
                        if (child instanceof DBase) {
                            child.setActive(false);
                        }
                    }
                    indices.length = 0;
                    // Add a new child
                    indices.push(content.getChildIndex(target));
                    target.setActive(true);
                    // Event
                    this.emit("change", this);
                }
            }
            else if (mode === DListSelectionMode.MULTIPLE) {
                if (!target.isActive()) {
                    if (this._isDirty) {
                        target.setActive(true);
                        this.emit("change", this);
                    }
                    else {
                        // Find an insertion position
                        var indices = this._indices;
                        var targetIndex = content.getChildIndex(target);
                        for (var i = 0, imax = indices.length; i < imax; ++i) {
                            var index = indices[i];
                            if (targetIndex === index) {
                                target.setActive(true);
                                return;
                            }
                            else if (targetIndex < index) {
                                indices.splice(i, 0, targetIndex);
                                target.setActive(true);
                                this.emit("change", this);
                                return;
                            }
                        }
                        // Push
                        indices.push(targetIndex);
                        target.setActive(true);
                        this.emit("change", this);
                    }
                }
            }
        };
        DListSelection.prototype.remove = function (target) {
            if (!target.isActive()) {
                if (this._isDirty) {
                    target.setActive(false);
                    this.emit("change", this);
                }
                else {
                    var indices = this._indices;
                    var content = this._content;
                    var targetIndex = content.getChildIndex(target);
                    for (var i = 0, imax = indices.length; i < imax; ++i) {
                        var index = indices[i];
                        if (targetIndex === index) {
                            indices.splice(i, 1);
                            target.setActive(false);
                            this.emit("change", this);
                            return;
                        }
                    }
                }
            }
        };
        return DListSelection;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DContent = /** @class */ (function (_super) {
        __extends(DContent, _super);
        function DContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DContent.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.UNFOCUSABLE, true);
        };
        DContent.prototype.initReflowable = function () {
            // DO NOTHING
        };
        DContent.prototype.getType = function () {
            return "DContent";
        };
        return DContent;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBar = /** @class */ (function (_super) {
        __extends(DScrollBar, _super);
        function DScrollBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBar.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._start = 0;
            this._end = 1;
            var thumb = this._thumb = this.createThumb(options != null ? options.thumb : undefined);
            this.addChild(thumb);
            this.setState(DBaseState.UNFOCUSABLE, true);
        };
        Object.defineProperty(DScrollBar.prototype, "thumb", {
            get: function () {
                return this._thumb;
            },
            enumerable: true,
            configurable: true
        });
        DScrollBar.prototype.getType = function () {
            return "DScrollBar";
        };
        DScrollBar.prototype.setRegion = function (start, end, size) {
            if (size < 1) {
                start = 0;
                end = 1;
            }
            else {
                start = Math.max(0, Math.min(1, start / size));
                end = Math.max(start, Math.min(1, end / size));
            }
            if (this._start !== start || this._end !== end) {
                this._start = start;
                this._end = end;
                this.onRegionChange();
            }
        };
        DScrollBar.prototype.isRegionVisible = function () {
            return 0 < this._start || this._end < 1;
        };
        DScrollBar.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.onRegionChange();
        };
        DScrollBar.prototype.onRegionChange = function () {
            // DO NOTHING
        };
        DScrollBar.prototype.getRegionStart = function () {
            return this._start;
        };
        DScrollBar.prototype.getRegionEnd = function () {
            return this._end;
        };
        return DScrollBar;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumb = /** @class */ (function (_super) {
        __extends(DScrollBarThumb, _super);
        function DScrollBarThumb() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumb.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.UNFOCUSABLE, true);
            var position = new pixi_js.Point();
            this._dragUtil = new UtilDrag({
                target: this,
                easing: false,
                on: {
                    start: function () {
                        position.copyFrom(_this.position);
                    },
                    move: function (dx, dy) {
                        position.set(position.x + dx, position.y + dy);
                        _this.onDragMove(position.x, position.y);
                    }
                }
            });
        };
        DScrollBarThumb.prototype.getMinimumSize = function () {
            return this.theme.getMinimumSize();
        };
        DScrollBarThumb.prototype.getType = function () {
            return "DScrollBarThumb";
        };
        return DScrollBarThumb;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbReflowableHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarThumbReflowableHorizontal, _super);
        function DScrollBarThumbReflowableHorizontal(base) {
            var _this = _super.call(this) || this;
            base.appendRenderable(_this, true);
            base.addReflowable(_this);
            return _this;
        }
        DScrollBarThumbReflowableHorizontal.prototype.onReflow = function (base, width, height) {
            var state = base.state;
            this.clear();
            var background = base.background;
            var backgroundColor = background.getColor(state);
            var backgroundAlpha = background.getAlpha(state);
            if (backgroundColor != null) {
                var size = 1;
                this.beginFill(backgroundColor, backgroundAlpha);
                this.lineStyle(0, 0, 0, 0);
                this.drawRect(0, height * 0.5 - size, width, size * 2);
                this.endFill();
                this.visible = true;
            }
            else {
                this.visible = false;
            }
        };
        return DScrollBarThumbReflowableHorizontal;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarThumbHorizontal, _super);
        function DScrollBarThumbHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumbHorizontal.prototype.onDragMove = function (dx, dy) {
            this.emit("regionmove", dx, this);
        };
        DScrollBarThumbHorizontal.prototype.initReflowable = function () {
            new DScrollBarThumbReflowableHorizontal(this);
        };
        return DScrollBarThumbHorizontal;
    }(DScrollBarThumb));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarHorizontal, _super);
        function DScrollBarHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarHorizontal.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.on(UtilPointerEvent.down, function (e) {
                if (e.target === _this) {
                    var width = _this.width;
                    if (0 < width) {
                        var size = _this._end - _this._start;
                        var position = e.data.getLocalPosition(_this);
                        var newStart = Math.min(1 - size, Math.max(0, position.x / width - size * 0.5));
                        if (_this._start !== newStart) {
                            _this.emit("regionmove", newStart, _this);
                        }
                    }
                }
            });
            this._thumb.on("regionmove", function (x) {
                var width = _this.width;
                if (0 < width) {
                    var size = _this._end - _this._start;
                    var newStart = Math.min(1 - size, Math.max(0, x / width));
                    if (_this._start !== newStart) {
                        _this.emit("regionmove", newStart, _this);
                    }
                }
            });
        };
        DScrollBarHorizontal.prototype.createThumb = function (options) {
            return new DScrollBarThumbHorizontal(options);
        };
        DScrollBarHorizontal.prototype.onRegionChange = function () {
            var thumb = this._thumb;
            var width = this.width;
            var height = this.height;
            var thumbMinimumSize = Math.min(width * 0.5, thumb.getMinimumSize());
            var space = width - thumbMinimumSize;
            var barStart = space * this._start;
            var barSize = space * this._end + thumbMinimumSize - barStart;
            thumb.position.set(barStart, 0);
            thumb.resize(barSize, height);
            _super.prototype.onRegionChange.call(this);
        };
        return DScrollBarHorizontal;
    }(DScrollBar));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbReflowableVertical = /** @class */ (function (_super) {
        __extends(DScrollBarThumbReflowableVertical, _super);
        function DScrollBarThumbReflowableVertical(base) {
            var _this = _super.call(this) || this;
            base.appendRenderable(_this, true);
            base.addReflowable(_this);
            return _this;
        }
        DScrollBarThumbReflowableVertical.prototype.onReflow = function (base, width, height) {
            var state = base.state;
            this.clear();
            var background = base.background;
            var backgroundColor = background.getColor(state);
            var backgroundAlpha = background.getAlpha(state);
            if (backgroundColor != null) {
                var size = 1;
                this.beginFill(backgroundColor, backgroundAlpha);
                this.lineStyle(0, 0, 0, 0);
                this.drawRect(width * 0.5 - size, 0, size * 2, height);
                this.endFill();
                this.visible = true;
            }
            else {
                this.visible = false;
            }
        };
        return DScrollBarThumbReflowableVertical;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbVertocal = /** @class */ (function (_super) {
        __extends(DScrollBarThumbVertocal, _super);
        function DScrollBarThumbVertocal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumbVertocal.prototype.onDragMove = function (dx, dy) {
            this.emit("regionmove", dy, this);
        };
        DScrollBarThumbVertocal.prototype.initReflowable = function () {
            new DScrollBarThumbReflowableVertical(this);
        };
        return DScrollBarThumbVertocal;
    }(DScrollBarThumb));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarVertical = /** @class */ (function (_super) {
        __extends(DScrollBarVertical, _super);
        function DScrollBarVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarVertical.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.on(UtilPointerEvent.down, function (e) {
                if (e.target === _this) {
                    var height = _this.height;
                    if (0 < height) {
                        var size = _this._end - _this._start;
                        var position = e.data.getLocalPosition(_this);
                        var newStart = Math.min(1 - size, Math.max(0, position.y / height - size * 0.5));
                        if (_this._start !== newStart) {
                            _this.emit("regionmove", newStart, _this);
                        }
                    }
                    e.stopPropagation();
                }
            });
            this._thumb.on("regionmove", function (y) {
                var height = _this.height;
                if (0 < height) {
                    var size = _this._end - _this._start;
                    var newStart = Math.min(1 - size, Math.max(0, y / height));
                    if (_this._start !== newStart) {
                        _this.emit("regionmove", newStart, _this);
                    }
                }
            });
        };
        DScrollBarVertical.prototype.createThumb = function (options) {
            return new DScrollBarThumbVertocal(options);
        };
        DScrollBarVertical.prototype.onRegionChange = function () {
            var thumb = this._thumb;
            var width = this.width;
            var height = this.height;
            var thumbMinimumSize = Math.min(height * 0.5, thumb.getMinimumSize());
            var space = height - thumbMinimumSize;
            var barStart = space * this._start;
            var barSize = space * this._end + thumbMinimumSize - barStart;
            thumb.position.set(0, barStart);
            thumb.resize(width, barSize);
            _super.prototype.onRegionChange.call(this);
        };
        return DScrollBarVertical;
    }(DScrollBar));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Option parsers
    var isOverflowMaskEnabled$2 = function (theme, options) {
        if (options && options.mask != null) {
            return options.mask;
        }
        return theme.isOverflowMaskEnabled();
    };
    var toBarOptionsVertical = function (options) {
        return options && options.bar && options.bar.vertical;
    };
    var toBarOptionsHorizontal = function (options) {
        return options && options.bar && options.bar.horizontal;
    };
    // Class
    var DPane = /** @class */ (function (_super) {
        __extends(DPane, _super);
        function DPane() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPane.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._overflowMask = null;
            // Content
            var theme = this.theme;
            var content = this._content = this.toContent(options);
            if (isOverflowMaskEnabled$2(theme, options)) {
                this.mask = this.getOrCreateOverflowMask();
            }
            this.addChild(content);
            // Scroll bar
            this.initScrollBar(content, theme, options);
            // Drag
            this.initDrag(content, theme, options);
        };
        DPane.prototype.initDrag = function (content, theme, options) {
            var _this = this;
            var dragMode = (options && options.drag && options.drag.mode != null ?
                (isString(options.drag.mode) ? DDragMode[options.drag.mode] : options.drag.mode) :
                theme.getDragMode());
            // Edge does not fire the wheel event when scrolling using the 2-fingure scroll gesture on a touchpad.
            // Instead, it fires touch events. This is why the dragging is enabled regardless of the `UtilPointerEvent.touchable`.
            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7134034/
            if (dragMode === DDragMode.ON || dragMode === DDragMode.TOUCH) {
                var position_1 = new pixi_js.Point();
                this._dragUtil = new UtilDrag({
                    target: this,
                    touch: dragMode === DDragMode.TOUCH,
                    on: {
                        start: function () {
                            position_1.copyFrom(content.position);
                        },
                        move: function (dx, dy) {
                            position_1.set(position_1.x + dx, position_1.y + dy);
                            content.position.set(_this.toContentX(content, position_1.x), _this.toContentY(content, position_1.y));
                        }
                    }
                });
            }
        };
        DPane.prototype.onRegionMoveX = function (content, start) {
            var dragUtil = this._dragUtil;
            if (dragUtil != null) {
                dragUtil.stop();
            }
            content.x = -content.width * start;
        };
        DPane.prototype.onRegionMoveY = function (content, start) {
            var dragUtil = this._dragUtil;
            if (dragUtil != null) {
                dragUtil.stop();
            }
            content.y = -content.height * start;
        };
        DPane.prototype.initScrollBar = function (content, theme, options) {
            var _this = this;
            // Vertical bar
            var verticalBar = this._verticalBar = new DScrollBarVertical(toBarOptionsVertical(options));
            verticalBar.on("regionmove", function (start) {
                _this.onRegionMoveY(content, start);
            });
            this.addChild(verticalBar);
            // Horizontal bar
            var horizontalBar = this._horizontalBar = new DScrollBarHorizontal(toBarOptionsHorizontal(options));
            horizontalBar.on("regionmove", function (start) {
                _this.onRegionMoveX(content, start);
            });
            this.addChild(horizontalBar);
            //
            content.on("move", function () {
                _this.onContentChanged();
            });
            content.on("resize", function () {
                _this.onContentChanged();
            });
            this.updateScrollBar();
        };
        DPane.prototype.getType = function () {
            return "DPane";
        };
        Object.defineProperty(DPane.prototype, "content", {
            get: function () {
                return this._content;
            },
            enumerable: true,
            configurable: true
        });
        DPane.prototype.toContent = function (options) {
            if (options && options.content) {
                var content = options.content;
                if (content instanceof DBase) {
                    return content;
                }
                else {
                    return this.newContent(content);
                }
            }
            return this.newContent();
        };
        DPane.prototype.newContent = function (options) {
            return new DContent(options);
        };
        DPane.prototype.getOrCreateOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.addReflowable(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        DPane.prototype.onWheel = function (e, deltas, global) {
            var content = this._content;
            var x = this.getWheelContentX(content, deltas.deltaX * deltas.lowest);
            var y = this.getWheelContentY(content, deltas.deltaY * deltas.lowest);
            if (content.x !== x || content.y !== y) {
                var dragUtil = this._dragUtil;
                if (dragUtil != null) {
                    dragUtil.stop();
                }
                content.position.set(x, y);
                return true;
            }
            return false;
        };
        DPane.prototype.getWheelContentX = function (content, delta) {
            if (0 < delta || delta < 0) {
                var speed = this.theme.getWheelSpeed();
                return this.toContentX(content, content.x - delta * speed);
            }
            return content.x;
        };
        DPane.prototype.getWheelContentY = function (content, delta) {
            if (0 < delta || delta < 0) {
                var speed = this.theme.getWheelSpeed();
                return this.toContentY(content, content.y + delta * speed);
            }
            return content.y;
        };
        DPane.prototype.toContentX = function (content, x) {
            return Math.min(0, Math.max(this.width - content.width, x));
        };
        DPane.prototype.toContentY = function (content, y) {
            return Math.min(0, Math.max(this.height - content.height, y));
        };
        DPane.prototype.isRefitable = function (target) {
            return _super.prototype.isRefitable.call(this, target) && !(target instanceof DScrollBar);
        };
        DPane.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.updateScrollBar();
        };
        DPane.prototype.onContentChanged = function () {
            this.updateScrollBar();
        };
        DPane.prototype.updateScrollBar = function () {
            var verticalBar = this._verticalBar;
            var horizontalBar = this._horizontalBar;
            if (verticalBar != null && horizontalBar != null) {
                this.updateScrollBarRegions(verticalBar, horizontalBar);
                this.updateScrollBarVisibilities(verticalBar, horizontalBar);
                this.updateScrollBarPositions(verticalBar, horizontalBar);
            }
        };
        DPane.prototype.getScrollBarOffsetHorizontalStart = function (size) {
            return size * 0.5;
        };
        DPane.prototype.getScrollBarOffsetHorizontalEnd = function (size) {
            return size * 0.5;
        };
        DPane.prototype.getScrollBarOffsetVerticalStart = function (size) {
            return size * 0.5;
        };
        DPane.prototype.getScrollBarOffsetVerticalEnd = function (size) {
            return size * 0.5;
        };
        DPane.prototype.updateScrollBarPositions = function (verticalBar, horizontalBar) {
            var width = this.width;
            var height = this.height;
            var verticalBarWidth = verticalBar.width;
            var verticalBarOffsetStart = this.getScrollBarOffsetVerticalStart(verticalBarWidth);
            var verticalBarOffsetEnd = this.getScrollBarOffsetVerticalEnd(verticalBarWidth);
            verticalBar.position.set(width - verticalBarWidth, verticalBarOffsetStart);
            verticalBar.height = height - verticalBarOffsetStart - verticalBarOffsetEnd;
            var horizontalBarHeight = horizontalBar.height;
            var horizontalBarOffsetStart = this.getScrollBarOffsetHorizontalStart(horizontalBarHeight);
            var horizontalBarOffsetEnd = this.getScrollBarOffsetHorizontalEnd(horizontalBarHeight);
            horizontalBar.position.set(horizontalBarOffsetStart, height - horizontalBarHeight);
            horizontalBar.width = width - horizontalBarOffsetStart - horizontalBarOffsetEnd;
        };
        DPane.prototype.updateScrollBarRegions = function (verticalBar, horizontalBar) {
            var content = this._content;
            var x = -content.x;
            var y = -content.y;
            horizontalBar.setRegion(x, x + this.width, content.width);
            verticalBar.setRegion(y, y + this.height, content.height);
        };
        DPane.prototype.updateScrollBarVisibilities = function (verticalBar, horizontalBar) {
            var isChangedHorizontal = this.updateScrollBarVisibility(horizontalBar);
            var isChangedVertical = this.updateScrollBarVisibility(verticalBar);
            if (isChangedHorizontal || isChangedVertical) {
                // Update the overflow mask
                var overflowMask = this._overflowMask;
                if (overflowMask != null) {
                    if (horizontalBar.visible || verticalBar.visible) {
                        var content = this._content;
                        if (content.mask !== overflowMask) {
                            content.mask = overflowMask;
                        }
                    }
                    else {
                        var content = this._content;
                        if (content.mask) {
                            content.mask = null;
                        }
                    }
                }
                // Rerender
                DApplications.update(this);
            }
        };
        DPane.prototype.updateScrollBarVisibility = function (bar) {
            var isRegionVisible = bar.isRegionVisible();
            if (bar.visible !== isRegionVisible) {
                bar.visible = isRegionVisible;
                return true;
            }
            return false;
        };
        DPane.prototype.onChildFocused = function (focused) {
            var work = DPane.WORK_ON_FOCUSED;
            var content = this.content;
            var contentX = content.x;
            var contentY = content.y;
            var contentWidth = content.width;
            var contentHeight = content.height;
            work.set(0, 0);
            focused.toGlobal(work, work, false);
            content.toLocal(work, undefined, work, false);
            var x0 = contentX + Math.min(contentWidth, Math.max(0, work.x));
            var y0 = contentY + Math.min(contentHeight, Math.max(0, work.y));
            work.set(focused.width, focused.height);
            focused.toGlobal(work, work, true);
            content.toLocal(work, undefined, work, true);
            var x1 = contentX + Math.min(contentWidth, Math.max(0, work.x));
            var y1 = contentY + Math.min(contentHeight, Math.max(0, work.y));
            var width = this.width;
            var newX = null;
            if (x0 < 0) {
                if (x1 <= width) {
                    newX = contentX - Math.max(x0, x1 - width);
                    newX = Math.max(width - contentWidth, Math.min(0, newX));
                }
            }
            else {
                if (width < x1) {
                    newX = contentX - Math.min(x0, x1 - width);
                    newX = Math.max(width - contentWidth, Math.min(0, newX));
                }
            }
            var height = this.height;
            var newY = null;
            if (y0 < 0) {
                if (y1 <= height) {
                    newY = contentY - Math.max(y0, y1 - height);
                    newY = Math.max(height - contentHeight, Math.min(0, newY));
                }
            }
            else {
                if (height < y1) {
                    newY = contentY - Math.min(y0, y1 - height);
                    newY = Math.max(height - contentHeight, Math.min(0, newY));
                }
            }
            if (newX != null) {
                if (newY != null) {
                    content.position.set(newX, newY);
                }
                else {
                    content.position.x = newX;
                }
            }
            else {
                if (newY != null) {
                    content.position.y = newY;
                }
            }
            _super.prototype.onChildFocused.call(this, focused);
        };
        DPane.prototype.destroy = function () {
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            this.mask = null;
            _super.prototype.destroy.call(this);
        };
        DPane.WORK_ON_FOCUSED = new pixi_js.Point();
        return DPane;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DList = /** @class */ (function (_super) {
        __extends(DList, _super);
        function DList() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DList.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var selection = options && options.selection;
            this._selection = (selection instanceof DListSelection ?
                selection : this.newSelection(selection));
            UtilPointerEvent.onClick(this, function (e) {
                var child = _this.findItem(e.target);
                if (child instanceof DBase && child.isActionable()) {
                    _this.selection.add(child);
                }
            });
        };
        DList.prototype.newSelection = function (options) {
            return new DListSelection(this._content, options);
        };
        DList.prototype.onChildrenDirty = function () {
            var selection = this._selection;
            if (selection != null) {
                selection.toDirty();
            }
            _super.prototype.onChildrenDirty.call(this);
        };
        Object.defineProperty(DList.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: true,
            configurable: true
        });
        DList.prototype.findItem = function (target) {
            var content = this.content;
            var current = target;
            while (current != null) {
                if (current.parent === content) {
                    return current;
                }
                current = current.parent;
            }
            return null;
        };
        DList.prototype.onRefit = function () {
            _super.prototype.onRefit.call(this);
            this.updateChildPosition();
            this.updateChildVisibility();
        };
        DList.prototype.updateChildPosition = function () {
            var content = this.content;
            var items = content.children;
            var y = 0;
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (item instanceof DBase) {
                    item.y = y;
                    y += item.height;
                }
            }
            var scrollLimit = Math.min(0, -y + this.height);
            if (content.y < scrollLimit) {
                content.y = scrollLimit;
            }
            content.height = y;
        };
        DList.prototype.updateChildVisibility = function () {
            var content = this.content;
            var items = content.children;
            var from = -content.y;
            var to = from + this.height;
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (item instanceof DBase) {
                    var itemY = item.y;
                    item.visible = (from <= itemY + item.height && itemY <= to);
                }
            }
        };
        DList.prototype.onContentChanged = function () {
            _super.prototype.onContentChanged.call(this);
            this.updateChildVisibility();
        };
        DList.prototype.getType = function () {
            return "DList";
        };
        return DList;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectList = /** @class */ (function (_super) {
        __extends(DDialogSelectList, _super);
        function DDialogSelectList(options) {
            var _this = _super.call(this, options) || this;
            _this.setState(DBaseState.UNFOCUSABLE, true);
            return _this;
        }
        DDialogSelectList.prototype.getType = function () {
            return "DDialogSelectList";
        };
        return DDialogSelectList;
    }(DList));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectListItem = /** @class */ (function (_super) {
        __extends(DDialogSelectListItem, _super);
        function DDialogSelectListItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelectListItem.prototype.getType = function () {
            return "DDialogSelectListItem";
        };
        return DDialogSelectListItem;
    }(DListItem));

    var DDialogSelectSearh = /** @class */ (function (_super) {
        __extends(DDialogSelectSearh, _super);
        function DDialogSelectSearh(search) {
            var _this = _super.call(this) || this;
            _this._search = search || (function (_) { return Promise.resolve([]); });
            _this._id = 0;
            _this._idCompleted = 0;
            _this._result = null;
            return _this;
        }
        DDialogSelectSearh.prototype.create = function (args) {
            var _this = this;
            var id = ++this._id;
            this._search(args[0]).then(function (searchResult) {
                if (_this._id === id) {
                    _this._idCompleted = id;
                    _this._result = searchResult;
                    _this.emit("success", _this, searchResult);
                    _this.emit("change", _this);
                }
            }, function () {
                if (_this._id === id) {
                    _this._idCompleted = id;
                    _this._result = null;
                    _this.emit("fail", _this);
                    _this.emit("change", _this);
                }
            });
            this.emit("change", this);
        };
        DDialogSelectSearh.prototype.isDone = function () {
            return this._id === this._idCompleted;
        };
        DDialogSelectSearh.prototype.getResult = function () {
            return this._result;
        };
        return DDialogSelectSearh;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNote = /** @class */ (function (_super) {
        __extends(DNote, _super);
        function DNote() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNote.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.visible = false;
        };
        DNote.prototype.getType = function () {
            return "DNote";
        };
        return DNote;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Helper
    var toItemTextFormatter = function (theme, options) {
        if (options) {
            var item = options.item;
            if (item) {
                var text = item.text;
                if (text) {
                    return text.formatter || theme.getItemTextFormatter();
                }
            }
        }
        return theme.getItemTextFormatter();
    };
    var toNoteOptions = function (options, parent, text) {
        if (options != null) {
            if (options.parent == null) {
                options.parent = parent;
            }
            if (options.text == null) {
                options.text = {
                    value: text
                };
            }
            else if (options.text.value == null) {
                options.text.value = text;
            }
            return options;
        }
        return {
            parent: parent,
            text: {
                value: text
            }
        };
    };
    var toNoteNoItemsOptions = function (theme, options, parent) {
        var note = options && options.note;
        return toNoteOptions(note && note.noItems, parent, theme.getNoteNoItemsText());
    };
    var toNoteSearchingOptions = function (theme, options, parent) {
        var note = options && options.note;
        return toNoteOptions(note && note.noItems, parent, theme.getNoteSearchingText());
    };
    var toSearch = function (controller) {
        if (controller) {
            var search = controller.search;
            if ("create" in search) {
                return search;
            }
            else {
                return new DDialogSelectSearh(search);
            }
        }
        else {
            return new DDialogSelectSearh();
        }
    };
    var DDialogSelect = /** @class */ (function (_super) {
        __extends(DDialogSelect, _super);
        function DDialogSelect() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelect.prototype.onInit = function (layout, options) {
            var _this = this;
            this._value = null;
            var theme = this.theme;
            this._itemTextFormatter = toItemTextFormatter(theme, options);
            // Search box
            this._input = new DInputText({
                parent: layout,
                width: "padding"
            });
            // List
            var list = this._list = new DDialogSelectList({
                parent: layout,
                width: "padding",
                selection: {
                    on: {
                        change: function (selection) {
                            var item = selection.first();
                            if (item != null) {
                                _this._value = item.value;
                                _this.onOk();
                            }
                        }
                    }
                }
            });
            // Text No Items
            var noteNoItems = new DNote(toNoteNoItemsOptions(theme, options, list));
            this._noteNoItems = noteNoItems;
            // Text Searching
            var noteSearching = new DNote(toNoteSearchingOptions(theme, options, list));
            this._noteSearching = noteSearching;
            // Controller binding
            var search = toSearch(options && options.controller);
            this._search = search;
            this._input.on("input", function (value) {
                search.create([value]);
            });
            search.on("success", function (e, results) {
                _this.onSearched(results);
            });
            // Visibility
            var transition = new UtilTransition();
            search.on("change", function () {
                if (search.isDone()) {
                    var result = search.getResult();
                    if (result != null && 0 < result.length) {
                        transition.hide();
                    }
                    else {
                        transition.show(noteNoItems);
                    }
                }
                else {
                    transition.show(noteSearching);
                }
            });
        };
        DDialogSelect.prototype.onSearched = function (results) {
            var list = this._list;
            var itemTextFormatter = this._itemTextFormatter;
            var content = list.content;
            var children = content.children;
            // Update the existing children
            var childrenLength = children.length;
            var searchResultsLength = results.length;
            var minLength = Math.min(childrenLength, searchResultsLength);
            for (var i = 0, imax = minLength; i < imax; ++i) {
                var child = children[i];
                var result = results[i];
                if (child instanceof DListItem) {
                    child.text = itemTextFormatter(result, this);
                    child.value = result;
                }
                else {
                    content.removeChildAt(i);
                    child.destroy();
                    var newChild = this.newItem(result, itemTextFormatter(result, this));
                    content.addChildAt(newChild, i);
                }
            }
            // Insert new children
            for (var i = minLength, imax = searchResultsLength; i < imax; ++i) {
                var result = results[i];
                var newChild = this.newItem(result, itemTextFormatter(result, this));
                content.addChild(newChild);
            }
            // Remove unused children
            for (var i = childrenLength - 1; minLength <= i; --i) {
                children[i].destroy();
            }
        };
        DDialogSelect.prototype.newItem = function (result, label) {
            return new DDialogSelectListItem({
                value: result,
                text: {
                    value: label
                }
            });
        };
        Object.defineProperty(DDialogSelect.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        DDialogSelect.prototype.getType = function () {
            return "DDialogSelect";
        };
        DDialogSelect.prototype.onOpen = function () {
            _super.prototype.onOpen.call(this);
            this._list.selection.clear();
            this._search.create([this._input.value]);
        };
        DDialogSelect.prototype.onOk = function () {
            this.emit("select", this._value, this);
            _super.prototype.onOk.call(this);
        };
        DDialogSelect.prototype.destroy = function () {
            this._input.destroy();
            this._noteNoItems.destroy();
            this._noteSearching.destroy();
            this._list.destroy();
            _super.prototype.destroy.call(this);
        };
        return DDialogSelect;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var defaultGetter = function (dialog) {
        // Assumes the dialog.value is VALUE.
        return dialog.value;
    };
    var defaultSetter = function () {
        // DO NOTHING
    };
    var DButtonSelect = /** @class */ (function (_super) {
        __extends(DButtonSelect, _super);
        function DButtonSelect() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonSelect.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, this.toOptions(options));
            var getter = (options && options.getter) || defaultGetter;
            var setter = (options && options.setter) || defaultSetter;
            this.on("active", function () {
                var dialog = _this.dialog;
                setter(dialog, _this._textValueComputed);
                dialog.open().then(function () {
                    var newValue = getter(dialog);
                    var oldValue = _this._textValueComputed;
                    if (newValue !== oldValue) {
                        _this.text = newValue;
                        _this.emit("change", newValue, oldValue, _this);
                    }
                });
            });
        };
        Object.defineProperty(DButtonSelect.prototype, "dialog", {
            get: function () {
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = this._options;
                    var dialogOptions = options && options.dialog;
                    if (dialogOptions && ("open" in dialogOptions)) {
                        dialog = dialogOptions;
                    }
                    else {
                        // Assumes DIALOG === DDialogSelect<DIALOG_VALUE>.
                        dialog = new DDialogSelect(dialogOptions);
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: true,
            configurable: true
        });
        DButtonSelect.prototype.toOptions = function (options) {
            var _a, _b, _c;
            if (options) {
                // Try to copy text.formatter to dialog.item.text.formatter at first
                var formatter = (_a = options.text) === null || _a === void 0 ? void 0 : _a.formatter;
                if (formatter !== undefined) {
                    var dialog = options.dialog;
                    if (!(dialog && "open" in dialog)) {
                        dialog = dialog || {};
                        var item = dialog.item = dialog.item || {};
                        var text = item.text = item.text || {};
                        if (text.formatter === undefined) {
                            // Assumes formatter is ( value: DIALOG_VALUE | null, caller: any ) => string.
                            text.formatter = formatter;
                        }
                    }
                }
                else {
                    // Try to copy dialog.item.text.formatter to text.formatter
                    var dialog = options.dialog;
                    if (!(dialog && "open" in dialog)) {
                        var dialogFormatter = (_c = (_b = dialog === null || dialog === void 0 ? void 0 : dialog.item) === null || _b === void 0 ? void 0 : _b.text) === null || _c === void 0 ? void 0 : _c.formatter;
                        if (dialogFormatter !== undefined) {
                            var text = options.text = options.text || {};
                            if (text.formatter === undefined) {
                                // Assumes dialogFormatter is ( value: VALUE | null, caller: any ) => string.
                                text.formatter = dialogFormatter;
                            }
                        }
                    }
                }
            }
            return options;
        };
        Object.defineProperty(DButtonSelect.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: true,
            configurable: true
        });
        DButtonSelect.prototype.getType = function () {
            return "DButtonSelect";
        };
        return DButtonSelect;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogTime = /** @class */ (function (_super) {
        __extends(DDialogTime, _super);
        function DDialogTime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogTime.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            var picker = new DPickerTime(options && options.picker);
            this._picker = picker;
            layout.addChild(picker);
        };
        Object.defineProperty(DDialogTime.prototype, "current", {
            get: function () {
                return this._picker.current;
            },
            set: function (dateCurrent) {
                this._picker.current = dateCurrent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogTime.prototype, "new", {
            get: function () {
                return this._picker.new;
            },
            set: function (dateNew) {
                this._picker.new = dateNew;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogTime.prototype, "picker", {
            get: function () {
                return this._picker;
            },
            enumerable: true,
            configurable: true
        });
        DDialogTime.prototype.getType = function () {
            return "DDialogTime";
        };
        return DDialogTime;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogTimes = /** @class */ (function () {
        function DDialogTimes() {
        }
        DDialogTimes.getInstance = function () {
            if (DDialogTimes.INSTANCE == null) {
                DDialogTimes.INSTANCE = new DDialogTime();
            }
            return DDialogTimes.INSTANCE;
        };
        return DDialogTimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonTime = /** @class */ (function (_super) {
        __extends(DButtonTime, _super);
        function DButtonTime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonTime.prototype.init = function (options) {
            var _this = this;
            this._dialogOptions = options && options.dialog;
            this._datetimeMask = DPickerTimes.toMask(options && options.dialog && options.dialog.picker);
            _super.prototype.init.call(this, options);
            this.on("active", function () {
                var currentTime = _this._textValueComputed.getTime();
                var dialog = _this.dialog;
                dialog.current = new Date(currentTime);
                dialog.new = new Date(currentTime);
                dialog.open().then(function () {
                    var dateNew = dialog.new;
                    var dateCurrent = dialog.current;
                    _this.text = new Date(dateNew.getTime());
                    _this.emit("change", dateNew, dateCurrent, _this);
                });
            });
        };
        DButtonTime.prototype.getDatetimeMask = function () {
            return this._datetimeMask;
        };
        Object.defineProperty(DButtonTime.prototype, "dialog", {
            get: function () {
                var dialog = this._dialog;
                if (dialog == null) {
                    var dialogOptions = this._dialogOptions;
                    if (dialogOptions != null) {
                        dialog = new DDialogTime(this._dialogOptions);
                    }
                    else {
                        dialog = DDialogTimes.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DButtonTime.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            set: function (value) {
                if (this._textValueComputed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        DButtonTime.prototype.getType = function () {
            return "DButtonTime";
        };
        return DButtonTime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonUndo = /** @class */ (function (_super) {
        __extends(DButtonUndo, _super);
        function DButtonUndo(options) {
            var _this = _super.call(this, options) || this;
            var commandController = DControllers.getCommandController();
            _this.setState(DBaseState.DISABLED, !commandController.isUndoable());
            commandController.on("change", function () {
                _this.setState(DBaseState.DISABLED, !commandController.isUndoable());
            });
            _this.on("active", function () {
                commandController.undo();
            });
            return _this;
        }
        return DButtonUndo;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCanvas = /** @class */ (function (_super) {
        __extends(DCanvas, _super);
        function DCanvas() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCanvas.prototype.getType = function () {
            return "DCanvas";
        };
        return DCanvas;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisPosition;
    (function (DChartAxisPosition) {
        DChartAxisPosition[DChartAxisPosition["TOP"] = 0] = "TOP";
        DChartAxisPosition[DChartAxisPosition["BOTTOM"] = 1] = "BOTTOM";
        DChartAxisPosition[DChartAxisPosition["LEFT"] = 2] = "LEFT";
        DChartAxisPosition[DChartAxisPosition["RIGHT"] = 3] = "RIGHT";
    })(DChartAxisPosition || (DChartAxisPosition = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisTickPosition;
    (function (DChartAxisTickPosition) {
        DChartAxisTickPosition[DChartAxisTickPosition["INSIDE"] = 0] = "INSIDE";
        DChartAxisTickPosition[DChartAxisTickPosition["OUTSIDE"] = 1] = "OUTSIDE";
    })(DChartAxisTickPosition || (DChartAxisTickPosition = {}));

    var EShapePointsStyles = /** @class */ (function () {
        function EShapePointsStyles() {
        }
        EShapePointsStyles.from = function (style) {
            if (isString(style)) {
                return EShapePointsStyle[style];
            }
            else if (isNumber(style)) {
                return style;
            }
            else {
                var result = EShapePointsStyle.NONE;
                for (var i = 0, imax = style.length; i < imax; ++i) {
                    result |= EShapePointsStyle[style[i]];
                }
                return result;
            }
        };
        return EShapePointsStyles;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisBaseOptionParser = /** @class */ (function () {
        function DChartAxisBaseOptionParser(theme, options) {
            this._coordinateIndex = (options && options.coordinate != null ? options.coordinate : 0);
            this._position = this.toPosition(theme, options);
            this._tick = this.toTickContainer(theme, options);
            this._label = this.toLabel(theme, options);
            this._padding = (options && options.padding != null ? options.padding : theme.getPadding());
            this._bar = this.toBar(theme, options);
        }
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "coordinateIndex", {
            get: function () {
                return this._coordinateIndex;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "bar", {
            get: function () {
                return this._bar;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "tick", {
            get: function () {
                return this._tick;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: true,
            configurable: true
        });
        DChartAxisBaseOptionParser.prototype.toPosition = function (theme, options) {
            var position = options && options.position;
            if (isString(position)) {
                return DChartAxisPosition[position];
            }
            else if (position != null) {
                return position;
            }
            return theme.getPosition();
        };
        DChartAxisBaseOptionParser.prototype.toBar = function (theme, options) {
            return {
                style: options && options.style != null ? options.style : theme.getStyle(),
                stroke: this.toBarStroke(theme, options && options.stroke),
                shape: undefined
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickContainer = function (theme, options) {
            var tick = options && options.tick;
            return {
                enable: (tick && tick.enable != null ? tick.enable : theme.getTickEnable()),
                major: this.toTickMajor(theme, tick),
                minor: this.toMinorTick(theme, tick)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajor = function (theme, options) {
            var major = options && options.major;
            var position = (major && major.position != null ? major.position :
                (options && options.position != null ? options.position : theme.getMajorTickPosition()));
            var optionsStyle = options && options.style;
            var style = EShapePointsStyles.from(major && major.style != null ? major.style :
                (optionsStyle != null ? optionsStyle : theme.getMajorTickStyle()));
            var optionsStroke = options && options.stroke;
            var stroke = this.toTickMajorStroke(theme, major && major.stroke, optionsStroke);
            return {
                count: (major && major.count != null ? major.count : theme.getMajorTickCount()),
                size: (major && major.size != null ? major.size : theme.getMajorTickSize()),
                position: this.toTickPosition(position),
                style: style,
                stroke: stroke,
                text: this.toMajorTickText(theme, major && major.text),
                formatter: this.toMajorTickFormatter(theme, major),
                shapes: undefined,
                gridline: this.toTickMajorGridline(theme, major && major.gridline, optionsStyle, optionsStroke)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorGridline = function (theme, options, optionsStyle, optionsStroke) {
            var style = EShapePointsStyles.from(options && options.style != null ? options.style :
                (optionsStyle != null ? optionsStyle : theme.getMajorTickGridlineStyle()));
            return {
                enable: options && options.enable != null ? options.enable : theme.getMajorTickGridlineEnable(),
                style: style,
                stroke: this.toTickMajorGridlineStroke(theme, options && options.stroke, optionsStroke),
                shapes: undefined
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickPosition = function (tickPosition) {
            var position = this._position;
            if (tickPosition === DChartAxisTickPosition.OUTSIDE || tickPosition === "OUTSIDE") {
                switch (position) {
                    case DChartAxisPosition.TOP:
                        return EShapeBarPosition.BOTTOM;
                    case DChartAxisPosition.BOTTOM:
                        return EShapeBarPosition.TOP;
                    case DChartAxisPosition.LEFT:
                        return EShapeBarPosition.RIGHT;
                    case DChartAxisPosition.RIGHT:
                        return EShapeBarPosition.LEFT;
                    default:
                        return EShapeBarPosition.TOP;
                }
            }
            else {
                switch (position) {
                    case DChartAxisPosition.TOP:
                        return EShapeBarPosition.TOP;
                    case DChartAxisPosition.BOTTOM:
                        return EShapeBarPosition.BOTTOM;
                    case DChartAxisPosition.LEFT:
                        return EShapeBarPosition.LEFT;
                    case DChartAxisPosition.RIGHT:
                        return EShapeBarPosition.RIGHT;
                    default:
                        return EShapeBarPosition.TOP;
                }
            }
        };
        DChartAxisBaseOptionParser.prototype.toMinorTick = function (theme, options) {
            var minor = options && options.major;
            var position = (minor && minor.position != null ? minor.position :
                (options && options.position != null ? options.position : theme.getMinorTickPosition()));
            var style = EShapePointsStyles.from(minor && minor.style != null ? minor.style :
                (options && options.style != null ? options.style : theme.getMinorTickStyle()));
            return {
                count: (minor && minor.count != null ? minor.count : theme.getMinorTickCount()),
                size: (minor && minor.size != null ? minor.size : theme.getMinorTickSize()),
                position: this.toTickPosition(position),
                style: style,
                stroke: this.toTickMinorStroke(theme, minor && minor.stroke, options && options.stroke),
                shapes: undefined
            };
        };
        DChartAxisBaseOptionParser.prototype.toBarStroke = function (theme, options) {
            return this.toStroke(options, undefined, theme.getStrokeEnable(), theme.getStrokeColor(), theme.getStrokeAlpha(), theme.getStrokeWidth(), theme.getStrokeAlign(), theme.getStrokeSide());
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMajorTickStrokeEnable(), theme.getMajorTickStrokeColor(), theme.getMajorTickStrokeAlpha(), theme.getMajorTickStrokeWidth(), theme.getMajorTickStrokeAlign(), theme.getMajorTickStrokeSide());
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorGridlineStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMajorTickGridlineStrokeEnable(), theme.getMajorTickGridlineStrokeColor(), theme.getMajorTickGridlineStrokeAlpha(), theme.getMajorTickGridlineStrokeWidth(), theme.getMajorTickGridlineStrokeAlign(), theme.getMajorTickGridlineStrokeSide());
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMinorTickStrokeEnable(), theme.getMinorTickStrokeColor(), theme.getMinorTickStrokeAlpha(), theme.getMinorTickStrokeWidth(), theme.getMinorTickStrokeAlign(), theme.getMinorTickStrokeSide());
        };
        DChartAxisBaseOptionParser.prototype.toStroke = function (optionsA, optionsB, enable, color, alpha, width, align, side) {
            if (optionsA) {
                if (optionsB) {
                    return {
                        enable: (optionsA.enable != null ? optionsA.enable :
                            (optionsB.enable != null ? optionsB.enable : enable)),
                        color: (optionsA.color != null ? optionsA.color :
                            (optionsB.color != null ? optionsB.color : color)),
                        alpha: (optionsA.alpha != null ? optionsA.alpha :
                            (optionsB.alpha != null ? optionsB.alpha : alpha)),
                        width: (optionsA.width != null ? optionsA.width :
                            (optionsB.width != null ? optionsB.width : width)),
                        align: (optionsA.align != null ? optionsA.align :
                            (optionsB.align != null ? optionsB.align : align)),
                        side: (optionsA.side != null ? optionsA.side :
                            (optionsB.side != null ? optionsB.side : side))
                    };
                }
                else {
                    return {
                        enable: (optionsA.enable != null ? optionsA.enable : enable),
                        color: (optionsA.color != null ? optionsA.color : color),
                        alpha: (optionsA.alpha != null ? optionsA.alpha : alpha),
                        width: (optionsA.width != null ? optionsA.width : width),
                        align: (optionsA.align != null ? optionsA.align : align),
                        side: (optionsA.side != null ? optionsA.side : side)
                    };
                }
            }
            else if (optionsB) {
                return {
                    enable: (optionsB.enable != null ? optionsB.enable : enable),
                    color: (optionsB.color != null ? optionsB.color : color),
                    alpha: (optionsB.alpha != null ? optionsB.alpha : alpha),
                    width: (optionsB.width != null ? optionsB.width : width),
                    align: (optionsB.align != null ? optionsB.align : align),
                    side: (optionsB.side != null ? optionsB.side : side)
                };
            }
            else {
                return {
                    enable: enable,
                    color: color,
                    alpha: alpha,
                    width: width,
                    align: align,
                    side: side
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickFormatter = function (theme, options) {
            var text = options && options.text;
            if (text) {
                var format = text.format;
                if (format != null) {
                    return NumberFormatters.create(format);
                }
                else {
                    var formatter = text.formatter;
                    if (formatter) {
                        return {
                            format: formatter
                        };
                    }
                }
            }
            return NumberFormatters.create(theme.getMajorTickTextFormat());
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickText = function (theme, options) {
            options = options || {};
            return {
                format: options.format,
                color: this.toMajorTickTextColor(theme, options.color),
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: options.weight,
                align: this.toMajorTickTextAlign(theme, options.align),
                offset: this.toMajorTickTextOffset(theme, options.offset),
                style: options.style,
                outline: this.toMajorTickTextOutline(theme, options.outline),
                spacing: this.toMajorTickTextSpacing(theme, options.spacing),
                direction: this.toTickMajorTextDirection(theme, options.direction),
                padding: this.toMajorTickTextPadding(theme, options.padding),
                clipping: options.clipping
            };
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextOutline = function (theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextAlign = function (theme, options) {
            var position = this._position;
            if (options) {
                return {
                    horizontal: (options.horizontal != null ? options.horizontal :
                        theme.getMajorTickTextAlignHorizontal(position)),
                    vertical: (options.vertical != null ? options.vertical :
                        theme.getMajorTickTextAlignVertical(position))
                };
            }
            return {
                horizontal: theme.getMajorTickTextAlignHorizontal(position),
                vertical: theme.getMajorTickTextAlignVertical(position)
            };
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextOffset = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextSpacing = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextPadding = function (theme, options) {
            return {
                horizontal: (options && options.horizontal != null ?
                    options.horizontal : theme.getMajorTickTextPaddingHorizontal()),
                vertical: (options && options.vertical != null ?
                    options.vertical : theme.getMajorTickTextPaddingVertical())
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextDirection = function (theme, options) {
            return (options != null ? options : theme.getMajorTickTextDirection());
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextColor = function (theme, options) {
            return (options != null ? options : theme.getMajorTickTextColor());
        };
        DChartAxisBaseOptionParser.prototype.toLabel = function (theme, options) {
            var label = options && options.label;
            if (label) {
                return {
                    value: label.value,
                    color: this.toLabelColor(theme, label.color),
                    alpha: label.alpha,
                    family: label.family,
                    size: label.size,
                    weight: label.weight,
                    align: this.toLabelAlign(theme, label.align),
                    offset: this.toLabelOffset(theme, label.offset),
                    style: label.style,
                    outline: this.toLabelOutline(theme, label.outline),
                    spacing: this.toLabelSpacing(theme, label.spacing),
                    direction: this.toLabelDirection(theme, label.direction),
                    padding: this.toLabelPadding(theme, label.padding),
                    clipping: label.clipping
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelOutline = function (theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelAlign = function (theme, options) {
            var position = this._position;
            if (options) {
                return {
                    horizontal: (options.horizontal != null ?
                        options.horizontal : theme.getLabelAlignHorizontal(position)),
                    vertical: (options.vertical != null ?
                        options.vertical : theme.getLabelAlignVertical(position))
                };
            }
            return {
                horizontal: theme.getLabelAlignHorizontal(position),
                vertical: theme.getLabelAlignVertical(position)
            };
        };
        DChartAxisBaseOptionParser.prototype.toLabelOffset = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelSpacing = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelPadding = function (theme, options) {
            return {
                horizontal: (options && options.horizontal != null ?
                    options.horizontal : theme.getLabelPaddingHorizontal()),
                vertical: (options && options.vertical != null ?
                    options.vertical : theme.getLabelPaddingVertical())
            };
        };
        DChartAxisBaseOptionParser.prototype.toLabelDirection = function (theme, options) {
            return (options != null ? options : theme.getLabelDirection());
        };
        DChartAxisBaseOptionParser.prototype.toLabelColor = function (theme, options) {
            return (options != null ? options : theme.getLabelColor());
        };
        return DChartAxisBaseOptionParser;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisBase = /** @class */ (function () {
        function DChartAxisBase(options) {
            var theme = this.toTheme(options);
            this._theme = theme;
            this._index = 0;
            var parser = new DChartAxisBaseOptionParser(theme, options);
            this._coordinateIndex = parser.coordinateIndex;
            this._padding = parser.padding;
            this._position = parser.position;
            var tick = parser.tick;
            this._tick = tick;
            this._label = parser.label;
            this._bar = parser.bar;
            this._majorTicks = new Float64Array(tick.major.count * 3);
            this._minorTicks = new Float64Array((tick.major.count + 1) * tick.minor.count * 3);
        }
        Object.defineProperty(DChartAxisBase.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: true,
            configurable: true
        });
        DChartAxisBase.prototype.updateBar = function (container) {
            var bar = this._bar;
            var barShape = bar.shape;
            if (barShape) {
                var plotArea = container.plotArea;
                var plotAreaWidth = plotArea.width;
                var plotAreaHeight = plotArea.height;
                var padding = this._padding * this._index;
                barShape.disallowUploadedUpdate();
                switch (this._position) {
                    case DChartAxisPosition.TOP:
                        barShape.transform.position.set(plotAreaWidth * 0.5, 0 - padding);
                        barShape.size.set(plotAreaWidth, 0);
                        break;
                    case DChartAxisPosition.BOTTOM:
                        barShape.transform.position.set(plotAreaWidth * 0.5, plotAreaHeight + padding);
                        barShape.size.set(plotAreaWidth, 0);
                        break;
                    case DChartAxisPosition.LEFT:
                        barShape.transform.position.set(0 - padding, plotAreaHeight * 0.5);
                        barShape.size.set(0, plotAreaHeight);
                        break;
                    case DChartAxisPosition.RIGHT:
                        barShape.transform.position.set(plotAreaWidth + padding, plotAreaHeight * 0.5);
                        barShape.size.set(0, plotAreaHeight);
                        break;
                }
                barShape.allowUploadedUpdate();
            }
        };
        DChartAxisBase.prototype.updateTicksX = function (domainMin, domainMax, coordinate, majorShapes, minorShapes, gridlineShapes, shapePositionY, transform, plotAreaHeight) {
            var tick = this._tick;
            var majorCount = tick.major.count;
            var majorFormatter = tick.major.formatter;
            var minorCountPerMajor = tick.minor.count;
            var minorCount = (majorCount + 1) * minorCountPerMajor;
            var majorTicks = this._majorTicks;
            var minorTicks = this._minorTicks;
            coordinate.ticks(domainMin, domainMax, majorCount, minorCountPerMajor, minorCount, majorTicks, minorTicks);
            var a = transform.a;
            var tx = transform.tx;
            for (var i = 0; i < majorCount; ++i) {
                var majorShape = majorShapes[i];
                var imajorTick = i * 3;
                var majorTickPosition = majorTicks[imajorTick + 0];
                if (!isNaN(majorTickPosition)) {
                    var majorTickProjectedPosition = majorTicks[imajorTick + 1];
                    var majotTickPositionX = a * majorTickProjectedPosition + tx;
                    var majorTickStep = majorTicks[imajorTick + 2];
                    majorShape.disallowUploadedUpdate();
                    majorShape.visible = true;
                    majorShape.transform.position.set(majotTickPositionX, shapePositionY);
                    majorShape.text.value = majorFormatter.format(majorTickPosition, majorTickStep);
                    majorShape.allowUploadedUpdate();
                    if (gridlineShapes) {
                        var gridlineShape = gridlineShapes[i];
                        gridlineShape.disallowUploadedUpdate();
                        gridlineShape.visible = true;
                        gridlineShape.transform.position.set(majotTickPositionX, plotAreaHeight * 0.5);
                        gridlineShape.size.set(0, plotAreaHeight);
                        gridlineShape.allowUploadedUpdate();
                    }
                }
                else {
                    majorShape.visible = false;
                    if (gridlineShapes) {
                        gridlineShapes[i].visible = false;
                    }
                }
            }
            for (var i = 0; i < minorCount; ++i) {
                var minorShape = minorShapes[i];
                var iminorTick = i * 3;
                var minorTickPosition = minorTicks[iminorTick + 0];
                var minorTickProjectedPosition = minorTicks[iminorTick + 1];
                if (!isNaN(minorTickPosition)) {
                    minorShape.disallowUploadedUpdate();
                    minorShape.visible = true;
                    minorShape.transform.position.set(a * minorTickProjectedPosition + tx, shapePositionY);
                    minorShape.allowUploadedUpdate();
                }
                else {
                    minorShape.visible = false;
                }
            }
        };
        DChartAxisBase.prototype.updateTicksY = function (domainMin, domainMax, coordinate, majorShapes, minorShapes, gridlineShapes, shapePositionX, transform, plotAreaWidth) {
            var tick = this._tick;
            var majorCount = tick.major.count;
            var majorFormatter = tick.major.formatter;
            var minorCountPerMajor = tick.minor.count;
            var minorCount = (majorCount + 1) * minorCountPerMajor;
            var majorTicks = this._majorTicks;
            var minorTicks = this._minorTicks;
            coordinate.ticks(domainMin, domainMax, majorCount, minorCountPerMajor, minorCount, majorTicks, minorTicks);
            var d = transform.d;
            var ty = transform.ty;
            for (var i = 0; i < majorCount; ++i) {
                var majorShape = majorShapes[i];
                var imajorTick = i * 3;
                var majorTickPosition = majorTicks[imajorTick + 0];
                if (!isNaN(majorTickPosition)) {
                    var majorTickProjectedPosition = majorTicks[imajorTick + 1];
                    var majotTickPositionY = d * majorTickProjectedPosition + ty;
                    var majorTickStep = majorTicks[imajorTick + 2];
                    majorShape.disallowUploadedUpdate();
                    majorShape.visible = true;
                    majorShape.transform.position.set(shapePositionX, majotTickPositionY);
                    majorShape.text.value = majorFormatter.format(majorTickPosition, majorTickStep);
                    majorShape.allowUploadedUpdate();
                    if (gridlineShapes) {
                        var gridlineShape = gridlineShapes[i];
                        gridlineShape.disallowUploadedUpdate();
                        gridlineShape.visible = true;
                        gridlineShape.transform.position.set(plotAreaWidth * 0.5, majotTickPositionY);
                        gridlineShape.size.set(plotAreaWidth, 0);
                        gridlineShape.allowUploadedUpdate();
                    }
                }
                else {
                    majorShape.visible = false;
                    if (gridlineShapes) {
                        gridlineShapes[i].visible = false;
                    }
                }
            }
            for (var i = 0; i < minorCount; ++i) {
                var minorShape = minorShapes[i];
                var iminorTick = i * 3;
                var minorTickPosition = minorTicks[iminorTick + 0];
                var minorTickProjectedPosition = minorTicks[iminorTick + 1];
                if (!isNaN(minorTickPosition)) {
                    minorShape.disallowUploadedUpdate();
                    minorShape.visible = true;
                    minorShape.transform.position.set(shapePositionX, d * minorTickProjectedPosition + ty);
                    minorShape.allowUploadedUpdate();
                }
                else {
                    minorShape.visible = false;
                }
            }
        };
        DChartAxisBase.prototype.updateTicks = function (container) {
            var tick = this._tick;
            var majorShapes = tick.major.shapes;
            var minorShapes = tick.minor.shapes;
            if (majorShapes && minorShapes) {
                var plotArea = container.plotArea;
                var bounds = plotArea.getBoundsInContainer();
                var transform = plotArea.container.transform.localTransform;
                var gridlineShapes = tick.major.gridline.shapes;
                var coordinateIndex = this._coordinateIndex;
                var padding = this._padding * this._index;
                var coordinate = void 0;
                switch (this._position) {
                    case DChartAxisPosition.TOP:
                        coordinate = plotArea.coordinate.x.get(coordinateIndex);
                        if (coordinate) {
                            var domainFrom = coordinate.unmap(coordinate.transform.unmap(bounds.x));
                            var domainTo = coordinate.unmap(coordinate.transform.unmap(bounds.x + bounds.width));
                            var plotAreaHeight = plotArea.height;
                            this.updateTicksX(domainFrom, domainTo, coordinate, majorShapes, minorShapes, gridlineShapes, 0 - padding, transform, plotAreaHeight);
                        }
                        break;
                    case DChartAxisPosition.BOTTOM:
                        coordinate = plotArea.coordinate.x.get(coordinateIndex);
                        if (coordinate) {
                            var domainFrom = coordinate.unmap(coordinate.transform.unmap(bounds.x));
                            var domainTo = coordinate.unmap(coordinate.transform.unmap(bounds.x + bounds.width));
                            var plotAreaHeight = plotArea.height;
                            this.updateTicksX(domainFrom, domainTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaHeight + padding, transform, plotAreaHeight);
                        }
                        break;
                    case DChartAxisPosition.LEFT:
                        coordinate = plotArea.coordinate.y.get(coordinateIndex);
                        if (coordinate) {
                            var domainFrom = coordinate.unmap(coordinate.transform.unmap(bounds.y));
                            var domainTo = coordinate.unmap(coordinate.transform.unmap(bounds.y + bounds.height));
                            var plotAreaWidth = plotArea.width;
                            this.updateTicksY(domainFrom, domainTo, coordinate, majorShapes, minorShapes, gridlineShapes, 0 - padding, transform, plotAreaWidth);
                        }
                        break;
                    case DChartAxisPosition.RIGHT:
                        coordinate = plotArea.coordinate.y.get(coordinateIndex);
                        if (coordinate) {
                            var domainFrom = coordinate.unmap(coordinate.transform.unmap(bounds.y));
                            var domainTo = coordinate.unmap(coordinate.transform.unmap(bounds.y + bounds.height));
                            var plotAreaWidth = plotArea.width;
                            this.updateTicksY(domainFrom, domainTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaWidth + padding, transform, plotAreaWidth);
                        }
                        break;
                }
            }
        };
        DChartAxisBase.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            var tickShapeContainer = container.container;
            // Bar
            var bar = this._bar;
            var barShape = bar.shape;
            if (!barShape) {
                var position = this._position;
                var barPosition = (position === DChartAxisPosition.LEFT || position === DChartAxisPosition.RIGHT ?
                    EShapeBarPosition.TOP : EShapeBarPosition.LEFT);
                barShape = new EShapeBar(barPosition, -1, EShapeDefaults.STROKE_WIDTH, bar.style);
                barShape.stroke.copy(bar.stroke);
                barShape.text.copy(this._label);
                this._bar.shape = barShape;
            }
            barShape.attach(container.container);
            // Major tick gridline
            var tick = this._tick;
            var tickMajor = tick.major;
            var gridline = tickMajor.gridline;
            var gridlineShapes = gridline.shapes;
            if (!gridlineShapes && tick.enable && gridline.enable) {
                gridlineShapes = [];
                gridline.shapes = gridlineShapes;
                var position = this._position;
                var gridlinePosition = (position === DChartAxisPosition.LEFT || position === DChartAxisPosition.RIGHT ?
                    EShapeBarPosition.LEFT : EShapeBarPosition.TOP);
                var gridlineCount = tickMajor.count;
                var gridlineStyle = gridline.style;
                for (var i = 0; i < gridlineCount; ++i) {
                    var gridlineShape = new EShapeBar(gridlinePosition, -1, EShapeDefaults.STROKE_WIDTH, gridlineStyle);
                    gridlineShape.stroke.copy(gridline.stroke);
                    gridlineShapes.push(gridlineShape);
                }
            }
            if (gridlineShapes) {
                for (var i = 0, imax = gridlineShapes.length; i < imax; ++i) {
                    gridlineShapes[i].attach(tickShapeContainer);
                }
            }
            // Major ticks
            var tickMajorShapes = tickMajor.shapes;
            if (!tickMajorShapes && tick.enable) {
                tickMajorShapes = [];
                tickMajor.shapes = tickMajorShapes;
                var tickMajorCount = tickMajor.count;
                var tickMajorSize = tickMajor.size;
                var tickMajorPosition = tickMajor.position;
                var tickMajorStyle = tickMajor.style;
                for (var i = 0; i < tickMajorCount; ++i) {
                    var tickMajorShape = new EShapeBar(tickMajorPosition, tickMajorSize, EShapeDefaults.STROKE_WIDTH, tickMajorStyle);
                    tickMajorShape.stroke.copy(tickMajor.stroke);
                    tickMajorShape.text.copy(tickMajor.text);
                    tickMajorShape.size.set(0, 0);
                    tickMajorShapes.push(tickMajorShape);
                }
            }
            if (tickMajorShapes) {
                for (var i = 0, imax = tickMajorShapes.length; i < imax; ++i) {
                    tickMajorShapes[i].attach(tickShapeContainer);
                }
            }
            // Minor ticks
            var tickMinor = tick.minor;
            var tickMinorShapes = tickMinor.shapes;
            if (!tickMinorShapes && tick.enable) {
                tickMinorShapes = [];
                tickMinor.shapes = tickMinorShapes;
                var tickMinorCount = tickMinor.count;
                var tickMinorSize = tickMinor.size;
                var tickMinorPosition = tickMinor.position;
                var tickMinorStyle = tickMinor.style;
                for (var i = 0, imax = (tickMajor.count + 1) * tickMinorCount; i < imax; ++i) {
                    var tickMinorShape = new EShapeBar(tickMinorPosition, tickMinorSize, EShapeDefaults.STROKE_WIDTH, tickMinorStyle);
                    tickMinorShape.stroke.copy(tickMinor.stroke);
                    tickMinorShape.size.set(0, 0);
                    tickMinorShapes.push(tickMinorShape);
                }
            }
            if (tickMinorShapes) {
                for (var i = 0, imax = tickMinorShapes.length; i < imax; ++i) {
                    tickMinorShapes[i].attach(tickShapeContainer);
                }
            }
        };
        DChartAxisBase.prototype.unbind = function () {
            // Bar
            var barShape = this._bar.shape;
            if (barShape) {
                barShape.detach();
            }
            // Major ticks
            var tick = this._tick;
            var tickMajorShapes = tick.major.shapes;
            if (tickMajorShapes) {
                for (var i = 0, imax = tickMajorShapes.length; i < imax; ++i) {
                    tickMajorShapes[i].detach();
                }
            }
            // Major tick gridlines
            var tickMajorGridlineShapes = tick.major.gridline.shapes;
            if (tickMajorGridlineShapes) {
                for (var i = 0, imax = tickMajorGridlineShapes.length; i < imax; ++i) {
                    tickMajorGridlineShapes[i].detach();
                }
            }
            // Minor ticks
            var tickMinorShapes = tick.minor.shapes;
            if (tickMinorShapes) {
                for (var i = 0, imax = tickMinorShapes.length; i < imax; ++i) {
                    tickMinorShapes[i].detach();
                }
            }
            //
            this._container = undefined;
        };
        DChartAxisBase.prototype.update = function () {
            var container = this._container;
            if (container) {
                this.updateBar(container);
                this.updateTicks(container);
            }
        };
        DChartAxisBase.prototype.destroy = function () {
            // Bar
            var barShape = this._bar.shape;
            if (barShape) {
                barShape.destroy();
            }
            // Major ticks
            var tick = this._tick;
            var tickMajorShapes = tick.major.shapes;
            if (tickMajorShapes) {
                for (var i = 0, imax = tickMajorShapes.length; i < imax; ++i) {
                    tickMajorShapes[i].destroy();
                }
            }
            // Major tick gridlines
            var tickMajorGridlineShapes = tick.major.gridline.shapes;
            if (tickMajorGridlineShapes) {
                for (var i = 0, imax = tickMajorGridlineShapes.length; i < imax; ++i) {
                    tickMajorGridlineShapes[i].destroy();
                }
            }
            // Minor ticks
            var tickMinorShapes = tick.minor.shapes;
            if (tickMinorShapes) {
                for (var i = 0, imax = tickMinorShapes.length; i < imax; ++i) {
                    tickMinorShapes[i].destroy();
                }
            }
            //
            this._container = undefined;
        };
        DChartAxisBase.prototype.toTheme = function (options) {
            return (options && options.theme) || this.getThemeDefault();
        };
        DChartAxisBase.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartAxisBase.prototype.getType = function () {
            return "DChartAxisBase";
        };
        return DChartAxisBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisContainerImpl = /** @class */ (function () {
        function DChartAxisContainerImpl(plotArea, options) {
            this._plotArea = plotArea;
            this._container = new EShapeContainer();
            this._list = new Map();
            var list = options && options.list;
            if (list) {
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    this.add(list[i]);
                }
            }
        }
        Object.defineProperty(DChartAxisContainerImpl.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartAxisContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: true,
            configurable: true
        });
        DChartAxisContainerImpl.prototype.add = function (axis) {
            var list = this._list;
            var axes = list.get(axis.position);
            if (axes == null) {
                axes = [];
                list.set(axis.position, axes);
            }
            axes.push(axis);
            axis.bind(this, axes.length - 1);
        };
        DChartAxisContainerImpl.prototype.get = function (position, index) {
            var list = this._list;
            var axes = list.get(position);
            if (axes) {
                if (0 <= index && index < axes.length) {
                    return axes[index];
                }
            }
            return null;
        };
        DChartAxisContainerImpl.prototype.indexOf = function (axis) {
            var list = this._list;
            var axes = list.get(axis.position);
            if (axes) {
                return axes.indexOf(axis);
            }
            return -1;
        };
        DChartAxisContainerImpl.prototype.clear = function (position) {
            var list = this._list;
            var axes = list.get(position);
            if (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            }
            return this;
        };
        DChartAxisContainerImpl.prototype.size = function (position) {
            var list = this._list;
            var axes = list.get(position);
            if (axes) {
                return axes.length;
            }
            return 0;
        };
        DChartAxisContainerImpl.prototype.update = function () {
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].update();
                }
            });
        };
        DChartAxisContainerImpl.prototype.destroy = function () {
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            });
        };
        return DChartAxisContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An X axis.
     */
    var DChartAxisX = /** @class */ (function (_super) {
        __extends(DChartAxisX, _super);
        function DChartAxisX() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisX.prototype.getType = function () {
            return "DChartAxisX";
        };
        return DChartAxisX;
    }(DChartAxisBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An X axis for datetimes.
     */
    var DChartAxisXDatetime = /** @class */ (function (_super) {
        __extends(DChartAxisXDatetime, _super);
        function DChartAxisXDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisXDatetime.prototype.getType = function () {
            return "DChartAxisXDatetime";
        };
        return DChartAxisXDatetime;
    }(DChartAxisX));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An Y axis.
     */
    var DChartAxisY = /** @class */ (function (_super) {
        __extends(DChartAxisY, _super);
        function DChartAxisY() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisY.prototype.getType = function () {
            return "DChartAxisY";
        };
        return DChartAxisY;
    }(DChartAxisBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCHART_COLOR_SET_1 = [
        0x10b7e3,
        0xfe5420,
        0xf0c312,
        0x1c5d71
    ];
    var DCHART_COLOR_SET_2 = [
        DCHART_COLOR_SET_1[0],
        UtilRgb.brighten(DCHART_COLOR_SET_1[0], 0.4),
        DCHART_COLOR_SET_1[1],
        UtilRgb.brighten(DCHART_COLOR_SET_1[1], 0.4),
        DCHART_COLOR_SET_1[2],
        UtilRgb.brighten(DCHART_COLOR_SET_1[2], 0.4),
        DCHART_COLOR_SET_1[3],
        UtilRgb.brighten(DCHART_COLOR_SET_1[3], 0.4)
    ];
    var DChartColorSet1 = function (index) {
        return DCHART_COLOR_SET_1[index % DCHART_COLOR_SET_1.length];
    };
    var DChartColorSet2 = function (index) {
        return DCHART_COLOR_SET_2[index % DCHART_COLOR_SET_2.length];
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateDirection;
    (function (DChartCoordinateDirection) {
        DChartCoordinateDirection[DChartCoordinateDirection["X"] = 0] = "X";
        DChartCoordinateDirection[DChartCoordinateDirection["Y"] = 1] = "Y";
    })(DChartCoordinateDirection || (DChartCoordinateDirection = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateContainerSubImpl = /** @class */ (function () {
        function DChartCoordinateContainerSubImpl(container, direction) {
            this._container = container;
            this._direction = direction;
            this._list = [];
        }
        Object.defineProperty(DChartCoordinateContainerSubImpl.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: true,
            configurable: true
        });
        DChartCoordinateContainerSubImpl.prototype.add = function (coordinate, index) {
            var list = this._list;
            if (index == null) {
                list.push(coordinate);
            }
            else if (0 <= index && index < list.length) {
                list.splice(index, 0, coordinate);
            }
            else {
                list.push(coordinate);
            }
            coordinate.bind(this, this._direction);
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.get = function (index) {
            var list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        };
        DChartCoordinateContainerSubImpl.prototype.indexOf = function (coordinate) {
            return this._list.indexOf(coordinate);
        };
        DChartCoordinateContainerSubImpl.prototype.remove = function (coordinateOrIndex) {
            var list = this._list;
            if (isNumber(coordinateOrIndex)) {
                var index = coordinateOrIndex;
                if (0 <= index && index < list.length) {
                    var removed = list.splice(index, 1)[0];
                    removed.unbind();
                    return removed;
                }
            }
            else {
                var coordinate = coordinateOrIndex;
                var index = list.indexOf(coordinate);
                if (0 <= index) {
                    list.splice(index, 1);
                    coordinate.unbind();
                    return coordinate;
                }
            }
            return null;
        };
        DChartCoordinateContainerSubImpl.prototype.clear = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].unbind();
            }
            list.length = 0;
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.destroy = function () {
            return this.clear();
        };
        DChartCoordinateContainerSubImpl.prototype.size = function () {
            return this._list.length;
        };
        DChartCoordinateContainerSubImpl.prototype.fit = function (from, to) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].fit(from, to);
            }
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.mark = function (from, to) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].mark(from, to);
            }
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.blend = function (ratio) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].blend(ratio);
            }
            return this;
        };
        return DChartCoordinateContainerSubImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateContainerImpl = /** @class */ (function () {
        function DChartCoordinateContainerImpl(plotArea, options) {
            this._plotArea = plotArea;
            var x = this._x = new DChartCoordinateContainerSubImpl(this, DChartCoordinateDirection.X);
            var y = this._y = new DChartCoordinateContainerSubImpl(this, DChartCoordinateDirection.Y);
            if (options) {
                var cxs = options.x;
                if (cxs) {
                    if (isArray(cxs)) {
                        for (var i = 0, imax = cxs.length; i < imax; ++i) {
                            x.add(cxs[i]);
                        }
                    }
                    else {
                        x.add(cxs);
                    }
                }
                var cys = options.y;
                if (cys) {
                    if (isArray(cys)) {
                        for (var i = 0, imax = cys.length; i < imax; ++i) {
                            y.add(cys[i]);
                        }
                    }
                    else {
                        y.add(cys);
                    }
                }
            }
        }
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: true,
            configurable: true
        });
        DChartCoordinateContainerImpl.prototype.fit = function (domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.fit(domainFrom, domainTo);
            this._y.fit(rangeFrom, rangeTo);
            return this;
        };
        DChartCoordinateContainerImpl.prototype.mark = function (domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.mark(domainFrom, domainTo);
            this._y.mark(rangeFrom, rangeTo);
            return this;
        };
        DChartCoordinateContainerImpl.prototype.blend = function (ratio) {
            this._x.blend(ratio);
            this._y.blend(ratio);
            return this;
        };
        return DChartCoordinateContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLinearTick = /** @class */ (function () {
        function DChartCoordinateLinearTick(theme) {
            this._theme = theme;
        }
        DChartCoordinateLinearTick.prototype.calcStepMajor = function (domainMin, domainMax, count) {
            if (0 < count) {
                var span = Math.abs(domainMax - domainMin) / count;
                var power = Math.floor(Math.log(span) / Math.LN10);
                var base = Math.pow(10, power);
                return this._theme.toStepScale(span / base) * base;
            }
            return -1;
        };
        DChartCoordinateLinearTick.prototype.calcStepMinor = function (step, minorCount) {
            if (0 <= step) {
                return step / (minorCount + 1);
            }
            else {
                return -1;
            }
        };
        DChartCoordinateLinearTick.prototype.calcTickMinorPositions = function (step, count, majorPosition, rangeMin, rangeMax, iresult, result) {
            for (var i = 0; i < count; i += 1) {
                var minorPosition = majorPosition + (i + 1) * step;
                if (rangeMin <= minorPosition && minorPosition <= rangeMax) {
                    result[iresult++] = minorPosition;
                }
            }
        };
        DChartCoordinateLinearTick.prototype.calculate = function (domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult, coordinate) {
            if (majorCount <= 0) {
                return;
            }
            var transform = coordinate.transform;
            var domainMin = Math.min(domainFrom, domainTo);
            var domainMax = Math.max(domainFrom, domainTo);
            var majorStep = this.calcStepMajor(domainMin, domainMax, majorCount);
            if (majorStep <= 0) {
                majorResult[0] = domainMin;
                majorResult[1] = transform.map(coordinate.map(domainMin));
                majorResult[2] = 0;
                for (var i = 1; i < majorCount; ++i) {
                    var imajorResult = i * 3;
                    majorResult[imajorResult + 0] = NaN;
                    majorResult[imajorResult + 1] = NaN;
                    majorResult[imajorResult + 2] = NaN;
                }
                for (var i = 0; i < minorCount; ++i) {
                    var iminorResult = i * 3;
                    minorResult[iminorResult + 0] = NaN;
                    minorResult[iminorResult + 1] = NaN;
                    minorResult[iminorResult + 2] = NaN;
                }
                return;
            }
            // Major tick start position
            var idomainStart = Math.floor(domainMin / majorStep) - 1;
            var idomainEnd = Math.ceil(domainMax / majorStep) + 1;
            // Major / minor tick positions
            var minorStep = this.calcStepMinor(majorStep, minorCountPerMajor);
            var imajor = 0;
            var iminor = 0;
            for (var i = idomainStart; i <= idomainEnd; ++i) {
                var majorPosition = i * majorStep;
                if (imajor < majorCount) {
                    if (domainMin <= majorPosition && majorPosition <= domainMax) {
                        var majorProjectedPosition = transform.map(coordinate.map(majorPosition));
                        var imajorResult = imajor * 3;
                        majorResult[imajorResult + 0] = majorPosition;
                        majorResult[imajorResult + 1] = majorProjectedPosition;
                        majorResult[imajorResult + 2] = majorStep;
                        imajor += 1;
                    }
                }
                for (var j = 0; j < minorCountPerMajor; j += 1) {
                    if (iminor < minorCount) {
                        var minorPosition = majorPosition + (j + 1) * minorStep;
                        if (domainMin <= minorPosition && minorPosition <= domainMax) {
                            var minorProjectedPosition = transform.map(coordinate.map(minorPosition));
                            var iminorResult = iminor * 3;
                            minorResult[iminorResult + 0] = minorPosition;
                            minorResult[iminorResult + 1] = minorProjectedPosition;
                            minorResult[iminorResult + 2] = minorStep;
                            iminor += 1;
                        }
                    }
                }
            }
            for (var i = imajor; i < majorCount; ++i) {
                var imajorResult = i * 3;
                majorResult[imajorResult + 0] = NaN;
                majorResult[imajorResult + 1] = NaN;
                majorResult[imajorResult + 2] = NaN;
            }
            for (var i = iminor; i < minorCount; ++i) {
                var iminorResult = i * 3;
                minorResult[iminorResult + 0] = NaN;
                minorResult[iminorResult + 1] = NaN;
                minorResult[iminorResult + 2] = NaN;
            }
        };
        return DChartCoordinateLinearTick;
    }());

    var DChartCoordinateTransformImpl = /** @class */ (function () {
        function DChartCoordinateTransformImpl(theme) {
            this._theme = theme;
            this._id = 0;
            this._translate = 0;
            this._scale = 1;
            this._itranslate = 0;
            this._iscale = 1;
        }
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "translate", {
            get: function () {
                return this._translate;
            },
            set: function (translate) {
                this.set(translate);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            set: function (scale) {
                this.set(undefined, scale);
            },
            enumerable: true,
            configurable: true
        });
        DChartCoordinateTransformImpl.prototype.bind = function (container, direction) {
            this.set(0, direction === DChartCoordinateDirection.X ? +1 : -1);
        };
        DChartCoordinateTransformImpl.prototype.unbind = function () {
            // DO NOTHING
        };
        DChartCoordinateTransformImpl.prototype.set = function (translate, scale) {
            var isChanged = false;
            if (translate != null && this._translate !== translate) {
                isChanged = true;
                this._translate = translate;
            }
            if (scale != null && this._scale !== scale) {
                isChanged = true;
                this._scale = scale;
            }
            if (isChanged) {
                this._id += 1;
                this._iscale = (this._theme.isZero(this._scale) ? 0 : 1 / this._scale);
                this._itranslate = -this._translate * this._iscale;
            }
        };
        DChartCoordinateTransformImpl.prototype.blend = function (ratio, mark) {
            var ratioi = 1 - ratio;
            var newTranslate = mark.newTranslate * ratio + mark.oldTranslate * ratioi;
            var newScale = mark.newScale * ratio + mark.oldScale * ratioi;
            this.set(newTranslate, newScale);
        };
        DChartCoordinateTransformImpl.prototype.map = function (value) {
            return this._translate + this._scale * value;
        };
        DChartCoordinateTransformImpl.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            var translate = this._translate;
            var scale = this._scale;
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = translate + scale * values[i];
            }
        };
        DChartCoordinateTransformImpl.prototype.unmap = function (value) {
            return this._itranslate + this._iscale * value;
        };
        DChartCoordinateTransformImpl.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            var itranslate = this._itranslate;
            var iscale = this._iscale;
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = itranslate + iscale * values[i];
            }
        };
        return DChartCoordinateTransformImpl;
    }());

    var DChartCoordinateTransformMarkImpl = /** @class */ (function () {
        function DChartCoordinateTransformMarkImpl() {
            this.oldTranslate = 0;
            this.oldScale = 1;
            this.newTranslate = 0;
            this.newScale = 1;
        }
        DChartCoordinateTransformMarkImpl.prototype.set = function (translate, scale) {
            if (translate != null) {
                this.newTranslate = translate;
            }
            if (scale != null) {
                this.newScale = scale;
            }
        };
        return DChartCoordinateTransformMarkImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartRegionImpl = /** @class */ (function () {
        function DChartRegionImpl(from, to) {
            this.from = from;
            this.to = to;
        }
        DChartRegionImpl.prototype.set = function (from, to) {
            if (from != null) {
                this.from = from;
            }
            if (to != null) {
                this.to = to;
            }
            return this;
        };
        DChartRegionImpl.prototype.add = function (from, to) {
            if (!isNaN(from)) {
                this.from = (isNaN(this.from) ?
                    from : Math.min(this.from, from));
            }
            if (!isNaN(to)) {
                this.to = (isNaN(this.to) ?
                    to : Math.max(this.to, to));
            }
            return this;
        };
        DChartRegionImpl.prototype.clear = function () {
            this.from = NaN;
            this.to = NaN;
            return this;
        };
        return DChartRegionImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLinear = /** @class */ (function () {
        function DChartCoordinateLinear(options) {
            this._id = 0;
            this._direction = DChartCoordinateDirection.X;
            var theme = this.toTheme(options);
            this._theme = theme;
            this._transform = new DChartCoordinateTransformImpl(theme);
            this._tick = new DChartCoordinateLinearTick(theme);
            this._work = new DChartRegionImpl(NaN, NaN);
            this._mark = new DChartCoordinateTransformMarkImpl();
        }
        DChartCoordinateLinear.prototype.bind = function (container, direction) {
            this._container = container;
            this._direction = direction;
            this._transform.bind(container, direction);
        };
        DChartCoordinateLinear.prototype.unbind = function () {
            this._container = undefined;
            this._transform.unbind();
        };
        DChartCoordinateLinear.prototype.fit = function (from, to) {
            this.doFit(from, to, this._transform);
        };
        DChartCoordinateLinear.prototype.mark = function (from, to) {
            var mark = this._mark;
            var transform = this._transform;
            mark.oldTranslate = transform.translate;
            mark.oldScale = transform.scale;
            this.doFit(from, to, mark);
        };
        DChartCoordinateLinear.prototype.blend = function (ratio) {
            this._transform.blend(ratio, this._mark);
        };
        DChartCoordinateLinear.prototype.doFit = function (from, to, result) {
            var container = this._container;
            if (container) {
                var plotArea = container.container.plotArea;
                var padding = plotArea.padding;
                var work = this._work;
                switch (this._direction) {
                    case DChartCoordinateDirection.X:
                        this.doFit_(padding.getLeft(), plotArea.width - padding.getRight(), this.toFitDomain(from, to, plotArea, work), result);
                        break;
                    case DChartCoordinateDirection.Y:
                        this.doFit_(plotArea.height - padding.getBottom(), padding.getTop(), this.toFitRange(from, to, plotArea, work), result);
                        break;
                }
            }
        };
        DChartCoordinateLinear.prototype.toFitDomain = function (from, to, plotArea, result) {
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getDomain(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateLinear.prototype.toFitRange = function (from, to, plotArea, result) {
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getRange(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateLinear.prototype.doFit_ = function (pixelFrom, pixelTo, region, result) {
            var regionFrom = region.from;
            var regionTo = region.to;
            if (!(isNaN(regionFrom) || isNaN(regionTo))) {
                // Scale
                var newScale = 1;
                var regionSize = (regionTo - regionFrom);
                if (!this._theme.isZero(regionSize)) {
                    var pixelSize = (pixelTo - pixelFrom);
                    newScale = pixelSize / regionSize;
                }
                else {
                    newScale = (pixelTo < pixelFrom ? -1 : 1);
                }
                // Translation
                var newTranslation = pixelFrom - regionFrom * newScale;
                // Done
                result.set(newTranslation, newScale);
            }
        };
        Object.defineProperty(DChartCoordinateLinear.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateLinear.prototype, "transform", {
            get: function () {
                return this._transform;
            },
            enumerable: true,
            configurable: true
        });
        DChartCoordinateLinear.prototype.map = function (value) {
            return value;
        };
        DChartCoordinateLinear.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            // DO NOTHING
        };
        DChartCoordinateLinear.prototype.unmap = function (value) {
            return value;
        };
        DChartCoordinateLinear.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            // DO NOTHING
        };
        DChartCoordinateLinear.prototype.ticks = function (domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult) {
            this._tick.calculate(domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult, this);
        };
        DChartCoordinateLinear.prototype.toTheme = function (options) {
            return (options && options.theme) || this.getThemeDefault();
        };
        DChartCoordinateLinear.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateLinear.prototype.getType = function () {
            return "DChartCoordinateLinear";
        };
        return DChartCoordinateLinear;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLogTick = /** @class */ (function () {
        function DChartCoordinateLogTick(theme) {
            this._theme = theme;
        }
        DChartCoordinateLogTick.prototype.calcStepMajor = function (domainMin, domainMax, count) {
            if (0 < count) {
                var span = Math.abs(domainMax - domainMin) / count;
                var power = Math.floor(Math.log(span) / Math.LN10);
                var base = Math.pow(10, power);
                return this._theme.toStepScale(span / base) * base;
            }
            return -1;
        };
        DChartCoordinateLogTick.prototype.calcStepMinor = function (step, minorCount) {
            if (0 <= step) {
                return step / (minorCount + 1);
            }
            else {
                return -1;
            }
        };
        DChartCoordinateLogTick.prototype.calcTickMinorPositions = function (step, count, majorPosition, rangeMin, rangeMax, iresult, result) {
            for (var i = 0; i < count; i += 1) {
                var minorPosition = majorPosition + (i + 1) * step;
                if (rangeMin <= minorPosition && minorPosition <= rangeMax) {
                    result[iresult++] = minorPosition;
                }
            }
        };
        DChartCoordinateLogTick.prototype.calculate = function (domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult, coordinate) {
            if (majorCount <= 0) {
                return;
            }
            var transform = coordinate.transform;
            var domainFromMapped = coordinate.map(domainFrom);
            var domainToMapped = coordinate.map(domainTo);
            var domainMinMapped = Math.min(domainFromMapped, domainToMapped);
            var domainMaxMapped = Math.max(domainFromMapped, domainToMapped);
            var majorStepMapped = this.calcStepMajor(domainMinMapped, domainMaxMapped, majorCount);
            if (majorStepMapped <= 0) {
                var domainMin = Math.min(domainFrom, domainTo);
                majorResult[0] = domainMin;
                majorResult[1] = transform.map(coordinate.map(domainMin));
                majorResult[2] = 0;
                for (var i = 1; i < majorCount; ++i) {
                    var imajorResult = i * 3;
                    majorResult[imajorResult + 0] = NaN;
                    majorResult[imajorResult + 1] = NaN;
                    majorResult[imajorResult + 2] = NaN;
                }
                for (var i = 0; i < minorCount; ++i) {
                    var iminorResult = i * 3;
                    minorResult[iminorResult + 0] = NaN;
                    minorResult[iminorResult + 1] = NaN;
                    minorResult[iminorResult + 2] = NaN;
                }
                return;
            }
            // Major tick start position
            var idomainStartMapped = Math.floor(domainMinMapped / majorStepMapped) - 1;
            var idomainEndMapped = Math.ceil(domainMaxMapped / majorStepMapped) + 1;
            // Major / minor tick positions
            var minorStepMapped = this.calcStepMinor(majorStepMapped, minorCountPerMajor);
            var imajor = 0;
            var iminor = 0;
            for (var i = idomainStartMapped; i <= idomainEndMapped; ++i) {
                var majorPositionMapped = i * majorStepMapped;
                if (imajor < majorCount) {
                    if (domainMinMapped <= majorPositionMapped && majorPositionMapped <= domainMaxMapped) {
                        var majorPosition = coordinate.unmap(majorPositionMapped);
                        var majorProjectedPosition = transform.map(majorPositionMapped);
                        var majorStep = coordinate.unmap(majorPositionMapped - 1);
                        var imajorResult = imajor * 3;
                        majorResult[imajorResult + 0] = majorPosition;
                        majorResult[imajorResult + 1] = majorProjectedPosition;
                        majorResult[imajorResult + 2] = majorStep;
                        imajor += 1;
                    }
                }
                for (var j = 0; j < minorCountPerMajor; j += 1) {
                    if (iminor < minorCount) {
                        var minorPositionMapped = majorPositionMapped + (j + 1) * minorStepMapped;
                        if (domainMinMapped <= minorPositionMapped && minorPositionMapped <= domainMaxMapped) {
                            var minorPosition = coordinate.unmap(minorPositionMapped);
                            var minorProjectedPosition = transform.map(minorPositionMapped);
                            var minorStep = coordinate.unmap(minorPositionMapped - 1);
                            var iminorResult = iminor * 3;
                            minorResult[iminorResult + 0] = minorPosition;
                            minorResult[iminorResult + 1] = minorProjectedPosition;
                            minorResult[iminorResult + 2] = minorStep;
                            iminor += 1;
                        }
                    }
                }
            }
            for (var i = imajor; i < majorCount; ++i) {
                var imajorResult = i * 3;
                majorResult[imajorResult + 0] = NaN;
                majorResult[imajorResult + 1] = NaN;
                majorResult[imajorResult + 2] = NaN;
            }
            for (var i = iminor; i < minorCount; ++i) {
                var iminorResult = i * 3;
                minorResult[iminorResult + 0] = NaN;
                minorResult[iminorResult + 1] = NaN;
                minorResult[iminorResult + 2] = NaN;
            }
        };
        return DChartCoordinateLogTick;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLog = /** @class */ (function () {
        function DChartCoordinateLog(options) {
            this._id = 0;
            this._direction = DChartCoordinateDirection.X;
            var theme = this.toTheme(options);
            this._theme = theme;
            this._transform = new DChartCoordinateTransformImpl(theme);
            this._tick = new DChartCoordinateLogTick(theme);
            this._work = new DChartRegionImpl(NaN, NaN);
            this._mark = new DChartCoordinateTransformMarkImpl();
        }
        DChartCoordinateLog.prototype.bind = function (container, direction) {
            this._container = container;
            this._direction = direction;
        };
        DChartCoordinateLog.prototype.unbind = function () {
            this._container = undefined;
        };
        DChartCoordinateLog.prototype.fit = function (from, to) {
            this.doFit(from, to, this._transform);
        };
        DChartCoordinateLog.prototype.mark = function (from, to) {
            var mark = this._mark;
            var transform = this._transform;
            mark.oldTranslate = transform.translate;
            mark.oldScale = transform.scale;
            this.doFit(from, to, mark);
        };
        DChartCoordinateLog.prototype.blend = function (ratio) {
            this._transform.blend(ratio, this._mark);
        };
        DChartCoordinateLog.prototype.doFit = function (from, to, result) {
            var container = this._container;
            if (container) {
                var plotArea = container.container.plotArea;
                var padding = plotArea.padding;
                var work = this._work;
                switch (this._direction) {
                    case DChartCoordinateDirection.X:
                        this.doFit_(padding.getLeft(), plotArea.width - padding.getRight(), this.toFitDomain(from, to, plotArea, work), result);
                        break;
                    case DChartCoordinateDirection.Y:
                        this.doFit_(plotArea.height - padding.getBottom(), padding.getTop(), this.toFitRange(from, to, plotArea, work), result);
                        break;
                }
            }
        };
        DChartCoordinateLog.prototype.toFitDomain = function (from, to, plotArea, result) {
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getDomain(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateLog.prototype.toFitRange = function (from, to, plotArea, result) {
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getRange(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateLog.prototype.doFit_ = function (pixelFrom, pixelTo, region, result) {
            var regionFrom = region.from;
            var regionTo = region.to;
            if (!(isNaN(regionFrom) || isNaN(regionTo))) {
                // Scale
                var newScale = 1;
                var regionFromMapped = this.map(regionFrom);
                var regionToMapped = this.map(regionTo);
                var regionSizeMapped = (regionToMapped - regionFromMapped);
                if (!this._theme.isZero(regionSizeMapped)) {
                    var pixelSize = (pixelTo - pixelFrom);
                    newScale = pixelSize / regionSizeMapped;
                }
                else {
                    newScale = (pixelTo < pixelFrom ? -1 : 1);
                }
                // Translation
                var newTranslation = pixelFrom - regionFromMapped * newScale;
                // Done
                result.set(newTranslation, newScale);
            }
        };
        Object.defineProperty(DChartCoordinateLog.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateLog.prototype, "transform", {
            get: function () {
                return this._transform;
            },
            enumerable: true,
            configurable: true
        });
        DChartCoordinateLog.prototype.map = function (value) {
            return Math.log(Math.max(0, value)) / Math.LN10;
        };
        DChartCoordinateLog.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            var factor = 1 / Math.LN10;
            for (var i = ifrom + offset; i < iend; i += stride) {
                var value = values[i];
                values[i] = Math.log(Math.max(0, value)) * factor;
            }
        };
        DChartCoordinateLog.prototype.unmap = function (value) {
            return Math.pow(10, value);
        };
        DChartCoordinateLog.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = Math.pow(10, values[i]);
            }
        };
        DChartCoordinateLog.prototype.ticks = function (domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult) {
            this._tick.calculate(domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult, this);
        };
        DChartCoordinateLog.prototype.toTheme = function (options) {
            return (options && options.theme) || this.getThemeDefault();
        };
        DChartCoordinateLog.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateLog.prototype.getType = function () {
            return "DChartCoordinateLog";
        };
        return DChartCoordinateLog;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartLegendItem = /** @class */ (function (_super) {
        __extends(DChartLegendItem, _super);
        function DChartLegendItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartLegendItem.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
        };
        DChartLegendItem.prototype.getType = function () {
            return "DChartLegendItem";
        };
        return DChartLegendItem;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartLegend = /** @class */ (function (_super) {
        __extends(DChartLegend, _super);
        function DChartLegend() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartLegend.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
        };
        DChartLegend.prototype.getType = function () {
            return "DChartLegend";
        };
        return DChartLegend;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartOverview = /** @class */ (function (_super) {
        __extends(DChartOverview, _super);
        function DChartOverview() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartOverview.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
        };
        DChartOverview.prototype.getType = function () {
            return "DChartOverview";
        };
        return DChartOverview;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaContainer = /** @class */ (function (_super) {
        __extends(DChartPlotAreaContainer, _super);
        function DChartPlotAreaContainer(onChange) {
            var _this = _super.call(this) || this;
            var transform = _this.transform;
            _this._position = new DBasePoint(transform.position, onChange);
            _this._scale = new DBasePoint(transform.scale, onChange);
            _this._workRect = new pixi_js.Rectangle();
            return _this;
        }
        Object.defineProperty(DChartPlotAreaContainer.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaContainer.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            enumerable: true,
            configurable: true
        });
        DChartPlotAreaContainer.prototype.getBounds = function (skipUpdate, rect) {
            this._lastBoundsID = -1;
            return _super.prototype.getBounds.call(this, skipUpdate, rect);
        };
        DChartPlotAreaContainer.prototype.calculateBounds = function () {
            var bounds = this._bounds;
            var work = this._work;
            var rect = this._workRect;
            var worldTransform = this.transform.worldTransform;
            var xmin = 0;
            var xmax = 0;
            var ymin = 0;
            var ymax = 0;
            var children = this.children;
            if (0 < children.length) {
                var isFirst = true;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible) {
                        child.getBoundsInternal(work, false, rect);
                        if (isFirst) {
                            isFirst = false;
                            xmin = rect.x;
                            ymin = rect.y;
                            xmax = rect.x + rect.width;
                            ymax = rect.y + rect.height;
                        }
                        else {
                            xmin = Math.min(xmin, rect.x);
                            ymin = Math.min(ymin, rect.y);
                            xmax = Math.max(xmax, rect.x + rect.width);
                            ymax = Math.max(ymax, rect.y + rect.height);
                        }
                    }
                }
            }
            bounds.clear();
            work.set(xmin, ymin);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(xmax, ymax);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
        };
        return DChartPlotAreaContainer;
    }(EShapeContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesHitResult = /** @class */ (function () {
        function DChartSeriesHitResult() {
            this.shape = null;
            this.x = 0;
            this.y = 0;
            this.p0x = 0;
            this.p0y = 0;
            this.p1x = 0;
            this.p1y = 0;
            this.index = 0;
            this.t = 0;
            this.distance = 0;
        }
        DChartSeriesHitResult.prototype.copyFrom = function (other) {
            this.shape = other.shape;
            this.x = other.x;
            this.y = other.y;
            this.p0x = other.p0x;
            this.p0y = other.p0y;
            this.p1x = other.p1x;
            this.p1y = other.p1y;
            this.index = other.index;
            this.t = other.t;
            this.distance = other.distance;
            return this;
        };
        return DChartSeriesHitResult;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesFillComputedImpl = /** @class */ (function () {
        function DChartSeriesFillComputedImpl(enable, color, alpha) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
        }
        DChartSeriesFillComputedImpl.from = function (base, index, fill) {
            if (fill) {
                return new DChartSeriesFillComputedImpl((fill.enable != null ? fill.enable : base.enable(index)), (fill.color != null ? fill.color : base.color(index)), (fill.alpha != null ? fill.alpha : base.alpha(index)));
            }
            else {
                return new DChartSeriesFillComputedImpl(base.enable(index), base.color(index), base.alpha(index));
            }
        };
        return DChartSeriesFillComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesScalars = /** @class */ (function () {
        function DChartSeriesScalars() {
        }
        DChartSeriesScalars.from = function (value, def) {
            if (isArray(value)) {
                return function (index) { return value[index % value.length]; };
            }
            else if (isFunction(value)) {
                return value;
            }
            else if (value != null) {
                return function () { return value; };
            }
            else if (isArray(def)) {
                return function (index) { return def[index % def.length]; };
            }
            else if (isFunction(def)) {
                return def;
            }
            else {
                return function () { return def; };
            }
        };
        return DChartSeriesScalars;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesFillImpl = /** @class */ (function () {
        function DChartSeriesFillImpl(options) {
            this.enable = DChartSeriesScalars.from(options && options.enable, true);
            this.color = DChartSeriesScalars.from(options && options.color, DChartColorSet2);
            this.alpha = DChartSeriesScalars.from(options && options.alpha, EShapeDefaults.FILL_ALPHA);
        }
        return DChartSeriesFillImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPaddingComputedImpl = /** @class */ (function () {
        function DChartSeriesPaddingComputedImpl(outer, inner) {
            this.outer = outer;
            this.inner = inner;
        }
        DChartSeriesPaddingComputedImpl.from = function (base, index, point) {
            if (point) {
                return new DChartSeriesPaddingComputedImpl((point.outer != null ? point.outer : base.outer(index)), (point.inner != null ? point.inner : base.inner(index)));
            }
            else {
                return new DChartSeriesPaddingComputedImpl(base.outer(index), base.inner(index));
            }
        };
        return DChartSeriesPaddingComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPaddingImpl = /** @class */ (function () {
        function DChartSeriesPaddingImpl(options) {
            this.outer = DChartSeriesScalars.from(options && options.outer, 0.2);
            this.inner = DChartSeriesScalars.from(options && options.inner, 0.1);
        }
        return DChartSeriesPaddingImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPointComputedImpl = /** @class */ (function () {
        function DChartSeriesPointComputedImpl(x, y) {
            this.x = x;
            this.y = y;
        }
        DChartSeriesPointComputedImpl.from = function (base, index, point, x, y) {
            if (point) {
                return new DChartSeriesPointComputedImpl((point.x != null ? point.x : (base.x != null ? base.x(index) : x)), (point.y != null ? point.y : (base.y != null ? base.y(index) : y)));
            }
            else {
                return new DChartSeriesPointComputedImpl(base.x != null ? base.x(index) : x, base.y != null ? base.y(index) : y);
            }
        };
        return DChartSeriesPointComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPointImpl = /** @class */ (function () {
        function DChartSeriesPointImpl(options) {
            if (options) {
                if (options.x != null) {
                    this.x = DChartSeriesScalars.from(options.x, 0);
                }
                if (options.y != null) {
                    this.y = DChartSeriesScalars.from(options.y, 0);
                }
            }
        }
        return DChartSeriesPointImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesStrokeComputedImpl = /** @class */ (function () {
        function DChartSeriesStrokeComputedImpl(enable, color, alpha, width, align, side, style) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
            this.width = width;
            this.align = align;
            this.side = side;
            this.style = style;
        }
        DChartSeriesStrokeComputedImpl.from = function (base, index, stroke) {
            if (stroke) {
                return new DChartSeriesStrokeComputedImpl((stroke.enable != null ? stroke.enable : base.enable(index)), (stroke.color != null ? stroke.color : base.color(index)), (stroke.alpha != null ? stroke.alpha : base.alpha(index)), (stroke.width != null ? stroke.width : base.width(index)), (stroke.align != null ? stroke.align : base.align(index)), (stroke.side != null ? stroke.side : base.side(index)), EShapePointsStyles.from(stroke.style != null ? stroke.style : base.style(index)));
            }
            else {
                return new DChartSeriesStrokeComputedImpl(base.enable(index), base.color(index), base.alpha(index), base.width(index), base.align(index), base.side(index), EShapePointsStyles.from(base.style(index)));
            }
        };
        return DChartSeriesStrokeComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesStrokeImpl = /** @class */ (function () {
        function DChartSeriesStrokeImpl(options) {
            this.enable = DChartSeriesScalars.from(options && options.enable, true);
            this.color = DChartSeriesScalars.from(options && options.color, DChartColorSet2);
            this.alpha = DChartSeriesScalars.from(options && options.alpha, EShapeDefaults.STROKE_ALPHA);
            this.width = DChartSeriesScalars.from(options && options.width, EShapeDefaults.STROKE_WIDTH);
            this.align = DChartSeriesScalars.from(options && options.width, EShapeDefaults.STROKE_ALIGN);
            this.side = DChartSeriesScalars.from(options && options.side, EShapeStrokeSide.ALL);
            this.style = DChartSeriesScalars.from(options && options.style, EShapePointsStyle.NON_EXPANDING_WIDTH |
                EShapePointsStyle.NON_SHRINKING_WIDTH |
                EShapePointsStyle.NON_SCALING_DOT_AND_DASH);
        }
        return DChartSeriesStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesContainerImpl = /** @class */ (function () {
        function DChartSeriesContainerImpl(plotArea, options) {
            this._plotArea = plotArea;
            this._domain = new DChartRegionImpl(NaN, NaN);
            this._range = new DChartRegionImpl(NaN, NaN);
            this._selection = (options && options.selection) || null;
            this._fill = new DChartSeriesFillImpl(options && options.fill);
            this._stroke = new DChartSeriesStrokeImpl(options && options.stroke);
            this._size = new DChartSeriesPointImpl(options && options.size);
            this._offset = new DChartSeriesPointImpl(options && options.offset);
            this._padding = new DChartSeriesPaddingImpl(options && options.padding);
            this._list = [];
            var list = options && options.list;
            if (list) {
                var listLength = list.length;
                if (0 < listLength) {
                    for (var i = 0; i < listLength; ++i) {
                        this.add(list[i]);
                    }
                    this.update();
                }
            }
        }
        DChartSeriesContainerImpl.prototype.newFill = function (index, options) {
            return DChartSeriesFillComputedImpl.from(this._fill, index, options);
        };
        DChartSeriesContainerImpl.prototype.newStroke = function (index, options) {
            return DChartSeriesStrokeComputedImpl.from(this._stroke, index, options);
        };
        DChartSeriesContainerImpl.prototype.newSize = function (index, options, x, y) {
            return DChartSeriesPointComputedImpl.from(this._size, index, options, x, y);
        };
        DChartSeriesContainerImpl.prototype.newOffset = function (index, options, x, y) {
            return DChartSeriesPointComputedImpl.from(this._offset, index, options, x, y);
        };
        DChartSeriesContainerImpl.prototype.newPadding = function (index, options) {
            return DChartSeriesPaddingComputedImpl.from(this._padding, index, options);
        };
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: true,
            configurable: true
        });
        DChartSeriesContainerImpl.prototype.update = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].update();
            }
            var selection = this._selection;
            if (selection) {
                selection.update();
            }
        };
        DChartSeriesContainerImpl.prototype.add = function (series) {
            var list = this._list;
            series.bind(this, list.length);
            list.push(series);
        };
        DChartSeriesContainerImpl.prototype.get = function (index) {
            var list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        };
        DChartSeriesContainerImpl.prototype.indexOf = function (series) {
            return this._list.indexOf(series);
        };
        DChartSeriesContainerImpl.prototype.clear = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            return this;
        };
        DChartSeriesContainerImpl.prototype.size = function () {
            return this._list.length;
        };
        DChartSeriesContainerImpl.prototype.destroy = function () {
            this.clear();
            var selection = this._selection;
            if (selection) {
                selection.unbind();
            }
        };
        DChartSeriesContainerImpl.prototype.getDomain = function (coordinate, result) {
            result.clear();
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                var series = list[i];
                if (series.coordinate.x === coordinate) {
                    var domain = series.domain;
                    result.add(domain.from, domain.to);
                }
            }
            return result;
        };
        DChartSeriesContainerImpl.prototype.getRange = function (coordinate, result) {
            result.clear();
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                var series = list[i];
                if (series.coordinate.y === coordinate) {
                    var range = series.range;
                    result.add(range.from, range.to);
                }
            }
            return result;
        };
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "domain", {
            get: function () {
                var result = this._domain;
                result.clear();
                var list = this._list;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    var domain = list[i].domain;
                    result.add(domain.from, domain.to);
                }
                return result;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "range", {
            get: function () {
                var result = this._range;
                result.clear();
                var list = this._list;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    var range = list[i].range;
                    result.add(range.from, range.to);
                }
                return result;
            },
            enumerable: true,
            configurable: true
        });
        DChartSeriesContainerImpl.prototype.hitTest = function (global) {
            var list = this._list;
            for (var i = list.length - 1; 0 <= i; --i) {
                var series = list[i];
                if (series.hitTest(global)) {
                    return series;
                }
            }
            return null;
        };
        DChartSeriesContainerImpl.prototype.calcHitPoint = function (global, result) {
            var tmp1 = result;
            var tmp2 = DChartSeriesContainerImpl.WORK_CALCHITPOINT;
            var list = this._list;
            var closest = null;
            tmp2.distance = +Infinity;
            for (var i = list.length - 1; 0 <= i; --i) {
                var series = list[i];
                if (series.calcHitPoint(global, tmp1)) {
                    if (tmp1.distance < tmp2.distance) {
                        closest = series;
                        var tmp = tmp1;
                        tmp1 = tmp2;
                        tmp2 = tmp;
                    }
                }
            }
            if (closest && tmp2 !== result) {
                result.copyFrom(tmp2);
            }
            return closest;
        };
        DChartSeriesContainerImpl.WORK_CALCHITPOINT = new DChartSeriesHitResult();
        return DChartSeriesContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotArea = /** @class */ (function (_super) {
        __extends(DChartPlotArea, _super);
        function DChartPlotArea(chart, options) {
            var _this = _super.call(this, options) || this;
            _this._chart = chart;
            _this._blendStartTime = 0;
            _this._blendDuration = 1000;
            _this._blendTimeout = null;
            _this._onBlendBound = function () {
                _this.onBlend();
            };
            return _this;
        }
        DChartPlotArea.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var container = new DChartPlotAreaContainer(function () {
                _this._isViewDirty = true;
                _this._isBoundsInContainerDirty = true;
                DApplications.update(_this);
            });
            this._container = container;
            this._coordinate = new DChartCoordinateContainerImpl(this, options && options.coordinate);
            var series = new DChartSeriesContainerImpl(this, options && options.series);
            this._series = series;
            var axis = new DChartAxisContainerImpl(this, options && options.axis);
            this._axis = axis;
            this._isViewDirty = true;
            this._isBoundsInContainerDirty = true;
            this._boundsInContainer = new pixi_js.Rectangle();
            this._workPoint = new pixi_js.Point();
            this.addChild(container);
            this.addChild(axis.container);
            this._view = new DViewImpl(this, function () { return container; }, options && options.view);
            var selection = series.selection;
            if (selection) {
                selection.bind(series);
            }
            // Overflow mask
            this._overflowMask = null;
            if (options && options.mask != null ? options.mask :
                this.theme.isOverflowMaskEnabled()) {
                this._container.mask = this.getOrCreateOverflowMask();
            }
        };
        DChartPlotArea.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            this._isViewDirty = true;
            this._isBoundsInContainerDirty = true;
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
        };
        DChartPlotArea.prototype.getOrCreateOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.addReflowable(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        Object.defineProperty(DChartPlotArea.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartPlotArea.prototype, "chart", {
            get: function () {
                return this._chart;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartPlotArea.prototype, "series", {
            get: function () {
                return this._series;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartPlotArea.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartPlotArea.prototype, "axis", {
            get: function () {
                return this._axis;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartPlotArea.prototype, "view", {
            get: function () {
                return this._view;
            },
            enumerable: true,
            configurable: true
        });
        DChartPlotArea.prototype.onWheel = function (e, deltas, global) {
            var vresult = this._view.onWheel(e, deltas, global);
            var sresult = _super.prototype.onWheel.call(this, e, deltas, global);
            return vresult || sresult;
        };
        DChartPlotArea.prototype.onDblClick = function (e, interactionManager) {
            var vresult = this._view.onDblClick(e, interactionManager);
            var sresult = _super.prototype.onDblClick.call(this, e, interactionManager);
            return vresult || sresult;
        };
        DChartPlotArea.prototype.onDown = function (e) {
            this._view.onDown(e);
            _super.prototype.onDown.call(this, e);
        };
        DChartPlotArea.prototype.render = function (renderer) {
            if (this._isViewDirty) {
                this._isViewDirty = false;
                this._axis.update();
                var selection = this._series.selection;
                if (selection) {
                    selection.update();
                }
            }
            _super.prototype.render.call(this, renderer);
        };
        DChartPlotArea.prototype.destroy = function () {
            this._container.destroy();
            this._series.destroy();
            this._axis.destroy();
        };
        DChartPlotArea.prototype.getType = function () {
            return "DChartPlotArea";
        };
        DChartPlotArea.prototype.getBoundsInContainer = function () {
            var result = this._boundsInContainer;
            if (this._isBoundsInContainerDirty) {
                this._isBoundsInContainerDirty = false;
                var container = this.container;
                container.updateTransform();
                var transform = container.transform.localTransform;
                var work = this._workPoint;
                work.set(0, 0);
                transform.applyInverse(work, work);
                result.x = work.x;
                result.y = work.y;
                work.set(this.width, this.height);
                transform.applyInverse(work, work);
                result.width = work.x - result.x;
                result.height = work.y - result.y;
            }
            return result;
        };
        DChartPlotArea.prototype.fit = function (duration, domainFrom, domainTo, rangeFrom, rangeTo) {
            var coordinate = this._coordinate;
            var axis = this._axis;
            var series = this._series;
            if (duration != null && duration <= 0) {
                coordinate.fit(domainFrom, domainTo, rangeFrom, rangeTo);
                axis.update();
                series.update();
            }
            else {
                this._blendDuration = duration != null ? duration : 200;
                this._blendStartTime = Date.now();
                coordinate.mark(domainFrom, domainTo, rangeFrom, rangeTo);
                var blendTimeout = this._blendTimeout;
                if (blendTimeout != null) {
                    window.clearTimeout(blendTimeout);
                }
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            return this;
        };
        DChartPlotArea.prototype.onBlend = function () {
            var now = Date.now();
            var ratio = (now - this._blendStartTime) / this._blendDuration;
            if (ratio < 1) {
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            else {
                this._blendTimeout = null;
                ratio = 1;
            }
            this._coordinate.blend(DAnimationTimings.ELASTIC(ratio));
            this._axis.update();
            this._series.update();
        };
        return DChartPlotArea;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartRegionImplObservable = /** @class */ (function () {
        function DChartRegionImplObservable(from, to, onChange) {
            this._from = from;
            this._to = to;
            this._onChange = onChange;
        }
        Object.defineProperty(DChartRegionImplObservable.prototype, "from", {
            get: function () {
                return this._from;
            },
            set: function (from) {
                this.set(from, undefined);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartRegionImplObservable.prototype, "to", {
            get: function () {
                return this._to;
            },
            set: function (to) {
                this.set(undefined, to);
            },
            enumerable: true,
            configurable: true
        });
        DChartRegionImplObservable.prototype.set = function (from, to) {
            var isChanged = false;
            if (from != null && this._from !== from) {
                if (!isNaN(this._from) || !isNaN(from)) {
                    this._from = from;
                    isChanged = true;
                }
            }
            if (to != null && this._to !== to) {
                if (!isNaN(this._to) || !isNaN(to)) {
                    this._to = to;
                    isChanged = true;
                }
            }
            if (isChanged) {
                this._onChange();
            }
            return this;
        };
        DChartRegionImplObservable.prototype.add = function (from, to) {
            var newFrom;
            if (!isNaN(from)) {
                newFrom = (isNaN(this.from) ?
                    from : Math.min(this.from, from));
            }
            var newTo;
            if (!isNaN(to)) {
                newTo = (isNaN(this.to) ?
                    to : Math.max(this.to, to));
            }
            return this.set(newFrom, newTo);
        };
        DChartRegionImplObservable.prototype.clear = function () {
            return this.set(NaN, NaN);
        };
        return DChartRegionImplObservable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesBaseCoordinateContainer = /** @class */ (function () {
        function DChartSeriesBaseCoordinateContainer(parent, options) {
            this._parent = parent;
            this._coordinateIndexX = (options && options.x != null ? options.x : 0);
            this._coordinateIndexY = (options && options.y != null ? options.y : 0);
            this._coordinateIdUpdatedX = NaN;
            this._coordinateIdUpdatedY = NaN;
            this._coordinateTransformIdUpdatedX = NaN;
            this._coordinateTransformIdUpdatedY = NaN;
        }
        Object.defineProperty(DChartSeriesBaseCoordinateContainer.prototype, "x", {
            get: function () {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.x.get(this._coordinateIndexX);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBaseCoordinateContainer.prototype, "y", {
            get: function () {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.y.get(this._coordinateIndexY);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        DChartSeriesBaseCoordinateContainer.prototype.isDirty = function (coordinateX, coordinateY) {
            var coordinateIdX = coordinateX.id;
            var coordinateIdY = coordinateY.id;
            var isCoordinateXChanged = (coordinateIdX !== this._coordinateIdUpdatedX);
            var isCoordinateYChanged = (coordinateIdY !== this._coordinateIdUpdatedY);
            this._coordinateIdUpdatedX = coordinateIdX;
            this._coordinateIdUpdatedY = coordinateIdY;
            return (isCoordinateXChanged || isCoordinateYChanged);
        };
        DChartSeriesBaseCoordinateContainer.prototype.isTransformDirty = function (coordinateX, coordinateY) {
            var coordinateTransformIdX = coordinateX.transform.id;
            var coordinateTransformIdY = coordinateY.transform.id;
            var isCoordinateTransformXChanged = (coordinateTransformIdX !== this._coordinateTransformIdUpdatedX);
            var isCoordinateTransformYChanged = (coordinateTransformIdY !== this._coordinateTransformIdUpdatedY);
            this._coordinateTransformIdUpdatedX = coordinateTransformIdX;
            this._coordinateTransformIdUpdatedY = coordinateTransformIdY;
            return (isCoordinateTransformXChanged || isCoordinateTransformYChanged);
        };
        DChartSeriesBaseCoordinateContainer.prototype.reset = function () {
            this._coordinateIdUpdatedX = NaN;
            this._coordinateIdUpdatedY = NaN;
        };
        DChartSeriesBaseCoordinateContainer.prototype.destroy = function () {
            this.reset();
        };
        return DChartSeriesBaseCoordinateContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a polyline.
     */
    var DChartSeriesBase = /** @class */ (function (_super) {
        __extends(DChartSeriesBase, _super);
        function DChartSeriesBase(options) {
            var _this = _super.call(this) || this;
            _this._coordinate = new DChartSeriesBaseCoordinateContainer(_this, options && options.coordinate);
            _this._index = 0;
            _this._domain = new DChartRegionImpl(NaN, NaN);
            _this._range = new DChartRegionImpl(NaN, NaN);
            _this._regionPointId = NaN;
            _this._state = DBaseState.NONE;
            _this._stateLocal = DBaseState.NONE;
            // Events
            if (options) {
                var on = options.on;
                if (on != null) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            return _this;
        }
        DChartSeriesBase.prototype.bind = function (container, index) {
            this._container = container;
            this._coordinate.reset();
            this._index = index;
        };
        DChartSeriesBase.prototype.unbind = function () {
            this._container = undefined;
        };
        Object.defineProperty(DChartSeriesBase.prototype, "domain", {
            get: function () {
                this.updateRegion();
                return this._domain;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "range", {
            get: function () {
                this.updateRegion();
                return this._range;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "container", {
            get: function () {
                return this._container || null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "index", {
            get: function () {
                return this._index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: true,
            configurable: true
        });
        DChartSeriesBase.prototype.destroy = function () {
            this._container = undefined;
            this._coordinate.destroy();
        };
        DChartSeriesBase.prototype.hitTest = function (global) {
            return false;
        };
        DChartSeriesBase.prototype.calcHitPoint = function (global, result) {
            return false;
        };
        DChartSeriesBase.prototype.setState = function (state, isOn) {
            var oldStateLocal = this._stateLocal;
            var newStateLocal = (isOn ? (oldStateLocal | state) : (oldStateLocal & ~state));
            if (oldStateLocal !== newStateLocal) {
                this._stateLocal = newStateLocal;
                this.updateState();
            }
        };
        DChartSeriesBase.prototype.updateState = function () {
            var container = this._container;
            var chart = container && container.plotArea.chart;
            var stateLocal = this._stateLocal;
            var newState = (chart ?
                this.mergeState(stateLocal, chart.state) :
                stateLocal);
            var oldState = this._state;
            if (oldState !== newState) {
                this._state = newState;
                this.onStateChange(newState, oldState);
            }
        };
        DChartSeriesBase.prototype.mergeState = function (stateLocal, stateParent) {
            return stateLocal | (stateParent & DBaseState.DISABLED) |
                (stateParent & (DBaseState.FOCUSED | DBaseState.FOCUSED_IN) ? DBaseState.FOCUSED_IN : DBaseState.NONE) |
                (stateParent & (DBaseState.ACTIVE | DBaseState.ACTIVE_IN) ? DBaseState.ACTIVE_IN : DBaseState.NONE);
        };
        DChartSeriesBase.prototype.onStateChange = function (newState, oldState) {
            this.toDirty();
            var container = this._container;
            var chart = container && container.plotArea.chart;
            DApplications.update(chart);
            this.emit("statechange", newState, oldState, this);
        };
        return DChartSeriesBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of anything.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfAny = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfAny, _super);
        function DChartSeriesLineOfAny(options) {
            var _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._points = (options && options.points) || [];
            _this._pointId = 0;
            _this._pointIdUpdated = NaN;
            return _this;
        }
        DChartSeriesLineOfAny.prototype.getSizeDefault = function () {
            return 10;
        };
        DChartSeriesLineOfAny.prototype.getOffsetDefault = function () {
            return 0;
        };
        DChartSeriesLineOfAny.prototype.bind = function (container, index) {
            var line = this._line;
            if (!line) {
                line = this._line = this.newLineOfAny();
                var options = this._options;
                this.initLine(line, options, container, index);
            }
            line.attach(container.plotArea.container, index);
            this._pointIdUpdated = NaN;
            _super.prototype.bind.call(this, container, index);
        };
        DChartSeriesLineOfAny.prototype.initLine = function (line, options, container, index) {
            var fill = container.newFill(index, options && options.fill);
            this._fill = fill;
            line.fill.copy(fill);
            var stroke = container.newStroke(index, options && options.stroke);
            this._stroke = stroke;
            line.stroke.copy(stroke);
            var sizeDefault = this.getSizeDefault();
            var size = container.newSize(index, options && options.size, sizeDefault, sizeDefault);
            this._size = size;
            line.points.size.set(size.x, size.y);
            var offsetDefault = this.getOffsetDefault();
            var offset = container.newOffset(index, options && options.offset, offsetDefault, offsetDefault);
            this._offset = offset;
            line.points.offset.set(offset.x, offset.y);
        };
        DChartSeriesLineOfAny.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
        };
        Object.defineProperty(DChartSeriesLineOfAny.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLineOfAny.prototype, "points", {
            get: function () {
                return this._points;
            },
            set: function (points) {
                this._points = points;
                this._pointId += 1;
            },
            enumerable: true,
            configurable: true
        });
        DChartSeriesLineOfAny.prototype.toDirty = function () {
            this._pointId += 1;
        };
        DChartSeriesLineOfAny.prototype.update = function () {
            var line = this._line;
            if (line) {
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    var pointId = this._pointId;
                    var isPointChanged = (pointId !== this._pointIdUpdated);
                    var isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    var isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    if (isPointChanged || isCoordinateChanged || isCoordinateTransformChanged) {
                        this._pointIdUpdated = pointId;
                        this.updateLine(line, coordinateX, coordinateY);
                    }
                }
            }
        };
        DChartSeriesLineOfAny.prototype.updateLine = function (line, xcoordinate, ycoordinate) {
            var values = line.points.values;
            var valuesLength = values.length;
            var ivalues = 0;
            var points = this._points;
            var xmin = NaN;
            var xmax = NaN;
            var ymin = NaN;
            var ymax = NaN;
            for (var i = 0, imax = points.length; i < imax; i += 2) {
                var x = points[i];
                var y = points[i + 1];
                if (x != null && y != null) {
                    if (ivalues < valuesLength) {
                        values[ivalues] = x;
                        values[ivalues + 1] = y;
                    }
                    else {
                        values.push(x, y);
                    }
                    ivalues += 2;
                    if (xmin !== xmin) {
                        xmin = x;
                        xmax = x;
                        ymin = y;
                        ymax = y;
                    }
                    else {
                        xmin = Math.min(xmin, x);
                        xmax = Math.max(xmax, x);
                        ymin = Math.min(ymin, y);
                        ymax = Math.max(ymax, y);
                    }
                }
            }
            if (values.length !== ivalues) {
                values.length = ivalues;
            }
            xcoordinate.mapAll(values, 0, ivalues, 2, 0);
            ycoordinate.mapAll(values, 0, ivalues, 2, 1);
            xcoordinate.transform.mapAll(values, 0, ivalues, 2, 0);
            ycoordinate.transform.mapAll(values, 0, ivalues, 2, 1);
            if (xmin !== xmin) {
                xmin = 0;
                xmax = 0;
                ymin = 0;
                ymax = 0;
            }
            var region = this.adjustLineRegion(xmin, xmax, ymin, ymax, DChartSeriesLineOfAny.WORK_REGION || {
                xmin: 0, xmax: 0,
                ymin: 0, ymax: 0
            });
            xmin = xcoordinate.transform.map(xcoordinate.map(region.xmin));
            xmax = xcoordinate.transform.map(xcoordinate.map(region.xmax));
            ymin = ycoordinate.transform.map(ycoordinate.map(region.ymin));
            ymax = ycoordinate.transform.map(ycoordinate.map(region.ymax));
            var sx = Math.abs(xmax - xmin);
            var sy = Math.abs(ymax - ymin);
            var cx = (xmin + xmax) * 0.5;
            var cy = (ymin + ymax) * 0.5;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                values[i + 0] -= cx;
                values[i + 1] -= cy;
            }
            line.disallowUploadedUpdate();
            this.applyLine(line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
            line.allowUploadedUpdate();
            DApplications.update(line);
        };
        DChartSeriesLineOfAny.prototype.adjustLineRegion = function (xmin, xmax, ymin, ymax, result) {
            result.xmin = xmin;
            result.xmax = xmax;
            result.ymin = ymin;
            result.ymax = ymax;
            return result;
        };
        DChartSeriesLineOfAny.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            line.points.set(values);
            line.size.set(sx, sy);
            line.transform.position.set(cx, cy);
        };
        DChartSeriesLineOfAny.prototype.updateRegion = function () {
            var pointId = this._pointId;
            if (this._regionPointId !== pointId) {
                this._regionPointId = pointId;
                var points = this._points;
                var domain = this._domain;
                var range = this._range;
                domain.clear();
                range.clear();
                this.calcRegion(points, domain, range);
            }
        };
        DChartSeriesLineOfAny.prototype.calcRegion = function (points, domain, range) {
            for (var i = 0, imax = points.length; i < imax; i += 2) {
                var xraw = points[i];
                if (xraw != null) {
                    domain.add(xraw, xraw);
                }
                var yraw = points[i + 1];
                if (yraw != null) {
                    range.add(yraw, yraw);
                }
            }
        };
        DChartSeriesLineOfAny.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            this._points.length = 0;
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            _super.prototype.destroy.call(this);
        };
        DChartSeriesLineOfAny.prototype.hitTest = function (global) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLineOfAny.WORK;
                var local = line.toLocal(global, undefined, work);
                return line.contains(local) != null;
            }
            return false;
        };
        DChartSeriesLineOfAny.prototype.calcHitPoint = function (global, result) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLineOfAny.WORK;
                var local = line.toLocal(global, undefined, work);
                result.shape = line;
                return line.calcHitPoint(local, null, this.calcHitPointTestRange, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLineOfAny.prototype.calcHitPointTestRange = function (x, y, ax, ay, ox, oy, threshold, values, result) {
            var to = toCeilingIndex(values, x + ax + ox, 2, 0);
            var from = 0;
            for (var i = to - 1, iv = i << 1; 0 <= i; i -= 1, iv -= 2) {
                if (values[iv] <= x - ax) {
                    from = i;
                    break;
                }
            }
            result[0] = from;
            result[1] = from !== to ? to : Math.min(values.length << 1, to + 1);
            return result;
        };
        DChartSeriesLineOfAny.prototype.calcHitPointHitTester = function (x, y, ax, ay, ox, oy, px, py, index, threshold, result) {
            var shape = result.shape;
            if (shape.containsPointAbs(x, y, ax, ay, ox, oy, px, py)) {
                var position = shape.transform.position;
                result.x = result.p0x = result.p1x = position.x + px;
                result.y = result.p0y = result.p1y = position.y + py;
                result.t = threshold;
                result.index = index;
                var dx = x - (px + ox);
                var dy = y - (py + oy);
                result.distance = Math.sqrt(dx * dx + dy * dy);
                return true;
            }
            return false;
        };
        DChartSeriesLineOfAny.WORK = new pixi_js.Point();
        return DChartSeriesLineOfAny;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents bars.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesBar = /** @class */ (function (_super) {
        __extends(DChartSeriesBar, _super);
        function DChartSeriesBar(options) {
            var _this = _super.call(this, options) || this;
            _this._barCount = -1;
            _this._barIndex = -1;
            _this._xcoordinateId = -1;
            _this._xcoordinateTransformId = -1;
            return _this;
        }
        DChartSeriesBar.prototype.bind = function (container, index) {
            this._barCount = -1;
            this._barIndex = -1;
            this._xcoordinateId = -1;
            this._xcoordinateTransformId = -1;
            _super.prototype.bind.call(this, container, index);
        };
        DChartSeriesBar.prototype.initLine = function (line, options, container, index) {
            _super.prototype.initLine.call(this, line, options, container, index);
            this._padding = container.newPadding(index, options && options.padding);
        };
        DChartSeriesBar.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangles();
        };
        DChartSeriesBar.prototype.getSizeDefault = function () {
            return 1;
        };
        DChartSeriesBar.prototype.adjustLineRegion = function (xmin, xmax, ymin, ymax, result) {
            return _super.prototype.adjustLineRegion.call(this, xmin, xmax, Math.min(0, ymin), Math.max(0, ymax), result);
        };
        DChartSeriesBar.prototype.updateBarCountAndIndex = function () {
            if (this._barIndex < 0 || this._barCount < 0) {
                var barIndex = 0;
                var barCount = 0;
                var container = this._container;
                if (container) {
                    for (var i = 0, imax = container.size(); i < imax; ++i) {
                        var series = container.get(i);
                        if (series === this) {
                            barIndex = barCount;
                        }
                        if (series instanceof DChartSeriesBar) {
                            barCount += 1;
                        }
                    }
                }
                barCount = Math.max(1, barCount);
                this._barCount = barCount;
                this._barIndex = barIndex;
                return true;
            }
            return false;
        };
        DChartSeriesBar.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            // Offset
            var size = this._size;
            var offset = this._offset;
            var padding = this._padding;
            if (size && offset && padding) {
                var xcoordinateId = xcoordinate.id;
                var xcoordinateTransformId = xcoordinate.transform.id;
                if (this.updateBarCountAndIndex() || this._xcoordinateId !== xcoordinateId ||
                    this._xcoordinateTransformId !== xcoordinateTransformId) {
                    var barCount = this._barCount;
                    var barIndex = this._barIndex;
                    this._xcoordinateId = xcoordinateId;
                    this._xcoordinateTransformId = xcoordinateTransformId;
                    var x0 = xcoordinate.transform.map(xcoordinate.map(0));
                    var x1 = xcoordinate.transform.map(xcoordinate.map(size.x));
                    var totalBandWidth = Math.abs(x1 - x0) * (1 - padding.outer);
                    if (barCount <= 1) {
                        line.points.offset.x = offset.x;
                        line.points.size.x = totalBandWidth;
                    }
                    else {
                        var totalBarWidth = totalBandWidth * (1 - padding.inner);
                        var totalPaddingInner = totalBandWidth - totalBarWidth;
                        var barWidth = totalBarWidth / barCount;
                        var barPadding = totalPaddingInner / (barCount - 1);
                        var barX = barWidth * (barIndex + 0.5) + barIndex * barPadding;
                        line.points.offset.x = offset.x + barX - totalBandWidth * 0.5;
                        line.points.size.x = barWidth;
                    }
                }
            }
            // Sizes & Offsets
            var sizes = line.points.size.y;
            if (!isArray(sizes)) {
                sizes = [];
            }
            var sizesLength = sizes.length;
            var offsets = line.points.offset.y;
            if (!isArray(offsets)) {
                offsets = [];
            }
            var offsetsLength = offsets.length;
            var isize = 0;
            var y0 = ycoordinate.transform.map(ycoordinate.map(0)) - cy;
            for (var i = 0, imax = values.length; i < imax; i += 2, isize += 1) {
                var distance = values[i + 1] - y0;
                var s = Math.abs(distance);
                if (isize < sizesLength) {
                    sizes[isize] = s;
                }
                else {
                    sizes.push(s);
                }
                var o = -0.5 * distance;
                if (isize < offsetsLength) {
                    offsets[isize] = o;
                }
                else {
                    offsets.push(o);
                }
            }
            if (sizes.length !== isize) {
                sizes.length = isize;
            }
            if (offsets.length !== isize) {
                offsets.length = isize;
            }
            line.points.size.y = sizes;
            line.points.offset.y = offsets;
            // Others
            _super.prototype.applyLine.call(this, line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
        };
        DChartSeriesBar.prototype.calcRegion = function (points, domain, range) {
            _super.prototype.calcRegion.call(this, points, domain, range);
            var size = this._size;
            if (size) {
                var sx = size.x * 0.5;
                domain.set(domain.from - sx, domain.to + sx);
            }
            range.add(0, 0);
        };
        return DChartSeriesBar;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of circles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfCircles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfCircles, _super);
        function DChartSeriesLineOfCircles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfCircles.prototype.newLineOfAny = function () {
            return new EShapeLineOfCircles();
        };
        return DChartSeriesLineOfCircles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rounded rectangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfRectangleRoundeds = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfRectangleRoundeds, _super);
        function DChartSeriesLineOfRectangleRoundeds() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfRectangleRoundeds.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangleRoundeds();
        };
        return DChartSeriesLineOfRectangleRoundeds;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rectangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfRectangles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfRectangles, _super);
        function DChartSeriesLineOfRectangles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfRectangles.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangles();
        };
        return DChartSeriesLineOfRectangles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of triangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfTriangles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfTriangles, _super);
        function DChartSeriesLineOfTriangles(options) {
            var _this = _super.call(this, options) || this;
            _this._sizeId = 0;
            return _this;
        }
        DChartSeriesLineOfTriangles.prototype.newLineOfAny = function () {
            return new EShapeLineOfTriangles();
        };
        DChartSeriesLineOfTriangles.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            // Offset
            var size = this._size;
            var offset = this._offset;
            if (size && offset && this._sizeId !== size.y) {
                this._sizeId = size.y;
                line.points.offset.y = offset.y - size.y * 0.2;
            }
            //
            _super.prototype.applyLine.call(this, line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
        };
        return DChartSeriesLineOfTriangles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rounded triangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfTriangleRoundeds = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfTriangleRoundeds, _super);
        function DChartSeriesLineOfTriangleRoundeds() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfTriangleRoundeds.prototype.newLineOfAny = function () {
            return new EShapeLineOfTriangleRoundeds();
        };
        return DChartSeriesLineOfTriangleRoundeds;
    }(DChartSeriesLineOfTriangles));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a polyline.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLine = /** @class */ (function (_super) {
        __extends(DChartSeriesLine, _super);
        function DChartSeriesLine(options) {
            var _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._points = (options && options.points) || [];
            _this._pointId = 0;
            _this._pointIdUpdated = NaN;
            _this._centerX = 0;
            _this._centerY = 0;
            return _this;
        }
        DChartSeriesLine.prototype.bind = function (container, index) {
            var _a;
            var line = this._line;
            if (!line) {
                var stroke = this._stroke = container.newStroke(index, (_a = this._options) === null || _a === void 0 ? void 0 : _a.stroke);
                line = this._line = new EShapeLine([], [], stroke.width, stroke.style);
                line.stroke.copy(stroke);
            }
            line.attach(container.plotArea.container, index);
            this._pointIdUpdated = NaN;
            _super.prototype.bind.call(this, container, index);
        };
        DChartSeriesLine.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
        };
        Object.defineProperty(DChartSeriesLine.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLine.prototype, "points", {
            get: function () {
                return this._points;
            },
            set: function (points) {
                this._points = points;
                this._pointId += 1;
            },
            enumerable: true,
            configurable: true
        });
        DChartSeriesLine.prototype.toDirty = function () {
            this._pointId += 1;
        };
        DChartSeriesLine.prototype.update = function () {
            var line = this._line;
            if (line) {
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    var pointId = this._pointId;
                    var isPointChanged = (pointId !== this._pointIdUpdated);
                    var isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    var isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    if (isPointChanged || isCoordinateChanged || isCoordinateTransformChanged) {
                        this._pointIdUpdated = pointId;
                        this.updateLine(line, coordinateX, coordinateY, isPointChanged || isCoordinateChanged);
                    }
                }
            }
        };
        DChartSeriesLine.prototype.updateLine = function (line, xcoordinate, ycoordinate, isPointsDirty) {
            line.disallowUploadedUpdate();
            if (isPointsDirty) {
                var values = line.points.values;
                var segments = line.points.segments;
                var valuesLength = values.length;
                var segmentsLength = segments.length;
                var ivalues = 0;
                var isegments = 0;
                var points = this._points;
                var xmin = NaN;
                var xmax = NaN;
                var ymin = NaN;
                var ymax = NaN;
                for (var i = 0, imax = points.length; i < imax; i += 2) {
                    var x = points[i];
                    var y = points[i + 1];
                    if (x != null && y != null) {
                        if (ivalues < valuesLength) {
                            values[ivalues] = x;
                            values[ivalues + 1] = y;
                        }
                        else {
                            values.push(x, y);
                        }
                        ivalues += 2;
                        if (xmin !== xmin) {
                            xmin = x;
                            xmax = x;
                            ymin = y;
                            ymax = y;
                        }
                        else {
                            xmin = Math.min(xmin, x);
                            xmax = Math.max(xmax, x);
                            ymin = Math.min(ymin, y);
                            ymax = Math.max(ymax, y);
                        }
                    }
                    else {
                        var segment = (i >> 1) - isegments;
                        if (isegments < segmentsLength) {
                            segments[isegments] = segment;
                        }
                        else {
                            segments.push(segment);
                        }
                        isegments += 1;
                    }
                }
                if (values.length !== ivalues) {
                    values.length = ivalues;
                }
                if (segments.length !== isegments) {
                    segments.length = isegments;
                }
                xcoordinate.mapAll(values, 0, ivalues, 2, 0);
                ycoordinate.mapAll(values, 0, ivalues, 2, 1);
                if (xmin !== xmin) {
                    xmin = 0;
                    xmax = 0;
                    ymin = 0;
                    ymax = 0;
                }
                xmin = xcoordinate.map(xmin);
                xmax = xcoordinate.map(xmax);
                ymin = ycoordinate.map(ymin);
                ymax = ycoordinate.map(ymax);
                var sx = Math.abs(xmax - xmin);
                var sy = Math.abs(ymax - ymin);
                var cx = (xmin + xmax) * 0.5;
                var cy = (ymin + ymax) * 0.5;
                for (var i = 0, imax = values.length; i < imax; i += 2) {
                    values[i + 0] -= cx;
                    values[i + 1] -= cy;
                }
                line.size.set(sx, sy);
                line.points.set(values, segments);
                this._centerX = cx;
                this._centerY = cy;
            }
            line.transform.position.set(xcoordinate.transform.map(this._centerX), ycoordinate.transform.map(this._centerY));
            line.transform.scale.set(xcoordinate.transform.scale, ycoordinate.transform.scale);
            line.allowUploadedUpdate();
            DApplications.update(line);
        };
        DChartSeriesLine.prototype.updateRegion = function () {
            var pointId = this._pointId;
            if (this._regionPointId !== pointId) {
                this._regionPointId = pointId;
                var points = this._points;
                var domain = this._domain;
                var range = this._range;
                domain.clear();
                range.clear();
                if (points != null) {
                    for (var i = 0, imax = points.length; i < imax; i += 2) {
                        var xraw = points[i];
                        if (xraw != null) {
                            domain.add(xraw, xraw);
                        }
                        var yraw = points[i + 1];
                        if (yraw != null) {
                            range.add(yraw, yraw);
                        }
                    }
                }
            }
        };
        DChartSeriesLine.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            this._points.length = 0;
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            _super.prototype.destroy.call(this);
        };
        DChartSeriesLine.prototype.hitTest = function (global) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLine.WORK;
                var local = line.toLocal(global, undefined, work);
                return line.contains(local) != null;
            }
            return false;
        };
        DChartSeriesLine.prototype.calcHitPoint = function (global, result) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLine.WORK;
                var local = line.toLocal(global, undefined, work);
                result.shape = line;
                return line.calcHitPoint(local, this.toThreshold, this.calcHitPointTestRange, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLine.prototype.toThreshold = function (strokeWidth, strokeScale) {
            return +Infinity;
        };
        DChartSeriesLine.prototype.calcHitPointTestRange = function (x, y, threshold, values, result) {
            var index = toCeilingIndex(values, x, 2, 0);
            result[0] = Math.max(0, index - 1);
            result[1] = index;
            return result;
        };
        DChartSeriesLine.prototype.calcHitPointHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            if (p0x <= x && x < p1x) {
                var l = p1x - p0x;
                if (0.0001 < Math.abs(l)) {
                    var t = (x - p0x) / l;
                    var p2x = x;
                    var p2y = p0y + t * (p1y - p0y);
                    var distance = Math.abs(p2y - y);
                    if (distance < threshold) {
                        var position = result.shape.transform.position;
                        var px = position.x;
                        var py = position.y;
                        result.x = px + p2x;
                        result.y = py + p2y;
                        result.p0x = px + p0x;
                        result.p0y = py + p0y;
                        result.p1x = px + p1x;
                        result.p1y = py + p1y;
                        result.t = t;
                        result.index = index;
                        result.distance = distance;
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLine.WORK = new pixi_js.Point();
        return DChartSeriesLine;
    }(DChartSeriesBase));

    var DChartSeriesExpressionParametersImpl = /** @class */ (function () {
        function DChartSeriesExpressionParametersImpl(a, b, x0, y0) {
            this._id = 0;
            this._idUpdated = NaN;
            this._a = a;
            this._b = b;
            this._x0 = x0;
            this._y0 = y0;
        }
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "a", {
            get: function () {
                return this._a;
            },
            set: function (a) {
                if (this._a !== a) {
                    this._id += 1;
                    this._a = a;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "b", {
            get: function () {
                return this._b;
            },
            set: function (b) {
                if (this._b !== b) {
                    this._id += 1;
                    this._b = b;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "x0", {
            get: function () {
                return this._x0;
            },
            set: function (x0) {
                if (this._x0 !== x0) {
                    this._id += 1;
                    this._x0 = x0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "y0", {
            get: function () {
                return this._y0;
            },
            set: function (y0) {
                if (this._y0 !== y0) {
                    this._id += 1;
                    this._y0 = y0;
                }
            },
            enumerable: true,
            configurable: true
        });
        DChartSeriesExpressionParametersImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        DChartSeriesExpressionParametersImpl.prototype.isDirty = function () {
            return this._id !== this._idUpdated;
        };
        DChartSeriesExpressionParametersImpl.prototype.toClean = function () {
            this._idUpdated = this._id;
        };
        DChartSeriesExpressionParametersImpl.from = function (options) {
            if (options) {
                return new DChartSeriesExpressionParametersImpl((options.a != null ? options.a : 1), (options.b != null ? options.b : 1), (options.x0 != null ? options.x0 : 0), (options.y0 != null ? options.y0 : 0));
            }
            return new DChartSeriesExpressionParametersImpl(1, 1, 0, 0);
        };
        return DChartSeriesExpressionParametersImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a linear equation `a (x - x0) === b (y - y0)`.
     */
    var DChartSeriesLinear = /** @class */ (function (_super) {
        __extends(DChartSeriesLinear, _super);
        function DChartSeriesLinear(options) {
            var _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._plotAreaSizeXUpdated = NaN;
            _this._plotAreaSizeYUpdated = NaN;
            _this._parameters = DChartSeriesExpressionParametersImpl.from(options);
            return _this;
        }
        DChartSeriesLinear.prototype.bind = function (container, index) {
            var _a;
            var line = this._line;
            if (!line) {
                var stroke = this._stroke = container.newStroke(index, (_a = this._options) === null || _a === void 0 ? void 0 : _a.stroke);
                line = this._line = new EShapeLine([], [], stroke.width, stroke.style);
                line.stroke.color = stroke.color;
                line.stroke.alpha = stroke.alpha;
            }
            line.attach(container.plotArea.container, index);
            this._parameters.toDirty();
            this._plotAreaSizeXUpdated = NaN;
            this._plotAreaSizeYUpdated = NaN;
            _super.prototype.bind.call(this, container, index);
        };
        DChartSeriesLinear.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
        };
        Object.defineProperty(DChartSeriesLinear.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLinear.prototype, "parameters", {
            get: function () {
                return this._parameters;
            },
            enumerable: true,
            configurable: true
        });
        DChartSeriesLinear.prototype.toDirty = function () {
            this._parameters.toDirty();
        };
        DChartSeriesLinear.prototype.update = function () {
            var line = this._line;
            var container = this._container;
            if (line && container) {
                var plotArea = container.plotArea;
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    var plotAreaWidth = plotArea.width;
                    var plotAreaHeight = plotArea.height;
                    var parameters = this._parameters;
                    var isParametersChanged = parameters.isDirty();
                    var isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    var isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    var isPlotAreaSizeChagned = (plotAreaWidth !== this._plotAreaSizeXUpdated ||
                        plotAreaHeight !== this._plotAreaSizeYUpdated);
                    if (isParametersChanged || isCoordinateChanged || isCoordinateTransformChanged || isPlotAreaSizeChagned) {
                        parameters.toClean();
                        this._plotAreaSizeXUpdated = plotAreaWidth;
                        this._plotAreaSizeYUpdated = plotAreaHeight;
                        this.updateLine(line, coordinateX, coordinateY, plotAreaWidth, plotAreaHeight);
                    }
                }
            }
        };
        DChartSeriesLinear.prototype.updateLine = function (line, xcoordinate, ycoordinate, plotAreaSizeX, plotAreaSizeY) {
            var values = line.points.values;
            var segments = line.points.segments;
            var parameters = this._parameters;
            var a = parameters.a;
            var b = parameters.b;
            var x0 = parameters.x0;
            var y0 = parameters.y0;
            var aabs = Math.abs(a);
            var babs = Math.abs(b);
            var p0x = NaN;
            var p0y = NaN;
            var p1x = NaN;
            var p1y = NaN;
            var threshold = 0.00001;
            if (babs <= aabs) {
                var xfrom0 = xcoordinate.unmap(xcoordinate.transform.unmap(0));
                var xto0 = xcoordinate.unmap(xcoordinate.transform.unmap(plotAreaSizeX));
                p0x = Math.min(xfrom0, xto0);
                p1x = Math.max(xfrom0, xto0);
                if (threshold < aabs) {
                    var yfrom = ycoordinate.unmap(ycoordinate.transform.unmap(0));
                    var yto = ycoordinate.unmap(ycoordinate.transform.unmap(plotAreaSizeY));
                    var xfrom1 = b * (yfrom - y0) / a + x0;
                    var xto1 = b * (yto - y0) / a + x0;
                    var p2x = Math.min(xfrom1, xto1);
                    var p3x = Math.max(xfrom1, xto1);
                    if (p0x < p2x) {
                        p0x = p2x;
                    }
                    if (p3x < p1x) {
                        p1x = p3x;
                    }
                }
                p0y = a * (p0x - x0) + b * y0;
                p1y = a * (p1x - x0) + b * y0;
            }
            else {
                var yfrom0 = ycoordinate.unmap(ycoordinate.transform.unmap(0));
                var yto0 = ycoordinate.unmap(ycoordinate.transform.unmap(plotAreaSizeY));
                p0y = Math.min(yfrom0, yto0);
                p1y = Math.max(yfrom0, yto0);
                if (threshold < babs) {
                    var xfrom = xcoordinate.unmap(xcoordinate.transform.unmap(0));
                    var xto = xcoordinate.unmap(xcoordinate.transform.unmap(plotAreaSizeX));
                    var yfrom1 = a * (xfrom - x0) / b + y0;
                    var yto1 = a * (xto - x0) / b + y0;
                    var p2y = Math.min(yfrom1, yto1);
                    var p3y = Math.max(yfrom1, yto1);
                    if (p0y < p2y) {
                        p0y = p2y;
                    }
                    if (p3y < p1y) {
                        p1y = p3y;
                    }
                }
                p0x = b * (p0y - y0) + a * x0;
                p1x = b * (p1y - y0) + a * x0;
            }
            p0x = xcoordinate.transform.map(xcoordinate.map(p0x));
            p0y = ycoordinate.transform.map(ycoordinate.map(p0y));
            p1x = xcoordinate.transform.map(xcoordinate.map(p1x));
            p1y = ycoordinate.transform.map(ycoordinate.map(p1y));
            var cx = (p0x + p1x) * 0.5;
            var cy = (p0y + p1y) * 0.5;
            var sx = Math.abs(p1x - p0x);
            var sy = Math.abs(p1y - p0y);
            p0x -= cx;
            p0y -= cy;
            p1x -= cx;
            p1y -= cy;
            if (values.length !== 4) {
                values.length = 0;
                values.push(p0x, p0y, p1x, p1y);
            }
            else {
                values[0] = p0x;
                values[1] = p0y;
                values[2] = p1x;
                values[3] = p1y;
            }
            if (segments.length !== 0) {
                segments.length = 0;
            }
            line.disallowUploadedUpdate();
            line.points.set(values, segments);
            line.size.set(sx, sy);
            line.transform.position.set(cx, cy);
            line.allowUploadedUpdate();
            DApplications.update(line);
        };
        DChartSeriesLinear.prototype.updateRegion = function () {
            // DO NOTHING
        };
        DChartSeriesLinear.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            _super.prototype.destroy.call(this);
        };
        DChartSeriesLinear.prototype.hitTest = function (global) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLinear.WORK;
                var local = line.toLocal(global, undefined, work);
                return line.contains(local) != null;
            }
            return false;
        };
        DChartSeriesLinear.prototype.calcHitPoint = function (global, result) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLinear.WORK;
                var local = line.toLocal(global, undefined, work);
                result.shape = line;
                return line.calcHitPoint(local, this.toThreshold, null, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLinear.prototype.toThreshold = function (strokeWidth, strokeScale) {
            return +Infinity;
        };
        DChartSeriesLinear.prototype.calcHitPointHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            if (p0x <= x && x < p1x) {
                var l = p1x - p0x;
                if (0.0001 < Math.abs(l)) {
                    var t = (x - p0x) / l;
                    var p2x = x;
                    var p2y = p0y + t * (p1y - p0y);
                    var distance = Math.abs(p2y - y);
                    if (distance < threshold) {
                        var position = result.shape.transform.position;
                        var px = position.x;
                        var py = position.y;
                        result.x = result.p0x = result.p1x = px + p2x;
                        result.y = result.p0y = result.p1y = py + p2y;
                        result.t = t;
                        result.index = index;
                        result.distance = distance;
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLinear.prototype.onStateChange = function (newState, oldState) {
            var isActive = DBaseStates.isActive(newState);
            var wasActive = DBaseStates.isActive(oldState);
            if (isActive !== wasActive) {
                var line = this._line;
                var stroke = this._stroke;
                if (line && stroke) {
                    line.stroke.width = stroke.width * (isActive ? 2 : 1);
                }
            }
            _super.prototype.onStateChange.call(this, newState, oldState);
        };
        DChartSeriesLinear.WORK = new pixi_js.Point();
        return DChartSeriesLinear;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionShapeBase = /** @class */ (function () {
        function DChartSelectionShapeBase(options) {
            var theme = this.toTheme(options);
            this._theme = theme;
            var state = (options && options.state != null ? options.state : DBaseState.HOVERED);
            this._state = state;
            this._isEnabled = (options && options.enable != null ? options.enable : theme.isEnabled(state));
            this._shape = options && options.shape;
            this._style = (options && options.style) || this.setStyle;
        }
        DChartSelectionShapeBase.prototype.bind = function (container) {
            if (this._isEnabled) {
                var shape = this._shape = (this._shape || this.newShape(this._theme));
                shape.attach(container.plotArea.axis.container);
                shape.visible = false;
            }
        };
        DChartSelectionShapeBase.prototype.unbind = function () {
            var shape = this._shape;
            if (shape) {
                shape.detach();
            }
        };
        DChartSelectionShapeBase.prototype.newShape = function (theme) {
            return theme.newShape(this._state);
        };
        DChartSelectionShapeBase.prototype.set = function (container, mappedPosition, series) {
            this.update(container, mappedPosition);
            var shape = this._shape;
            if (shape) {
                this._style(shape, series);
            }
        };
        DChartSelectionShapeBase.prototype.setStyle = function (shape, series) {
            var seriesShape = series.shape;
            if (seriesShape) {
                shape.stroke.color = seriesShape.stroke.color;
            }
        };
        DChartSelectionShapeBase.prototype.unset = function () {
            var shape = this._shape;
            if (shape) {
                shape.visible = false;
            }
        };
        DChartSelectionShapeBase.prototype.toTheme = function (options) {
            var theme = (options && options.theme);
            if (isString(theme)) {
                return this.getTheme(theme);
            }
            else if (theme != null) {
                return theme;
            }
            else {
                return this.getTheme(this.getType());
            }
        };
        DChartSelectionShapeBase.prototype.getTheme = function (type) {
            return DThemes.getInstance().get(type);
        };
        return DChartSelectionShapeBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionGridlineX = /** @class */ (function (_super) {
        __extends(DChartSelectionGridlineX, _super);
        function DChartSelectionGridlineX() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionGridlineX.prototype.update = function (container, mappedPosition) {
            var shape = this._shape;
            if (shape) {
                var mappedX = mappedPosition.x;
                var height = container.plotArea.height;
                shape.transform.position.set(mappedX, height * 0.5);
                shape.size.set(0, height);
                shape.visible = this.isVisible(container, mappedX);
            }
        };
        DChartSelectionGridlineX.prototype.isVisible = function (container, mappedX) {
            return (0 <= mappedX && mappedX <= container.plotArea.width);
        };
        DChartSelectionGridlineX.prototype.getType = function () {
            return "DChartSelectionGridlineX";
        };
        return DChartSelectionGridlineX;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionGridlineY = /** @class */ (function (_super) {
        __extends(DChartSelectionGridlineY, _super);
        function DChartSelectionGridlineY() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionGridlineY.prototype.update = function (container, mappedPosition) {
            var shape = this._shape;
            if (shape) {
                var mappedY = mappedPosition.y;
                var width = container.plotArea.width;
                shape.transform.position.set(width * 0.5, mappedY);
                shape.size.set(width, 0);
                shape.visible = this.isVisible(container, mappedY);
            }
        };
        DChartSelectionGridlineY.prototype.isVisible = function (container, mappedY) {
            return (0 <= mappedY && mappedY <= container.plotArea.height);
        };
        DChartSelectionGridlineY.prototype.getType = function () {
            return "DChartSelectionGridlineY";
        };
        return DChartSelectionGridlineY;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionGridlineContainerImpl = /** @class */ (function () {
        function DChartSelectionGridlineContainerImpl(options) {
            this._x = new DChartSelectionGridlineX(options && options.x);
            this._y = new DChartSelectionGridlineY(options && options.y);
        }
        Object.defineProperty(DChartSelectionGridlineContainerImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSelectionGridlineContainerImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: true,
            configurable: true
        });
        DChartSelectionGridlineContainerImpl.prototype.bind = function (container) {
            this._x.bind(container);
            this._y.bind(container);
        };
        DChartSelectionGridlineContainerImpl.prototype.unbind = function () {
            this._x.unbind();
            this._y.unbind();
        };
        DChartSelectionGridlineContainerImpl.prototype.set = function (container, mappedPosition, series) {
            this._x.set(container, mappedPosition, series);
            this._y.set(container, mappedPosition, series);
        };
        DChartSelectionGridlineContainerImpl.prototype.unset = function () {
            this._x.unset();
            this._y.unset();
        };
        DChartSelectionGridlineContainerImpl.prototype.update = function (container, mappedPosition) {
            this._x.update(container, mappedPosition);
            this._y.update(container, mappedPosition);
        };
        return DChartSelectionGridlineContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionMarker = /** @class */ (function (_super) {
        __extends(DChartSelectionMarker, _super);
        function DChartSelectionMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionMarker.prototype.update = function (container, mappedPosition) {
            var shape = this._shape;
            if (shape) {
                shape.transform.position.copyFrom(mappedPosition);
                shape.visible = this.isVisible(container, mappedPosition);
            }
        };
        DChartSelectionMarker.prototype.isVisible = function (container, mappedPosition) {
            var x = mappedPosition.x;
            var y = mappedPosition.y;
            var plotArea = container.plotArea;
            return (0 <= x && x <= plotArea.width && 0 <= y && y <= plotArea.height);
        };
        DChartSelectionMarker.prototype.getType = function () {
            return "DChartSelectionMarker";
        };
        return DChartSelectionMarker;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionPoint;
    (function (DChartSelectionPoint) {
        DChartSelectionPoint[DChartSelectionPoint["PREVIOUS"] = 0] = "PREVIOUS";
        DChartSelectionPoint[DChartSelectionPoint["NEXT"] = 1] = "NEXT";
        DChartSelectionPoint[DChartSelectionPoint["CLOSER"] = 2] = "CLOSER";
        DChartSelectionPoint[DChartSelectionPoint["INTERSECTION"] = 3] = "INTERSECTION";
    })(DChartSelectionPoint || (DChartSelectionPoint = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionSubImpl = /** @class */ (function (_super) {
        __extends(DChartSelectionSubImpl, _super);
        function DChartSelectionSubImpl(options) {
            var _this = _super.call(this) || this;
            _this._container = null;
            _this._series = null;
            _this._isEnabled = (options.enable != null ? options.enable : true);
            _this._gridline = new DChartSelectionGridlineContainerImpl(options.gridline);
            _this._marker = new DChartSelectionMarker(options.marker);
            _this._state = (options.state != null ? options.state : DBaseState.HOVERED);
            _this._coordinateX = null;
            _this._coordinateY = null;
            _this._position = new pixi_js.Point();
            _this._point = (options.point != null ? options.point : DChartSelectionPoint.CLOSER);
            _this._work = new pixi_js.Point();
            // Events
            var on = options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DChartSelectionSubImpl.prototype.bind = function (container) {
            if (this._isEnabled) {
                this._container = container;
                this._gridline.bind(container);
                this._marker.bind(container);
            }
        };
        DChartSelectionSubImpl.prototype.unbind = function () {
            this._marker.unbind();
            this._gridline.unbind();
            this._container = null;
            this._coordinateX = null;
            this._coordinateY = null;
        };
        Object.defineProperty(DChartSelectionSubImpl.prototype, "series", {
            get: function () {
                return this._series;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "gridline", {
            get: function () {
                return this._gridline;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "marker", {
            get: function () {
                return this._marker;
            },
            enumerable: true,
            configurable: true
        });
        DChartSelectionSubImpl.prototype.set = function (series, result) {
            var container = this._container;
            var coordinateX = this._coordinateX = series.coordinate.x;
            var coordinateY = this._coordinateY = series.coordinate.y;
            if (container && coordinateX && coordinateY) {
                var transform = container.plotArea.container.localTransform;
                var position = this._position;
                var work = this._work;
                if (result instanceof DChartSeriesHitResult) {
                    var x = result.x;
                    var y = result.y;
                    switch (this._point) {
                        case DChartSelectionPoint.PREVIOUS:
                            x = result.p0x;
                            y = result.p0y;
                            break;
                        case DChartSelectionPoint.NEXT:
                            x = result.p1x;
                            y = result.p1y;
                            break;
                        case DChartSelectionPoint.CLOSER:
                            if (Math.abs(result.p0x - result.x) < Math.abs(result.p1x - result.x)) {
                                x = result.p0x;
                                y = result.p0y;
                            }
                            else {
                                x = result.p1x;
                                y = result.p1y;
                            }
                    }
                    work.set(x, y);
                    transform.apply(work, work);
                    position.set(coordinateX.unmap(coordinateX.transform.unmap(x)), coordinateY.unmap(coordinateY.transform.unmap(y)));
                }
                else {
                    position.copyFrom(result.position);
                    work.set(coordinateX.transform.map(coordinateX.map(position.x)), coordinateY.transform.map(coordinateY.map(position.y)));
                    transform.apply(work, work);
                }
                this._gridline.set(container, work, series);
                this._marker.set(container, work, series);
                DApplications.update(container.plotArea);
            }
            var oldSeries = this._series;
            if (oldSeries !== series) {
                var state = this._state;
                if (oldSeries) {
                    oldSeries.setState(state, false);
                }
                this._series = series;
                series.setState(state, true);
            }
            this.emit("change", this);
        };
        DChartSelectionSubImpl.prototype.setStyle = function (shape, series) {
            var seriesShape = series.shape;
            if (seriesShape) {
                shape.stroke.color = seriesShape.stroke.color;
            }
        };
        DChartSelectionSubImpl.prototype.unset = function () {
            var series = this._series;
            if (series) {
                this._series = null;
                this._coordinateX = null;
                this._coordinateY = null;
                series.setState(this._state, false);
                this._gridline.unset();
                this._marker.unset();
                this.emit("change", this);
            }
        };
        DChartSelectionSubImpl.prototype.update = function () {
            var container = this._container;
            var coordinateX = this._coordinateX;
            var coordinateY = this._coordinateY;
            if (container && coordinateX && coordinateY) {
                var position = this._position;
                var work = this._work;
                work.set(coordinateX.transform.map(coordinateX.map(position.x)), coordinateY.transform.map(coordinateY.map(position.y)));
                container.plotArea.container.localTransform.apply(work, work);
                this._gridline.update(container, work);
                this._marker.update(container, work);
            }
        };
        return DChartSelectionSubImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionSimple = /** @class */ (function (_super) {
        __extends(DChartSelectionSimple, _super);
        function DChartSelectionSimple(options) {
            var _this = _super.call(this) || this;
            _this._container = null;
            var point = (options && options.point != null ?
                (isString(options.point) ? DChartSelectionPoint[options.point] : options.point) :
                DChartSelectionPoint.CLOSER);
            _this._selected = _this.newSelected(point, options && options.selected);
            _this._hovered = _this.newHovered(point, options && options.hovered);
            // Events
            if (options) {
                var on = options.on;
                if (on != null) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            //
            _this._onMoveBound = function (e) {
                _this.onMove(e);
            };
            _this._onClickBound = function (e) {
                _this.onClick(e);
            };
            return _this;
        }
        DChartSelectionSimple.prototype.newSelected = function (point, options) {
            return new DChartSelectionSubImpl(this.toSubOptions(point, options, DBaseState.ACTIVE));
        };
        DChartSelectionSimple.prototype.newHovered = function (point, options) {
            return new DChartSelectionSubImpl(this.toSubOptions(point, options, DBaseState.HOVERED));
        };
        DChartSelectionSimple.prototype.toSubOptions = function (point, options, state) {
            options = options || {};
            if (options.point == null) {
                options.point = point;
            }
            if (options.state == null) {
                options.state = state;
            }
            var gridline = options.gridline || {};
            var gridlineX = gridline.x || {};
            if (gridlineX.state == null) {
                gridlineX.state = state;
            }
            var gridlineY = gridline.y || {};
            if (gridlineY.state == null) {
                gridlineY.state = state;
            }
            var marker = options.marker || {};
            if (marker.state == null) {
                marker.state = state;
            }
            return options;
        };
        DChartSelectionSimple.prototype.onClick = function (e) {
            var container = this._container;
            if (container && e.target === container.plotArea) {
                var hovered = this._hovered;
                var series = hovered.series;
                var selected = this._selected;
                if (series) {
                    selected.set(series, hovered);
                }
                else {
                    selected.unset();
                }
            }
        };
        DChartSelectionSimple.prototype.onMove = function (e) {
            var container = this._container;
            if (container) {
                var hovered = this._hovered;
                if (e.target === container.plotArea) {
                    var result = DChartSelectionSimple.WORK_SELECT;
                    var series = container.calcHitPoint(e.data.global, result);
                    if (series) {
                        hovered.set(series, result);
                    }
                    else {
                        hovered.unset();
                    }
                }
                else {
                    hovered.unset();
                }
            }
        };
        DChartSelectionSimple.prototype.bind = function (container) {
            this._container = container;
            this._selected.bind(container);
            this._hovered.bind(container);
            var plotArea = container.plotArea;
            plotArea.on(UtilPointerEvent.move, this._onMoveBound);
            UtilPointerEvent.onClick(plotArea, this._onClickBound);
        };
        DChartSelectionSimple.prototype.unbind = function () {
            var container = this._container;
            this._container = null;
            if (container) {
                var plotArea = container.plotArea;
                plotArea.off(UtilPointerEvent.move, this._onMoveBound);
            }
            this._selected.unbind();
            this._hovered.unbind();
        };
        Object.defineProperty(DChartSelectionSimple.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSimple.prototype, "hovered", {
            get: function () {
                return this._hovered;
            },
            enumerable: true,
            configurable: true
        });
        DChartSelectionSimple.prototype.update = function () {
            this._selected.update();
            this._hovered.update();
        };
        DChartSelectionSimple.WORK_SELECT = new DChartSeriesHitResult();
        return DChartSelectionSimple;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChart = /** @class */ (function (_super) {
        __extends(DChart, _super);
        function DChart() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChart.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            var plotArea = new DChartPlotArea(this, options && options.plotArea);
            this._plotArea = plotArea;
            this.addChild(plotArea);
        };
        Object.defineProperty(DChart.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: true,
            configurable: true
        });
        DChart.prototype.getType = function () {
            return "DChart";
        };
        DChart.prototype.destroy = function () {
            if (!this._destroyed) {
                this._plotArea.destroy();
                _super.prototype.destroy.call(this);
            }
        };
        return DChart;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandCreate = /** @class */ (function () {
        function DCommandCreate() {
        }
        DCommandCreate.prototype.redo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandCreate.prototype.undo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandCreate.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandCreate.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE | DCommandFlag.CLEAR;
        };
        return DCommandCreate;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandDelete = /** @class */ (function () {
        function DCommandDelete() {
        }
        DCommandDelete.prototype.execute = function () {
            return DControllers.getDocumentController().delete();
        };
        DCommandDelete.prototype.redo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandDelete.prototype.undo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandDelete.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandDelete.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE | DCommandFlag.CLEAR;
        };
        return DCommandDelete;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandSaveAs = /** @class */ (function () {
        function DCommandSaveAs(name) {
            this._name = name;
        }
        DCommandSaveAs.prototype.execute = function () {
            return DControllers.getDocumentController().saveAs(this._name);
        };
        DCommandSaveAs.prototype.redo = function () {
            return true;
        };
        DCommandSaveAs.prototype.undo = function () {
            return true;
        };
        DCommandSaveAs.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandSaveAs.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE;
        };
        return DCommandSaveAs;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandSave = /** @class */ (function () {
        function DCommandSave() {
        }
        DCommandSave.prototype.execute = function () {
            return DControllers.getDocumentController().save();
        };
        DCommandSave.prototype.redo = function () {
            return true;
        };
        DCommandSave.prototype.undo = function () {
            return true;
        };
        DCommandSave.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandSave.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE;
        };
        return DCommandSave;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTileMappingPointImpl = /** @class */ (function (_super) {
        __extends(DDiagramCanvasTileMappingPointImpl, _super);
        function DDiagramCanvasTileMappingPointImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DDiagramCanvasTileMappingPointImpl.prototype, "lon", {
            get: function () {
                return this.x;
            },
            set: function (lon) {
                this.x = lon;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingPointImpl.prototype, "lat", {
            get: function () {
                return this.y;
            },
            set: function (lat) {
                this.y = lat;
            },
            enumerable: true,
            configurable: true
        });
        DDiagramCanvasTileMappingPointImpl.prototype.toObject = function () {
            return {
                lon: this.x,
                lat: this.y
            };
        };
        return DDiagramCanvasTileMappingPointImpl;
    }(pixi_js.ObservablePoint));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTileMappingImpl = /** @class */ (function () {
        function DDiagramCanvasTileMappingImpl(cb, mappingOrEnable, lon0, lat0, lon1, lat1) {
            this._cb = cb;
            if (mappingOrEnable === true || mappingOrEnable === false) {
                this._enable = mappingOrEnable;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, lon0, lat0);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, lon1, lat1);
            }
            else if (mappingOrEnable != null) {
                this._enable = mappingOrEnable.enable;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, mappingOrEnable.from.lon, mappingOrEnable.from.lat);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, mappingOrEnable.to.lon, mappingOrEnable.to.lat);
            }
            else {
                this._enable = false;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, -180, +85.05112877980659);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, +180, -85.05112877980659);
            }
        }
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._cb();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "from", {
            get: function () {
                return this._from;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "to", {
            get: function () {
                return this._to;
            },
            enumerable: true,
            configurable: true
        });
        DDiagramCanvasTileMappingImpl.prototype.serialize = function () {
            return {
                enable: this._enable,
                from: this._from.toObject(),
                to: this._to.toObject()
            };
        };
        return DDiagramCanvasTileMappingImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTile = /** @class */ (function () {
        function DDiagramCanvasTile(canvas, options) {
            var _this = this;
            this._canvas = canvas;
            this._factory = options && options.factory;
            this._mapping = new DDiagramCanvasTileMappingImpl(function () {
                _this.onMappingChange();
            }, options && options.mapping);
        }
        DDiagramCanvasTile.prototype.init = function () {
            this.onMappingChange();
        };
        DDiagramCanvasTile.prototype.onMappingChange = function () {
            var factory = this._factory;
            if (factory) {
                var mapping = this._mapping;
                if (mapping.enable) {
                    var pyramid = this._pyramid;
                    if (pyramid) {
                        pyramid.mapping = mapping;
                    }
                    else {
                        this._pyramid = factory(this._canvas).fit();
                    }
                }
                else {
                    var pyramid = this._pyramid;
                    if (pyramid) {
                        this._pyramid = undefined;
                        pyramid.destroy();
                    }
                }
            }
        };
        Object.defineProperty(DDiagramCanvasTile.prototype, "pyramid", {
            get: function () {
                return this._pyramid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTile.prototype, "factory", {
            get: function () {
                return this._factory;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTile.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            enumerable: true,
            configurable: true
        });
        DDiagramCanvasTile.prototype.serialize = function () {
            return {
                mapping: this._mapping.serialize()
            };
        };
        DDiagramCanvasTile.prototype.destroy = function () {
            var pyramid = this._pyramid;
            if (pyramid != null) {
                this._pyramid = undefined;
                pyramid.destroy();
            }
        };
        return DDiagramCanvasTile;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramLayer = /** @class */ (function (_super) {
        __extends(DDiagramLayer, _super);
        function DDiagramLayer(name) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.interactive = false;
            _this.reference = 0;
            return _this;
        }
        DDiagramLayer.prototype.destroy = function () {
            if (!this._destroyed) {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    children[i].destroy();
                }
                children.length = 0;
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramLayer.prototype.serialize = function (layer, manager, items) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var shape = children[i];
                var item = shape.serialize(manager);
                item[16] = layer;
                items.push(item);
            }
            return [
                this.name || ""
            ];
        };
        return DDiagramLayer;
    }(EShapeContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramLayerContainer = /** @class */ (function (_super) {
        __extends(DDiagramLayerContainer, _super);
        function DDiagramLayerContainer() {
            var _this = _super.call(this) || this;
            _this._active = null;
            _this.interactive = false;
            _this.interactiveChildren = false;
            return _this;
        }
        Object.defineProperty(DDiagramLayerContainer.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (layer) {
                if (this._active !== layer && (layer == null || 0 <= this.children.indexOf(layer))) {
                    this._active = layer;
                    this.emit("change", this);
                }
            },
            enumerable: true,
            configurable: true
        });
        DDiagramLayerContainer.prototype.create = function (name, activate) {
            var result = new DDiagramLayer(name);
            this.attach(result, activate);
            return result;
        };
        /**
         * Adds the specified layer and activates it if the `activate` is true.
         *
         * @param layer
         * @param activate
         */
        DDiagramLayerContainer.prototype.attach = function (layer, activate) {
            this.addChild(layer);
            if (activate === true) {
                this._active = layer;
            }
            this.emit("change", this);
            DApplications.update(this);
        };
        DDiagramLayerContainer.prototype.attachAt = function (layer, index, activate) {
            this.addChildAt(layer, index);
            if (activate === true) {
                this._active = layer;
            }
            this.emit("change", this);
            DApplications.update(this);
        };
        /**
         * Removes the specified layer from this container and activates the specified layer.
         * This method does not destroy the secified layer.
         *
         * @param layer
         */
        DDiagramLayerContainer.prototype.detach = function (layer, active) {
            var children = this.children;
            var index = children.indexOf(layer);
            if (0 <= index) {
                this._active = active;
                children.splice(index, 1);
                layer.parent = undefined;
                this.emit("change", this);
                DApplications.update(this);
            }
        };
        /**
         * Removes the specified layer and activate the next layer.
         * This method does not destroy the specified layer.
         *
         * @param layer
         * @param activateNext
         */
        DDiagramLayerContainer.prototype.delete = function (layer, activateNext) {
            var children = this.children;
            var index = children.indexOf(layer);
            if (0 <= index) {
                children.splice(index, 1);
                layer.parent = undefined;
                if (this._active === layer) {
                    if (activateNext === true) {
                        if (index < children.length) {
                            this._active = children[index];
                        }
                        else if (0 < children.length) {
                            this._active = children[index - 1];
                        }
                        else {
                            this._active = null;
                        }
                    }
                    else {
                        this._active = null;
                    }
                }
                this.emit("change", this);
                DApplications.update(this);
            }
            return index;
        };
        DDiagramLayerContainer.prototype.get = function (index) {
            var child = this.children[index];
            if (child != null) {
                return child;
            }
            return null;
        };
        DDiagramLayerContainer.prototype.clear = function () {
            var children = this.children;
            if (0 < children.length) {
                for (var i = children.length - 1; 0 <= i; --i) {
                    var child = children[i];
                    child.parent = null;
                    child.destroy();
                }
                children.length = 0;
                this.emit("change", this);
                DApplications.update(this);
            }
        };
        DDiagramLayerContainer.prototype.destroy = function () {
            if (!this._destroyed) {
                this.clear();
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramLayerContainer.prototype.size = function () {
            return this.children.length;
        };
        DDiagramLayerContainer.prototype.serialize = function (manager, items) {
            var result = [];
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                result.push(child.serialize(i, manager, items));
            }
            return result;
        };
        return DDiagramLayerContainer;
    }(pixi_js.Container));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasBase = /** @class */ (function (_super) {
        __extends(DDiagramCanvasBase, _super);
        function DDiagramCanvasBase(options) {
            var _this = _super.call(this, options) || this;
            var layer = new DDiagramLayerContainer();
            _this._layer = layer;
            _this.addChild(layer);
            var tile = _this._tile = new DDiagramCanvasTile(_this, options && options.tile);
            tile.init();
            return _this;
        }
        Object.defineProperty(DDiagramCanvasBase.prototype, "tile", {
            get: function () {
                return this._tile;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasBase.prototype, "layer", {
            get: function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        DDiagramCanvasBase.prototype.initialize = function (shapes) {
            // DO NOTHING
        };
        DDiagramCanvasBase.prototype.destroy = function () {
            if (!this._destroyed) {
                this._tile.destroy();
                this._layer.destroy();
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramCanvasBase.prototype.hitTest = function (global, handler) {
            var layers = this._layer.children;
            for (var i = layers.length - 1; 0 <= i; --i) {
                var layer = layers[i];
                var shape = layer.hitTest(global, handler);
                if (shape != null) {
                    return shape;
                }
            }
            return null;
        };
        DDiagramCanvasBase.prototype.getType = function () {
            return "DDiagramCanvasBase";
        };
        return DDiagramCanvasBase;
    }(DCanvas));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditorBackground = /** @class */ (function () {
        function DDiagramCanvasEditorBackground(target, base) {
            this._target = target;
            this._base = base;
        }
        DDiagramCanvasEditorBackground.prototype.getTheme = function () {
            return this._target.getTheme();
        };
        DDiagramCanvasEditorBackground.prototype.setTheme = function (theme) {
            this._target.setTheme(theme);
        };
        DDiagramCanvasEditorBackground.prototype.getBaseColor = function () {
            return this._base;
        };
        DDiagramCanvasEditorBackground.prototype.setBaseColor = function (baseColor) {
            this._base = baseColor;
        };
        DDiagramCanvasEditorBackground.prototype.getColor = function (state) {
            var target = this._target;
            var base = this._base;
            var color = target.getColor(state);
            if (base != null) {
                if (color != null) {
                    return UtilRgb.blend(base, color, target.getAlpha(state));
                }
                return base;
            }
            return color;
        };
        Object.defineProperty(DDiagramCanvasEditorBackground.prototype, "color", {
            get: function () {
                return this._target.color;
            },
            set: function (color) {
                this._target.color = color;
            },
            enumerable: true,
            configurable: true
        });
        DDiagramCanvasEditorBackground.prototype.getAlpha = function (state) {
            var base = this._base;
            if (base != null) {
                return 1;
            }
            return this._target.getAlpha(state);
        };
        Object.defineProperty(DDiagramCanvasEditorBackground.prototype, "alpha", {
            get: function () {
                return this._target.alpha;
            },
            set: function (alpha) {
                this._target.alpha = alpha;
            },
            enumerable: true,
            configurable: true
        });
        return DDiagramCanvasEditorBackground;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramSerializedVersion = 1;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditor = /** @class */ (function (_super) {
        __extends(DDiagramCanvasEditor, _super);
        function DDiagramCanvasEditor(options) {
            var _this = _super.call(this, options) || this;
            _this._background = new DDiagramCanvasEditorBackground(_this._background, _this.toBackgroundColorBase(_this.theme, options));
            _this.shadow = _this.theme.newShadowWeak();
            var snapperGraphics = new pixi_js.Graphics();
            snapperGraphics.visible = false;
            _this.addChildAt(snapperGraphics, _this.children.length - 1);
            _this._snapperGraphics = snapperGraphics;
            var snapper = options.snapper;
            snapper.target.on("change", function () {
                _this.toDirty();
                DApplications.update(_this);
            });
            _this._snapper = snapper;
            return _this;
        }
        DDiagramCanvasEditor.prototype.toBackgroundColorBase = function (theme, options) {
            var background = options.background;
            var backgroundBase = background && background.base;
            return (backgroundBase != null ? backgroundBase : theme.getBackgroundBase());
        };
        DDiagramCanvasEditor.prototype.serialize = function (id) {
            var manager = new EShapeResourceManagerSerialization();
            var items = [];
            var background = this._background;
            var backgroundColor = background.color;
            var backgroundAlpha = background.alpha;
            return {
                version: DDiagramSerializedVersion,
                id: id,
                name: this.name,
                width: this.width,
                height: this.height,
                background: {
                    color: isNumber(backgroundColor) ? backgroundColor : 0xffffff,
                    alpha: isNumber(backgroundAlpha) ? backgroundAlpha : 0
                },
                tile: this._tile.serialize(),
                resources: manager.serialize(),
                layers: this._layer.serialize(manager, items),
                items: items,
                snap: this._snapper.serialize()
            };
        };
        DDiagramCanvasEditor.prototype.onReflow = function () {
            _super.prototype.onReflow.call(this);
            var snapperGraphics = this._snapperGraphics;
            var target = this._snapper.target;
            if (target.visible) {
                var borderColor = 0x1e87f0;
                var borderWidth = 1;
                var borderAlpha = 0.5;
                var width = this.width + 0.5;
                var height = this.height + 0.5;
                var values = target.values;
                snapperGraphics.clear();
                snapperGraphics.lineStyle(0, 0, 0, 0);
                snapperGraphics.beginFill(borderColor, borderAlpha);
                for (var i = 0, imax = values.length; i < imax; ++i) {
                    var value = values[i];
                    if (value.type === ESnapperTargetValueType.VERTICAL) {
                        snapperGraphics.drawRect(value.position, 0, borderWidth, height);
                    }
                    else {
                        snapperGraphics.drawRect(0, value.position, width, borderWidth);
                    }
                }
                snapperGraphics.endFill();
                snapperGraphics.visible = true;
            }
            else {
                snapperGraphics.visible = false;
            }
        };
        DDiagramCanvasEditor.prototype.getType = function () {
            return "DDiagramCanvasEditor";
        };
        return DDiagramCanvasEditor;
    }(DDiagramCanvasBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var defaultTagMapper = function (tag) { return tag; };
    var DDiagramCanvas = /** @class */ (function (_super) {
        __extends(DDiagramCanvas, _super);
        function DDiagramCanvas(options) {
            var _this = _super.call(this, options) || this;
            _this.tags = {};
            _this.tagMapper = (options.tag && options.tag.mapper) || defaultTagMapper;
            _this.interactives = [];
            _this.actionables = [];
            _this.ids = {};
            _this._workLocal = new pixi_js.Point();
            _this._workGlobal = new pixi_js.Point();
            _this._lastOverShape = null;
            return _this;
        }
        DDiagramCanvas.prototype.initialize = function () {
            var time = Date.now();
            var tags = this.tags;
            var tagMapper = this.tagMapper;
            var interactives = this.interactives;
            var actionables = this.actionables;
            var ids = this.ids;
            var layers = this._layer.children;
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                this.initializeShapes(layers[i].children, tags, tagMapper, interactives, actionables, ids);
            }
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                this.updateShapes(layers[i].children, time);
            }
            this.initializeFocus();
        };
        DDiagramCanvas.prototype.initializeFocus = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var focusController = layer.getFocusController();
                var focusable = focusController.findFocusable(this, false, true, true);
                if (focusable) {
                    focusController.setFocused(focusable, true, true);
                }
            }
        };
        DDiagramCanvas.prototype.initializeShapes = function (shapes, tags, tagMapper, interactives, actionables, ids) {
            var _loop_1 = function (i, imax) {
                var shape = shapes[i];
                // Tag mappings
                var tag = shape.tag;
                for (var j = 0, jmax = tag.size(); j < jmax; ++j) {
                    var value = tag.get(j);
                    if (value) {
                        var valueId = value.id;
                        if (0 < valueId.length) {
                            var mappedValueId = tagMapper(valueId);
                            if (mappedValueId != null) {
                                var values = tags[mappedValueId];
                                if (values == null) {
                                    values = [];
                                    tags[mappedValueId] = values;
                                }
                                values.push(value);
                            }
                        }
                    }
                }
                // Id mappings
                var shapeId = shape.id;
                if (0 < shapeId.length) {
                    var mapping = ids[shapeId];
                    if (mapping == null) {
                        ids[shapeId] = [shape];
                    }
                    else {
                        mapping.push(shape);
                    }
                }
                // Interactives
                var runtime = shape.runtime;
                if (shape.interactive || (0 < shape.cursor.length) || (runtime && runtime.interactive)) {
                    interactives.push(shape);
                }
                // Actionables
                if (runtime && 0 < runtime.actions.length) {
                    actionables.push(shape);
                }
                // Shortcuts
                var shortcut = shape.shortcut;
                if (shortcut != null) {
                    UtilKeyboardEvent.on(this_1, shortcut, function (e) {
                        shape.onShortcut(e);
                    });
                }
                // Children
                var children = shape.children;
                if (0 < children.length) {
                    this_1.initializeShapes(children, tags, tagMapper, interactives, actionables, ids);
                }
            };
            var this_1 = this;
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                _loop_1(i);
            }
        };
        DDiagramCanvas.prototype.updateShapes = function (shapes, time) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].update(time);
            }
        };
        DDiagramCanvas.prototype.onShapeMove = function (e) {
            var global = e.data.global;
            var local = this._workLocal;
            var interactives = this.interactives;
            var found = null;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local)) {
                        found = interactive;
                        break;
                    }
                }
            }
            var layer = DApplications.getLayer(this);
            if (found) {
                if (0 < found.cursor.length) {
                    if (layer && layer.view.style.cursor !== found.cursor) {
                        layer.view.style.cursor = found.cursor;
                    }
                }
                var lastOverShape = this._lastOverShape;
                if (found === lastOverShape) {
                    var runtime = lastOverShape.runtime;
                    if (runtime) {
                        runtime.onPointerMove(lastOverShape, e);
                    }
                }
                else {
                    this._lastOverShape = found;
                    // Previous
                    if (lastOverShape) {
                        var previousRuntime = lastOverShape.runtime;
                        if (previousRuntime) {
                            previousRuntime.onPointerOut(lastOverShape, e);
                        }
                        // Parents
                        var lastOverParent = lastOverShape.parent;
                        while ((lastOverParent instanceof EShapeBase) && lastOverParent !== found) {
                            var parentRuntime = lastOverShape.runtime;
                            if (parentRuntime) {
                                parentRuntime.onPointerOut(lastOverParent, e);
                            }
                            lastOverParent = lastOverParent.parent;
                        }
                    }
                    // Next
                    var runtime = found.runtime;
                    if (runtime) {
                        runtime.onPointerOver(found, e);
                    }
                    if (layer) {
                        layer.view.title = (found.title || "");
                    }
                    // Parents
                    var parent_1 = found.parent;
                    while (parent_1 instanceof EShapeBase) {
                        var parentRuntime = parent_1.runtime;
                        if (parentRuntime) {
                            parentRuntime.onPointerOver(parent_1, e);
                        }
                        parent_1 = parent_1.parent;
                    }
                }
                return true;
            }
            else {
                if (layer && layer.view.style.cursor !== "auto") {
                    layer.view.style.cursor = "auto";
                }
                // Previous
                var lastOverShape = this._lastOverShape;
                this._lastOverShape = null;
                if (lastOverShape) {
                    var runtime = lastOverShape.runtime;
                    if (runtime) {
                        runtime.onPointerOut(lastOverShape, e);
                    }
                    // Parents
                    var lastOverParent = lastOverShape.parent;
                    while (lastOverParent instanceof EShapeBase) {
                        var parentRuntime = lastOverParent.runtime;
                        if (parentRuntime) {
                            parentRuntime.onPointerOut(lastOverParent, e);
                        }
                        lastOverParent = lastOverParent.parent;
                    }
                }
                //
                if (layer) {
                    layer.view.title = "";
                }
                return false;
            }
        };
        DDiagramCanvas.prototype.onShapeDown = function (e) {
            var interactives = this.interactives;
            var global = e.data.global;
            var local = this._workLocal;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local)) {
                        var runtime = interactive.runtime;
                        if (runtime) {
                            runtime.onPointerDown(interactive, e);
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeUp = function (e) {
            var interactives = this.interactives;
            var global = e.data.global;
            var local = this._workLocal;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local)) {
                        var runtime = interactive.runtime;
                        if (runtime) {
                            runtime.onPointerUp(interactive, e);
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeClick = function (e) {
            var interactives = this.interactives;
            var global = e.data.global;
            var local = this._workLocal;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local)) {
                        var target = interactive;
                        while (true) {
                            var runtime = target.runtime;
                            if (runtime) {
                                runtime.onPointerClick(target, e);
                            }
                            var parent_2 = target.parent;
                            if (parent_2 instanceof EShapeBase) {
                                target = parent_2;
                            }
                            else {
                                break;
                            }
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeDblClick = function (e, interactionManager) {
            var interactives = this.interactives;
            var global = UtilPointerEvent.toGlobal(e, interactionManager, this._workGlobal);
            var local = this._workLocal;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local)) {
                        var target = interactive;
                        while (true) {
                            var runtime = target.runtime;
                            if (runtime) {
                                runtime.onPointerDblClick(target, e);
                            }
                            var parent_3 = target.parent;
                            if (parent_3 instanceof EShapeBase) {
                                target = parent_3;
                            }
                            else {
                                break;
                            }
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DDiagramCanvas.prototype.getType = function () {
            return "DDiagramCanvas";
        };
        return DDiagramCanvas;
    }(DDiagramCanvasBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagrams = /** @class */ (function () {
        function DDiagrams() {
        }
        DDiagrams.toSerialized = function (target) {
            if ("data" in target) {
                var result = JSON.parse(target.data);
                result.id = target.id;
                return result;
            }
            return target;
        };
        DDiagrams.newLayer = function (serialized, container) {
            // Layers
            var pflayers = serialized.layers;
            for (var i = 0, imax = pflayers.length; i < imax; ++i) {
                container.create(pflayers[i][0] || "");
            }
            // Activate the first later if it exists
            if (0 < container.size()) {
                container.active = container.children[0];
            }
            // Items
            var pfresources = serialized.resources;
            var pfitems = serialized.items;
            var shapePromises = EShapeDeserializer.deserializeAll(pfitems, pfresources);
            if (shapePromises != null) {
                return shapePromises.then(function (shapes) {
                    var layers = container.children;
                    for (var i = 0, imax = shapes.length; i < imax; ++i) {
                        var pfitem = pfitems[i];
                        var shape = shapes[i];
                        var layer = layers[pfitem[16]];
                        if (layer != null) {
                            shape.attach(layer);
                        }
                    }
                    return shapes;
                });
            }
            else {
                return Promise.resolve([]);
            }
        };
        DDiagrams.applyBackground = function (serialized, canvas, canvasContainer) {
            var background = serialized.background;
            var backgroundColor = (background && background.color != null ? background.color : 0xffffff);
            var backgroundAlpha = (background && background.alpha != null ? background.alpha : 1.0);
            if (EShapeDefaults.IS_EDIT_MODE) {
                var canvasBackground = canvas.background;
                canvasBackground.color = backgroundColor;
                canvasBackground.alpha = backgroundAlpha;
            }
            else {
                var canvasContainerBackground = canvasContainer.background;
                canvasContainerBackground.color = backgroundColor;
                canvasContainerBackground.alpha = backgroundAlpha;
            }
        };
        return DDiagrams;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramBase = /** @class */ (function (_super) {
        __extends(DDiagramBase, _super);
        function DDiagramBase(options) {
            var _this = _super.call(this, options) || this;
            _this._serialized = null;
            _this._tileFactory = options && options.tile;
            return _this;
        }
        DDiagramBase.prototype.set = function (serialized) {
            var oldSerialized = this._serialized;
            if (oldSerialized !== serialized) {
                if (oldSerialized) {
                    this._serialized = null;
                    this.onUnset();
                }
                this._serialized = serialized;
                if (serialized) {
                    this.onSet(serialized);
                }
            }
        };
        DDiagramBase.prototype.onSet = function (serialized) {
            var _this = this;
            var canvas = this.newCanvas(serialized);
            DDiagrams.newLayer(serialized, canvas.layer).then(function (shapes) {
                _this.initialize(shapes);
                canvas.initialize(shapes);
                DApplications.update(_this);
                _this.emit("ready", _this);
            });
            DDiagrams.applyBackground(serialized, canvas, this);
            this.canvas = canvas;
        };
        DDiagramBase.prototype.initialize = function (shapes) {
            // DO NOTHING
        };
        DDiagramBase.prototype.onUnset = function () {
            var canvas = this.canvas;
            if (canvas != null) {
                this.canvas = null;
            }
        };
        DDiagramBase.prototype.get = function () {
            return this._serialized;
        };
        Object.defineProperty(DDiagramBase.prototype, "layer", {
            get: function () {
                var canvas = this.canvas;
                if (canvas != null) {
                    return canvas.layer.active;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        DDiagramBase.prototype.getType = function () {
            return "DDiagramBase";
        };
        return DDiagramBase;
    }(DCanvasContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramEditor = /** @class */ (function (_super) {
        __extends(DDiagramEditor, _super);
        function DDiagramEditor(options) {
            var _this = _super.call(this, options) || this;
            _this._isChanged = false;
            _this._controller = options.controller;
            _this._isChanged = false;
            var commands = DControllers.getCommandController();
            commands.on("dirty", function () {
                if (_this._isChanged !== true) {
                    _this._isChanged = true;
                    _this.emit("change", _this);
                }
            });
            _this.snapper = new ESnapper(_this);
            return _this;
        }
        DDiagramEditor.prototype.newCanvas = function (serialized) {
            return new DDiagramCanvasEditor(this.toCanvasOptions(serialized));
        };
        DDiagramEditor.prototype.toCanvasOptions = function (serialized) {
            return {
                name: serialized.name,
                width: serialized.width,
                height: serialized.height,
                snapper: this.snapper,
                tile: {
                    factory: this._tileFactory,
                    mapping: serialized.tile && serialized.tile.mapping
                }
            };
        };
        DDiagramEditor.prototype.serialize = function () {
            var canvas = this.canvas;
            var serialized = this._serialized;
            if (canvas != null && serialized != null) {
                return canvas.serialize(serialized.id);
            }
            return null;
        };
        DDiagramEditor.prototype.save = function () {
            var _this = this;
            var serialized = this.serialize();
            if (serialized != null) {
                return this.controller.save({
                    version: serialized.version,
                    id: serialized.id,
                    name: serialized.name,
                    data: JSON.stringify(serialized)
                })
                    .then(function (newId) {
                    _this._isChanged = false;
                    serialized.id = newId;
                    _this._serialized = serialized;
                    _this.emit("change", _this);
                    _this.emit("success", "save", _this);
                }, function (reason) {
                    _this.emit("fail", "save", _this);
                });
            }
            return true;
        };
        DDiagramEditor.prototype.saveAs = function (name) {
            var _this = this;
            var serialized = this.serialize();
            if (serialized != null) {
                serialized.id = undefined;
                serialized.name = name;
                return this.controller.save({
                    version: serialized.version,
                    id: serialized.id,
                    name: serialized.name,
                    data: JSON.stringify(serialized)
                })
                    .then(function (newId) {
                    _this._isChanged = false;
                    serialized.id = newId;
                    _this._serialized = serialized;
                    var canvas = _this.canvas;
                    if (canvas != null) {
                        canvas.name = name;
                    }
                    _this.emit("change", _this);
                    _this.emit("success", "save-as", _this);
                }, function (reason) {
                    _this.emit("fail", "save-as", _this);
                });
            }
            return true;
        };
        DDiagramEditor.prototype.delete = function () {
            var _this = this;
            var serialized = this._serialized;
            if (serialized != null) {
                if (serialized.id != null) {
                    return this.controller.delete(serialized.id)
                        .then(function () {
                        _this.set(null);
                        _this.emit("success", "delete", _this);
                    }, function (reason) {
                        _this.emit("fail", "delete", _this);
                    });
                }
                else {
                    this.set(null);
                    this.emit("success", "delete", this);
                }
                return true;
            }
            return false;
        };
        DDiagramEditor.prototype.create = function (name, width, height) {
            this.set({
                version: DDiagramSerializedVersion,
                id: undefined,
                name: name,
                width: width,
                height: height,
                resources: [],
                layers: [["Default layer"]],
                items: [],
                snap: undefined
            });
            return true;
        };
        DDiagramEditor.prototype.onSet = function (serialized) {
            _super.prototype.onSet.call(this, serialized);
            var snap = serialized.snap;
            var snapper = this.snapper;
            if (snap != null) {
                snapper.deserialize(snap);
            }
            else {
                snapper.reset();
            }
            this._isChanged = false;
            this.emit("change", this);
        };
        DDiagramEditor.prototype.onUnset = function () {
            _super.prototype.onUnset.call(this);
            this._isChanged = false;
            this.emit("change", this);
        };
        DDiagramEditor.prototype.open = function (id) {
            var _this = this;
            return this._controller.get(id).then(function (serialized) {
                _this.set(DDiagrams.toSerialized(serialized));
                _this.emit("success", "open", _this);
            }, function (reason) {
                _this.emit("fail", "open", _this);
            });
        };
        DDiagramEditor.prototype.close = function () {
            this.set(null);
        };
        DDiagramEditor.prototype.isChanged = function () {
            return this._isChanged || this.isNew();
        };
        DDiagramEditor.prototype.isNew = function () {
            var serialized = this._serialized;
            if (serialized != null) {
                return serialized.id == null;
            }
            return false;
        };
        DDiagramEditor.prototype.getName = function () {
            var serialized = this._serialized;
            if (serialized != null) {
                return serialized.name;
            }
            return null;
        };
        Object.defineProperty(DDiagramEditor.prototype, "controller", {
            get: function () {
                return this._controller;
            },
            enumerable: true,
            configurable: true
        });
        DDiagramEditor.prototype.getType = function () {
            return "DDiagramEditor";
        };
        return DDiagramEditor;
    }(DDiagramBase));

    /**
     * A shape helper class for diagrams.
     */
    var DDiagramShape = /** @class */ (function (_super) {
        __extends(DDiagramShape, _super);
        function DDiagramShape(diagram) {
            var _this = _super.call(this) || this;
            _this._diagram = diagram;
            _this._updateBound = function () {
                DApplications.update(diagram);
            };
            return _this;
        }
        DDiagramShape.prototype.update = function () {
            var diagram = this._diagram;
            var canvas = diagram.canvas;
            if (canvas) {
                var actionables = canvas.actionables;
                if (0 < actionables.length) {
                    var effect = -1;
                    var time = Date.now();
                    for (var i = 0, imax = actionables.length; i < imax; ++i) {
                        var actionable = actionables[i];
                        actionable.update(time);
                        var runtime = actionable.runtime;
                        if (runtime && time < runtime.effect) {
                            var runtimeEffect = runtime.effect;
                            if (time < runtimeEffect) {
                                effect = (effect < 0 ? runtimeEffect : Math.min(effect, runtimeEffect));
                            }
                        }
                    }
                    if (0 <= effect) {
                        setTimeout(this._updateBound, effect - Date.now());
                    }
                }
            }
        };
        DDiagramShape.prototype.get = function (id) {
            var canvas = this._diagram.canvas;
            var shapes = (canvas && canvas.ids[id]);
            return (shapes && 0 < shapes.length ? shapes[0] : null);
        };
        DDiagramShape.prototype.getAll = function (id) {
            var canvas = this._diagram.canvas;
            return (canvas && canvas.ids[id]) || [];
        };
        DDiagramShape.prototype.each = function (callback, reverse) {
            if (reverse === void 0) { reverse = false; }
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var layers = canvas.layer.children;
                if (!reverse) {
                    for (var i = 0, imax = layers.length; i < imax; ++i) {
                        var layer = layers[i];
                        var children = layer.children;
                        for (var j = 0, jmax = children.length; j < jmax; ++j) {
                            var child = children[j];
                            if (callback(child) === false) {
                                return child;
                            }
                        }
                    }
                }
                else {
                    for (var i = layers.length - 1; 0 <= i; --i) {
                        var layer = layers[i];
                        var children = layer.children;
                        for (var j = children.length - 1; 0 <= j; --j) {
                            var child = children[j];
                            if (callback(child) === false) {
                                return child;
                            }
                        }
                    }
                }
            }
            return null;
        };
        return DDiagramShape;
    }(pixi_js.utils.EventEmitter));

    /**
     * A tag helper class for diagrams.
     */
    var DDiagramTag = /** @class */ (function () {
        function DDiagramTag(diagram) {
            this._diagram = diagram;
        }
        DDiagramTag.prototype.update = function () {
            // DO NOTHING
        };
        DDiagramTag.prototype.getIds = function () {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return Object.keys(canvas.tags);
            }
            return [];
        };
        DDiagramTag.prototype.each = function (callback) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tags = canvas.tags;
                for (var id in tags) {
                    if (callback(id) === false) {
                        return id;
                    }
                }
            }
            return null;
        };
        DDiagramTag.prototype.set = function (id, value, time, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        var tagValue = tagValues[i];
                        var range = tagValue.range;
                        // Range
                        range.set(from, to);
                        // Time
                        if (time !== undefined) {
                            tagValue.time = time;
                        }
                        // Value
                        tagValue.value = value;
                    }
                }
            }
        };
        DDiagramTag.prototype.clear = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        tagValues[i].clear();
                    }
                }
            }
        };
        DDiagramTag.prototype.setAll = function (id, values, times, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        var tagValue = tagValues[i];
                        var range = tagValue.range;
                        // Range
                        range.set(from, to);
                        // Time
                        if (times !== undefined) {
                            tagValue.times = times;
                        }
                        // Value
                        tagValue.values = values;
                    }
                }
            }
        };
        DDiagramTag.prototype.setValue = function (id, value, time) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        var tagValue = tagValues[i];
                        if (time !== undefined) {
                            tagValue.time = time;
                        }
                        tagValue.value = value;
                    }
                }
            }
        };
        DDiagramTag.prototype.setValues = function (id, values, times) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        var tagValue = tagValues[i];
                        if (times !== undefined) {
                            tagValue.times = times;
                        }
                        tagValue.values = values;
                    }
                }
            }
        };
        DDiagramTag.prototype.setTime = function (id, time) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        tagValues[i].time = time;
                    }
                }
            }
        };
        DDiagramTag.prototype.setTimes = function (id, times) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        tagValues[i].times = times;
                    }
                }
            }
        };
        DDiagramTag.prototype.setRange = function (id, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        var range = tagValues[i].range;
                        if (from !== undefined) {
                            if (from !== null) {
                                range.type |= EShapeTagValueRangeType.FROM;
                                range.from = from;
                            }
                            else {
                                range.type &= ~EShapeTagValueRangeType.FROM;
                            }
                        }
                        if (to !== undefined) {
                            if (to !== null) {
                                range.type |= EShapeTagValueRangeType.TO;
                                range.to = to;
                            }
                            else {
                                range.type &= ~EShapeTagValueRangeType.TO;
                            }
                        }
                    }
                }
            }
        };
        return DDiagramTag;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagram = /** @class */ (function (_super) {
        __extends(DDiagram, _super);
        function DDiagram(options) {
            var _this = _super.call(this, options) || this;
            // Hover handling
            _this.on(UtilPointerEvent.move, function (e) {
                if (UtilPointerEvent.contains(_this, e.target)) {
                    var canvas = _this.canvas;
                    if (canvas) {
                        canvas.onShapeMove(e);
                    }
                }
            });
            // Pointer down / up handling
            _this.on(UtilPointerEvent.up, function (e) {
                if (UtilPointerEvent.contains(_this, e.target)) {
                    var canvas = _this.canvas;
                    if (canvas) {
                        canvas.onShapeUp(e);
                    }
                }
            });
            // Click handling
            _this.on("click", function (e) {
                if (UtilPointerEvent.contains(_this, e.target)) {
                    var canvas = _this.canvas;
                    if (canvas) {
                        canvas.onShapeClick(e);
                    }
                }
            });
            //
            _this.tag = new DDiagramTag(_this);
            _this.shape = new DDiagramShape(_this);
            return _this;
        }
        DDiagram.prototype.initialize = function (shapes) {
            var formatterMap = {};
            var initialMap = {};
            var actionMap = new Map();
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                var runtimeConstructor = EShapeRuntimes[shape.type] || EShapeRuntime;
                var runtime = shape.runtime = new (runtimeConstructor)(shape);
                // Tag
                var tag = shape.tag;
                for (var j = 0, jmax = tag.size(); j < jmax; ++j) {
                    var value = tag.get(j);
                    if (value) {
                        // Format
                        var tagFormat = value.format;
                        var tagInitial = value.initial;
                        if (tagFormat in formatterMap) {
                            value.formatter = formatterMap[tagFormat];
                        }
                        else if (0 < tagFormat.length) {
                            try {
                                var formatter = Function("value", "try {" +
                                    ("return (" + tagFormat + ");") +
                                    "} catch( e1 ) {" +
                                    "try {" +
                                    ("return (" + (0 < tagInitial.length ? tagInitial : 0) + ");") +
                                    "} catch( e2 ) {" +
                                    "return 0;" +
                                    "}" +
                                    "}");
                                formatterMap[tagFormat] = formatter;
                                value.formatter = formatter;
                            }
                            catch (e) {
                                //
                            }
                        }
                        // Initial
                        if (tagInitial in initialMap) {
                            value.value = initialMap[tagInitial];
                        }
                        else if (0 < tagInitial.length) {
                            try {
                                value.value = initialMap[tagInitial] = (Function("try {" +
                                    ("return (" + tagInitial + ");") +
                                    "} catch( e ) {" +
                                    "return 0;" +
                                    "}")());
                            }
                            catch (e) {
                                //
                            }
                        }
                    }
                }
                // Initialize runtime actions
                var values = shape.action.values;
                var actions = runtime.actions;
                for (var j = 0, jmax = values.length; j < jmax; ++j) {
                    var value = values[j];
                    var action = actionMap.get(value);
                    if (action == null) {
                        action = value.toRuntime(shape);
                        if (action != null) {
                            if (action instanceof EShapeActionRuntimeOpen) {
                                if (shape.cursor.length <= 0) {
                                    shape.cursor = "pointer";
                                }
                            }
                            actionMap.set(value, action);
                            actions.push(action);
                            runtime.reset |= action.reset;
                        }
                    }
                    else {
                        actions.push(action);
                        runtime.reset |= action.reset;
                    }
                }
                // Children
                var children = shape.children;
                if (0 < children.length) {
                    this.initialize(children);
                }
            }
        };
        DDiagram.prototype.newCanvas = function (serialized) {
            return new DDiagramCanvas(this.toCanvasOptions(serialized));
        };
        DDiagram.prototype.toCanvasOptions = function (serialized) {
            var options = this._options;
            return {
                name: serialized.name,
                width: serialized.width,
                height: serialized.height,
                background: {
                    color: null
                },
                border: {
                    color: null
                },
                tile: {
                    factory: this._tileFactory,
                    mapping: serialized.tile && serialized.tile.mapping
                },
                tag: options && options.tag
            };
        };
        DDiagram.prototype.onDown = function (e) {
            var canvas = this.canvas;
            if (canvas && canvas.onShapeDown(e)) {
                return;
            }
            _super.prototype.onDown.call(this, e);
        };
        DDiagram.prototype.onDblClick = function (e, interactionManager) {
            var canvas = this.canvas;
            if (canvas && canvas.onShapeDblClick(e, interactionManager)) {
                return true;
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DDiagram.prototype.render = function (renderer) {
            this.shape.update();
            _super.prototype.render.call(this, renderer);
        };
        DDiagram.prototype.getType = function () {
            return "DDiagram";
        };
        return DDiagram;
    }(DDiagramBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmMessage = /** @class */ (function (_super) {
        __extends(DDialogConfirmMessage, _super);
        function DDialogConfirmMessage(options) {
            var _this = _super.call(this, options) || this;
            _this.setState(DBaseState.UNFOCUSABLE, true);
            return _this;
        }
        DDialogConfirmMessage.prototype.getType = function () {
            return "DDialogConfirmMessage";
        };
        return DDialogConfirmMessage;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirm = /** @class */ (function (_super) {
        __extends(DDialogConfirm, _super);
        function DDialogConfirm() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirm.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            var message = this.toMessage(this.theme, options);
            this._message = message;
            layout.addChild(message);
        };
        DDialogConfirm.prototype.toMessage = function (theme, options) {
            if (options && options.message != null) {
                var message = options.message;
                if (isString(message) || isFunction(message)) {
                    return this.newMessage(this.toMessageOptions(message));
                }
                else if (message instanceof DBase) {
                    return message;
                }
                else {
                    return this.newMessage(this.toMessageOptionsMerged(message, theme.getMessage()));
                }
            }
            return this.newMessage(this.toMessageOptions(theme.getMessage()));
        };
        DDialogConfirm.prototype.toMessageOptionsMerged = function (options, message) {
            if (options.text == null) {
                options.text = {};
            }
            if (options.text.value === undefined) {
                options.text.value = message;
            }
            return options;
        };
        DDialogConfirm.prototype.toMessageOptions = function (message) {
            return {
                text: {
                    value: message
                }
            };
        };
        DDialogConfirm.prototype.newMessage = function (options) {
            return new DDialogConfirmMessage(options);
        };
        Object.defineProperty(DDialogConfirm.prototype, "message", {
            get: function () {
                return this._message;
            },
            enumerable: true,
            configurable: true
        });
        DDialogConfirm.prototype.getType = function () {
            return "DDialogConfirm";
        };
        return DDialogConfirm;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmDelete = /** @class */ (function (_super) {
        __extends(DDialogConfirmDelete, _super);
        function DDialogConfirmDelete() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirmDelete.prototype.getType = function () {
            return "DDialogConfirmDelete";
        };
        return DDialogConfirmDelete;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmDiscard = /** @class */ (function (_super) {
        __extends(DDialogConfirmDiscard, _super);
        function DDialogConfirmDiscard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirmDiscard.prototype.getType = function () {
            return "DDialogConfirmDiscard";
        };
        return DDialogConfirmDiscard;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputText = /** @class */ (function (_super) {
        __extends(DDialogInputText, _super);
        function DDialogInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputText.prototype.onInit = function (layout, options) {
            var _this = this;
            _super.prototype.onInit.call(this, layout, options);
            var theme = this.theme;
            this._inputAndLabel = new DInputTextAndLabel({
                parent: layout,
                width: "padding", height: "auto",
                input: {
                    weight: 1,
                    on: {
                        enter: function () {
                            _this.onOk();
                        }
                    }
                },
                label: {
                    width: theme.getLabelWidth(),
                    text: {
                        value: (options != null && options.label != null ?
                            options.label : theme.getLabel())
                    }
                },
                space: {
                    width: theme.getLabelWidth()
                }
            });
        };
        Object.defineProperty(DDialogInputText.prototype, "input", {
            get: function () {
                return this._inputAndLabel.input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DDialogInputText.prototype, "value", {
            get: function () {
                return this._inputAndLabel.input.value;
            },
            set: function (value) {
                this._inputAndLabel.input.value = value;
            },
            enumerable: true,
            configurable: true
        });
        DDialogInputText.prototype.getType = function () {
            return "DDialogInputText";
        };
        return DDialogInputText;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogMessage = /** @class */ (function (_super) {
        __extends(DDialogMessage, _super);
        function DDialogMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogMessage.prototype.getType = function () {
            return "DDialogMessage";
        };
        return DDialogMessage;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogProcessingMessage = /** @class */ (function (_super) {
        __extends(DDialogProcessingMessage, _super);
        function DDialogProcessingMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogProcessingMessage.prototype.getType = function () {
            return "DDialogProcessingMessage";
        };
        return DDialogProcessingMessage;
    }(DDialogConfirmMessage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogProcessing = /** @class */ (function (_super) {
        __extends(DDialogProcessing, _super);
        function DDialogProcessing(options) {
            var _this = _super.call(this, options) || this;
            _this._isDone = true;
            _this._startTime = 0;
            _this._interval = (options && options.interval != null ? options.interval : _this.theme.getInterval());
            return _this;
        }
        DDialogProcessing.prototype.newMessage = function (options) {
            return new DDialogProcessingMessage(options);
        };
        DDialogProcessing.prototype.onOpen = function () {
            this._isDone = false;
            this._startTime = Date.now();
            var timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
            }
            this._message.setStates(DBaseState.NONE, DBaseState.SUCCEEDED | DBaseState.FAILED);
            var buttonLayout = this._buttonLayout;
            if (buttonLayout != null) {
                buttonLayout.setDisabled(true);
            }
            _super.prototype.onOpen.call(this);
        };
        DDialogProcessing.prototype.onDone = function () {
            var buttonLayout = this._buttonLayout;
            if (buttonLayout != null) {
                buttonLayout.setDisabled(false);
            }
            else {
                this.close();
            }
        };
        DDialogProcessing.prototype.onResolved = function (message) {
            if (message != null) {
                this._message.text = message;
            }
            this._message.setStates(DBaseState.SUCCEEDED, DBaseState.FAILED);
            this.onDone();
        };
        DDialogProcessing.prototype.onRejected = function (message) {
            if (message != null) {
                this._message.text = message;
            }
            this._message.setStates(DBaseState.FAILED, DBaseState.SUCCEEDED);
            this.onDone();
        };
        DDialogProcessing.prototype.resolve = function (message) {
            var _this = this;
            if (!this._isDone) {
                this._isDone = true;
                var elapsedTime = Date.now() - this._startTime;
                var delay = this._interval - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(function () {
                        _this._timeoutId = undefined;
                        _this.onResolved(message);
                    }, delay);
                }
                else {
                    this.onResolved(message);
                }
            }
        };
        DDialogProcessing.prototype.reject = function (message) {
            var _this = this;
            if (!this._isDone) {
                this._isDone = true;
                var elapsedTime = Date.now() - this._startTime;
                var delay = this._interval - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(function () {
                        _this._timeoutId = undefined;
                        _this.onRejected(message);
                    }, delay);
                }
                else {
                    this.onRejected(message);
                }
            }
        };
        DDialogProcessing.prototype.onCloseOn = function () {
            if (this._isDone) {
                _super.prototype.onCloseOn.call(this);
            }
        };
        DDialogProcessing.prototype.getType = function () {
            return "DDialogProcessing";
        };
        return DDialogProcessing;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSaveAs = /** @class */ (function (_super) {
        __extends(DDialogSaveAs, _super);
        function DDialogSaveAs() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSaveAs.prototype.onOpen = function () {
            var name = DControllers.getDocumentController().getName();
            if (name != null) {
                this._inputAndLabel.input.value = name;
            }
            _super.prototype.onOpen.call(this);
        };
        DDialogSaveAs.prototype.onOk = function () {
            _super.prototype.onOk.call(this);
            var name = this._inputAndLabel.input.value;
            DControllers.getCommandController().push(new DCommandSaveAs(name));
        };
        DDialogSaveAs.prototype.getType = function () {
            return "DDialogSaveAs";
        };
        return DDialogSaveAs;
    }(DDialogInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuContext = /** @class */ (function () {
        function DMenuContext(owner) {
            this._owner = owner;
            this._closeables = [];
        }
        DMenuContext.prototype.indexOf = function (target) {
            return this._closeables.indexOf(target);
        };
        DMenuContext.prototype.close = function (index) {
            var closeables = this._closeables;
            var imin = Math.max(0, index);
            for (var i = closeables.length - 1; imin <= i; --i) {
                closeables[i].close();
            }
        };
        DMenuContext.prototype.add = function (closeable) {
            this._closeables.push(closeable);
        };
        DMenuContext.prototype.trim = function (closeable) {
            this.close(this.indexOf(closeable) + 1);
        };
        DMenuContext.prototype.remove = function (closeable) {
            var index = this.indexOf(closeable);
            if (0 <= index) {
                this.close(index + 1);
                this._closeables.splice(index, 1);
                if (index === 0) {
                    this._owner.focus();
                }
            }
        };
        return DMenuContext;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenu = /** @class */ (function (_super) {
        __extends(DMenu, _super);
        function DMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenu.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            if (options != null) {
                this._align = (options.align != null ?
                    (isString(options.align) ? DMenuAlign[options.align] : options.align) :
                    DMenuAlign.BOTTOM);
                this._fit = (options.fit != null ? options.fit : false);
                this._sticky = (options.sticky != null ? options.sticky : false);
            }
            else {
                this._align = DMenuAlign.BOTTOM;
                this._fit = false;
                this._sticky = false;
            }
            this._sub = false;
            this._owner = null;
            this.visible = false;
            this._context = null;
            this.setState(DBaseState.FOCUS_ROOT, true);
            // Event handlers
            UtilClickOutside.apply(this, function () {
                _this.close();
            });
            this.on("select", function () {
                _this.close();
            });
            // Items
            if (options && options.items) {
                DMenus.newItems(this, options.items, this._sticky);
            }
            // Overlay
            this._overlay = new UtilOverlay(options);
        };
        DMenu.prototype.findItem = function (value) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItem && child.value === value) {
                    return child;
                }
            }
            return null;
        };
        DMenu.prototype.getType = function () {
            return "DMenu";
        };
        DMenu.prototype.getContext = function () {
            return this._context;
        };
        DMenu.prototype.getCloseable = function () {
            return this;
        };
        DMenu.prototype.open = function (owner, closeable, context) {
            if (this.isHidden()) {
                var layer = this._overlay.pick(this);
                this._owner = owner;
                // States
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.setState(DBaseState.FOCUSED | DBaseState.HOVERED, false);
                    }
                }
                // Position & size
                var renderer = layer.renderer;
                var onPrerenderBound = this._onPrerenderBound;
                if (this._sticky) {
                    renderer.on("prerender", onPrerenderBound);
                }
                else {
                    renderer.once("prerender", onPrerenderBound);
                }
                if (this._fit) {
                    var bounds = owner.getBounds();
                    if (bounds != null) {
                        this.width = bounds.width;
                    }
                }
                // Target
                this._sub = (context != null);
                context = context || new DMenuContext(owner);
                if (closeable != null) {
                    context.trim(closeable);
                }
                context.add(this);
                this._context = context;
                // Stage
                layer.stage.addChild(this);
                // Focus
                this.focus();
                // Show
                _super.prototype.show.call(this);
                // Event
                this.emit("open", this);
            }
            return this;
        };
        DMenu.prototype.onPrerender = function () {
            var owner = this._owner;
            if (owner) {
                var bounds = owner.getBounds();
                if (bounds) {
                    if (this._fit) {
                        this.width = bounds.width;
                    }
                    var layer = this._overlay.picked;
                    if (layer) {
                        var theme = this.theme;
                        UtilAttach.attach(this, bounds, theme.getOffsetX(), theme.getOffsetY(), layer.width, layer.height, this._align);
                    }
                }
            }
        };
        DMenu.prototype.close = function () {
            if (this.isShown()) {
                var context = this._context;
                if (context) {
                    context.remove(this);
                }
                var layer = this._overlay.picked;
                if (layer) {
                    layer.renderer.off("prerender", this._onPrerenderBound);
                }
                this._owner = null;
                _super.prototype.hide.call(this);
                var parent_1 = this.parent;
                if (parent_1) {
                    parent_1.removeChild(this);
                }
                this.emit("close", this);
            }
            return this;
        };
        DMenu.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowUpKey(e) || UtilKeyboardEvent.isArrowDownKey(e)) {
                var layer = this._overlay.picked;
                if (layer) {
                    var focusController = layer.getFocusController();
                    var focused = focusController.getFocused();
                    if (focused != null) {
                        var direction = UtilKeyboardEvent.isArrowDownKey(e);
                        var next = focusController.findFocusable(focused, false, focused.hasState(DBaseState.FOCUS_ROOT) || direction, direction);
                        if (next != null) {
                            focusController.setFocused(next, true, true);
                        }
                    }
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenu.prototype.containsGlobalPoint = function (point) {
            return !this._sub;
        };
        return DMenu;
    }(DLayoutVertical));
    DMenus.setMenuCreator(function (options) { return new DMenu(options); });

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDropdownBase = /** @class */ (function (_super) {
        __extends(DDropdownBase, _super);
        function DDropdownBase(options) {
            var _this = _super.call(this, options) || this;
            _this.on("active", function () {
                _this.start();
            });
            return _this;
        }
        DDropdownBase.prototype.toItemText = function (item) {
            if (item) {
                var text = item.text;
                if (isString(text)) {
                    return text;
                }
                else if (text != null) {
                    var computed = text(item.state);
                    if (computed != null) {
                        return computed;
                    }
                }
            }
            return null;
        };
        DDropdownBase.prototype.toMenu = function (theme, options) {
            var menu = options && options.menu;
            return (menu instanceof DMenu ? menu :
                new DMenu(this.toMenuOptions(theme, menu)));
        };
        DDropdownBase.prototype.toMenuOptions = function (theme, options) {
            options = options || {};
            if (options.fit == null) {
                options.fit = true;
            }
            return options;
        };
        Object.defineProperty(DDropdownBase.prototype, "menu", {
            get: function () {
                var menu = this._menu;
                if (menu == null) {
                    menu = this.toMenu(this.theme, this._options);
                    this._menu = menu;
                }
                return menu;
            },
            enumerable: true,
            configurable: true
        });
        DDropdownBase.prototype.getType = function () {
            return "DDropdownBase";
        };
        DDropdownBase.prototype.start = function () {
            this.menu.open(this);
        };
        DDropdownBase.prototype.close = function () {
            this.menu.close();
        };
        return DDropdownBase;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDropdown = /** @class */ (function (_super) {
        __extends(DDropdown, _super);
        function DDropdown() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDropdown.prototype.getType = function () {
            return "DDropdown";
        };
        return DDropdown;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DExpandableHeader = /** @class */ (function (_super) {
        __extends(DExpandableHeader, _super);
        function DExpandableHeader(options) {
            var _this = _super.call(this, options) || this;
            _this.on(UtilPointerEvent.down, function () {
                if (_this.isActionable()) {
                    _this.onSelect();
                }
            });
            return _this;
        }
        DExpandableHeader.prototype.onSelect = function () {
            this.emit("select", this);
        };
        DExpandableHeader.prototype.onKeyDown = function (e) {
            if (this.isActionable() && this.isFocused() && UtilKeyboardEvent.isActivateKey(e)) {
                this.onSelect();
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DExpandableHeader.prototype.getType = function () {
            return "DExpandableHeader";
        };
        return DExpandableHeader;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DExpandable = /** @class */ (function (_super) {
        __extends(DExpandable, _super);
        function DExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DExpandable.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            // Header
            var theme = this.theme;
            var header = this.toHeader(theme, options);
            this._header = header;
            header.on("select", function () {
                _this.toggle();
            });
            this.addChild(header);
            // Body
            var body = this.toBody(theme, options);
            this._body = body;
            this.addChild(body);
            //
            if (this.isActive()) {
                this.onActivated();
            }
            else {
                this.onDeactivated();
            }
        };
        DExpandable.prototype.toHeader = function (theme, options) {
            if (options && options.header) {
                if (options.header instanceof pixi_js.DisplayObject) {
                    return options.header;
                }
                else {
                    return this.newHeader(theme, options.header);
                }
            }
            return this.newHeader(theme);
        };
        DExpandable.prototype.newHeader = function (theme, options) {
            return new DExpandableHeader(options);
        };
        DExpandable.prototype.toBody = function (theme, options) {
            return options.body;
        };
        DExpandable.prototype.open = function () {
            this.setActive(true);
        };
        DExpandable.prototype.close = function () {
            this.setActive(false);
        };
        DExpandable.prototype.toggle = function () {
            this.setActive(!this.isActive());
        };
        DExpandable.prototype.onActivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.show();
            }
            else {
                body.visible = true;
            }
        };
        DExpandable.prototype.onDeactivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.hide();
            }
            else {
                body.visible = false;
            }
        };
        DExpandable.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (DBaseStates.isActive(newState)) {
                if (!DBaseStates.isActive(oldState)) {
                    this.onActivated();
                }
            }
            else {
                if (DBaseStates.isActive(oldState)) {
                    this.onDeactivated();
                }
            }
        };
        DExpandable.prototype.getType = function () {
            return "DExpandable";
        };
        return DExpandable;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputIntegerAndLabel = /** @class */ (function (_super) {
        __extends(DInputIntegerAndLabel, _super);
        function DInputIntegerAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputIntegerAndLabel.prototype.createInput = function (options) {
            return new DInputInteger(options);
        };
        return DInputIntegerAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapCoordinateEPSG3857 = /** @class */ (function () {
        function DMapCoordinateEPSG3857(tileSize) {
            if (tileSize === void 0) { tileSize = 256; }
            this._tileSize = tileSize;
        }
        DMapCoordinateEPSG3857.prototype.getTileSize = function () {
            return this._tileSize;
        };
        /**
         * Converts the given (lon, lat) point in WGS84 to (x, y) in EPSG:900913.
         * The origin of the converted point (x, y) is at the middle-left corner.
         * The `meters` can be the same instance that is passed in as the `lonlat`.
         *
         * @param lonlat (lon, lat) point
         * @param meters (x, y) point in meters converted from the given lonlat.
         * @return (x, y) point in meters
         * @see https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/
         * @see https://qiita.com/MALORGIS/items/1a9114dd090e5b891bf7
         */
        DMapCoordinateEPSG3857.prototype.lonLatToMeters = function (lonlat, meters) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = lonlat.x * C / 180;
            meters.y = Math.log(Math.tan((90 + lonlat.y) * Math.PI / 360)) * C / Math.PI;
            return meters;
        };
        /**
         * The `lonlat` can be the same instance that is passed in as the `meters`.
         *
         * @param meters
         * @param lonlat
         */
        DMapCoordinateEPSG3857.prototype.metersToLonLat = function (meters, lonlat) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            lonlat.x = meters.x / C * 180;
            lonlat.y = Math.atan(Math.exp(meters.y * Math.PI / C)) * 360 / Math.PI - 90;
            return lonlat;
        };
        /**
         * Converts pixel coordinates in given zoom level of pyramid to EPSG:900913.
         * The origin of the `pixels` is the top-left corner.
         * The `meters` can be the same instance that is passed in as the `pixels`.
         */
        DMapCoordinateEPSG3857.prototype.pixelsToMeters = function (pixels, tz, tileSize, meters) {
            var R = this.toResolution(tz, tileSize);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = pixels.x * R - C;
            meters.y = C - pixels.y * R;
            return meters;
        };
        /**
         * Converts EPSG:900913 to pyramid pixel coordinates in given zoom level.
         * The origin of the pixels is the top-left corner.
         * The `pixels` can be the same instance that is passed in as the `meters`.
         */
        DMapCoordinateEPSG3857.prototype.metersToPixels = function (meters, tz, tileSize, pixels) {
            var R = this.toResolution(tz, tileSize);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            pixels.x = (meters.x + C) / R;
            pixels.y = (C - meters.y) / R;
            return pixels;
        };
        /**
         * Returns a tile covering region in given pixel coordinates.
         * The origin of the tile is the top-left corner.
         * The `tile` can be the same instance that is passed in as the `pixels`.
         */
        DMapCoordinateEPSG3857.prototype.pixelsToTile = function (pixels, tileSize, tile) {
            tile.x = Math.ceil(pixels.x / tileSize) - 1;
            tile.y = Math.ceil(pixels.y / tileSize) - 1;
            return tile;
        };
        /**
         * The origin of the tile is the top-left corner.
         * The `tile` can be the same instance that is passed in as the `meters`.
         */
        DMapCoordinateEPSG3857.prototype.metersToTile = function (meters, tz, tile) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            var Z = 1 << tz;
            tile.x = Math.ceil(0.5 * (meters.x / C + 1) * Z) - 1;
            tile.y = Math.ceil(0.5 * (1 - meters.y / C) * Z) - 1;
            return tile;
        };
        DMapCoordinateEPSG3857.prototype.lonLatToTile = function (lonlat, tz, tile) {
            return this.metersToTile(this.lonLatToMeters(lonlat, tile), tz, tile);
        };
        DMapCoordinateEPSG3857.prototype.lonLatToPixels = function (lonlat, tz, tileSize, pixels) {
            return this.metersToPixels(this.lonLatToMeters(lonlat, pixels), tz, tileSize, pixels);
        };
        DMapCoordinateEPSG3857.prototype.pixelsToLonLat = function (pixels, tz, tileSize, lonlat) {
            return this.metersToLonLat(this.pixelsToMeters(pixels, tz, tileSize, lonlat), lonlat);
        };
        /**
         * The `pixels` can be the same instance that is passed in as the `tile`.
         */
        DMapCoordinateEPSG3857.prototype.tileToPixels = function (tile, tileSize, pixels) {
            pixels.x = tile.x * tileSize;
            pixels.y = tile.y * tileSize;
            return pixels;
        };
        /**
         * Returns bounds of the given tile in EPSG:900913 coordinates
         * The `meters` can be the same instance that is passed in as the `tile`.
         */
        DMapCoordinateEPSG3857.prototype.tileToMeters = function (tile, tz, meters) {
            var R = this.toResolutionMeter(tz);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = tile.x * R + C;
            meters.y = C - tile.y * R;
            return meters;
        };
        DMapCoordinateEPSG3857.prototype.toResolutionMeter = function (tz) {
            return (2 * DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF) / (1 << tz);
        };
        DMapCoordinateEPSG3857.prototype.toResolution = function (tz, tileSize) {
            return (2 * DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF) / (tileSize << tz);
        };
        DMapCoordinateEPSG3857.prototype.toTileCount = function (tz) {
            return (1 << tz);
        };
        DMapCoordinateEPSG3857.prototype.toTileCode = function (tz, tx, ty) {
            return (tx << tz) + ty;
        };
        DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF = Math.PI * 6378137 /* Approximate earth radius in meter */;
        return DMapCoordinateEPSG3857;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapCoordinates = /** @class */ (function () {
        function DMapCoordinates() {
        }
        Object.defineProperty(DMapCoordinates, "DEFAULT", {
            get: function () {
                if (this._default == null) {
                    this._default = new DMapCoordinateEPSG3857();
                }
                return this._default;
            },
            enumerable: true,
            configurable: true
        });
        return DMapCoordinates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTile = /** @class */ (function () {
        function DMapTile(parent, tx, ty, px, py, scale) {
            this.tx = tx;
            this.ty = ty;
            var sprite = new pixi_js.Sprite(pixi_js.Texture.EMPTY);
            sprite.parent = parent;
            sprite.position.set(px, py);
            sprite.scale.set(scale, scale);
            this._sprite = sprite;
        }
        DMapTile.prototype.load = function (url, onLoaded) {
            var texture = pixi_js.Texture.from(url, { resolution: 1 });
            this._sprite.texture = texture;
            if (texture.valid) {
                onLoaded();
            }
            else {
                texture.on("update", onLoaded);
            }
        };
        DMapTile.prototype.transform = function (px, py, scale) {
            var sprite = this._sprite;
            sprite.position.set(px, py);
            sprite.scale.set(scale, scale);
        };
        Object.defineProperty(DMapTile.prototype, "loaded", {
            get: function () {
                return this._sprite.texture.valid;
            },
            enumerable: true,
            configurable: true
        });
        DMapTile.prototype.render = function (renderer) {
            var sprite = this._sprite;
            sprite.updateTransform();
            sprite.render(renderer);
        };
        DMapTile.prototype.destroy = function () {
            var sprite = this._sprite;
            var texture = sprite.texture;
            var resource = texture.baseTexture.resource;
            var image = null;
            if (resource instanceof pixi_js.resources.BaseImageResource) {
                if (resource.source instanceof HTMLImageElement) {
                    image = resource.source;
                }
            }
            texture.destroy(true);
            sprite.destroy();
            if (image) {
                image.src = "";
            }
        };
        return DMapTile;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTilePlane = /** @class */ (function () {
        function DMapTilePlane(parent, builder, tz, mapping, coordinate, onLoaded) {
            var _this = this;
            this._parent = parent;
            this._builder = builder;
            this._onLoaded = onLoaded;
            this._isOnLoadedCalled = false;
            this._isOnLoadedAllowed = true;
            this._onLoadedBound = function () {
                _this.onLoaded();
            };
            this._tz = tz;
            this._lon0 = NaN;
            this._lat0 = NaN;
            this._lon1 = NaN;
            this._lat1 = NaN;
            this._tiles = new Map();
            this._renderTileBound = function (tile) {
                _this.renderTile(tile);
            };
            this._txmin = NaN;
            this._txmax = NaN;
            this._tymin = NaN;
            this._tymax = NaN;
            this._deleteTileBound = function (tile, tileCode, tiles) {
                _this.deleteTile(tile, tileCode, tiles);
            };
            this._destroyTileBound = function (tile) {
                _this.destroyTile(tile);
            };
            this._updateLoadingStateForEach = function (tile) {
                if (!tile.loaded) {
                    _this._isLoaded = false;
                }
            };
            this._tileCount = coordinate.toTileCount(tz);
            this._tileScaleRelative = 1 / this._tileCount;
            this._tileScale = mapping.scale * this._tileScaleRelative;
            this._tileSize = coordinate.getTileSize() * mapping.scale;
            this._mapping = mapping;
            this._coordinate = coordinate;
            this._isLoaded = true;
        }
        DMapTilePlane.prototype.newTile = function (tx, ty, px, py, scale) {
            return new DMapTile(this._parent, tx, ty, px, py, scale);
        };
        DMapTilePlane.prototype.renderTile = function (tile) {
            tile.render(this._renderer);
        };
        Object.defineProperty(DMapTilePlane.prototype, "tz", {
            get: function () {
                return this._tz;
            },
            enumerable: true,
            configurable: true
        });
        DMapTilePlane.prototype.render = function (renderer) {
            this._renderer = renderer;
            this._tiles.forEach(this._renderTileBound);
        };
        DMapTilePlane.prototype.move = function (lon0, lat0, lon1, lat1) {
            var oldLon0 = this._lon0;
            var oldLat0 = this._lat0;
            var oldLon1 = this._lon1;
            var oldLat1 = this._lat1;
            if (oldLon0 !== lon0 || oldLat0 !== lat0 || oldLon1 !== lon1 || oldLat1 !== lat1) {
                this._lon0 = lon0;
                this._lat0 = lat0;
                this._lon1 = lon1;
                this._lat1 = lat1;
                var tz = this._tz;
                var coordinate = this._coordinate;
                var work = DMapTilePlane.WORK;
                work.set(lon0, lat0);
                coordinate.lonLatToTile(work, tz, work);
                var tx0 = work.x;
                var ty0 = work.y;
                work.set(lon1, lat1);
                coordinate.lonLatToTile(work, tz, work);
                var tx1 = work.x;
                var ty1 = work.y;
                var tileCount = this._tileCount;
                var txmin = Math.max(0, tx0);
                var txmax = Math.min(tileCount - 1, tx1);
                var tymin = Math.max(0, ty0);
                var tymax = Math.min(tileCount - 1, ty1);
                var dtxmin = txmin - this._txmin;
                var dtxmax = txmax - this._txmax;
                var dtymin = tymin - this._tymin;
                var dtymax = tymax - this._tymax;
                var isTxMinChanged = dtxmin !== dtxmin || dtxmin < 0 || 1 < dtxmin;
                var isTxMaxChanged = dtxmax !== dtxmax || 0 < dtxmax || dtxmax < -1;
                var isTyMinChanged = dtymin !== dtymin || dtymin < 0 || 1 < dtymin;
                var isTyMaxChanged = dtymax !== dtymax || 0 < dtymax || dtymax < -1;
                if (isTxMinChanged || isTxMaxChanged || isTyMinChanged || isTyMaxChanged) {
                    if (isTxMinChanged) {
                        this._txmin = txmin;
                    }
                    else {
                        txmin = this._txmin;
                    }
                    if (isTxMaxChanged) {
                        this._txmax = txmax;
                    }
                    else {
                        txmax = this._txmax;
                    }
                    if (isTyMinChanged) {
                        this._tymin = tymin;
                    }
                    else {
                        tymin = this._tymin;
                    }
                    if (isTyMaxChanged) {
                        this._tymax = tymax;
                    }
                    else {
                        tymax = this._tymax;
                    }
                    var tiles = this._tiles;
                    tiles.forEach(this._deleteTileBound);
                    var ctx = (txmin + txmax) >> 1;
                    var cty = (tymin + tymax) >> 1;
                    var ltx = Math.max(ctx - txmin, txmax - ctx);
                    var lty = Math.max(cty - tymin, tymax - cty);
                    var lt = Math.max(ltx, lty);
                    this.toOffset(work);
                    var offsetX = work.x;
                    var offsetY = work.y;
                    this._isOnLoadedCalled = false;
                    this._isOnLoadedAllowed = false;
                    this.loadTile(tz, ctx, cty, offsetX, offsetY, work);
                    for (var it = 1; it <= lt; ++it) {
                        var txa = ctx - it;
                        if (txmin <= txa) {
                            this.loadTilesY(tz, txa, cty, it, tymin, tymax, offsetX, offsetY, work);
                        }
                        var txb = ctx + it;
                        if (txb <= txmax) {
                            this.loadTilesY(tz, txb, cty, it, tymin, tymax, offsetX, offsetY, work);
                        }
                        var tya = cty - it;
                        if (tymin <= tya) {
                            this.loadTilesX(tz, ctx, it - 1, txmin, txmax, tya, offsetX, offsetY, work);
                        }
                        var tyb = cty + it;
                        if (tyb <= tymax) {
                            this.loadTilesX(tz, ctx, it - 1, txmin, txmax, tyb, offsetX, offsetY, work);
                        }
                    }
                    this._isOnLoadedAllowed = true;
                    if (this._isOnLoadedCalled) {
                        this.onLoaded();
                    }
                }
            }
        };
        DMapTilePlane.prototype.loadTilesX = function (tz, ctx, ltx, txmin, txmax, ty, ox, oy, work) {
            this.loadTile(tz, ctx, ty, ox, oy, work);
            for (var i = 1; i <= ltx; ++i) {
                var txa = ctx - i;
                if (txmin <= txa) {
                    this.loadTile(tz, txa, ty, ox, oy, work);
                }
                var txb = ctx + i;
                if (txb <= txmax) {
                    this.loadTile(tz, txb, ty, ox, oy, work);
                }
            }
        };
        DMapTilePlane.prototype.loadTilesY = function (tz, tx, cty, lty, tymin, tymax, ox, oy, work) {
            this.loadTile(tz, tx, cty, ox, oy, work);
            for (var i = 1; i <= lty; ++i) {
                var tya = cty - i;
                if (tymin <= tya) {
                    this.loadTile(tz, tx, tya, ox, oy, work);
                }
                var tyb = cty + i;
                if (tyb <= tymax) {
                    this.loadTile(tz, tx, tyb, ox, oy, work);
                }
            }
        };
        DMapTilePlane.prototype.loadTile = function (tz, tx, ty, ox, oy, work) {
            var coordinate = this._coordinate;
            var tileCode = coordinate.toTileCode(tz, tx, ty);
            var tiles = this._tiles;
            var tile = tiles.get(tileCode);
            if (tile == null) {
                this.toTilePosition(tx, ty, ox, oy, work);
                tile = this.newTile(tx, ty, work.x, work.y, this._tileScale);
                tiles.set(tileCode, tile);
                tile.load(this._builder(tz, tx, ty), this._onLoadedBound);
                this._isLoaded = false;
            }
        };
        DMapTilePlane.prototype.toTilePosition = function (tx, ty, ox, oy, result) {
            var tileSize = this._tileSize;
            var tileScaleRelative = this._tileScaleRelative;
            result.set(tx, ty);
            this._coordinate.tileToPixels(result, tileSize, result);
            result.set(result.x * tileScaleRelative + ox, result.y * tileScaleRelative + oy);
            return result;
        };
        DMapTilePlane.prototype.toOffset = function (result) {
            var parent = this._parent;
            var mapping = this._mapping;
            var tileSize = this._tileSize;
            result.set(-mapping.x * tileSize + parent.width * 0.5, -mapping.y * tileSize + parent.height * 0.5);
            return result;
        };
        DMapTilePlane.prototype.deleteTile = function (tile, tileCode, tiles) {
            var tx = tile.tx;
            var ty = tile.ty;
            if (tx < this._txmin || this._txmax < tx || ty < this._tymin || this._tymax < ty) {
                tiles.delete(tileCode);
                tile.destroy();
            }
        };
        DMapTilePlane.prototype.destroy = function () {
            var tiles = this._tiles;
            tiles.forEach(this._destroyTileBound);
            tiles.clear();
        };
        DMapTilePlane.prototype.destroyTile = function (tile) {
            tile.destroy();
        };
        DMapTilePlane.prototype.updateLoadingState = function () {
            this._isLoaded = true;
            this._tiles.forEach(this._updateLoadingStateForEach);
        };
        DMapTilePlane.prototype.onLoaded = function () {
            if (this._isOnLoadedAllowed) {
                this._onLoaded();
            }
            else {
                this._isOnLoadedCalled = true;
            }
        };
        Object.defineProperty(DMapTilePlane.prototype, "loaded", {
            get: function () {
                if (!this._isLoaded) {
                    this.updateLoadingState();
                }
                return this._isLoaded;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DMapTilePlane.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            set: function (mapping) {
                var _this = this;
                var coordinate = this._coordinate;
                var tileScale = mapping.scale * this._tileScaleRelative;
                var tileSize = coordinate.getTileSize() * mapping.scale;
                this._tileScale = tileScale;
                this._tileSize = tileSize;
                this._mapping = mapping;
                var work = DMapTilePlane.WORK;
                this.toOffset(work);
                var offsetX = work.x;
                var offsetY = work.y;
                this._tiles.forEach(function (tile) {
                    _this.toTilePosition(tile.tx, tile.ty, offsetX, offsetY, work);
                    tile.transform(work.x, work.y, tileScale);
                });
            },
            enumerable: true,
            configurable: true
        });
        DMapTilePlane.WORK = new pixi_js.Point();
        return DMapTilePlane;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTilePyramidImpl = /** @class */ (function (_super) {
        __extends(DMapTilePyramidImpl, _super);
        function DMapTilePyramidImpl(options) {
            var _this = _super.call(this) || this;
            var canvas = _this._canvas = options.canvas;
            _this._builder = options.builder;
            var mappingLonLat = _this._mapping = options.mapping;
            var coordinate = _this._coordinate = options.coordinate;
            _this._mappingInternal = _this.toMapping(canvas, mappingLonLat, coordinate);
            _this._z = NaN;
            _this._tz = NaN;
            _this._minZ = options.plane.min;
            _this._maxZ = options.plane.max;
            _this._planes = [];
            _this._onLoadedBound = function () {
                _this.onLoaded();
            };
            _this._fitBound = function () {
                _this._fitBoundTimeout = undefined;
                _this.fit();
            };
            _this._fitThrottle = options.plane.throttle;
            var fitThrottledBound = _this._fitThrottledBound = function () {
                _this.fitThrottled();
            };
            canvas.on("scale", fitThrottledBound);
            canvas.on("move", fitThrottledBound);
            canvas.appendRenderable(_this, true);
            return _this;
        }
        Object.defineProperty(DMapTilePyramidImpl.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: true,
            configurable: true
        });
        DMapTilePyramidImpl.prototype.fitThrottled = function () {
            if (this._fitBoundTimeout == null) {
                this._fitBoundTimeout = window.setTimeout(this._fitBound, this._fitThrottle);
            }
        };
        DMapTilePyramidImpl.prototype.toMapping = function (canvas, mapping, coordinate) {
            var work = DMapTilePyramidImpl.WORK_LONLAT;
            var tileSize = coordinate.getTileSize();
            work.set(mapping.from.lon, mapping.from.lat);
            coordinate.lonLatToPixels(work, 0, tileSize, work);
            var x0 = work.x;
            var y0 = work.y;
            work.set(mapping.to.lon, mapping.to.lat);
            coordinate.lonLatToPixels(work, 0, tileSize, work);
            var x1 = work.x;
            var y1 = work.y;
            var dx = Math.abs(x1 - x0);
            var dy = Math.abs(y1 - y0);
            var dmin = 0.0000001;
            var scale = 1;
            if (dmin < dx) {
                if (dmin < dy) {
                    scale = Math.max(canvas.width / dx, canvas.height / dy);
                }
                else {
                    scale = canvas.width / dx;
                }
            }
            else {
                if (dmin < dy) {
                    scale = canvas.height / dy;
                }
            }
            return {
                scale: scale,
                x: 0.5 * (x1 + x0) / tileSize,
                y: 0.5 * (y1 + y0) / tileSize
            };
        };
        Object.defineProperty(DMapTilePyramidImpl.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            set: function (mapping) {
                var oldMapping = this._mappingInternal;
                var newMapping = this.toMapping(this._canvas, mapping, this._coordinate);
                var threshold = 0.0000001;
                if (threshold < Math.abs(oldMapping.scale - newMapping.scale) ||
                    threshold < Math.abs(oldMapping.x - newMapping.x) ||
                    threshold < Math.abs(oldMapping.y - newMapping.y)) {
                    this._mappingInternal = newMapping;
                    var planes = this._planes;
                    for (var i = 0, imax = planes.length; i < imax; ++i) {
                        var plane = planes[i];
                        if (plane) {
                            plane.mapping = newMapping;
                        }
                    }
                    DApplications.update(this._canvas);
                    this._fitThrottledBound();
                }
            },
            enumerable: true,
            configurable: true
        });
        DMapTilePyramidImpl.prototype.newPlane = function (tz) {
            return new DMapTilePlane(this._canvas, this._builder, tz, this._mappingInternal, this._coordinate, this._onLoadedBound);
        };
        DMapTilePyramidImpl.prototype.render = function (renderer) {
            var tz = this._tz;
            var planes = this._planes;
            for (var i = 0; i < tz; ++i) {
                var plane = planes[i];
                if (plane != null) {
                    plane.render(renderer);
                }
            }
            for (var i = planes.length - 1; tz < i; --i) {
                var plane = planes[i];
                if (plane != null) {
                    plane.render(renderer);
                }
            }
            var planeTz = planes[tz];
            if (planeTz != null) {
                planeTz.render(renderer);
            }
        };
        DMapTilePyramidImpl.prototype.toTileZ = function (tz) {
            return Math.min(this._maxZ, Math.max(this._minZ, Math.floor(tz)));
        };
        DMapTilePyramidImpl.prototype.updateTransform = function () {
            // DO NOTHING
        };
        DMapTilePyramidImpl.prototype.toZ = function (scale) {
            return Math.log(this._mappingInternal.scale * scale) / Math.log(2);
        };
        DMapTilePyramidImpl.prototype.move = function (scale, lon0, lat0, lon1, lat1) {
            var planes = this._planes;
            var z = this.toZ(scale);
            if (this._z !== z) {
                this._z = z;
                var tz = this.toTileZ(z);
                if (this._tz !== tz) {
                    this._tz = tz;
                    var newPlane = planes[tz];
                    if (newPlane == null) {
                        newPlane = this.newPlane(tz);
                        planes[tz] = newPlane;
                    }
                }
            }
            var plane = planes[this._tz];
            if (plane != null) {
                plane.move(lon0, lat0, lon1, lat1);
            }
            return this;
        };
        DMapTilePyramidImpl.prototype.fit = function () {
            var canvas = this._canvas;
            if (canvas != null) {
                var container = canvas.parent;
                if (container != null) {
                    var scale = canvas.scale;
                    var scaleX = scale.x;
                    var scaleY = scale.y;
                    var x = canvas.x;
                    var y = canvas.y;
                    var coordinate = this._coordinate;
                    var mapping = this._mappingInternal;
                    var tileSize = coordinate.getTileSize() * mapping.scale;
                    var x0 = mapping.x * tileSize - (x / scaleX + 0.5 * canvas.width);
                    var x1 = x0 + container.width / scaleX;
                    var y0 = mapping.y * tileSize - (y / scaleY + 0.5 * canvas.height);
                    var y1 = y0 + container.height / scaleY;
                    var work = DMapTilePyramidImpl.WORK_LONLAT;
                    work.set(x0, y0);
                    coordinate.pixelsToLonLat(work, 0, tileSize, work);
                    var lon0 = work.x;
                    var lat0 = work.y;
                    work.set(x1, y1);
                    coordinate.pixelsToLonLat(work, 0, tileSize, work);
                    var lon1 = work.x;
                    var lat1 = work.y;
                    this.move(scaleX, lon0, lat0, lon1, lat1);
                }
            }
            return this;
        };
        DMapTilePyramidImpl.prototype.destroyPlanesBefore = function (tz, planes) {
            for (var i = 0; i < tz; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
        };
        DMapTilePyramidImpl.prototype.destroyPlanesAfter = function (tz, planes) {
            for (var i = tz + 1, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
        };
        DMapTilePyramidImpl.prototype.cleanup = function () {
            var tz = this._tz;
            var planes = this._planes;
            var planeTz = planes[tz];
            if (planeTz && planeTz.loaded) {
                this.destroyPlanesBefore(tz, planes);
                this.destroyPlanesAfter(tz, planes);
                return;
            }
            for (var i = tz + 1, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane && plane.loaded) {
                    this.destroyPlanesBefore(tz, planes);
                    this.destroyPlanesAfter(i, planes);
                    return;
                }
            }
            for (var i = tz - 1; 0 <= i; --i) {
                var plane = planes[i];
                if (plane && plane.loaded) {
                    this.destroyPlanesBefore(i, planes);
                    return;
                }
            }
        };
        DMapTilePyramidImpl.prototype.onLoaded = function () {
            this.cleanup();
            DApplications.update(this._canvas);
        };
        DMapTilePyramidImpl.prototype.destroy = function () {
            var planes = this._planes;
            for (var i = 0, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
            var canvas = this._canvas;
            var fitThrottledBound = this._fitThrottledBound;
            canvas.off("scale", fitThrottledBound);
            canvas.off("move", fitThrottledBound);
            canvas.removeRenderable(this, true);
            return this;
        };
        DMapTilePyramidImpl.WORK_LONLAT = new pixi_js.Point();
        return DMapTilePyramidImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTileUrlBuilderKokudo = function (tz, tx, ty) {
        if (5 <= tz) {
            return "https://cyberjapandata.gsi.go.jp/xyz/pale/" + tz + "/" + tx + "/" + ty + ".png";
        }
        else if (2 <= tz) {
            return "https://cyberjapandata.gsi.go.jp/xyz/std/" + tz + "/" + tx + "/" + ty + ".png";
        }
        else {
            return "https://cyberjapandata.gsi.go.jp/xyz/earthhillshade/" + tz + "/" + tx + "/" + ty + ".png";
        }
    };
    var DMapTileUrlBuilderOsm = function (tz, tx, ty) {
        return "https://" + "abc"[(tx + ty) % 3] + ".tile.openstreetmap.org/" + tz + "/" + tx + "/" + ty + ".png";
    };
    var DMapTileUrlBuilderOsmfj = function (tz, tx, ty) {
        return "https://j.tile.openstreetmap.jp/" + tz + "/" + tx + "/" + ty + ".png";
    };
    var DMapTilePyramids = /** @class */ (function () {
        function DMapTilePyramids() {
        }
        DMapTilePyramids.toPlaneOptions = function (options) {
            var plane = options.plane;
            if (plane) {
                return {
                    min: (plane.min != null ? plane.min : this.MIN),
                    max: (plane.max != null ? plane.max : this.MAX),
                    throttle: (plane.throttle != null ? plane.throttle : this.THROTTLE)
                };
            }
            else {
                return {
                    min: this.MIN,
                    max: this.MAX,
                    throttle: this.THROTTLE
                };
            }
        };
        DMapTilePyramids.from = function (options) {
            return new DMapTilePyramidImpl({
                canvas: options.canvas,
                builder: options.builder || DMapTileUrlBuilderOsmfj,
                mapping: options.canvas.tile.mapping,
                coordinate: options.coordinate || DMapCoordinates.DEFAULT,
                plane: this.toPlaneOptions(options)
            });
        };
        DMapTilePyramids.MIN = 0;
        DMapTilePyramids.MAX = 18;
        DMapTilePyramids.THROTTLE = 333;
        return DMapTilePyramids;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuBarItem = /** @class */ (function (_super) {
        __extends(DMenuBarItem, _super);
        function DMenuBarItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuBarItem.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._menu = this.toMenu(this.theme, options);
            this._menu.on("select", function (value, item, menu) {
                _this.onSelect(value, item, menu);
            });
        };
        DMenuBarItem.prototype.toMenu = function (theme, options) {
            var menu = options && options.menu;
            if (menu instanceof DMenu) {
                return menu;
            }
            else {
                return new DMenu(this.toMenuOptions(theme, menu));
            }
        };
        DMenuBarItem.prototype.newMenu = function (theme, options) {
            return new DMenu(this.toMenuOptions(theme, options));
        };
        DMenuBarItem.prototype.toMenuOptions = function (theme, options) {
            options = options || {};
            if (options.fit == null) {
                options.fit = false;
            }
            return options;
        };
        DMenuBarItem.prototype.close = function () {
            this._menu.close();
        };
        Object.defineProperty(DMenuBarItem.prototype, "menu", {
            get: function () {
                return this._menu;
            },
            enumerable: true,
            configurable: true
        });
        DMenuBarItem.prototype.onSelect = function (value, item, menu) {
            var parent = this.parent;
            if (parent != null) {
                parent.emit("select", value, item, menu);
            }
        };
        DMenuBarItem.prototype.getType = function () {
            return "DMenuBarItem";
        };
        return DMenuBarItem;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuBarBlocker = /** @class */ (function (_super) {
        __extends(DMenuBarBlocker, _super);
        function DMenuBarBlocker(target) {
            var _this = _super.call(this) || this;
            _this.renderable = false;
            _this.interactive = true;
            _this.on(UtilPointerEvent.down, function (e) {
                if (e.target === _this) {
                    target.close();
                }
            });
            _this.on(UtilPointerEvent.move, function (e) {
                if (e.target === _this) {
                    var children = target.children;
                    for (var i = 0, imax = children.length; i < imax; ++i) {
                        var child = children[i];
                        if (child instanceof DMenuBarItem) {
                            child.setHovered(child.containsPoint(e.data.global));
                        }
                    }
                }
            });
            return _this;
        }
        DMenuBarBlocker.prototype.containsPoint = function (global) {
            return true;
        };
        return DMenuBarBlocker;
    }(pixi_js.Container));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuBar = /** @class */ (function (_super) {
        __extends(DMenuBar, _super);
        function DMenuBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuBar.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.FOCUS_ROOT, true);
            if (options != null && options.items != null) {
                var items = options.items;
                UtilClickOutside.apply(this, function () {
                    _this.close();
                });
                var onItemStateChangeBound = function (newState, oldState, item) {
                    _this.onItemStateChange(newState, oldState, item);
                };
                for (var i = 0, imax = items.length; i < imax; ++i) {
                    var itemOrItemOptions = items[i];
                    var item = (itemOrItemOptions instanceof pixi_js.DisplayObject ? itemOrItemOptions :
                        ("space" in itemOrItemOptions ? new DLayoutSpace(itemOrItemOptions) :
                            new DMenuBarItem(itemOrItemOptions)));
                    if (item instanceof DMenuBarItem) {
                        item.on("statechange", onItemStateChangeBound);
                    }
                    this.addChild(item);
                }
            }
            this.on("select", function () {
                _this.close();
            });
            this._context = null;
            this._blocker = new DMenuBarBlocker(this);
            this._overlay = new UtilOverlay(options);
        };
        DMenuBar.prototype.onItemStateChange = function (newState, oldState, item) {
            var context = this._context;
            if (context == null) {
                if (!DBaseStates.isDisabled(newState)) {
                    if (DBaseStates.isPressed(newState)) {
                        if (item.menu.isHidden()) {
                            item.setPressed(false);
                            this.open(item);
                        }
                    }
                }
            }
            else {
                if (!DBaseStates.isDisabled(newState)) {
                    if (DBaseStates.isHovered(newState) && !DBaseStates.isHovered(oldState)) {
                        var menu = item.menu;
                        if (menu.isHidden()) {
                            menu.open(item, this, context);
                        }
                    }
                }
            }
        };
        DMenuBar.prototype.getContext = function () {
            return this._context;
        };
        DMenuBar.prototype.getCloseable = function () {
            return this;
        };
        DMenuBar.prototype.open = function (item) {
            var context = this._context;
            if (context == null) {
                var layer = this._overlay.pick(this);
                layer.stage.addChild(this._blocker);
                context = this._context = new DMenuContext(this);
                context.trim(item);
                context.add(this);
                item.menu.open(item, this, context);
            }
        };
        DMenuBar.prototype.close = function () {
            var context = this._context;
            if (context != null) {
                this._context = null;
                context.remove(this);
                var blocker = this._blocker;
                var parent_1 = blocker.parent;
                if (parent_1) {
                    parent_1.removeChild(blocker);
                }
            }
        };
        DMenuBar.prototype.getType = function () {
            return "DMenuBar";
        };
        return DMenuBar;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedContent = /** @class */ (function (_super) {
        __extends(DMenuSidedContent, _super);
        function DMenuSidedContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedContent.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.UNFOCUSABLE, true);
        };
        DMenuSidedContent.prototype.initReflowable = function () {
            // DO NOTHING
        };
        DMenuSidedContent.prototype.getType = function () {
            return "DMenuSidedContent";
        };
        return DMenuSidedContent;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedSelectionMode;
    (function (DMenuSidedSelectionMode) {
        DMenuSidedSelectionMode[DMenuSidedSelectionMode["NONE"] = 0] = "NONE";
        DMenuSidedSelectionMode[DMenuSidedSelectionMode["SINGLE"] = 1] = "SINGLE";
        DMenuSidedSelectionMode[DMenuSidedSelectionMode["SINGLE_ONCE"] = 2] = "SINGLE_ONCE";
        DMenuSidedSelectionMode[DMenuSidedSelectionMode["DEFAULT"] = 2] = "DEFAULT";
    })(DMenuSidedSelectionMode || (DMenuSidedSelectionMode = {}));
    var defaultFilter = function () { return true; };
    var DMenuSidedSelection = /** @class */ (function (_super) {
        __extends(DMenuSidedSelection, _super);
        function DMenuSidedSelection(content, options) {
            var _this = _super.call(this) || this;
            _this._content = content;
            _this._item = null;
            _this._isDirty = true;
            _this._mode = (options && options.mode != null ?
                (isString(options.mode) ? DMenuSidedSelectionMode[options.mode] : options.mode) :
                DMenuSidedSelectionMode.DEFAULT);
            _this._filter = (options && options.filter) || _this.getFilterDefault();
            // Events
            var on = options && options.on;
            if (on) {
                for (var name_1 in on) {
                    _this.on(name_1, on[name_1]);
                }
            }
            return _this;
        }
        DMenuSidedSelection.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DMenuSidedSelection.prototype.update = function () {
            if (this._isDirty) {
                this._isDirty = false;
                this.update_(this._content);
            }
        };
        DMenuSidedSelection.prototype.hasMenu = function (child) {
            return child && child.menu instanceof DMenu;
        };
        DMenuSidedSelection.prototype.update_ = function (root) {
            var children = root.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DListItem) {
                    if (child.isActive()) {
                        this.set_(child, false);
                    }
                }
                if (child instanceof pixi_js.Container) {
                    this.update_(child);
                }
                if (this.hasMenu(child)) {
                    this.update_(child.menu);
                }
            }
        };
        DMenuSidedSelection.prototype.add = function (item) {
            this.update();
            this.set_(item, true);
        };
        DMenuSidedSelection.prototype.set = function (item) {
            this.update();
            this.set_(item, true);
        };
        DMenuSidedSelection.prototype.get = function () {
            this.update();
            return this._item;
        };
        DMenuSidedSelection.prototype.size = function () {
            return (this._item ? 1 : 0);
        };
        DMenuSidedSelection.prototype.isEmpty = function () {
            return this._item == null;
        };
        DMenuSidedSelection.prototype.remove = function (item) {
            this.update();
            if (this._item === item) {
                this.set_(null, true);
            }
        };
        DMenuSidedSelection.prototype.clear = function () {
            this.update();
            this.set_(null, true);
        };
        DMenuSidedSelection.prototype.getFilterDefault = function () {
            return defaultFilter;
        };
        DMenuSidedSelection.prototype.set_ = function (item, emit) {
            var oldItem = this._item;
            var mode = this._mode;
            if (mode !== DMenuSidedSelectionMode.NONE && this._filter(item) && oldItem !== item) {
                this.setState(oldItem, mode, false);
                this._item = item;
                this.setState(item, mode, true);
                if (emit) {
                    this.emit("change", this);
                }
            }
        };
        DMenuSidedSelection.prototype.setState = function (item, mode, isOn) {
            if (item) {
                if (mode === DMenuSidedSelectionMode.SINGLE) {
                    item.setState(DBaseState.ACTIVE, isOn);
                }
                else {
                    item.setState(DBaseState.ACTIVE | DBaseState.READ_ONLY, isOn);
                }
            }
        };
        return DMenuSidedSelection;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSided = /** @class */ (function (_super) {
        __extends(DMenuSided, _super);
        function DMenuSided() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSided.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            var context = new DMenuContext(this);
            this._context = context;
            context.add(this);
            var items = options && options.items;
            if (items != null) {
                var sticky = (options && options.sticky != null ? options.sticky : false);
                this.newItems(items, sticky);
            }
            var selection = options && options.selection;
            this._selection = (selection instanceof DMenuSidedSelection ?
                selection : this.newSelection(selection));
        };
        DMenuSided.prototype.newSelection = function (options) {
            return new DMenuSidedSelection(this._content, options);
        };
        DMenuSided.prototype.onChildrenDirty = function () {
            var selection = this._selection;
            if (selection != null) {
                selection.toDirty();
            }
            _super.prototype.onChildrenDirty.call(this);
        };
        DMenuSided.prototype.newItems = function (items, sticky) {
            DMenuSideds.newItems(this.content, items, sticky);
        };
        DMenuSided.prototype.newContent = function (options) {
            return new DMenuSidedContent(options);
        };
        Object.defineProperty(DMenuSided.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: true,
            configurable: true
        });
        DMenuSided.prototype.getContext = function () {
            return this._context;
        };
        DMenuSided.prototype.getCloseable = function () {
            return this;
        };
        DMenuSided.prototype.open = function () {
            // DO NOTHING
        };
        DMenuSided.prototype.close = function () {
            // DO NOTHING
        };
        DMenuSided.prototype.getType = function () {
            return "DMenuSided";
        };
        return DMenuSided;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNotification = /** @class */ (function (_super) {
        __extends(DNotification, _super);
        function DNotification() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DNotification;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationDotsButton = /** @class */ (function (_super) {
        __extends(DPaginationDotsButton, _super);
        function DPaginationDotsButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationDotsButton.prototype.getType = function () {
            return "DPaginationDotsButton";
        };
        return DPaginationDotsButton;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationDynamicButtons = /** @class */ (function (_super) {
        __extends(DPaginationDynamicButtons, _super);
        function DPaginationDynamicButtons() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationDynamicButtons.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._dotsBtnLeft = new DPaginationDotsButton({
                width: options.button.width,
                visible: !!options.button.dotsLeft
            });
            this._dotsBtnRight = new DPaginationDotsButton({
                width: options.button.width,
                visible: !!options.button.dotsRight
            });
            this.addChild(this._dotsBtnLeft);
            this.addChild(this._dotsBtnRight);
        };
        DPaginationDynamicButtons.prototype.update = function (options) {
            var _this = this;
            if (options.start == null || options.end == null) {
                return;
            }
            var btnsCount = options.end - options.start + 1 > 0 ? options.end - options.start + 1 : 0;
            var pageButtons = this.children.slice(1, this.children.length - 1);
            if (pageButtons.length < btnsCount) {
                for (var i = pageButtons.length; i < btnsCount; i++) {
                    var btn = new DButton({
                        width: options.button.width
                    });
                    this.addChildAt(btn, this.children.length - 1);
                    btn.on("active", function (clickedBtn) {
                        _this.emit("active", clickedBtn);
                    });
                }
                // re-new "pageButtons" after add new buttons
                pageButtons = this.children.slice(1, this.children.length - 1);
            }
            else if (pageButtons.length > btnsCount) {
                for (var i = btnsCount; i < pageButtons.length; i++) {
                    pageButtons[i].hide();
                }
            }
            // update button text and active state
            for (var i = 0; i < btnsCount; i++) {
                var btn = pageButtons[i];
                btn.text = options.start + i + 1;
                btn.setActive(options.start + i === options.selected);
                if (btn.isHidden()) {
                    btn.show();
                }
            }
            // update visible state of dots buttons
            if (!!options.button.dotsLeft) {
                this._dotsBtnLeft.show();
            }
            else {
                this._dotsBtnLeft.hide();
            }
            if (!!options.button.dotsRight) {
                this._dotsBtnRight.show();
            }
            else {
                this._dotsBtnRight.hide();
            }
        };
        DPaginationDynamicButtons.prototype.getType = function () {
            return "DPaginationDynamicButtons";
        };
        return DPaginationDynamicButtons;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationNavigationButton = /** @class */ (function (_super) {
        __extends(DPaginationNavigationButton, _super);
        function DPaginationNavigationButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationNavigationButton.prototype.getType = function () {
            return "DPaginationNavigationButton";
        };
        return DPaginationNavigationButton;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPagination = /** @class */ (function (_super) {
        __extends(DPagination, _super);
        function DPagination() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPagination.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.DEFAULT_SELECTED = 0; // set default selected index page is page 0
            // get total pages
            this._total = options.total;
            // get selected page
            this._selected = options.selected ? options.selected : this.DEFAULT_SELECTED;
            // get button options
            this._buttonOptions = {
                first: !!(options.button && options.button.first),
                last: !!(options.button && options.button.last),
                width: options.button && options.button.width
            };
            this.initButtons(this.getButtonWidth());
            this.listenButtonClicked();
            this.on("resize", function () {
                _this._numberPageButtonVisible = _this.toNumberVisible();
                _this.update();
            });
        };
        Object.defineProperty(DPagination.prototype, "selected", {
            /**
             * Get selected page.
             *
             * @returns index of selected page.
             */
            get: function () {
                return this._selected;
            },
            /**
             * Set selected page.
             *
             * @param selected page's index want to select.
             */
            set: function (selected) {
                if (selected < 0 || selected >= this._total || !Number.isInteger(selected)) {
                    selected = this.DEFAULT_SELECTED;
                }
                this._selected = selected;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "total", {
            /**
             * Get total pages.
             *
             * @returns number of total pages.
             */
            get: function () {
                return this._total;
            },
            /**
             * Set total page.
             *
             * @param total number of page want to present in pagination.
             */
            set: function (total) {
                if (total >= 0 && Number.isInteger(total)) {
                    this._total = total;
                    this._numberPageButtonVisible = this.toNumberVisible();
                    this.selected = this._selected;
                    this._lastPageBtn.text = this._total;
                    this.update();
                }
            },
            enumerable: true,
            configurable: true
        });
        DPagination.prototype.initButtons = function (width) {
            this._previousBtn = new DPaginationNavigationButton({
                width: width,
                image: {
                    source: DThemes.getInstance().getAtlas().mappings.pagination_navigation_button_previous
                }
            });
            this._nextBtn = new DPaginationNavigationButton({
                width: width,
                image: {
                    source: DThemes.getInstance().getAtlas().mappings.pagination_navigation_button_next
                }
            });
            this._goFirstBtn = new DPaginationNavigationButton({
                width: width,
                image: {
                    source: DThemes.getInstance().getAtlas().mappings.pagination_navigation_button_go_first
                },
                visible: this._buttonOptions.first
            });
            this._goLastBtn = new DPaginationNavigationButton({
                width: width,
                image: {
                    source: DThemes.getInstance().getAtlas().mappings.pagination_navigation_button_go_last
                },
                visible: this._buttonOptions.last
            });
            this._dynamicPageBtns = new DPaginationDynamicButtons({
                button: {
                    width: width
                }
            });
            this._firstPageBtn = new DButton({
                width: width,
                text: {
                    value: 1
                }
            });
            this._lastPageBtn = new DButton({
                width: width,
                text: {
                    value: this._total
                }
            });
            this.addChild(this._goFirstBtn);
            this.addChild(this._previousBtn);
            this.addChild(this._firstPageBtn);
            this.addChild(this._dynamicPageBtns);
            this.addChild(this._lastPageBtn);
            this.addChild(this._nextBtn);
            this.addChild(this._goLastBtn);
        };
        DPagination.prototype.listenButtonClicked = function () {
            var _this = this;
            this._firstPageBtn.on("active", function (btn) {
                _this.onClickPageButton(btn);
            });
            this._lastPageBtn.on("active", function (btn) {
                _this.onClickPageButton(btn);
            });
            this._dynamicPageBtns.on("active", function (btn) {
                _this.onClickPageButton(btn);
            });
            this._goFirstBtn.on("active", function (btn) {
                _this.selected = _this.DEFAULT_SELECTED;
            });
            this._goLastBtn.on("active", function (btn) {
                _this.selected = _this._total - 1;
            });
            this._nextBtn.on("active", function (btn) {
                if (_this.selected !== _this._total + 1) {
                    _this.selected = _this._selected + 1;
                }
            });
            this._previousBtn.on("active", function (btn) {
                if (_this._selected !== 0) {
                    _this.selected = _this._selected - 1;
                }
            });
        };
        DPagination.prototype.update = function () {
            var startDynamic;
            var endDynamic;
            var dotsLeft;
            var dotsRight;
            var numberButtonsInLeft = 0;
            var numberButtonsInRight = 0;
            this.updateStaticButtons();
            // Number displayed buttons from first button to selected button when select center button of all buttons.
            // Not including selected button.
            var numberButtonsFirstToCenter = Math.ceil((this._numberPageButtonVisible - 1) * 0.5);
            var numberButtonsCenterToEnd = Math.floor((this._numberPageButtonVisible - 1) * 0.5);
            if (this._selected < numberButtonsFirstToCenter) {
                numberButtonsInLeft = this._selected;
                numberButtonsInRight = this._numberPageButtonVisible - numberButtonsInLeft - 1;
            }
            else if (this._selected + numberButtonsCenterToEnd > this._total - 1) {
                numberButtonsInRight = (this._total - 1) - this.selected;
                numberButtonsInLeft = this._numberPageButtonVisible - numberButtonsInRight - 1;
            }
            else {
                numberButtonsInLeft = numberButtonsFirstToCenter;
                numberButtonsInRight = numberButtonsCenterToEnd;
            }
            if (this._selected <= numberButtonsInLeft) {
                startDynamic = 1;
                dotsLeft = false;
            }
            else {
                startDynamic = this._selected - numberButtonsInLeft + 2;
                dotsLeft = true;
            }
            if (this._selected + numberButtonsInRight >= this._total - 1) {
                endDynamic = this._total - 2;
                dotsRight = false;
            }
            else {
                endDynamic = this._selected + numberButtonsInRight - 2;
                dotsRight = true;
            }
            this._dynamicPageBtns.update({
                start: startDynamic,
                end: endDynamic,
                selected: this._selected,
                button: {
                    width: this.getButtonWidth(),
                    dotsLeft: dotsLeft,
                    dotsRight: dotsRight
                }
            });
        };
        DPagination.prototype.updateStaticButtons = function () {
            if (this._total > 0) {
                this._firstPageBtn.show();
            }
            else {
                this._firstPageBtn.hide();
            }
            if (this._total > 1) {
                this._lastPageBtn.show();
            }
            else {
                this._lastPageBtn.hide();
            }
            var isFirst = this._selected === this.DEFAULT_SELECTED;
            var isLast = this._selected === this._total - 1 || this._total === 0;
            this._firstPageBtn.setActive(isFirst);
            this._lastPageBtn.setActive(isLast);
            this._goFirstBtn.setDisabled(isFirst);
            this._previousBtn.setDisabled(isFirst);
            this._nextBtn.setDisabled(isLast);
            this._goLastBtn.setDisabled(isLast);
        };
        DPagination.prototype.getButtonWidth = function () {
            return this._buttonOptions.width ? this._buttonOptions.width : this.theme.getButtonWidth();
        };
        DPagination.prototype.toNumberVisible = function () {
            var numberNavigationBtn = 2; // 2 buttons always displayed are "next" and "previous" button
            if (this._buttonOptions.first) {
                numberNavigationBtn++;
            }
            if (this._buttonOptions.last) {
                numberNavigationBtn++;
            }
            var widthOfNavigationBtns = numberNavigationBtn * (this.getButtonWidth() + this._margin.horizontal * 2);
            var widthOfPageBtns = this.width - widthOfNavigationBtns;
            var numberVisible = Math.floor(widthOfPageBtns / (this.getButtonWidth() + this._margin.horizontal * 2));
            /* set numberVisible is 5, if it less than 5
                 If total pages less than numberVisible, set numberVisible equal total pages
            **/
            return Math.min(this._total, Math.max(numberVisible, 5));
        };
        DPagination.prototype.onClickPageButton = function (btn) {
            var btnIndex = Number(btn.text) - 1;
            if (this._selected !== btnIndex) {
                this._selected = btnIndex;
                this.update();
            }
        };
        DPagination.prototype.getType = function () {
            return "DPagination";
        };
        return DPagination;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeRange = /** @class */ (function (_super) {
        __extends(DPickerDatetimeRange, _super);
        function DPickerDatetimeRange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DPickerDatetimeRange;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeRange = /** @class */ (function (_super) {
        __extends(DPickerTimeRange, _super);
        function DPickerTimeRange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DPickerTimeRange;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSelectMultiple = /** @class */ (function (_super) {
        __extends(DSelectMultiple, _super);
        function DSelectMultiple(options) {
            return _super.call(this, options) || this;
        }
        DSelectMultiple.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._onSelectedBound = function (value, child) {
                if (child instanceof DMenuItemCheck) {
                    var oldValues = _this._values;
                    var newValues = [];
                    var newItems = [];
                    var menu = _this.menu;
                    if (child.isActive()) {
                        _this.updateMenuItems(menu, oldValues, value, undefined, newValues, newItems);
                    }
                    else {
                        _this.updateMenuItems(menu, oldValues, undefined, value, newValues, newItems);
                    }
                    _this._values = newValues;
                    _this.onSelected(newValues, oldValues, newItems, true);
                }
                else {
                    _this.emit("menuselect", value, child, _this);
                }
            };
            this._onClosedBound = function () {
                _this.onClosed();
            };
            // Default value
            this._values = [];
            if (options && options.values !== undefined) {
                this.values = options.values;
            }
        };
        DSelectMultiple.prototype.onSelected = function (newValues, oldValues, items, emit) {
            // Chante texts
            this.text = items;
            // Event
            if (emit) {
                this.emit("change", newValues, oldValues, items, this);
            }
        };
        DSelectMultiple.prototype.onClosed = function () {
            var menu = this.menu;
            menu.off("select", this._onSelectedBound);
            menu.off("close", this._onClosedBound);
        };
        DSelectMultiple.prototype.start = function () {
            var menu = this.menu;
            menu.on("select", this._onSelectedBound);
            menu.on("close", this._onClosedBound);
            this.updateMenuItems(menu, this._values);
            _super.prototype.start.call(this);
        };
        Object.defineProperty(DSelectMultiple.prototype, "values", {
            /**
             * Returns a selected value or null.
             */
            get: function () {
                return this._values;
            },
            /**
             * Sets to the specified value.
             */
            set: function (values) {
                var oldValues = this._values;
                if (!this.isSameValues(values, oldValues)) {
                    var newValues = [];
                    var newItems = [];
                    this.updateMenuItems(this.menu, values, undefined, undefined, newValues, newItems);
                    this._values = newValues;
                    this.onSelected(newValues, oldValues, newItems, false);
                }
            },
            enumerable: true,
            configurable: true
        });
        DSelectMultiple.prototype.isSameValues = function (a, b) {
            if (a.length === b.length) {
                for (var i = 0, imax = a.length; i < imax; ++i) {
                    if (b.indexOf(a[i]) < 0) {
                        return false;
                    }
                }
            }
            return false;
        };
        DSelectMultiple.prototype.updateMenuItems = function (menu, oldValues, addedValue, removedValue, newValues, newItems) {
            var children = menu.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemMenu) {
                    this.updateMenuItems(child.menu, oldValues, addedValue, removedValue, newValues, newItems);
                }
                else if (child instanceof DMenuItemCheck) {
                    var childValue = child.value;
                    if (removedValue !== undefined && removedValue === childValue) {
                        child.setActive(false);
                    }
                    else if ((addedValue !== undefined && child.value === addedValue) || 0 <= oldValues.indexOf(child.value)) {
                        if (newValues) {
                            newValues.push(child.value);
                        }
                        if (newItems) {
                            newItems.push(child);
                        }
                        child.setActive(true);
                    }
                    else {
                        child.setActive(false);
                    }
                }
            }
        };
        DSelectMultiple.prototype.getType = function () {
            return "DSelectMultiple";
        };
        return DSelectMultiple;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSelect = /** @class */ (function (_super) {
        __extends(DSelect, _super);
        function DSelect(options) {
            return _super.call(this, options) || this;
        }
        DSelect.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._onSelectedBound = function (value, child) {
                _this.onSelected(value, child, true);
            };
            this._onClosedBound = function () {
                _this.onClosed();
            };
            // Default value
            this._value = null;
            if (options && options.value !== undefined) {
                this.value = options.value;
            }
        };
        DSelect.prototype.onSelected = function (newValue, item, emit) {
            if (this._value !== newValue) {
                // Value
                var oldValue = this._value;
                this._value = newValue;
                // Text
                this.text = item;
                // Event
                if (emit) {
                    this.emit("change", newValue, oldValue, item, this);
                }
            }
        };
        DSelect.prototype.onClosed = function () {
            var menu = this.menu;
            menu.off("select", this._onSelectedBound);
            menu.off("close", this._onClosedBound);
        };
        DSelect.prototype.start = function () {
            var menu = this.menu;
            menu.on("select", this._onSelectedBound);
            menu.on("close", this._onClosedBound);
            _super.prototype.start.call(this);
        };
        DSelect.prototype.findMenuItem = function (menu, value) {
            var children = menu.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemMenu) {
                    var result = this.findMenuItem(child.menu, value);
                    if (result != null) {
                        return result;
                    }
                }
                else if (child instanceof DMenuItem) {
                    if (child.value === value) {
                        return child;
                    }
                }
            }
            return null;
        };
        Object.defineProperty(DSelect.prototype, "value", {
            /**
             * Returns a selected value or null.
             */
            get: function () {
                return this._value;
            },
            /**
             * Sets to the specified value.
             */
            set: function (value) {
                var item = this.findMenuItem(this.menu, value);
                if (item != null) {
                    this.onSelected(value, item, false);
                }
                else {
                    this.onSelected(null, null, false);
                }
            },
            enumerable: true,
            configurable: true
        });
        DSelect.prototype.getType = function () {
            return "DSelect";
        };
        return DSelect;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DShadowImpl = /** @class */ (function (_super) {
        __extends(DShadowImpl, _super);
        function DShadowImpl(texture, width, height, offsetX, offsetY) {
            var _this = _super.call(this, texture, width, height, width, height) || this;
            _this._offsetX = offsetX;
            _this._offsetY = offsetY;
            _this._shiftX = width * 0.5;
            _this._shiftY = height * 0.5;
            _this.interactive = false;
            _this.interactiveChildren = false;
            texture.on("update", function () {
                _this.onTextureUpdate();
            });
            return _this;
        }
        DShadowImpl.prototype.onTextureUpdate = function () {
            this.emit("update", this);
        };
        DShadowImpl.prototype.onReflow = function (base, width, height) {
            var sx = this._shiftX;
            var sy = this._shiftY;
            this.x = -sx + this._offsetX;
            this.y = -sy + this._offsetY;
            this.width = sx + width + sx;
            this.height = sy + height + sy;
        };
        return DShadowImpl;
    }(pixi_js.NineSlicePlane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderLabel = /** @class */ (function (_super) {
        __extends(DSliderLabel, _super);
        function DSliderLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderLabel.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.UNFOCUSABLE, true);
            this._value = options && options.value || 0;
        };
        Object.defineProperty(DSliderLabel.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        DSliderLabel.prototype.getType = function () {
            return "DSliderLabel";
        };
        return DSliderLabel;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderThumb = /** @class */ (function (_super) {
        __extends(DSliderThumb, _super);
        function DSliderThumb() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderThumb.prototype.getType = function () {
            return "DSliderThumb";
        };
        return DSliderThumb;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderValue = /** @class */ (function (_super) {
        __extends(DSliderValue, _super);
        function DSliderValue() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderValue.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.setState(DBaseState.UNFOCUSABLE, true);
            this._value = options && options.value || 0;
            this._rounder = this.toRounder(options);
        };
        DSliderValue.prototype.toRounder = function (options) {
            var rounder = options && options.rounder;
            if (rounder) {
                return rounder;
            }
            var precision = (options && options.precision) ? options.precision : this.theme.getPrecision();
            return function (value) {
                var base = Math.pow(10, precision);
                return Math.round(value * base) / base;
            };
        };
        Object.defineProperty(DSliderValue.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DSliderValue.prototype, "rounder", {
            get: function () {
                return this._rounder;
            },
            enumerable: true,
            configurable: true
        });
        DSliderValue.prototype.getType = function () {
            return "DSliderValue";
        };
        return DSliderValue;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSlider = /** @class */ (function (_super) {
        __extends(DSlider, _super);
        function DSlider() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSlider.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._ratioValue = 0;
            this._track = this.newTrack(options);
            this.addChild(this._track);
            this._trackSelected = this.newTrackSelected(options);
            this._trackSelected.setActive(true);
            this.addChild(this._trackSelected);
            this._thumb = this.newThumb(options);
            this.addChild(this._thumb);
            this._min = this.newLabelMin(options);
            this.addChild(this._min);
            this._max = this.newLabelMax(options);
            this.addChild(this._max);
            this._value = this.newValue(options);
            this.addChild(this._value);
            // Event listeners
            this._track.on(UtilPointerEvent.down, function (e) {
                _this._value.visible =  !_this.isDisabled();
                _this.onTrackDown(e.data.global);
            });
            this._trackSelected.on(UtilPointerEvent.down, function (e) {
                _this._value.visible =  !_this.isDisabled();
                _this.onTrackSelectedDown(e.data.global);
            });
            this._onTrackUpBound = function (e) {
                _this.onTrackUpBound(e);
                _this._value.visible = false;
            };
            this._onTrackSelectedUpBound = function (e) {
                _this.onTrackSelectedUpBound(e);
                _this._value.visible = false;
            };
            this._thumb.on(UtilPointerEvent.down, function (e) {
                _this._value.visible = true;
                _this.onThumbDown(e);
            });
            this._onThumbMoveBound = function (e) {
                _this.onThumbMove(e);
            };
            this._onThumbUpBound = function (e) {
                _this.onThumbUp(e);
                _this._value.visible = false;
            };
            //
            this.onValuesChanged();
        };
        DSlider.prototype.newThumb = function (options) {
            return new DSliderThumb(options && options.thumb);
        };
        DSlider.prototype.newValue = function (options) {
            return new DSliderValue(this.toValueOptions(options && options.value));
        };
        DSlider.prototype.toValueOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 0;
            }
            var text = options.text = options.text || {};
            if (text.value == null) {
                text.value = options.value;
            }
            if (options.visible == null) {
                options.visible = false;
            }
            return options;
        };
        DSlider.prototype.newLabelMin = function (options) {
            return new DSliderLabel(this.toLabelMinOptions(options && options.min));
        };
        DSlider.prototype.toLabelMinOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 0;
            }
            var text = options.text = options.text || {};
            if (text.value == null) {
                text.value = "" + options.value;
            }
            return options;
        };
        DSlider.prototype.newLabelMax = function (options) {
            return new DSliderLabel(this.toLabelMaxOptions(options && options.max));
        };
        DSlider.prototype.toLabelMaxOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 1;
            }
            var text = options.text = options.text || {};
            if (text.value == null) {
                text.value = "" + options.value;
            }
            return options;
        };
        DSlider.prototype.getValueMargin = function () {
            return 14;
        };
        DSlider.prototype.onTrackDown = function (global) {
            if (this.isDisabled()) {
                return;
            }
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                interactionManager.on(UtilPointerEvent.up, this._onTrackUpBound);
            }
            this.onPick(global);
        };
        DSlider.prototype.onTrackSelectedDown = function (global) {
            if (this.isDisabled()) {
                return;
            }
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                interactionManager.on(UtilPointerEvent.up, this._onTrackSelectedUpBound);
            }
            this.onPick(global);
        };
        DSlider.prototype.onTrackUpBound = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                interactionManager.off(UtilPointerEvent.up, this._onTrackUpBound);
            }
        };
        DSlider.prototype.onTrackSelectedUpBound = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                interactionManager.off(UtilPointerEvent.up, this._onTrackSelectedUpBound);
            }
        };
        DSlider.prototype.onThumbMove = function (e) {
            if (this.isDisabled()) {
                return;
            }
            this.onPick(e.data.global);
        };
        DSlider.prototype.onThumbDown = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                interactionManager.on(UtilPointerEvent.move, this._onThumbMoveBound);
                interactionManager.on(UtilPointerEvent.up, this._onThumbUpBound);
            }
        };
        DSlider.prototype.onThumbUp = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                interactionManager.off(UtilPointerEvent.move, this._onThumbMoveBound);
                interactionManager.off(UtilPointerEvent.up, this._onThumbUpBound);
            }
        };
        DSlider.prototype.updateValue = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value;
            value.value = value.rounder(min + this._ratioValue * (max - min));
            value.text = value.value;
        };
        DSlider.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.onValuesChanged();
        };
        Object.defineProperty(DSlider.prototype, "value", {
            /**
             * Gets current value of slider
             */
            get: function () {
                return this._value.value;
            },
            /**
             * Sets value for slider
             * - New value will be applied
             * - UI components will be changed arcording to new value
             */
            set: function (value) {
                value = Math.max(this._min.value, Math.min(this._max.value, value));
                // Adjust if value is new
                if (this._value.value !== value) {
                    this._value.value = value;
                    this.onValuesChanged();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DSlider.prototype, "min", {
            /**
             * Gets min value of slider
             */
            get: function () {
                return this._min.value;
            },
            /**
             * Sets min value for slider
             * - New min value will be applied
             * - UI components will be changed arcording to new value
             */
            set: function (newMin) {
                var min = this._min;
                newMin = Math.min(this._max.value, newMin);
                if (min.value !== newMin) {
                    var value = this._value;
                    min.text = min.value = newMin;
                    value.value = Math.max(newMin, value.value);
                    this.onValuesChanged();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DSlider.prototype, "max", {
            /**
             * Gets max value of slider
             */
            get: function () {
                return this._max.value;
            },
            /**
             * Sets max value for slider
             * - New max value will be applied
             * - UI components will be changed arcording to new value
             */
            set: function (newMax) {
                var max = this._max;
                newMax = Math.max(this._min.value, newMax);
                if (max.value !== newMax) {
                    var value = this._value;
                    max.text = max.value = newMax;
                    value.value = Math.min(newMax, value.value);
                    this.onValuesChanged();
                }
            },
            enumerable: true,
            configurable: true
        });
        DSlider.prototype.getType = function () {
            return "DSlider";
        };
        return DSlider;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrack = /** @class */ (function (_super) {
        __extends(DSliderTrack, _super);
        function DSliderTrack() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrack.prototype.getType = function () {
            return "DSliderTrack";
        };
        return DSliderTrack;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrackHorizontal = /** @class */ (function (_super) {
        __extends(DSliderTrackHorizontal, _super);
        function DSliderTrackHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrackHorizontal.prototype.getType = function () {
            return "DSliderTrackHorizontal";
        };
        return DSliderTrackHorizontal;
    }(DSliderTrack));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderHorizontal = /** @class */ (function (_super) {
        __extends(DSliderHorizontal, _super);
        function DSliderHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderHorizontal.prototype.newTrack = function (options) {
            return new DSliderTrackHorizontal(options && options.track);
        };
        DSliderHorizontal.prototype.newTrackSelected = function (options) {
            return new DSliderTrackHorizontal(options && options.track);
        };
        DSliderHorizontal.prototype.toValueOptions = function (options) {
            var _this = this;
            options = _super.prototype.toValueOptions.call(this, options);
            if (options.y == null) {
                options.y = function (p, s) { return p * 0.5 - s - _this.getValueMargin(); };
            }
            return options;
        };
        DSliderHorizontal.prototype.toLabelMinOptions = function (options) {
            options = _super.prototype.toLabelMinOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s * 0.5; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s; };
            }
            return options;
        };
        DSliderHorizontal.prototype.toLabelMaxOptions = function (options) {
            options = _super.prototype.toLabelMaxOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return p - s * 0.5; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s; };
            }
            return options;
        };
        DSliderHorizontal.prototype.onPick = function (global) {
            var point = new pixi_js.Point(0, 0);
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(this._track.width, point.x));
            this._ratioValue = x / this._track.width;
            this.moveThumbPosition(x);
        };
        DSliderHorizontal.prototype.onValuesChanged = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value.value;
            this._ratioValue = (value - min) / (max - min);
            var x = this._ratioValue * this._track.width;
            this.moveThumbPosition(x);
        };
        DSliderHorizontal.prototype.moveThumbPosition = function (x) {
            var thumb = this._thumb;
            thumb.x = x - thumb.width * 0.5;
            this._trackSelected.width = x;
            var value = this._value;
            value.x = x - value.width * 0.5;
            this.updateValue();
        };
        DSliderHorizontal.prototype.toThumbCoordinate = function (x) {
            return x - this._thumb.width * 0.5;
        };
        DSliderHorizontal.prototype.getType = function () {
            return "DSliderHorizontal";
        };
        return DSliderHorizontal;
    }(DSlider));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrackVertical = /** @class */ (function (_super) {
        __extends(DSliderTrackVertical, _super);
        function DSliderTrackVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrackVertical.prototype.getType = function () {
            return "DSliderTrackVertical";
        };
        return DSliderTrackVertical;
    }(DSliderTrack));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderVertical = /** @class */ (function (_super) {
        __extends(DSliderVertical, _super);
        function DSliderVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderVertical.prototype.newTrack = function (options) {
            return new DSliderTrackVertical(options && options.track);
        };
        DSliderVertical.prototype.newTrackSelected = function (options) {
            return new DSliderTrackVertical(options && options.track);
        };
        DSliderVertical.prototype.toLabelMinOptions = function (options) {
            options = _super.prototype.toLabelMinOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return p - s * 0.5; };
            }
            var text = options.text = options.text || {};
            var textAlign = text.align = text.align || {};
            if (textAlign.horizontal == null) {
                textAlign.horizontal = DAlignHorizontal.RIGHT;
            }
            return options;
        };
        DSliderVertical.prototype.toLabelMaxOptions = function (options) {
            options = _super.prototype.toLabelMaxOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s * 0.5; };
            }
            var text = options.text = options.text || {};
            var textAlign = text.align = text.align || {};
            if (textAlign.horizontal == null) {
                textAlign.horizontal = DAlignHorizontal.RIGHT;
            }
            return options;
        };
        DSliderVertical.prototype.onPick = function (global) {
            var point = new pixi_js.Point(0, 0);
            this.toLocal(global, undefined, point);
            var height = this.height;
            var y = Math.max(0, Math.min(height, point.y));
            this._ratioValue = (height - y) / height;
            this.moveThumbPosition(y);
        };
        DSliderVertical.prototype.onValuesChanged = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value.value;
            this._ratioValue = (value - min) / (max - min);
            var y = this.height * (1 - this._ratioValue);
            this.moveThumbPosition(y);
        };
        DSliderVertical.prototype.moveThumbPosition = function (y) {
            var thumb = this._thumb;
            thumb.y = y - thumb.height * 0.5;
            var trackSelected = this._trackSelected;
            trackSelected.y = y;
            trackSelected.height = this.height - y;
            var value = this._value;
            value.y = y - value.height - this.getValueMargin();
            this.updateValue();
        };
        DSliderVertical.prototype.getType = function () {
            return "DSliderVertical";
        };
        return DSliderVertical;
    }(DSlider));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCells = /** @class */ (function () {
        function DTableBodyCells() {
        }
        DTableBodyCells.setReadOnly = function (target, row, columnIndex, columnData) {
            target.setReadOnly(this.toReadOnly(row, columnIndex, columnData));
        };
        DTableBodyCells.setRenderable = function (target, row, columnIndex, columnData) {
            var renderable = this.toRenderable(row, columnIndex, columnData);
            target.renderable = renderable;
            target.setDisabled(!renderable);
        };
        DTableBodyCells.toReadOnly = function (row, columnIndex, columnData) {
            var enable = columnData.editing.enable;
            if (enable === true) {
                return false;
            }
            else if (enable === false) {
                return true;
            }
            else {
                return !enable(row, columnIndex);
            }
        };
        DTableBodyCells.toRenderable = function (row, columnIndex, columnData) {
            var renderable = columnData.renderable;
            if (renderable === true) {
                return true;
            }
            else if (renderable === false) {
                return false;
            }
            else {
                return renderable(row, columnIndex);
            }
        };
        return DTableBodyCells;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectDialog = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectDialog, _super);
        function DTableBodyCellSelectDialog(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellSelectDialog.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var column = options.column;
            this._rowIndex = 0;
            this._columnIndex = column.index;
            this._columnData = column.data;
            this._isSyncEnabled = this.toSync(this.theme, options);
            var selecting = column.data.selecting;
            var dialog = selecting.dialog;
            if (dialog != null) {
                this.on("active", function () {
                    selecting.setter(dialog, _this.text);
                    dialog.open().then(function () {
                        var newValue = selecting.getter(dialog);
                        if (_this._isSyncEnabled) {
                            var oldValue = _this.text;
                            if (newValue !== oldValue) {
                                _this.text = newValue;
                                _this.onCellChange(newValue, oldValue);
                            }
                        }
                        else {
                            _this.onCellChange(newValue, null);
                        }
                    });
                });
            }
        };
        DTableBodyCellSelectDialog.prototype.onCellChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._columnData.setter(row, columnIndex, newValue);
                this.emit("cellchange", newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellSelectDialog.prototype.toSync = function (theme, options) {
            return (options && options.sync != null ? options.sync : theme.isSyncEnabled());
        };
        DTableBodyCellSelectDialog.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "value", {
            get: function () {
                return this.text;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: true,
            configurable: true
        });
        DTableBodyCellSelectDialog.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (forcibly) {
                this._textValue = value;
                this._textValueComputed = value;
                this.onTextChange();
                this.createOrUpdateText();
            }
            else {
                this.text = value;
            }
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellSelectDialog.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellSelectDialog.prototype.getType = function () {
            return "DTableBodyCellSelectDialog";
        };
        return DTableBodyCellSelectDialog;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionDialog = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionDialog, _super);
        function DTableBodyCellActionDialog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellActionDialog.prototype.getType = function () {
            return "DTableBodyCellActionDialog";
        };
        return DTableBodyCellActionDialog;
    }(DTableBodyCellSelectDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionMenu = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionMenu, _super);
        function DTableBodyCellActionMenu(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellActionMenu.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var column = options.column;
            this._rowIndex = 0;
            this._columnIndex = column.index;
            this._columnData = column.data;
            this._onSelectedBound = function (selected) {
                _this.onSelected(selected);
            };
            this._onClosedBound = function () {
                _this.onClosed();
            };
        };
        DTableBodyCellActionMenu.prototype.onSelected = function (selected) {
            var columnData = this._columnData;
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                columnData.setter(row, columnIndex, selected);
                this.emit("cellchange", selected, null, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellActionMenu.prototype.onClosed = function () {
            var menu = this.menu;
            menu.off("select", this._onSelectedBound);
            menu.off("close", this._onClosedBound);
        };
        DTableBodyCellActionMenu.prototype.start = function () {
            var menu = this.menu;
            menu.on("select", this._onSelectedBound);
            menu.on("close", this._onClosedBound);
            _super.prototype.start.call(this);
        };
        DTableBodyCellActionMenu.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellActionMenu.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellActionMenu.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellActionMenu.prototype.getType = function () {
            return "DTableBodyCellActionMenu";
        };
        return DTableBodyCellActionMenu;
    }(DDropdown));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectPromise = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectPromise, _super);
        function DTableBodyCellSelectPromise(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellSelectPromise.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var column = options.column;
            this._rowIndex = 0;
            this._columnIndex = column.index;
            this._columnData = column.data;
            this._isSyncEnabled = this.toSync(this.theme, options);
            var selecting = column.data.selecting;
            var promise = selecting.promise;
            if (promise != null) {
                this.on("active", function () {
                    promise().then(function (newValue) {
                        if (_this._isSyncEnabled) {
                            var oldValue = _this.text;
                            if (newValue !== oldValue) {
                                _this.text = newValue;
                                _this.onCellChange(newValue, oldValue);
                            }
                        }
                        else {
                            _this.onCellChange(newValue, null);
                        }
                    });
                });
            }
        };
        DTableBodyCellSelectPromise.prototype.onCellChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._columnData.setter(row, columnIndex, newValue);
                this.emit("cellchange", newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellSelectPromise.prototype.toSync = function (theme, options) {
            return (options && options.sync != null ? options.sync : theme.isSyncEnabled());
        };
        DTableBodyCellSelectPromise.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: true,
            configurable: true
        });
        DTableBodyCellSelectPromise.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (forcibly) {
                this._textValue = value;
                this._textValueComputed = value;
                this.onTextChange();
                this.createOrUpdateText();
            }
            else {
                this.text = value;
            }
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellSelectPromise.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellSelectPromise.prototype.getType = function () {
            return "DTableBodyCellSelectPromise";
        };
        return DTableBodyCellSelectPromise;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionPromise = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionPromise, _super);
        function DTableBodyCellActionPromise() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellActionPromise.prototype.getType = function () {
            return "DTableBodyCellActionPromise";
        };
        return DTableBodyCellActionPromise;
    }(DTableBodyCellSelectPromise));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellText = /** @class */ (function (_super) {
        __extends(DTableBodyCellText, _super);
        function DTableBodyCellText(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellText.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._rowIndex = 0;
            this._columnIndex = options.column.index;
            this._columnData = options.column.data;
        };
        DTableBodyCellText.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellText.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellText.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellText.prototype.getType = function () {
            return "DTableBodyCellText";
        };
        return DTableBodyCellText;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellButton = /** @class */ (function (_super) {
        __extends(DTableBodyCellButton, _super);
        function DTableBodyCellButton(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellButton.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.buttonMode = true;
            this.initOnClick(options);
        };
        DTableBodyCellButton.prototype.initOnClick = function (options) {
            var _this = this;
            UtilPointerEvent.onClick(this, function (e) {
                if (_this.isActionable()) {
                    _this.onActive(e);
                }
            });
        };
        DTableBodyCellButton.prototype.onActive = function (e) {
            this.emit("active", this);
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._columnData.setter(row, columnIndex, null);
                this.emit("cellchange", null, null, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellButton.prototype.onActivateKeyDown = function (e) {
            if (this.isActionable()) {
                this.setPressed(true);
            }
        };
        DTableBodyCellButton.prototype.onActivateKeyUp = function (e) {
            if (this.isActionable()) {
                if (this.isPressed()) {
                    this.onActive(e);
                }
                this.setPressed(false);
            }
        };
        DTableBodyCellButton.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTableBodyCellButton.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DTableBodyCellButton.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            this.buttonMode = DBaseStates.isActionable(newState);
        };
        DTableBodyCellButton.prototype.getType = function () {
            return "DTableBodyCellButton";
        };
        return DTableBodyCellButton;
    }(DTableBodyCellText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableColumnType;
    (function (DTableColumnType) {
        DTableColumnType[DTableColumnType["INDEX"] = 0] = "INDEX";
        DTableColumnType[DTableColumnType["TEXT"] = 1] = "TEXT";
        DTableColumnType[DTableColumnType["INTEGER"] = 2] = "INTEGER";
        DTableColumnType[DTableColumnType["REAL"] = 3] = "REAL";
        DTableColumnType[DTableColumnType["CHECK"] = 4] = "CHECK";
        DTableColumnType[DTableColumnType["CHECK_SINGLE"] = 5] = "CHECK_SINGLE";
        DTableColumnType[DTableColumnType["COLOR"] = 6] = "COLOR";
        DTableColumnType[DTableColumnType["BUTTON"] = 7] = "BUTTON";
        DTableColumnType[DTableColumnType["SELECT"] = 8] = "SELECT";
        DTableColumnType[DTableColumnType["DATE"] = 9] = "DATE";
        DTableColumnType[DTableColumnType["DATETIME"] = 10] = "DATETIME";
        DTableColumnType[DTableColumnType["TIME"] = 11] = "TIME";
        DTableColumnType[DTableColumnType["ACTION"] = 12] = "ACTION";
        DTableColumnType[DTableColumnType["LINK"] = 13] = "LINK";
        DTableColumnType[DTableColumnType["TREE"] = 14] = "TREE";
    })(DTableColumnType || (DTableColumnType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellCheck = /** @class */ (function (_super) {
        __extends(DTableBodyCellCheck, _super);
        function DTableBodyCellCheck(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellCheck.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._rowIndex = 0;
            this._columnIndex = options.column.index;
            this._columnData = options.column.data;
            this.on("active", function () {
                _this.onChange(true);
            });
            this.on("inactive", function () {
                _this.onChange(false);
            });
        };
        DTableBodyCellCheck.prototype.onChangeSingle = function (rowIndex, columnIndex, columnData) {
            var _this = this;
            var tableBodyRow = this.parent;
            if (tableBodyRow) {
                var tableBody = tableBodyRow.parent;
                if (tableBody) {
                    var isChanged_1 = false;
                    var getter_1 = columnData.getter;
                    var setter_1 = columnData.setter;
                    var data = tableBody.data;
                    data.each(function (row, index) {
                        if (rowIndex !== index && getter_1(row, columnIndex)) {
                            setter_1(row, columnIndex, false);
                            isChanged_1 = true;
                            _this.emit("cellchange", false, true, row, index, columnIndex, _this);
                            return false;
                        }
                        return true;
                    });
                    if (isChanged_1) {
                        tableBody.update(true);
                    }
                }
            }
        };
        DTableBodyCellCheck.prototype.onChange = function (newValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var columnData = this._columnData;
                columnData.setter(row, columnIndex, newValue);
                this.emit("cellchange", newValue, !newValue, row, rowIndex, columnIndex, this);
                if (newValue && columnData.type === DTableColumnType.CHECK_SINGLE) {
                    this.onChangeSingle(rowIndex, columnIndex, columnData);
                }
            }
        };
        DTableBodyCellCheck.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellCheck.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.setActive(!!value);
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellCheck.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellCheck.prototype.getType = function () {
            return "DTableBodyCellCheck";
        };
        return DTableBodyCellCheck;
    }(DButtonCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var clone = function (value) {
        return {
            color: value.color,
            alpha: value.alpha
        };
    };
    var hasColor = function (value) {
        return ("color" in value);
    };
    var hasAlpha = function (value) {
        return ("alpha" in value);
    };
    var DTableBodyCellColor = /** @class */ (function (_super) {
        __extends(DTableBodyCellColor, _super);
        function DTableBodyCellColor(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellColor.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._rowIndex = 0;
            this._columnIndex = options.column.index;
            this._columnData = options.column.data;
            this.on("change", function (newValue, oldValue) {
                var row = _this._row;
                if (row !== undefined) {
                    var newValueCloned = clone(newValue);
                    var oldValueCloned = clone(oldValue);
                    var rowIndex = _this._rowIndex;
                    var columnIndex = _this._columnIndex;
                    _this._columnData.setter(row, columnIndex, newValueCloned);
                    _this.emit("cellchange", newValueCloned, oldValueCloned, row, rowIndex, columnIndex, _this);
                }
            });
        };
        DTableBodyCellColor.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellColor.prototype.set = function (newValue, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            var value = this._value;
            if (isNumber(newValue)) {
                value.color = newValue;
                value.alpha = 1;
            }
            else if (isString(newValue)) {
                var parsed = Number(newValue);
                if (parsed === parsed) {
                    value.color = parsed;
                }
                else {
                    value.color = 0xffffff;
                }
                value.alpha = 1;
            }
            else if (newValue != null) {
                if (hasColor(newValue)) {
                    value.color = Number(newValue.color);
                }
                else {
                    value.color = 0xffffff;
                }
                if (hasAlpha(newValue)) {
                    value.alpha = Number(newValue.alpha);
                }
                else {
                    value.alpha = 1;
                }
            }
            else {
                value.color = 0xffffff;
                value.alpha = 1;
            }
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellColor.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellColor.prototype.getType = function () {
            return "DTableBodyCellColor";
        };
        return DTableBodyCellColor;
    }(DButtonColor));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellDate = /** @class */ (function (_super) {
        __extends(DTableBodyCellDate, _super);
        function DTableBodyCellDate(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellDate.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._dialogOptions = options.dialog;
            this._rowIndex = 0;
            this._columnIndex = options.column.index;
            this._columnData = options.column.data;
            this.on("active", function () {
                var currentTime = _this._textValueComputed.getTime();
                var dialog = _this.dialog;
                dialog.current = new Date(currentTime);
                dialog.new = new Date(currentTime);
                dialog.page = new Date(currentTime);
                dialog.open().then(function () {
                    var newValue = dialog.new;
                    var oldValue = dialog.current;
                    _this.text = new Date(newValue.getTime());
                    var row = _this._row;
                    if (row !== undefined) {
                        var rowIndex = _this._rowIndex;
                        var columnIndex = _this._columnIndex;
                        _this._columnData.setter(row, columnIndex, newValue);
                        _this.emit("cellchange", newValue, oldValue, row, rowIndex, columnIndex, _this);
                    }
                });
            });
        };
        DTableBodyCellDate.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        Object.defineProperty(DTableBodyCellDate.prototype, "dialog", {
            get: function () {
                var dialog = this._dialog;
                if (dialog == null) {
                    var dialogOptions = this._dialogOptions;
                    if (dialogOptions != null) {
                        dialog = new DDialogDate(this._dialogOptions);
                    }
                    else {
                        dialog = DDialogDates.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: true,
            configurable: true
        });
        DTableBodyCellDate.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this._textValue = value;
                    this._textValueComputed = value;
                    this.onTextChange();
                    this.createOrUpdateText();
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed.getTime() !== value) {
                    textValueComputed.setTime(value);
                    this.onTextChange();
                    this.createOrUpdateText();
                }
            }
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellDate.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellDate.prototype.getType = function () {
            return "DTableBodyCellDate";
        };
        return DTableBodyCellDate;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellDatetime = /** @class */ (function (_super) {
        __extends(DTableBodyCellDatetime, _super);
        function DTableBodyCellDatetime(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellDatetime.prototype.init = function (options) {
            var _this = this;
            this._dialogOptions = options.dialog;
            this._datetimeMask = DPickerDatetimes.toMask(options && options.dialog && options.dialog.picker);
            this._columnIndex = options.column.index;
            this._columnData = options.column.data;
            _super.prototype.init.call(this, options);
            this.on("active", function () {
                var currentTime = _this._textValueComputed.getTime();
                var dialog = _this.dialog;
                dialog.current = new Date(currentTime);
                dialog.new = new Date(currentTime);
                dialog.page = new Date(currentTime);
                dialog.open().then(function () {
                    var newValue = dialog.new;
                    var oldValue = dialog.current;
                    _this.text = new Date(newValue.getTime());
                    var row = _this._row;
                    if (row !== undefined) {
                        var rowIndex = _this._rowIndex;
                        var columnIndex = _this._columnIndex;
                        _this._columnData.setter(row, columnIndex, newValue);
                        _this.emit("cellchange", newValue, oldValue, row, rowIndex, columnIndex, _this);
                    }
                });
            });
        };
        DTableBodyCellDatetime.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellDatetime.prototype.getDatetimeMask = function () {
            return this._datetimeMask;
        };
        Object.defineProperty(DTableBodyCellDatetime.prototype, "dialog", {
            get: function () {
                var dialog = this._dialog;
                if (dialog == null) {
                    var dialogOptions = this._dialogOptions;
                    if (dialogOptions != null) {
                        dialog = new DDialogDatetime(this._dialogOptions);
                    }
                    else {
                        dialog = DDialogDatetimes.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: true,
            configurable: true
        });
        DTableBodyCellDatetime.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this._textValue = value;
                    this._textValueComputed = value;
                    this.onTextChange();
                    this.createOrUpdateText();
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed.getTime() !== value) {
                    textValueComputed.setTime(value);
                    this.onTextChange();
                    this.createOrUpdateText();
                }
            }
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellDatetime.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellDatetime.prototype.getType = function () {
            return "DTableBodyCellDatetime";
        };
        return DTableBodyCellDatetime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellIndex = /** @class */ (function (_super) {
        __extends(DTableBodyCellIndex, _super);
        function DTableBodyCellIndex(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellIndex.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._columnIndex = options.column.index;
            this._columnData = options.column.data;
        };
        DTableBodyCellIndex.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellIndex.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this.text = rowIndex;
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellIndex.prototype.unset = function () {
            // DO NOTHING
        };
        DTableBodyCellIndex.prototype.getType = function () {
            return "DTableBodyCellIndex";
        };
        return DTableBodyCellIndex;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputInteger = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputInteger, _super);
        function DTableBodyCellInputInteger(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellInputInteger.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._rowIndex = 0;
            this._columnIndex = options.column.index;
            this._columnData = options.column.data;
            this.on("change", function (newValue, oldValue) {
                var row = _this._row;
                if (row !== undefined) {
                    var rowIndex = _this._rowIndex;
                    var columnIndex = _this._columnIndex;
                    _this._columnData.setter(row, columnIndex, newValue);
                    _this.emit("cellchange", newValue, oldValue, row, rowIndex, columnIndex, _this);
                }
            });
        };
        DTableBodyCellInputInteger.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellInputInteger.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = Number(value);
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellInputInteger.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellInputInteger.prototype.getType = function () {
            return "DTableBodyCellInputInteger";
        };
        return DTableBodyCellInputInteger;
    }(DInputInteger));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputReal = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputReal, _super);
        function DTableBodyCellInputReal(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellInputReal.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._rowIndex = 0;
            this._columnIndex = options.column.index;
            this._columnData = options.column.data;
            this.on("change", function (newValue, oldValue) {
                var row = _this._row;
                if (row !== undefined) {
                    var rowIndex = _this._rowIndex;
                    var columnIndex = _this._columnIndex;
                    _this._columnData.setter(row, columnIndex, newValue);
                    _this.emit("cellchange", newValue, oldValue, row, rowIndex, columnIndex, _this);
                }
            });
        };
        DTableBodyCellInputReal.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellInputReal.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = Number(value);
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellInputReal.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellInputReal.prototype.getType = function () {
            return "DTableBodyCellInputReal";
        };
        return DTableBodyCellInputReal;
    }(DInputReal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputText = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputText, _super);
        function DTableBodyCellInputText(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellInputText.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._rowIndex = 0;
            this._columnIndex = options.column.index;
            this._columnData = options.column.data;
            this.on("change", function (newValue, oldValue) {
                var row = _this._row;
                if (row !== undefined) {
                    var rowIndex = _this._rowIndex;
                    var columnIndex = _this._columnIndex;
                    _this._columnData.setter(row, columnIndex, newValue);
                    _this.emit("cellchange", newValue, oldValue, row, rowIndex, columnIndex, _this);
                }
            });
        };
        DTableBodyCellInputText.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellInputText.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = String(value);
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellInputText.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellInputText.prototype.getType = function () {
            return "DTableBodyCellInputText";
        };
        return DTableBodyCellInputText;
    }(DInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputTreeInput = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTreeInput, _super);
        function DTableBodyCellInputTreeInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellInputTreeInput.prototype.getType = function () {
            return "DTableBodyCellInputTreeInput";
        };
        return DTableBodyCellInputTreeInput;
    }(DInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputTreeMarker = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTreeMarker, _super);
        function DTableBodyCellInputTreeMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellInputTreeMarker.prototype.getType = function () {
            return "DTableBodyCellInputTreeMarker";
        };
        return DTableBodyCellInputTreeMarker;
    }(DButtonBase));

    /**
     * Cell states.
     */
    var DTableCellState = {
        /**
         * Cells of even rows.
         */
        EVEN: DBaseState.CUSTOM << 0,
        /**
         * Start cells in rows.
         */
        START: DBaseState.CUSTOM << 1,
        /**
         * End cells in rows.
         */
        END: DBaseState.CUSTOM << 2,
        /**
         * Cells of frozen columns.
         */
        FROZEN: DBaseState.CUSTOM << 3,
        /**
         * Cells of a right-most frozen column.
         */
        FROZEN_END: DBaseState.CUSTOM << 4,
        /**
         * Header cells of columns sorted in the ascending order.
         */
        SORTED_ASCENDING: DBaseState.CUSTOM << 5,
        /**
         * Header cells of columns sorted in the descending order.
         */
        SORTED_DESCENDING: DBaseState.CUSTOM << 6,
        /**
         * Cells with a link which is opened in a new window.
         */
        NEW_WINDOW: DBaseState.CUSTOM << 7,
        /**
         * Cells with child cells.
         */
        HAS_CHILDREN: DBaseState.CUSTOM << 8,
        /**
         * Cells opened.
         */
        OPENED: DBaseState.CUSTOM << 9
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputTree = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTree, _super);
        function DTableBodyCellInputTree(options) {
            var _this = _super.call(this, {
                weight: options.weight,
                width: options.width
            }) || this;
            _this._rowIndex = 0;
            _this._columnIndex = options.column.index;
            _this._columnData = options.column.data;
            // Marker
            var marker = new DTableBodyCellInputTreeMarker({
                visible: false,
                on: {
                    active: function () {
                        _this.onMarkerActive();
                    }
                }
            });
            _this._marker = marker;
            _this.addChild(marker);
            // Input
            var input = new DTableBodyCellInputTreeInput({
                weight: 1,
                text: options.text,
                editing: options.editing
            });
            _this._input = input;
            input.on("change", function (newValue, oldValue) {
                var row = _this._row;
                if (row !== undefined) {
                    var rowIndex = _this._rowIndex;
                    var columnIndex = _this._columnIndex;
                    _this._columnData.setter(row, columnIndex, newValue);
                    _this.emit("cellchange", newValue, oldValue, row, rowIndex, columnIndex, _this);
                }
            });
            _this.addChild(input);
            return _this;
        }
        DTableBodyCellInputTree.prototype.onMarkerActive = function () {
            if (this._marker.state & DTableCellState.HAS_CHILDREN) {
                var row = this.parent;
                if (row) {
                    var body = row.parent;
                    if (body) {
                        var data = body.data;
                        if (data && data.toggle) {
                            data.toggle(this._row);
                            this.emit("cellchange", null, null, this._row, this._rowIndex, this._columnIndex, this);
                        }
                    }
                }
            }
        };
        DTableBodyCellInputTree.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellInputTree.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this._input.visible = true;
            this._input.text = String(value);
            var marker = this._marker;
            if (isNumber(supplimental)) {
                var isOpened = !!(supplimental & 0x1);
                var hasChildren = !!(supplimental & 0x2);
                var level = (supplimental >> 2);
                if (hasChildren) {
                    if (isOpened) {
                        marker.setStates(DTableCellState.HAS_CHILDREN | DTableCellState.OPENED, DBaseState.DISABLED);
                    }
                    else {
                        marker.setStates(DTableCellState.HAS_CHILDREN, DBaseState.DISABLED | DTableCellState.OPENED);
                    }
                }
                else {
                    if (isOpened) {
                        marker.setStates(DBaseState.DISABLED | DTableCellState.OPENED, DTableCellState.HAS_CHILDREN);
                    }
                    else {
                        marker.setStates(DBaseState.DISABLED, DTableCellState.HAS_CHILDREN | DTableCellState.OPENED);
                    }
                }
                marker.show();
                marker.width = this.theme.getLevelPadding(level);
            }
            else {
                marker.setStates(DBaseState.DISABLED, DTableCellState.OPENED | DTableCellState.HAS_CHILDREN);
                marker.hide();
            }
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this._input, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellInputTree.prototype.unset = function () {
            this._row = undefined;
            this._input.visible = false;
            this._marker.hide();
        };
        DTableBodyCellInputTree.prototype.getType = function () {
            return "DTableBodyCellInputTree";
        };
        return DTableBodyCellInputTree;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellLink = /** @class */ (function (_super) {
        __extends(DTableBodyCellLink, _super);
        function DTableBodyCellLink(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellLink.prototype.toLinkOptions = function (options) {
            var link = options.link;
            if (link) {
                return {
                    url: this.toUrl(link.url),
                    target: link.target,
                    checker: this.toChecker(link.checker),
                    menu: link.menu
                };
            }
            return undefined;
        };
        DTableBodyCellLink.prototype.toUrl = function (url) {
            var _this = this;
            if (isString(url) || url == null) {
                return url;
            }
            else {
                return function () {
                    var row = _this._row;
                    if (row !== undefined) {
                        return url(row, _this._rowIndex, _this._columnIndex, _this);
                    }
                    return null;
                };
            }
        };
        DTableBodyCellLink.prototype.toChecker = function (checker) {
            var _this = this;
            if (checker != null) {
                return function () {
                    var row = _this._row;
                    if (row !== undefined) {
                        return checker(row, _this._rowIndex, _this._columnIndex, _this);
                    }
                    return false;
                };
            }
            return undefined;
        };
        DTableBodyCellLink.prototype.init = function (options) {
            if (options.link && options.link.target === DLinkTarget.NEW_WINDOW) {
                options.state = (options.state || DBaseState.NONE) || DTableCellState.NEW_WINDOW;
            }
            this._link = new DLink(this.theme, this.toLinkOptions(options));
            _super.prototype.init.call(this, options);
        };
        DTableBodyCellLink.prototype.initOnClick = function (options) {
            var _this = this;
            this._link.apply(this, function (e) { return _this.onActive(e); });
        };
        Object.defineProperty(DTableBodyCellLink.prototype, "url", {
            get: function () {
                return this._link.url;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellLink.prototype, "menu", {
            get: function () {
                return this._link.menu;
            },
            enumerable: true,
            configurable: true
        });
        DTableBodyCellLink.prototype.getType = function () {
            return "DTableBodyCellLink";
        };
        DTableBodyCellLink.prototype.onActive = function (e) {
            this.emit("active", this);
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._columnData.setter(row, columnIndex, null);
                this.emit("cellchange", null, null, row, rowIndex, columnIndex, this);
                this.open(this._link.inNewWindow(e));
            }
        };
        DTableBodyCellLink.prototype.open = function (inNewWindow) {
            this._link.open(inNewWindow);
        };
        return DTableBodyCellLink;
    }(DTableBodyCellButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectMenu = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectMenu, _super);
        function DTableBodyCellSelectMenu(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellSelectMenu.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var column = options.column;
            this._rowIndex = 0;
            this._columnIndex = column.index;
            this._columnData = column.data;
            this.on("change", function (newValue, oldValue) {
                var row = _this._row;
                if (row !== undefined) {
                    var rowIndex = _this._rowIndex;
                    var columnIndex = _this._columnIndex;
                    _this._columnData.setter(row, columnIndex, newValue);
                    _this.emit("cellchange", newValue, oldValue, row, rowIndex, columnIndex, _this);
                }
            });
        };
        DTableBodyCellSelectMenu.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellSelectMenu.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.value = value;
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellSelectMenu.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellSelectMenu.prototype.getType = function () {
            return "DTableBodyCellSelectMenu";
        };
        return DTableBodyCellSelectMenu;
    }(DSelect));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectMultiple = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectMultiple, _super);
        function DTableBodyCellSelectMultiple(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellSelectMultiple.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var column = options.column;
            this._rowIndex = 0;
            this._columnIndex = column.index;
            this._columnData = column.data;
            this.on("change", function (newValues, oldValues) {
                var row = _this._row;
                if (row !== undefined) {
                    var rowIndex = _this._rowIndex;
                    var columnIndex = _this._columnIndex;
                    _this._columnData.setter(row, columnIndex, newValues);
                    _this.emit("cellchange", newValues, oldValues, row, rowIndex, columnIndex, _this);
                }
            });
        };
        DTableBodyCellSelectMultiple.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellSelectMultiple.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.values = value;
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellSelectMultiple.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellSelectMultiple.prototype.getType = function () {
            return "DTableBodyCellSelectMultiple";
        };
        return DTableBodyCellSelectMultiple;
    }(DSelectMultiple));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePaddingAdjustable = /** @class */ (function () {
        function DBasePaddingAdjustable(target) {
            this._target = target;
            this._adjuster = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            };
        }
        Object.defineProperty(DBasePaddingAdjustable.prototype, "adjuster", {
            get: function () {
                return this._adjuster;
            },
            enumerable: true,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.getTheme = function () {
            return this._target.getTheme();
        };
        DBasePaddingAdjustable.prototype.setTheme = function (theme) {
            this._target.setTheme(theme);
        };
        DBasePaddingAdjustable.prototype.getLeft = function () {
            return this._target.getLeft() + this._adjuster.left;
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "left", {
            get: function () {
                return this._target.left;
            },
            set: function (left) {
                this._target.left = left;
            },
            enumerable: true,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.getTop = function () {
            return this._target.getTop() + this._adjuster.top;
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "top", {
            get: function () {
                return this._target.top;
            },
            set: function (top) {
                this._target.top = top;
            },
            enumerable: true,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.getRight = function () {
            return this._target.getRight() + this._adjuster.right;
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "right", {
            get: function () {
                return this._target.right;
            },
            set: function (right) {
                this._target.right = right;
            },
            enumerable: true,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.getBottom = function () {
            return this._target.getBottom() + this._adjuster.bottom;
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "bottom", {
            get: function () {
                return this._target.bottom;
            },
            set: function (bottom) {
                this._target.bottom = bottom;
            },
            enumerable: true,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.set = function (top, right, bottom, left) {
            this._target.set(top, right, bottom, left);
        };
        return DBasePaddingAdjustable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellTree = /** @class */ (function (_super) {
        __extends(DTableBodyCellTree, _super);
        function DTableBodyCellTree(options) {
            var _this = _super.call(this, options) || this;
            _this._padding = new DBasePaddingAdjustable(_this._padding);
            return _this;
        }
        DTableBodyCellTree.prototype.onActive = function (e) {
            this.emit("active", this);
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this.emit("cellchange", null, null, row, rowIndex, columnIndex, this);
                var parent_1 = this.parent;
                if (parent_1) {
                    var body = parent_1.parent;
                    if (body) {
                        var data = body.data;
                        if (data && data.toggle) {
                            data.toggle(row);
                        }
                    }
                }
            }
        };
        DTableBodyCellTree.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            var columnData = this._columnData;
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
            var adjuster = this._padding.adjuster;
            if (isNumber(supplimental)) {
                var isOpened = !!(supplimental & 0x1);
                var hasChildren = !!(supplimental & 0x2);
                var level = (supplimental >> 2);
                if (hasChildren) {
                    if (isOpened) {
                        this.setStates(DTableCellState.HAS_CHILDREN | DTableCellState.OPENED, DBaseState.NONE);
                    }
                    else {
                        this.setStates(DTableCellState.HAS_CHILDREN, DTableCellState.OPENED);
                    }
                }
                else {
                    if (isOpened) {
                        this.setStates(DTableCellState.OPENED, DTableCellState.HAS_CHILDREN);
                    }
                    else {
                        this.setStates(DBaseState.NONE, DTableCellState.HAS_CHILDREN | DTableCellState.OPENED);
                    }
                }
                adjuster.left = this.theme.getLevelPadding(level);
            }
            else {
                this.setStates(DBaseState.NONE, DTableCellState.OPENED | DTableCellState.HAS_CHILDREN);
                adjuster.left = 0;
            }
        };
        DTableBodyCellTree.prototype.getType = function () {
            return "DTableBodyCellTree";
        };
        return DTableBodyCellTree;
    }(DTableBodyCellButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellTime = /** @class */ (function (_super) {
        __extends(DTableBodyCellTime, _super);
        function DTableBodyCellTime(options) {
            return _super.call(this, options) || this;
        }
        DTableBodyCellTime.prototype.init = function (options) {
            var _this = this;
            this._dialogOptions = options.dialog;
            this._datetimeMask = DPickerTimes.toMask(options.dialog && options.dialog.picker);
            this._rowIndex = 0;
            this._columnIndex = options.column.index;
            this._columnData = options.column.data;
            _super.prototype.init.call(this, options);
            this.on("active", function () {
                var currentTime = _this._textValueComputed.getTime();
                var dialog = _this.dialog;
                dialog.current = new Date(currentTime);
                dialog.new = new Date(currentTime);
                dialog.open().then(function () {
                    var newValue = dialog.new;
                    var oldValue = dialog.current;
                    _this.text = new Date(newValue.getTime());
                    var row = _this._row;
                    if (row !== undefined) {
                        var rowIndex = _this._rowIndex;
                        var columnIndex = _this._columnIndex;
                        _this._columnData.setter(row, columnIndex, newValue);
                        _this.emit("cellchange", newValue, oldValue, row, rowIndex, columnIndex, _this);
                    }
                });
            });
        };
        DTableBodyCellTime.prototype.mergeState = function (stateLocal, stateParent) {
            return _super.prototype.mergeState.call(this, stateLocal, stateParent) |
                (stateParent & DBaseState.HOVERED ? DBaseState.HOVERED : DBaseState.NONE);
        };
        DTableBodyCellTime.prototype.getDatetimeMask = function () {
            return this._datetimeMask;
        };
        Object.defineProperty(DTableBodyCellTime.prototype, "dialog", {
            get: function () {
                var dialog = this._dialog;
                if (dialog == null) {
                    var dialogOptions = this._dialogOptions;
                    if (dialogOptions != null) {
                        dialog = new DDialogTime(this._dialogOptions);
                    }
                    else {
                        if (DTableBodyCellTime.DIALOG == null) {
                            DTableBodyCellTime.DIALOG = new DDialogTime();
                        }
                        dialog = DTableBodyCellTime.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: true,
            configurable: true
        });
        DTableBodyCellTime.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this._textValue = value;
                    this._textValueComputed = value;
                    this.onTextChange();
                    this.createOrUpdateText();
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed.getTime() !== value) {
                    textValueComputed.setTime(value);
                    this.onTextChange();
                    this.createOrUpdateText();
                }
            }
            var columnData = this._columnData;
            DTableBodyCells.setReadOnly(this, row, columnIndex, columnData);
            DTableBodyCells.setRenderable(this, row, columnIndex, columnData);
        };
        DTableBodyCellTime.prototype.unset = function () {
            this._row = undefined;
        };
        DTableBodyCellTime.prototype.getType = function () {
            return "DTableBodyCellTime";
        };
        return DTableBodyCellTime;
    }(DButton));

    /**
     * Row states.
     */
    var DTableRowState = {
        /**
         * Even rows.
         */
        EVEN: DBaseState.CUSTOM << 0
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableRow = /** @class */ (function (_super) {
        __extends(DTableRow, _super);
        function DTableRow(options) {
            return _super.call(this, options) || this;
        }
        DTableRow.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            // State
            var even = !!options.even;
            if (even) {
                this.setState(DTableRowState.EVEN, true);
            }
            // Frozen
            var frozen = this._frozen = (_a = options.frozen) !== null && _a !== void 0 ? _a : 0;
            // Cells
            var columns = this._columns = options.columns || [];
            var iend = this.toIndexEnd(columns);
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                var cell = this.newCell(columns[i], i, columns, options);
                var cellState = this.toCellState(even, i, iend, frozen);
                if (cellState) {
                    cell.setState(cellState, true);
                }
                this.addChild(cell);
            }
        };
        DTableRow.prototype.toCellState = function (even, index, iend, frozen) {
            return (even ? DTableCellState.EVEN : DBaseState.NONE) |
                (index === 0 ? DTableCellState.START : DBaseState.NONE) |
                (index === iend ? DTableCellState.END : DBaseState.NONE) |
                (index < frozen ? DTableCellState.FROZEN : DBaseState.NONE) |
                (index === frozen - 1 ? DTableCellState.FROZEN_END : DBaseState.NONE);
        };
        DTableRow.prototype.toIndexEnd = function (columns) {
            var imax = columns.length;
            for (var i = 0; i < imax; ++i) {
                var column = columns[i];
                if (column.weight !== undefined) {
                    return imax - 1;
                }
            }
            return imax;
        };
        DTableRow.prototype.onRefit = function () {
            _super.prototype.onRefit.call(this);
            this.resetFrozenCellPosition();
        };
        DTableRow.prototype.updateFrozenCellPosition = function (x) {
            var columns = this._columns;
            var cells = this.children;
            var frozen = this._frozen;
            for (var i = 0; i < frozen; ++i) {
                var column = columns[i];
                var cell = cells[i];
                cell.position.x = -x + column.offset;
            }
        };
        DTableRow.prototype.resetFrozenCellPosition = function () {
            var columns = this._columns;
            var cells = this.children;
            var frozen = this._frozen;
            var x = this.getContentPositionX();
            for (var i = 0; i < frozen; ++i) {
                var column = columns[i];
                var cell = cells[i];
                column.offset = cell.position.x;
                cell.position.x = -x + column.offset;
            }
        };
        DTableRow.prototype.getClippingRect = function (target, result) {
            _super.prototype.getClippingRect.call(this, target, result);
            var frozen = this._frozen;
            if (0 < frozen && target.parent === this) {
                var cells = this.children;
                var cellIndex = cells.indexOf(target);
                if (0 <= cellIndex) {
                    if (frozen <= cellIndex) {
                        var previous = cells[cellIndex - 1];
                        var shiftX = previous.position.x + previous.width;
                        result.x += shiftX;
                        result.width -= shiftX;
                    }
                }
            }
        };
        DTableRow.prototype.render = function (renderer) {
            if (this.visible && 0 < this.worldAlpha && this.renderable) {
                this.renderBefore(renderer);
                this._render(renderer);
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    children[i].render(renderer);
                }
                this.renderAfter(renderer);
            }
        };
        DTableRow.prototype.getType = function () {
            return "DTableRow";
        };
        return DTableRow;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isBodyCell = function (target) {
        return (target != null && "set" in target);
    };
    var DTableBodyRow = /** @class */ (function (_super) {
        __extends(DTableBodyRow, _super);
        function DTableBodyRow(options) {
            var _this = _super.call(this, options) || this;
            _this._row = undefined;
            return _this;
        }
        DTableBodyRow.prototype.init = function (options) {
            var _this = this;
            this._onCellChangeBound = function (newValue, oldValue, row, rowIndex, columnIndex) {
                _this.emit("rowchange", newValue, oldValue, row, rowIndex, columnIndex, _this);
            };
            _super.prototype.init.call(this, options);
        };
        DTableBodyRow.prototype.newCell = function (column, columnIndex, columns, options) {
            var cellOptions = this.toCellOptions(column, columnIndex, options);
            if (column.editing.enable !== false) {
                var cell = this.newCellEditable(column, columnIndex, cellOptions);
                cell.on("cellchange", this._onCellChangeBound);
                return cell;
            }
            else {
                var cell = this.newCellUnediable(column, columnIndex, cellOptions);
                if (column.type === DTableColumnType.TREE) {
                    cell.on("cellchange", this._onCellChangeBound);
                }
                else {
                    cell.setReadOnly(true);
                }
                return cell;
            }
        };
        DTableBodyRow.prototype.newCellEditable = function (column, columnIndex, options) {
            switch (column.type) {
                case DTableColumnType.INDEX:
                    return new DTableBodyCellIndex(options);
                case DTableColumnType.TEXT:
                    return new DTableBodyCellInputText(options);
                case DTableColumnType.TREE:
                    return new DTableBodyCellInputTree(options);
                case DTableColumnType.INTEGER:
                    return new DTableBodyCellInputInteger(options);
                case DTableColumnType.REAL:
                    return new DTableBodyCellInputReal(options);
                case DTableColumnType.CHECK:
                case DTableColumnType.CHECK_SINGLE:
                    return new DTableBodyCellCheck(options);
                case DTableColumnType.COLOR:
                    return new DTableBodyCellColor(options);
                case DTableColumnType.BUTTON:
                    return new DTableBodyCellButton(options);
                case DTableColumnType.LINK:
                    return new DTableBodyCellLink(options);
                case DTableColumnType.SELECT:
                    return this.newCellSelect(column, options);
                case DTableColumnType.ACTION:
                    return this.newCellAction(column, options);
                case DTableColumnType.DATE:
                    return new DTableBodyCellDate(options);
                case DTableColumnType.DATETIME:
                    return new DTableBodyCellDatetime(options);
                case DTableColumnType.TIME:
                    return new DTableBodyCellTime(options);
                default:
                    return new DTableBodyCellText(options);
            }
        };
        DTableBodyRow.prototype.newCellUnediable = function (column, columnIndex, options) {
            switch (column.type) {
                case DTableColumnType.INDEX:
                    return new DTableBodyCellIndex(options);
                case DTableColumnType.TEXT:
                    return new DTableBodyCellText(options);
                case DTableColumnType.TREE:
                    return new DTableBodyCellTree(options);
                case DTableColumnType.INTEGER:
                    return new DTableBodyCellText(options);
                case DTableColumnType.REAL:
                    return new DTableBodyCellText(options);
                case DTableColumnType.CHECK:
                case DTableColumnType.CHECK_SINGLE:
                    return new DTableBodyCellCheck(options);
                case DTableColumnType.COLOR:
                    return new DTableBodyCellColor(options);
                case DTableColumnType.BUTTON:
                    return new DTableBodyCellButton(options);
                case DTableColumnType.LINK:
                    return new DTableBodyCellLink(options);
                case DTableColumnType.SELECT:
                    return this.newCellSelect(column, options);
                case DTableColumnType.ACTION:
                    return this.newCellAction(column, options);
                case DTableColumnType.DATE:
                    return new DTableBodyCellDate(options);
                case DTableColumnType.DATETIME:
                    return new DTableBodyCellDatetime(options);
                case DTableColumnType.TIME:
                    return new DTableBodyCellTime(options);
                default:
                    return new DTableBodyCellText(options);
            }
        };
        DTableBodyRow.prototype.newCellSelect = function (column, options) {
            var selecting = column.selecting;
            if (selecting.menu != null) {
                return new DTableBodyCellSelectMenu(options);
            }
            else if (selecting.multiple != null) {
                return new DTableBodyCellSelectMultiple(options);
            }
            else if (selecting.dialog != null) {
                return new DTableBodyCellSelectDialog(options);
            }
            else if (selecting.promise != null) {
                return new DTableBodyCellSelectPromise(options);
            }
            else {
                return new DTableBodyCellText(options);
            }
        };
        DTableBodyRow.prototype.newCellAction = function (column, options) {
            var selecting = column.selecting;
            if (selecting.menu != null) {
                return new DTableBodyCellActionMenu(options);
            }
            else if (selecting.dialog != null) {
                return new DTableBodyCellActionDialog(options);
            }
            else if (selecting.promise != null) {
                return new DTableBodyCellActionPromise(options);
            }
            else {
                return new DTableBodyCellText(options);
            }
        };
        DTableBodyRow.prototype.toCellOptions = function (column, columnIndex, options) {
            var result = (column.body || options.cell);
            if (result != null) {
                result.weight = column.weight;
                result.width = column.width;
                var text = result.text = result.text || {};
                var align = text.align = text.align || {};
                align.horizontal = column.align;
                text.formatter = column.formatter;
                result.column = {
                    index: columnIndex,
                    data: column
                };
                if (column.selecting.menu) {
                    result.menu = column.selecting.menu;
                }
                if (column.selecting.multiple) {
                    result.menu = column.selecting.menu;
                }
            }
            else {
                result = {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        formatter: column.formatter,
                        align: {
                            horizontal: column.align
                        }
                    },
                    column: {
                        index: columnIndex,
                        data: column
                    },
                    menu: column.selecting.menu || column.selecting.multiple
                };
            }
            if (column.editing.enable !== false) {
                var editing = result.editing = result.editing || {};
                editing.formatter = editing.formatter || column.editing.formatter;
                editing.unformatter = editing.unformatter || column.editing.unformatter;
                editing.validator = editing.validator || column.editing.validator;
            }
            if (column.link) {
                result.link = column.link;
            }
            return result;
        };
        DTableBodyRow.prototype.getType = function () {
            return "DTableBodyRow";
        };
        DTableBodyRow.prototype.set = function (row, supplimental, rowIndex, forcibly) {
            if (forcibly || this._row !== row) {
                this._row = row;
                var cells = this.children;
                var cellsLength = cells.length;
                var columns = this._columns;
                var columnsLength = columns.length;
                for (var i = 0, imax = Math.min(columnsLength, cellsLength); i < imax; ++i) {
                    var cell = cells[i];
                    var column = columns[i];
                    if (isBodyCell(cell)) {
                        cell.set(column.getter(row, i), row, supplimental, rowIndex, i, forcibly);
                    }
                }
                this.emit("set", row, rowIndex, this);
            }
        };
        DTableBodyRow.prototype.unset = function () {
            if (this._row !== undefined) {
                this._row = undefined;
                var cells = this.children;
                for (var i = 0, imax = cells.length; i < imax; ++i) {
                    var cell = cells[i];
                    if (isBodyCell(cell)) {
                        cell.unset();
                    }
                }
                this.emit("unset", this);
            }
        };
        DTableBodyRow.prototype.getContentPositionX = function () {
            var parent = this.parent;
            if (parent) {
                var content = parent.parent;
                if (content) {
                    return content.position.x;
                }
            }
            return 0;
        };
        return DTableBodyRow;
    }(DTableRow));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataFilterImpl = /** @class */ (function (_super) {
        __extends(DTableDataFilterImpl, _super);
        function DTableDataFilterImpl(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._sorterId = -1;
            _this._parent = parent;
            _this._filter = null;
            _this._filtered = null;
            return _this;
        }
        Object.defineProperty(DTableDataFilterImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataFilterImpl.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataFilterImpl.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataFilterImpl.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataFilterImpl.prototype.newFiltered = function () {
            var filter = this._filter;
            if (filter != null) {
                var filtered = [];
                var parent_1 = this._parent;
                var sorter = parent_1.sorter;
                var rows = parent_1.rows;
                if (isFunction(filter)) {
                    var indicesSorted = sorter.indices;
                    if (indicesSorted) {
                        for (var i = 0, imax = indicesSorted.length; i < imax; ++i) {
                            var indexSorted = indicesSorted[i];
                            if (filter(rows[indexSorted], indexSorted)) {
                                filtered.push(i);
                            }
                        }
                    }
                    else {
                        for (var i = 0, imax = rows.length; i < imax; ++i) {
                            if (filter(rows[i], i)) {
                                filtered.push(i);
                            }
                        }
                    }
                }
                else {
                    var indicesSorted = sorter.indices;
                    if (indicesSorted) {
                        for (var i = 0, imax = indicesSorted.length; i < imax; ++i) {
                            var indexSorted = indicesSorted[i];
                            if (filter.test(rows[indexSorted], indexSorted)) {
                                filtered.push(i);
                            }
                        }
                    }
                    else {
                        for (var i = 0, imax = rows.length; i < imax; ++i) {
                            if (filter.test(rows[i], i)) {
                                filtered.push(i);
                            }
                        }
                    }
                }
                return filtered;
            }
            else {
                return null;
            }
        };
        DTableDataFilterImpl.prototype.get = function () {
            return this._filter;
        };
        DTableDataFilterImpl.prototype.set = function (filter) {
            if (this._filter !== filter) {
                this._filter = filter;
            }
        };
        DTableDataFilterImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataFilterImpl.prototype.update = function () {
            if (this._id !== this._idUpdated || this._parent.sorter.id !== this._sorterId) {
                this._idUpdated = this._id;
                this._sorterId = this._parent.sorter.id;
                if (this._isApplied) {
                    this._filtered = this.newFiltered();
                    this.emit("change", this);
                }
                else if (this._filtered != null) {
                    this._filtered = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataFilterImpl.prototype, "indices", {
            get: function () {
                this.update();
                return this._filtered;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataFilterImpl.prototype.map = function (sortedIndex) {
            var result = sortedIndex;
            var indicesFiltered = this.indices;
            if (indicesFiltered) {
                var index = indicesFiltered.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataFilterImpl.prototype.unmap = function (index) {
            var result = index;
            var indicesFiltered = this.indices;
            if (indicesFiltered) {
                result = indicesFiltered[result];
            }
            return result;
        };
        return DTableDataFilterImpl;
    }(pixi_js.utils.EventEmitter));

    var DTableDataListMapped = /** @class */ (function () {
        function DTableDataListMapped(parent) {
            this._parent = parent;
        }
        DTableDataListMapped.prototype.map = function (unmappedIndex) {
            var parent = this._parent;
            var sortedIndex = parent.sorter.map(unmappedIndex);
            if (sortedIndex != null) {
                return parent.filter.map(sortedIndex);
            }
            return null;
        };
        DTableDataListMapped.prototype.unmap = function (index) {
            var parent = this._parent;
            return parent.sorter.unmap(parent.filter.unmap(index));
        };
        DTableDataListMapped.prototype.size = function () {
            var parent = this._parent;
            var indicesFiltered = parent.filter.indices;
            return (indicesFiltered != null ? indicesFiltered.length : parent.size());
        };
        DTableDataListMapped.prototype.get = function (index) {
            var parent = this._parent;
            return parent.get(this.unmap(index));
        };
        DTableDataListMapped.prototype.each = function (iteratee, ifrom, ito) {
            var parent = this._parent;
            var rows = parent.rows;
            var supplimentals = parent.supplimentals;
            var indicesFiltered = parent.filter.indices;
            var indicesSorted = parent.sorter.indices;
            ifrom = (ifrom != null ? Math.max(0, ifrom) : 0);
            if (indicesFiltered) {
                var size = indicesFiltered.length;
                ito = (ito != null ? Math.min(size, ito) : size);
                if (indicesSorted) {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesSorted[indicesFiltered[i]];
                        var row = rows[unmappedIndex];
                        var supplimental = (supplimentals ? supplimentals[unmappedIndex] : null);
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
                else {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesFiltered[i];
                        var row = rows[unmappedIndex];
                        var supplimental = (supplimentals ? supplimentals[unmappedIndex] : null);
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
            }
            else {
                var size = rows.length;
                ito = (ito != null ? Math.min(size, ito) : size);
                if (indicesSorted) {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesSorted[i];
                        var row = rows[unmappedIndex];
                        var supplimental = (supplimentals ? supplimentals[unmappedIndex] : null);
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
                else {
                    for (var i = ifrom; i < ito; ++i) {
                        var row = rows[i];
                        var supplimental = (supplimentals ? supplimentals[i] : null);
                        if (iteratee(row, supplimental, i, i) === false) {
                            break;
                        }
                    }
                }
            }
        };
        return DTableDataListMapped;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataSelectionType;
    (function (DTableDataSelectionType) {
        DTableDataSelectionType[DTableDataSelectionType["NONE"] = 0] = "NONE";
        DTableDataSelectionType[DTableDataSelectionType["SINGLE"] = 1] = "SINGLE";
        DTableDataSelectionType[DTableDataSelectionType["MULTIPLE"] = 2] = "MULTIPLE";
    })(DTableDataSelectionType || (DTableDataSelectionType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var COMPARATOR = function (a, b) {
        return a[0] - b[0];
    };
    var DTableDataSelectionImpl = /** @class */ (function (_super) {
        __extends(DTableDataSelectionImpl, _super);
        function DTableDataSelectionImpl(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._type = _this.toType(options);
            _this._indices = new Set();
            return _this;
        }
        DTableDataSelectionImpl.prototype.toType = function (options) {
            return (options && options.type != null ?
                (isString(options.type) ? DTableDataSelectionType[options.type] : options.type) :
                DTableDataSelectionType.NONE);
        };
        Object.defineProperty(DTableDataSelectionImpl.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataSelectionImpl.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTableDataSelectionImpl.prototype.toggle = function (rowIndex) {
            var indices = this._indices;
            if (indices.has(rowIndex)) {
                indices.delete(rowIndex);
            }
            else {
                indices.add(rowIndex);
            }
            this.onChange();
        };
        DTableDataSelectionImpl.prototype.add = function (rowIndex) {
            var indices = this._indices;
            var oldSize = indices.size;
            indices.add(rowIndex);
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        Object.defineProperty(DTableDataSelectionImpl.prototype, "first", {
            get: function () {
                var indices = this._indices;
                if (0 < indices.size) {
                    var result_1 = NaN;
                    indices.forEach(function (index) {
                        if (result_1 !== result_1) {
                            result_1 = index;
                        }
                    });
                    return result_1;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataSelectionImpl.prototype, "last", {
            get: function () {
                var indices = this._indices;
                if (0 < indices.size) {
                    var result_2 = 0;
                    indices.forEach(function (index) {
                        result_2 = index;
                    });
                    return result_2;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataSelectionImpl.prototype.addTo = function (rowIndex) {
            var lastRowIndex = this.last;
            if (lastRowIndex != null) {
                this.addRange(lastRowIndex, false, rowIndex, true);
            }
        };
        DTableDataSelectionImpl.prototype.addRange = function (from, includeFrom, to, includeTo) {
            var indices = this._indices;
            var oldSize = indices.size;
            if (from < to) {
                for (var i = from + (includeFrom ? 0 : 1), imax = to + (includeTo ? 1 : 0); i < imax; ++i) {
                    indices.add(i);
                }
            }
            else {
                for (var i = to + (includeTo ? 0 : 1), imax = from + (includeFrom ? 1 : 0); i < imax; ++i) {
                    indices.add(i);
                }
            }
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataSelectionImpl.prototype.addAll = function (rowIndices) {
            var indices = this._indices;
            var oldSize = indices.size;
            for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                indices.add(rowIndices[i]);
            }
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataSelectionImpl.prototype.contains = function (rowIndex) {
            return this._indices.has(rowIndex);
        };
        DTableDataSelectionImpl.prototype.remove = function (rowIndex) {
            if (this._indices.delete(rowIndex)) {
                this.onChange();
            }
        };
        DTableDataSelectionImpl.prototype.clear = function () {
            var indices = this._indices;
            if (0 < indices.size) {
                indices.clear();
                this.onChange();
            }
        };
        DTableDataSelectionImpl.prototype.clearAndAdd = function (rowIndex) {
            var indices = this._indices;
            if (!indices.has(rowIndex) || indices.size !== 1) {
                indices.clear();
                indices.add(rowIndex);
                this.onChange();
            }
        };
        DTableDataSelectionImpl.prototype.clearAndAddAll = function (rowIndices) {
            var indices = this._indices;
            if (0 < indices.size || 0 < rowIndices.length) {
                indices.clear();
                for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                    indices.add(rowIndices[i]);
                }
                this.onChange();
            }
        };
        DTableDataSelectionImpl.prototype.shift = function (rowIndex, amount) {
            var shifted = [];
            var indices = this._indices;
            indices.forEach(function (index) {
                if (rowIndex <= index) {
                    shifted.push(index);
                }
            });
            var shiftedLength = shifted.length;
            if (0 < shiftedLength) {
                for (var i = 0, imax = shifted.length; i < imax; ++i) {
                    indices.delete(shifted[i]);
                }
                for (var i = 0, imax = shifted.length; i < imax; ++i) {
                    indices.add(shifted[i] + amount);
                }
                this.onChange();
            }
        };
        DTableDataSelectionImpl.prototype.size = function () {
            return this._indices.size;
        };
        DTableDataSelectionImpl.prototype.isEmpty = function () {
            return this._indices.size === 0;
        };
        Object.defineProperty(DTableDataSelectionImpl.prototype, "indices", {
            /**
             * Returns a copy of an index array of selected rows.
             * The order of indices is an insertion order.
             */
            get: function () {
                var result = [];
                this._indices.forEach(function (index) {
                    result.push(index);
                });
                return result;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataSelectionImpl.prototype, "rows", {
            /**
             * Returns a copy of an array of selected row value.
             * The order is an insertion order.
             */
            get: function () {
                var result = [];
                var parent = this._parent;
                this._indices.forEach(function (index) {
                    result.push(parent.get(index));
                });
                return result;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns an array of the (index, row value) pairs of selected rows.
         * The order of pairs is an insertion order.
         */
        DTableDataSelectionImpl.prototype.toArray = function () {
            var result = [];
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result.push([index, parent.get(index)]);
            });
            return result;
        };
        /**
         * Returns an sorted array of the (index, row value) pairs of selected rows.
         */
        DTableDataSelectionImpl.prototype.toSortedArray = function () {
            return this.toArray().sort(COMPARATOR);
        };
        DTableDataSelectionImpl.prototype.toObject = function () {
            var result = {};
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result[index] = parent.get(index);
            });
            return result;
        };
        DTableDataSelectionImpl.prototype.toMap = function () {
            var result = new Map();
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result.set(index, parent.get(index));
            });
            return result;
        };
        return DTableDataSelectionImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A sort order.
     */
    var DTableDataOrder;
    (function (DTableDataOrder) {
        DTableDataOrder[DTableDataOrder["ASCENDING"] = 0] = "ASCENDING";
        DTableDataOrder[DTableDataOrder["DESCENDING"] = 1] = "DESCENDING";
    })(DTableDataOrder || (DTableDataOrder = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataSorterImpl = /** @class */ (function (_super) {
        __extends(DTableDataSorterImpl, _super);
        function DTableDataSorterImpl(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._parent = parent;
            _this._comparator = null;
            _this._sorted = null;
            _this._order = DTableDataOrder.ASCENDING;
            return _this;
        }
        Object.defineProperty(DTableDataSorterImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataSorterImpl.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (order) {
                this._order = order;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataSorterImpl.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataSorterImpl.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataSorterImpl.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataSorterImpl.prototype.newSorted = function () {
            var comparator = this._comparator;
            if (comparator != null) {
                var parent_1 = this._parent;
                var sorted = [];
                var rows = parent_1.rows;
                for (var i = 0, imax = rows.length; i < imax; ++i) {
                    sorted.push(i);
                }
                sorted.sort(this.toComparator(rows, comparator));
                return sorted;
            }
            else {
                return null;
            }
        };
        DTableDataSorterImpl.prototype.toComparator = function (rows, comparator) {
            var order = this._order;
            if (isFunction(comparator)) {
                if (order === DTableDataOrder.ASCENDING) {
                    return function (indexA, indexB) {
                        return comparator(rows[indexA], rows[indexB], indexA, indexB);
                    };
                }
                else {
                    return function (indexA, indexB) {
                        return comparator(rows[indexB], rows[indexA], indexB, indexA);
                    };
                }
            }
            else {
                if (order === DTableDataOrder.ASCENDING) {
                    return function (indexA, indexB) {
                        return comparator.compare(rows[indexA], rows[indexB], indexA, indexB);
                    };
                }
                else {
                    return function (indexA, indexB) {
                        return comparator.compare(rows[indexB], rows[indexA], indexB, indexA);
                    };
                }
            }
        };
        DTableDataSorterImpl.prototype.get = function () {
            return this._comparator;
        };
        DTableDataSorterImpl.prototype.set = function (comparator) {
            if (this._comparator !== comparator) {
                this._comparator = comparator;
            }
        };
        DTableDataSorterImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataSorterImpl.prototype.update = function () {
            if (this._id !== this._idUpdated) {
                this._idUpdated = this._id;
                if (this._isApplied) {
                    this._sorted = this.newSorted();
                    this.emit("change", this);
                }
                else if (this._sorted != null) {
                    this._sorted = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataSorterImpl.prototype, "indices", {
            get: function () {
                this.update();
                return this._sorted;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataSorterImpl.prototype.map = function (unmappedIndex) {
            var result = unmappedIndex;
            var indicesSorted = this.indices;
            if (indicesSorted) {
                var index = indicesSorted.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataSorterImpl.prototype.unmap = function (index) {
            var result = index;
            var indicesSorted = this.indices;
            if (indicesSorted) {
                result = indicesSorted[result];
            }
            return result;
        };
        return DTableDataSorterImpl;
    }(pixi_js.utils.EventEmitter));

    var DTableDataList = /** @class */ (function (_super) {
        __extends(DTableDataList, _super);
        function DTableDataList(options) {
            var _this = _super.call(this) || this;
            _this._parent = null;
            _this._mapped = new DTableDataListMapped(_this);
            _this._rows = _this.toRows(options && options.rows);
            _this._selection = new DTableDataSelectionImpl(_this, options && options.selection);
            _this._filter = new DTableDataFilterImpl(_this);
            _this._sorter = new DTableDataSorterImpl(_this);
            if (options) {
                // Filter
                var filter = options.filter;
                if (filter) {
                    _this._filter.set(filter);
                }
                // Comparator
                var comparator = options.comparator;
                if (comparator) {
                    _this._sorter.set(comparator);
                }
                // Events
                var on = options.on;
                if (on) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            return _this;
        }
        DTableDataList.prototype.bind = function (parent) {
            this._parent = parent;
        };
        DTableDataList.prototype.toRows = function (row) {
            var result = [];
            if (row != null) {
                for (var i = 0, imax = row.length; i < imax; ++i) {
                    result.push(row[i]);
                }
            }
            return result;
        };
        Object.defineProperty(DTableDataList.prototype, "rows", {
            get: function () {
                return this._rows;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataList.prototype.update = function () {
            var parent = this._parent;
            if (parent) {
                parent.update();
            }
        };
        DTableDataList.prototype.lock = function () {
            var parent = this._parent;
            if (parent) {
                parent.lock();
            }
        };
        DTableDataList.prototype.unlock = function () {
            var parent = this._parent;
            if (parent) {
                parent.unlock(false);
                parent.update();
            }
        };
        DTableDataList.prototype.size = function () {
            return this._rows.length;
        };
        DTableDataList.prototype.clear = function () {
            var rows = this._rows;
            if (0 < rows.length) {
                rows.length = 0;
                this.lock();
                this._selection.clear();
                this._sorter.toDirty();
                this._filter.toDirty();
                this.unlock();
            }
        };
        DTableDataList.prototype.clearAndAdd = function (row) {
            var rows = this._rows;
            rows.length = 0;
            rows.push(row);
            this.lock();
            this._selection.clear();
            this._sorter.toDirty();
            this._filter.toDirty();
            this.unlock();
        };
        DTableDataList.prototype.clearAndAddAll = function (newRows) {
            var rows = this._rows;
            rows.length = 0;
            for (var i = 0, imax = newRows.length; i < imax; ++i) {
                rows.push(newRows[i]);
            }
            this.lock();
            this._selection.clear();
            this._sorter.toDirty();
            this._filter.toDirty();
            this.unlock();
        };
        DTableDataList.prototype.add = function (row, index) {
            var rows = this._rows;
            var selection = this._selection;
            var sorter = this._sorter;
            var filter = this._filter;
            if (index == null) {
                rows.push(row);
                this.lock();
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
            else if (0 <= index && index < rows.length) {
                rows.splice(index, 0, row);
                this.lock();
                selection.shift(index, 1);
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
        };
        DTableDataList.prototype.addAll = function (newRows, index) {
            var rows = this._rows;
            var rowsLength = rows.length;
            var selection = this._selection;
            var sorter = this._sorter;
            var filter = this._filter;
            if (index == null) {
                var newRowsLength = newRows.length;
                for (var i = 0, imax = newRowsLength; i < imax; ++i) {
                    rows.push(newRows[i]);
                }
                this.lock();
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
            else if (0 <= index && index < rowsLength) {
                var newRowsLength = newRows.length;
                for (var i = 0; i < newRowsLength; ++i) {
                    rows.splice(index + i, 0, newRows[i]);
                }
                this.lock();
                selection.shift(index, newRowsLength);
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
        };
        DTableDataList.prototype.get = function (index) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        DTableDataList.prototype.set = function (index, row) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                var result = rows[index];
                rows[index] = row;
                this.lock();
                this._sorter.toDirty();
                this._filter.toDirty();
                this.unlock();
                return result;
            }
            return null;
        };
        DTableDataList.prototype.remove = function (index) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                var result = rows.splice(index, 1)[0];
                this.lock();
                this._selection.remove(index);
                this._sorter.toDirty();
                this._filter.toDirty();
                this.unlock();
                return result;
            }
            return null;
        };
        DTableDataList.prototype.each = function (iteratee, ifrom, ito) {
            var rows = this._rows;
            ifrom = (ifrom != null ? Math.max(0, ifrom) : 0);
            ito = (ito != null ? Math.min(rows.length, ito) : rows.length);
            for (var i = ifrom; i < ito; ++i) {
                var row = rows[i];
                if (iteratee(row, i) === false) {
                    break;
                }
            }
        };
        Object.defineProperty(DTableDataList.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "filter", {
            get: function () {
                return this._filter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "sorter", {
            get: function () {
                return this._sorter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: true,
            configurable: true
        });
        return DTableDataList;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toRowOptions = function (theme, options, selectionType) {
        var columns = options.columns || [];
        var result = options.row;
        if (result != null) {
            if (result.height == null) {
                result.height = theme.getRowHeight();
            }
            if (result.columns === undefined) {
                result.columns = columns;
            }
            if (result.interactive == null && selectionType !== DTableDataSelectionType.NONE) {
                result.interactive = "SELF";
            }
            if (result.frozen == null) {
                result.frozen = options.frozen;
            }
        }
        else {
            result = {
                columns: columns,
                height: theme.getRowHeight(),
                interactive: (selectionType !== DTableDataSelectionType.NONE ? "SELF" : undefined),
                frozen: options.frozen
            };
        }
        return result;
    };
    var isDTableData = function (target) {
        return (target != null && "mapped" in target);
    };
    var DTableBody = /** @class */ (function (_super) {
        __extends(DTableBody, _super);
        function DTableBody(options) {
            var _this = _super.call(this, options) || this;
            _this.setState(DBaseState.UNFOCUSABLE, true);
            _this._data.emit("init", _this._data);
            return _this;
        }
        DTableBody.prototype.init = function (options) {
            this.transform.position.y = options.offset || 0;
            this._onRowChangeBound = function (newValue, oldValue, row, rowIndex, columnIndex) {
                data.emit("change", newValue, oldValue, row, rowIndex, columnIndex, data);
            };
            _super.prototype.init.call(this, options);
            var data = (isDTableData(options.data) ? options.data :
                new DTableDataList(options.data));
            this._data = data;
            data.bind(this);
            var theme = this.theme;
            var rowOptions = toRowOptions(theme, options, data.selection.type);
            this._rowOptions = rowOptions;
            this._rowHeight = (rowOptions.height != null ? rowOptions.height : theme.getRowHeight());
            this._columns = rowOptions.columns || [];
            this._rowIndexMappedStart = 0;
            this._rowIndexMappedEnd = 0;
            this._updateRowsCount = 0;
            this._isUpdateRowsCalled = false;
            this._isUpdateRowsCalledForcibly = false;
            this._workRows = [];
        };
        DTableBody.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.update();
        };
        Object.defineProperty(DTableBody.prototype, "selection", {
            get: function () {
                return this._data.selection;
            },
            enumerable: true,
            configurable: true
        });
        DTableBody.prototype.lock = function () {
            this._updateRowsCount += 1;
            if (this._updateRowsCount === 1) {
                this._isUpdateRowsCalled = false;
                this._isUpdateRowsCalledForcibly = false;
            }
        };
        DTableBody.prototype.unlock = function (callIfNeeded) {
            this._updateRowsCount -= 1;
            if (this._updateRowsCount === 0) {
                if (callIfNeeded && this._isUpdateRowsCalled) {
                    this.update(this._isUpdateRowsCalledForcibly);
                }
                this._isUpdateRowsCalled = false;
                this._isUpdateRowsCalledForcibly = false;
            }
        };
        /**
         * Updates rows. If the `forcibly` is true, some dirty checkings for
         * avoiding unnecessary state changes are skipped.
         *
         * @param forcibly true to update forcibly
         */
        DTableBody.prototype.update = function (forcibly) {
            if (0 < this._updateRowsCount) {
                this._isUpdateRowsCalled = true;
                if (forcibly) {
                    this._isUpdateRowsCalledForcibly = true;
                }
                return;
            }
            var content = this.parent;
            var rows = this.children;
            var height = content.parent.height;
            var rowHeight = this._rowHeight;
            var data = this._data;
            var dataMappedSize = data.mapped.size();
            var oldRowIndexMappedStart = this._rowIndexMappedStart;
            var oldRowIndexMappedEnd = this._rowIndexMappedEnd;
            var oldRowCount = oldRowIndexMappedEnd - oldRowIndexMappedStart;
            var y = this.transform.position.y;
            var newHeight = y + dataMappedSize * rowHeight;
            var newContentHeight = Math.max(height, newHeight);
            var newContentY = Math.max(height - newContentHeight, content.position.y);
            var newRowIndexMappedLowerBound = Math.floor((0 - (newContentY + y)) / rowHeight);
            var newRowIndexMappedUpperBound = Math.floor((height - (newContentY + y)) / rowHeight);
            var newRowIndexMappedStart = newRowIndexMappedLowerBound - (newRowIndexMappedLowerBound % 2 === 0 ? 2 : 1);
            var newRowIndexMappedEnd = newRowIndexMappedUpperBound +
                ((newRowIndexMappedUpperBound - newRowIndexMappedStart + 1) % 2 === 0 ? 3 : 2);
            var newRowCount = newRowIndexMappedEnd - newRowIndexMappedStart;
            if (newRowCount < oldRowCount && oldRowCount - 2 <= newRowCount) {
                newRowCount = oldRowCount;
                newRowIndexMappedEnd = newRowIndexMappedStart + newRowCount;
            }
            if (oldRowCount < newRowCount) {
                for (var i = oldRowCount; i < newRowCount; ++i) {
                    var oldRowIndexMapped = oldRowIndexMappedStart + i;
                    var newRow = this.newRow((oldRowIndexMapped % 2) === 0);
                    this.addChild(newRow);
                }
                oldRowCount = newRowCount;
                oldRowIndexMappedEnd = oldRowIndexMappedStart + oldRowCount;
            }
            else if (newRowCount < oldRowCount) {
                for (var i = oldRowCount - 1; newRowCount <= i; --i) {
                    this.removeChild(rows[i]);
                }
                oldRowCount = newRowCount;
                oldRowIndexMappedEnd = oldRowIndexMappedStart + oldRowCount;
            }
            this._rowIndexMappedStart = newRowIndexMappedStart;
            this._rowIndexMappedEnd = newRowIndexMappedEnd;
            var rowIndexMappedStartDelta = newRowIndexMappedStart - oldRowIndexMappedStart;
            var rowIndexMappedStartDeltaAbs = Math.abs(rowIndexMappedStartDelta);
            var rowsLength = rows.length;
            if (0 < rowIndexMappedStartDeltaAbs && rowIndexMappedStartDeltaAbs < rowsLength) {
                var work = this._workRows;
                if (0 < rowIndexMappedStartDelta) {
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        work.push(this.resetRow(rows[i]));
                    }
                    for (var i = rowIndexMappedStartDeltaAbs; i < rowsLength; ++i) {
                        rows[i - rowIndexMappedStartDeltaAbs] = rows[i];
                    }
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        rows[rowsLength - rowIndexMappedStartDeltaAbs + i] = work[i];
                    }
                }
                else {
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        work.push(this.resetRow(rows[rowsLength - rowIndexMappedStartDeltaAbs + i]));
                    }
                    for (var i = rowsLength - rowIndexMappedStartDeltaAbs - 1; 0 <= i; --i) {
                        rows[i + rowIndexMappedStartDeltaAbs] = rows[i];
                    }
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        rows[i] = work[i];
                    }
                }
                work.length = 0;
            }
            var selection = data.selection;
            data.mapped.each(function (datum, supplimental, index, unmappedIndex) {
                var row = rows[index - newRowIndexMappedStart];
                row.position.y = index * rowHeight;
                if (selection.contains(unmappedIndex)) {
                    row.setStates(DBaseState.ACTIVE, DBaseState.DISABLED);
                }
                else {
                    row.setStates(DBaseState.NONE, DBaseState.ACTIVE | DBaseState.DISABLED);
                }
                row.set(datum, supplimental, unmappedIndex, forcibly);
            }, newRowIndexMappedStart, newRowIndexMappedStart + rowsLength);
            for (var i = 0; newRowIndexMappedStart + i < 0 && i < rowsLength; ++i) {
                var row = rows[i];
                row.position.y = (newRowIndexMappedStart + i) * rowHeight;
                row.setStates(DBaseState.DISABLED, DBaseState.ACTIVE);
                row.unset();
            }
            for (var i = rowsLength - 1; dataMappedSize <= newRowIndexMappedStart + i && 0 <= i; --i) {
                var row = rows[i];
                row.position.y = (newRowIndexMappedStart + i) * rowHeight;
                row.setStates(DBaseState.DISABLED, DBaseState.ACTIVE);
                row.unset();
            }
            this.lock();
            content.position.y = newContentY;
            content.height = newContentHeight;
            this.height = newHeight;
            this.unlock(false);
        };
        DTableBody.prototype.resetRow = function (row) {
            row.blur(true);
            var cells = row.children;
            for (var i = 0, imax = cells.length; i < imax; ++i) {
                var cell = cells[i];
                if (cell instanceof DBase) {
                    cell.setPressed(false);
                }
            }
            return row;
        };
        DTableBody.prototype.newRow = function (isEven) {
            var options = this._rowOptions;
            options.even = isEven;
            var result = new DTableBodyRow(options);
            result.on("rowchange", this._onRowChangeBound);
            return result;
        };
        DTableBody.prototype.onParentMove = function (x, y) {
            _super.prototype.onParentMove.call(this, x, y);
            this.updateFrozenCellPosition(x);
        };
        DTableBody.prototype.updateFrozenCellPosition = function (x) {
            var frozen = this._rowOptions.frozen;
            if (frozen != null && 0 < frozen) {
                var rows = this.children;
                for (var i = 0, imax = rows.length; i < imax; ++i) {
                    rows[i].updateFrozenCellPosition(x);
                }
            }
        };
        DTableBody.prototype.getClippingRect = function (target, result) {
            _super.prototype.getClippingRect.call(this, target, result);
            var parent = this.parent;
            if (parent) {
                var shiftY = -parent.transform.position.y;
                result.y += shiftY;
                result.height -= shiftY;
            }
        };
        DTableBody.prototype.onRowClicked = function (e) {
            if (this.isActionable()) {
                var local = DTableBody.WORK_ON_CLICK;
                local.copyFrom(e.data.global);
                this.toLocal(local, undefined, local, false);
                if (0 <= this.parent.position.y + local.y) {
                    var rowIndexMapped = Math.floor(local.y / this._rowHeight);
                    var data = this._data;
                    var mapped = data.mapped;
                    var selection = data.selection;
                    if (0 <= rowIndexMapped && rowIndexMapped < mapped.size()) {
                        var isSingle = (selection.type === DTableDataSelectionType.SINGLE);
                        var isNotSingle = !isSingle;
                        var originalEvent = e.data.originalEvent;
                        var ctrlKey = originalEvent.ctrlKey;
                        var shiftKey = originalEvent.shiftKey;
                        var rowIndex = mapped.unmap(rowIndexMapped);
                        if (isSingle || selection.isEmpty() || !(isNotSingle && (ctrlKey || shiftKey))) {
                            selection.clearAndAdd(rowIndex);
                        }
                        else if (ctrlKey) {
                            selection.toggle(rowIndex);
                        }
                        else if (shiftKey) {
                            var lastRowIndex = selection.last;
                            if (lastRowIndex != null) {
                                var sorter = data.sorter;
                                var filter = data.filter;
                                var rowIndexSorted = sorter.map(rowIndex);
                                var lastRowIndexSorted = sorter.map(lastRowIndex);
                                if (rowIndexSorted != null && lastRowIndexSorted != null) {
                                    var istart = lastRowIndexSorted + 1;
                                    var iend = rowIndexSorted + 1;
                                    if (rowIndexSorted < lastRowIndexSorted) {
                                        istart = rowIndexSorted;
                                        iend = lastRowIndexSorted;
                                    }
                                    if (istart < iend) {
                                        var rowIndices = [];
                                        var indicesFiltered = filter.indices;
                                        var indicesSorted = sorter.indices;
                                        if (indicesFiltered) {
                                            if (indicesSorted) {
                                                for (var i = 0, imax = indicesFiltered.length; i < imax; ++i) {
                                                    var indexFiltered = indicesFiltered[i];
                                                    if (istart <= indexFiltered && indexFiltered < iend) {
                                                        rowIndices.push(indicesSorted[indexFiltered]);
                                                    }
                                                }
                                            }
                                            else {
                                                for (var i = 0, imax = indicesFiltered.length; i < imax; ++i) {
                                                    var indexFiltered = indicesFiltered[i];
                                                    if (istart <= indexFiltered && indexFiltered < iend) {
                                                        rowIndices.push(indexFiltered);
                                                    }
                                                }
                                            }
                                        }
                                        else {
                                            if (indicesSorted) {
                                                for (var i = istart; i < iend; ++i) {
                                                    rowIndices.push(indicesSorted[i]);
                                                }
                                            }
                                            else {
                                                for (var i = istart; i < iend; ++i) {
                                                    rowIndices.push(i);
                                                }
                                            }
                                        }
                                        selection.addAll(rowIndices);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        DTableBody.prototype.onDblClick = function (e, interactionManager) {
            var result = false;
            var data = this._data;
            if (this.isActionable() && data.selection.type !== DTableDataSelectionType.NONE) {
                var local = UtilPointerEvent.toGlobal(e, interactionManager, DTableBody.WORK_ON_CLICK);
                this.toLocal(local, undefined, local, false);
                var x = local.x;
                var y = local.y;
                if (0 <= this.parent.position.y + y) {
                    var rowIndexMapped = Math.floor(y / this._rowHeight);
                    if (0 <= rowIndexMapped && rowIndexMapped < data.mapped.size()) {
                        var index = rowIndexMapped - this._rowIndexMappedStart;
                        var rows = this.children;
                        if (0 <= index && index < rows.length) {
                            var row = rows[index];
                            var cells = row.children;
                            var cellsLength = cells.length;
                            var columns = this._columns;
                            var columnsLength = columns.length;
                            for (var i = 0, imax = Math.min(cellsLength, columnsLength); i < imax; ++i) {
                                var cell = cells[cellsLength - i - 1];
                                if (cell.isActionable()) {
                                    var dx = x - cell.position.x;
                                    if (0 <= dx && dx <= cell.width) {
                                        cell.focus();
                                        if (cell instanceof DButtonBase) {
                                            cell.onClick(e);
                                        }
                                        result = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            result = _super.prototype.onDblClick.call(this, e, interactionManager) || result;
            return result;
        };
        DTableBody.prototype.getType = function () {
            return "DTableBody";
        };
        Object.defineProperty(DTableBody.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: true,
            configurable: true
        });
        DTableBody.WORK_ON_CLICK = new pixi_js.Point();
        return DTableBody;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableCategoryCell = /** @class */ (function (_super) {
        __extends(DTableCategoryCell, _super);
        function DTableCategoryCell(options) {
            return _super.call(this, options) || this;
        }
        DTableCategoryCell.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
        };
        DTableCategoryCell.prototype.getType = function () {
            return "DTableCategoryCell";
        };
        return DTableCategoryCell;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableCategory = /** @class */ (function (_super) {
        __extends(DTableCategory, _super);
        function DTableCategory(options) {
            return _super.call(this, options) || this;
        }
        DTableCategory.prototype.init = function (options) {
            this._offset = this.transform.position.y = options.offset || 0;
            _super.prototype.init.call(this, options);
        };
        DTableCategory.prototype.onParentMove = function (x, y) {
            _super.prototype.onParentMove.call(this, x, y);
            this.transform.position.y = -y + this._offset;
            this.updateFrozenCellPosition(x);
        };
        DTableCategory.prototype.getContentPositionX = function () {
            var content = this.parent;
            if (content) {
                return content.position.x;
            }
            return 0;
        };
        DTableCategory.prototype.newCell = function (column, columnIndex, columns, options) {
            return new DTableCategoryCell(this.toCellOptions(column, options));
        };
        DTableCategory.prototype.toCellOptions = function (column, options) {
            var result = options.cell;
            if (result) {
                result.weight = column.weight;
                result.width = column.width;
                var text = result.text = result.text || {};
                text.value = text.value || column.label;
                return result;
            }
            else {
                return {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        value: column.label
                    }
                };
            }
        };
        DTableCategory.prototype.getType = function () {
            return "DTableCategory";
        };
        return DTableCategory;
    }(DTableRow));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataFilterTree = /** @class */ (function (_super) {
        __extends(DTableDataFilterTree, _super);
        function DTableDataFilterTree(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._parent = parent;
            _this._filter = null;
            _this._filtered = null;
            return _this;
        }
        Object.defineProperty(DTableDataFilterTree.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataFilterTree.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataFilterTree.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataFilterTree.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataFilterTree.prototype.isFiltered = function (node, index, filter) {
            if (isFunction(filter)) {
                return filter(node, index);
            }
            else {
                return filter.test(node, index);
            }
        };
        DTableDataFilterTree.prototype.hasFiltered = function (parent, nodes, filter) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (this.isFiltered(node, -1, filter)) {
                    return true;
                }
                if (node.children != null && 0 < node.children.length && this.hasFiltered(parent, node.children, filter)) {
                    return true;
                }
            }
            return false;
        };
        DTableDataFilterTree.prototype.addAllToFiltered = function (parent, nodes, filtered, cursor) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                filtered.push(cursor[0]);
                cursor[0] += 1;
                if (node.children != null && 0 < node.children.length && parent.isOpened(node)) {
                    this.addAllToFiltered(parent, node.children, filtered, cursor);
                }
            }
        };
        DTableDataFilterTree.prototype.newFilteredSub = function (parent, nodes, filter, filtered, cursor) {
            var result = false;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                var index = cursor[0];
                cursor[0] += 1;
                var isFiltered = this.isFiltered(node, index, filter);
                if (node.children != null && 0 < node.children.length) {
                    if (parent.isOpened(node)) {
                        if (isFiltered) {
                            filtered.push(index);
                            result = true;
                            this.addAllToFiltered(parent, node.children, filtered, cursor);
                        }
                        else {
                            var position = filtered.length;
                            if (this.newFilteredSub(parent, node.children, filter, filtered, cursor)) {
                                filtered.splice(position, 0, index);
                                result = true;
                            }
                        }
                    }
                    else if (isFiltered || this.hasFiltered(parent, node.children, filter)) {
                        filtered.push(index);
                        result = true;
                    }
                }
                else if (isFiltered) {
                    filtered.push(index);
                    result = true;
                }
            }
            return result;
        };
        DTableDataFilterTree.prototype.newFiltered = function () {
            var filter = this._filter;
            if (filter != null) {
                var filtered = [];
                var parent_1 = this._parent;
                var nodes = parent_1.nodes;
                if (nodes) {
                    var cursor = [0];
                    this.newFilteredSub(parent_1, nodes, filter, filtered, cursor);
                }
                return filtered;
            }
            return null;
        };
        DTableDataFilterTree.prototype.get = function () {
            return this._filter;
        };
        DTableDataFilterTree.prototype.set = function (filter) {
            if (this._filter !== filter) {
                this._filter = filter;
            }
        };
        DTableDataFilterTree.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataFilterTree.prototype.update = function () {
            if (this._id !== this._idUpdated) {
                this._idUpdated = this._id;
                if (this._isApplied) {
                    this._filtered = this.newFiltered();
                    this.emit("change", this);
                }
                else if (this._filtered != null) {
                    this._filtered = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataFilterTree.prototype, "indices", {
            get: function () {
                this.update();
                return this._filtered;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataFilterTree.prototype.map = function (sortedIndex) {
            var result = sortedIndex;
            var indices = this.indices;
            if (indices) {
                var index = indices.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataFilterTree.prototype.unmap = function (index) {
            var result = index;
            var indices = this.indices;
            if (indices) {
                result = indices[result];
            }
            return result;
        };
        return DTableDataFilterTree;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataSorterTree = /** @class */ (function (_super) {
        __extends(DTableDataSorterTree, _super);
        function DTableDataSorterTree() {
            return _super.call(this) || this;
        }
        Object.defineProperty(DTableDataSorterTree.prototype, "id", {
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataSorterTree.prototype, "order", {
            get: function () {
                return DTableDataOrder.ASCENDING;
            },
            set: function (order) {
                // DO NOTHING
            },
            enumerable: true,
            configurable: true
        });
        DTableDataSorterTree.prototype.apply = function () {
            // DO NOTHING
        };
        DTableDataSorterTree.prototype.unapply = function () {
            // DO NOTHING
        };
        DTableDataSorterTree.prototype.isApplied = function () {
            return false;
        };
        DTableDataSorterTree.prototype.get = function () {
            return null;
        };
        DTableDataSorterTree.prototype.set = function (comparator) {
            // DO NOTHING
        };
        DTableDataSorterTree.prototype.toDirty = function () {
            // DO NOTHING
        };
        DTableDataSorterTree.prototype.update = function () {
            // DO NOTHING
        };
        Object.defineProperty(DTableDataSorterTree.prototype, "indices", {
            get: function () {
                return null;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataSorterTree.prototype.map = function (unmappedIndex) {
            return unmappedIndex;
        };
        DTableDataSorterTree.prototype.unmap = function (index) {
            return index;
        };
        return DTableDataSorterTree;
    }(pixi_js.utils.EventEmitter));

    var DTableDataTree = /** @class */ (function (_super) {
        __extends(DTableDataTree, _super);
        function DTableDataTree(options) {
            var _this = _super.call(this) || this;
            _this._parent = null;
            _this._mapped = new DTableDataListMapped(_this);
            _this._rows = [];
            _this._isRowsDirty = false;
            _this._supplimentals = [];
            _this._flags = new WeakMap();
            _this._selection = new DTableDataSelectionImpl(_this, options && options.selection);
            _this._filter = new DTableDataFilterTree(_this);
            _this._sorter = new DTableDataSorterTree();
            if (options) {
                // Filter
                var filter = options.filter;
                if (filter) {
                    _this._filter.set(filter);
                }
                // Events
                var on = options.on;
                if (on) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            // Update rows
            _this.nodes = options && options.nodes;
            return _this;
        }
        DTableDataTree.prototype.bind = function (parent) {
            this._parent = parent;
        };
        Object.defineProperty(DTableDataTree.prototype, "nodes", {
            get: function () {
                return this._nodes;
            },
            set: function (nodes) {
                this._nodes = nodes;
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "rows", {
            get: function () {
                if (this._isRowsDirty) {
                    this._isRowsDirty = false;
                    this.updateRows(this._nodes);
                }
                return this._rows;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "supplimentals", {
            get: function () {
                return this._supplimentals;
            },
            enumerable: true,
            configurable: true
        });
        DTableDataTree.prototype.updateRows = function (nodes) {
            var rows = this._rows;
            var supplimentals = this._supplimentals;
            var flags = this._flags;
            if (nodes != null) {
                var irows = this.updateRows_(nodes, 0, 0, rows, supplimentals, flags);
                if (irows !== rows.length) {
                    rows.length = irows;
                    supplimentals.length = irows;
                }
            }
            else {
                rows.length = 0;
                supplimentals.length = 0;
            }
        };
        DTableDataTree.prototype.toSupplimental = function (ilevel, hasChildren, isOpened) {
            return (ilevel << 2) | (hasChildren ? 2 : 0) | (isOpened ? 1 : 0);
        };
        DTableDataTree.prototype.updateRows_ = function (nodes, irows, ilevel, rows, supplimentals, flags) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                var children = node.children;
                var isOpened = flags.has(node);
                var supplimental = this.toSupplimental(ilevel, !!(children && 0 < children.length), isOpened);
                if (irows < rows.length) {
                    rows[irows] = node;
                    supplimentals[irows] = supplimental;
                }
                else {
                    rows.push(node);
                    supplimentals.push(supplimental);
                }
                irows += 1;
                if (isOpened && children) {
                    irows = this.updateRows_(children, irows, ilevel + 1, rows, supplimentals, flags);
                }
            }
            return irows;
        };
        DTableDataTree.prototype.update = function (forcibly) {
            var parent = this._parent;
            if (parent) {
                parent.update(forcibly);
            }
        };
        DTableDataTree.prototype.size = function () {
            return this.rows.length;
        };
        DTableDataTree.prototype.get = function (index) {
            var rows = this.rows;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        DTableDataTree.prototype.open = function (node) {
            var flags = this._flags;
            if (!flags.has(node)) {
                flags.set(node, 1);
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
            }
        };
        DTableDataTree.prototype.close = function (node) {
            var flags = this._flags;
            if (flags.has(node)) {
                flags.delete(node);
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
            }
        };
        DTableDataTree.prototype.isOpened = function (node) {
            return this._flags.has(node);
        };
        DTableDataTree.prototype.toggle = function (node) {
            var flags = this._flags;
            if (flags.has(node)) {
                flags.delete(node);
            }
            else {
                flags.set(node, 1);
            }
            this._isRowsDirty = true;
            this._filter.toDirty();
            this.update(true);
        };
        DTableDataTree.prototype.each = function (iteratee, ifrom, ito) {
            var rows = this.rows;
            ifrom = (ifrom != null ? Math.max(0, ifrom) : 0);
            ito = (ito != null ? Math.min(rows.length, ito) : rows.length);
            for (var i = ifrom; i < ito; ++i) {
                var row = rows[i];
                if (iteratee(row, i) === false) {
                    break;
                }
            }
        };
        Object.defineProperty(DTableDataTree.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "filter", {
            get: function () {
                return this._filter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "sorter", {
            get: function () {
                return this._sorter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: true,
            configurable: true
        });
        return DTableDataTree;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableHeaderCell = /** @class */ (function (_super) {
        __extends(DTableHeaderCell, _super);
        function DTableHeaderCell(options) {
            var _this = _super.call(this, options) || this;
            _this._header = options.header;
            _this._column = options.column;
            _this._comparator = options.column.sorting.comparator;
            var sorting = options.column.sorting;
            if (sorting.enable) {
                UtilPointerEvent.onClick(_this, function (e) {
                    _this.onClick();
                });
            }
            return _this;
        }
        Object.defineProperty(DTableHeaderCell.prototype, "sorter", {
            get: function () {
                var _this = this;
                var sorter = this._sorter || null;
                if (sorter == null) {
                    var table = this._header.table;
                    if (table) {
                        sorter = table.data.sorter;
                        this._sorter = sorter;
                        this._onSorterChangeBound = this._onSorterChangeBound || (function () {
                            _this.onSorterChange();
                        });
                        sorter.on("change", this._onSorterChangeBound);
                    }
                }
                return sorter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "comparator", {
            get: function () {
                return this._comparator || null;
            },
            enumerable: true,
            configurable: true
        });
        DTableHeaderCell.prototype.onClick = function () {
            var comparator = this._comparator;
            if (comparator) {
                var sorter = this.sorter;
                if (sorter) {
                    if (sorter.get() === comparator) {
                        if (sorter.order === DTableDataOrder.ASCENDING) {
                            sorter.order = DTableDataOrder.DESCENDING;
                            sorter.apply();
                        }
                        else {
                            sorter.set(null);
                            sorter.apply();
                        }
                    }
                    else {
                        sorter.set(comparator);
                        sorter.order = DTableDataOrder.ASCENDING;
                        sorter.apply();
                    }
                }
            }
        };
        DTableHeaderCell.prototype.onSorterChange = function () {
            var sorter = this._sorter;
            var comparator = this._comparator;
            if (sorter && comparator) {
                var SORTED_ASCENDING = DTableCellState.SORTED_ASCENDING;
                var SORTED_DESCENDING = DTableCellState.SORTED_DESCENDING;
                if (sorter.isApplied() && sorter.get() === comparator) {
                    if (sorter.order === DTableDataOrder.ASCENDING) {
                        this.setStates(SORTED_ASCENDING, SORTED_DESCENDING);
                    }
                    else {
                        this.setStates(SORTED_DESCENDING, SORTED_ASCENDING);
                    }
                }
                else {
                    this.setState(SORTED_ASCENDING | SORTED_DESCENDING, false);
                }
            }
        };
        DTableHeaderCell.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
        };
        DTableHeaderCell.prototype.getType = function () {
            return "DTableHeaderCell";
        };
        DTableHeaderCell.prototype.destroy = function () {
            var sorter = this._sorter;
            var onSorterChangeBound = this._onSorterChangeBound;
            if (sorter && onSorterChangeBound) {
                sorter.off("change", onSorterChangeBound);
            }
            this._sorter = undefined;
            this._onSorterChangeBound = undefined;
            this._comparator = undefined;
            _super.prototype.destroy.call(this);
        };
        return DTableHeaderCell;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableHeader = /** @class */ (function (_super) {
        __extends(DTableHeader, _super);
        function DTableHeader(options) {
            return _super.call(this, options) || this;
        }
        DTableHeader.prototype.init = function (options) {
            var _a;
            this._table = options.table || null;
            this._offset = this.transform.position.y = options.offset || 0;
            this._frozen = (_a = options.frozen) !== null && _a !== void 0 ? _a : 0;
            _super.prototype.init.call(this, options);
        };
        Object.defineProperty(DTableHeader.prototype, "table", {
            get: function () {
                return this._table;
            },
            enumerable: true,
            configurable: true
        });
        DTableHeader.prototype.onParentMove = function (x, y) {
            _super.prototype.onParentMove.call(this, x, y);
            this.transform.position.y = -y + this._offset;
            this.updateFrozenCellPosition(x);
        };
        DTableHeader.prototype.getContentPositionX = function () {
            var content = this.parent;
            if (content) {
                return content.position.x;
            }
            return 0;
        };
        DTableHeader.prototype.newCell = function (column, columnIndex, columns, options) {
            return new DTableHeaderCell(this.toCellOptions(column, options));
        };
        DTableHeader.prototype.toCellOptions = function (column, options) {
            var result = column.header || options.cell;
            if (result != null) {
                if (result.weight === undefined) {
                    result.weight = column.weight;
                }
                if (result.width === undefined) {
                    result.width = column.width;
                }
                if (result.text === undefined) {
                    result.text = {
                        value: column.label
                    };
                }
                else if (result.text.value === undefined) {
                    result.text.value = column.label;
                }
                if (result.header === undefined) {
                    result.header = this;
                }
                if (result.column === undefined) {
                    result.column = column;
                }
                return result;
            }
            else {
                return {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        value: column.label
                    },
                    header: this,
                    column: column
                };
            }
        };
        DTableHeader.prototype.getType = function () {
            return "DTableHeader";
        };
        return DTableHeader;
    }(DTableRow));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var defaultGetter$1 = function (row, columnIndex) {
        return row[columnIndex];
    };
    var defaultSetter$1 = function (row, columnIndex, cell) {
        row[columnIndex] = cell;
    };
    var defaultGetterEmpty = function () { return ""; };
    var defaultSetterEmpty = function () {
        // DO NOTHING
    };
    var toPathGetter = function (path, def) {
        if (path.length <= 1) {
            var key_1 = path[0];
            if (def === undefined) {
                return function (row) {
                    return row[key_1];
                };
            }
            else {
                return function (row) {
                    return key_1 in row ? row[key_1] : def;
                };
            }
        }
        else {
            if (def === undefined) {
                return function (row) {
                    for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                        row = row[path[i]];
                    }
                    return row[path[path.length - 1]];
                };
            }
            else {
                return function (row) {
                    for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                        row = row[path[i]];
                    }
                    var key = path[path.length - 1];
                    return key in row ? row[key] : def;
                };
            }
        }
    };
    var toPathSetter = function (path) {
        if (path.length <= 1) {
            var key_2 = path[0];
            return function (row, columnIndex, cell) {
                row[key_2] = cell;
            };
        }
        else {
            return function (row, columnIndex, cell) {
                for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                    row = row[path[i]] || {};
                }
                row[path[path.length - 1]] = cell;
            };
        }
    };
    var defaultEditingUnformatter = function (formatted) {
        return formatted;
    };
    var toColumnAlign = function (options, type) {
        if (options.align != null) {
            if (isString(options.align)) {
                return DAlignHorizontal[options.align];
            }
            else {
                return options.align;
            }
        }
        switch (type) {
            case DTableColumnType.TEXT:
                return DAlignHorizontal.LEFT;
            case DTableColumnType.REAL:
            case DTableColumnType.INTEGER:
                return DAlignHorizontal.RIGHT;
            case DTableColumnType.BUTTON:
            case DTableColumnType.INDEX:
            case DTableColumnType.SELECT:
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return DAlignHorizontal.CENTER;
            default:
                return DAlignHorizontal.LEFT;
        }
    };
    var toColumnDataChecker = function (path) {
        if (path != null) {
            if (path.length <= 1) {
                var key_3 = path[0];
                return function (row) {
                    return key_3 in row;
                };
            }
            else {
                return function (row) {
                    for (var i = 0, imax = path.length; i < imax; ++i) {
                        var part = path[i];
                        if (part in row) {
                            row = row[part];
                        }
                        else {
                            return false;
                        }
                    }
                    return true;
                };
            }
        }
        return function (row, columnIndex) {
            return columnIndex < row.length;
        };
    };
    var toColumnEditingEnable = function (enable, path) {
        if (isString(enable)) {
            return toColumnDataChecker(path);
        }
        else if (enable != null) {
            return enable;
        }
        else {
            return false;
        }
    };
    var toColumnEditing = function (options, path) {
        var editing = options.editing;
        if (editing) {
            return {
                enable: toColumnEditingEnable(editing.enable != null ? editing.enable : options.editable, path),
                formatter: editing.formatter || toString,
                unformatter: editing.unformatter || defaultEditingUnformatter,
                validator: editing.validator
            };
        }
        return {
            enable: toColumnEditingEnable(options.editable, path),
            formatter: toString,
            unformatter: defaultEditingUnformatter
        };
    };
    var toComparator = function (getter, index) {
        return function (rowA, rowB) {
            var valueA = getter(rowA, index);
            var valueB = getter(rowB, index);
            return (valueA < valueB ? -1 : (valueB < valueA ? +1 : 0));
        };
    };
    var toColumnSorting = function (getter, index, options) {
        var sorting = options.sorting;
        if (sorting) {
            var enable = sorting.enable === true || options.sortable === true;
            if (enable) {
                return {
                    enable: enable,
                    comparator: sorting.comparator || toComparator(getter, index)
                };
            }
            else {
                return {
                    enable: enable
                };
            }
        }
        if (options.sortable === true) {
            return {
                enable: true,
                comparator: toComparator(getter, index)
            };
        }
        else {
            return {
                enable: false
            };
        }
    };
    var toColumnMenu = function (options) {
        if (options == null) {
            return undefined;
        }
        else if (options instanceof DMenu) {
            return options;
        }
        else {
            return new DMenu(options);
        }
    };
    var toColumnDialog = function (options) {
        if (options == null) {
            return undefined;
        }
        else if ("open" in options) {
            return options;
        }
        else {
            return new DDialogSelect(options);
        }
    };
    var defaultSelectingGetter = function (dialog) {
        return dialog.value;
    };
    var defaultSelectingSetter = function () {
        // DO NOTHING
    };
    var toColumnSelecting = function (options) {
        if (options) {
            return {
                getter: options.getter || defaultSelectingGetter,
                setter: options.setter || defaultSelectingSetter,
                menu: toColumnMenu(options.menu),
                multiple: toColumnMenu(options.multiple),
                dialog: toColumnDialog(options.dialog),
                promise: options.promise
            };
        }
        return {
            getter: defaultSelectingGetter,
            setter: defaultSelectingSetter
        };
    };
    var toColumnGetter = function (options, type, parts) {
        var getter = options.getter;
        if (getter) {
            return getter;
        }
        switch (type) {
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return defaultGetterEmpty;
            default:
                if (parts == null) {
                    return defaultGetter$1;
                }
                else {
                    return toPathGetter(parts, options.default);
                }
        }
    };
    var toColumnSetter = function (options, type, path) {
        var setter = options.setter;
        if (setter) {
            return setter;
        }
        switch (type) {
            case DTableColumnType.BUTTON:
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return defaultSetterEmpty;
            default:
                if (path == null) {
                    return defaultSetter$1;
                }
                else {
                    return toPathSetter(path);
                }
        }
    };
    var toColumnPath = function (options) {
        return options.path != null ? options.path.split(".") : null;
    };
    var toColumnRenderable = function (options, path) {
        var renderable = options.renderable;
        if (isString(renderable)) {
            return toColumnDataChecker(path);
        }
        else if (renderable != null) {
            return renderable;
        }
        return true;
    };
    var toColumn = function (index, options) {
        var weight = (options.weight != null ? options.weight :
            (options.width != null ? undefined : +1));
        var width = (weight != null ? undefined :
            (options.width != null ? options.width : 100));
        var type = (options.type != null ?
            (isString(options.type) ? DTableColumnType[options.type] : options.type) :
            DTableColumnType.TEXT);
        var align = toColumnAlign(options, type);
        var label = options.label || "";
        var path = toColumnPath(options);
        var getter = toColumnGetter(options, type, path);
        var setter = toColumnSetter(options, type, path);
        return {
            weight: weight,
            width: width,
            type: type,
            label: label,
            getter: getter,
            setter: setter,
            formatter: options.formatter,
            renderable: toColumnRenderable(options, path),
            align: align,
            editing: toColumnEditing(options, path),
            sorting: toColumnSorting(getter, index, options),
            header: options.header,
            body: options.body,
            selecting: toColumnSelecting(options.selecting),
            category: options.category,
            frozen: options.frozen,
            offset: 0.0,
            link: options.link
        };
    };
    var toColumns = function (options) {
        var result = [];
        for (var i = 0, imax = options.length; i < imax; ++i) {
            result.push(toColumn(i, options[i]));
        }
        return result;
    };
    var toFrozen = function (columns) {
        for (var i = columns.length - 1; 0 <= i; --i) {
            if (columns[i].frozen === true) {
                return i + 1;
            }
        }
        return 0;
    };
    var DTable = /** @class */ (function (_super) {
        __extends(DTable, _super);
        function DTable(options) {
            return _super.call(this, options) || this;
        }
        DTable.prototype.init = function (options) {
            // Column
            var columns = toColumns(options.columns);
            // Frozen
            var frozen = toFrozen(columns);
            // Categories
            var categories = this.newCategories(options, columns, frozen);
            this._categories = categories;
            // Header
            var headerOffset = 0;
            for (var i = 0, imax = categories.length; i < imax; ++i) {
                headerOffset += categories[i].height;
            }
            var header = this.newHeader(options, columns, frozen, headerOffset);
            this._header = header;
            // Body
            var bodyOffset = headerOffset + ((header && header.height) || 0);
            var body = this.newBody(options, columns, frozen, bodyOffset);
            this._body = body;
            // Super
            _super.prototype.init.call(this, options);
            // Content
            var content = this._content;
            content.setWidth(this.toContentWidth(options));
            content.addChild(body);
            if (header) {
                content.addChild(header);
            }
            for (var i = categories.length - 1; 0 <= i; --i) {
                content.addChild(categories[i]);
            }
            content.on("move", function () {
                body.update();
            });
            content.on("resize", function () {
                body.update();
            });
            if (body.data.selection.type !== DTableDataSelectionType.NONE) {
                UtilPointerEvent.onClick(this, function (e) {
                    body.onRowClicked(e);
                });
            }
            body.update();
        };
        DTable.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var body = this._body;
            body.lock();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            body.update();
            body.unlock(true);
        };
        DTable.prototype.getCategoryCount = function (columns) {
            var result = 0;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                var category = columns[i].category;
                if (category != null) {
                    var count = isString(category) ? 1 : category.length;
                    result = Math.max(result, count);
                }
            }
            return result;
        };
        DTable.prototype.toCategoryLabel = function (index, category) {
            if (category) {
                if (isString(category)) {
                    if (index === 0) {
                        return category;
                    }
                }
                else {
                    if (index < category.length) {
                        return category[index];
                    }
                }
            }
            return undefined;
        };
        DTable.prototype.isSameCategory = function (index, a, b) {
            if (a != null) {
                if (b != null) {
                    if (isString(a)) {
                        if (isString(b)) {
                            if (0 < index) {
                                return true;
                            }
                            else {
                                return a === b;
                            }
                        }
                        else {
                            if (0 < index) {
                                return b.length <= index;
                            }
                            else {
                                return b.length === 1 && a === b[0];
                            }
                        }
                    }
                    else {
                        if (isString(b)) {
                            if (0 < index) {
                                return a.length <= index;
                            }
                            else {
                                return a.length === 1 && a[0] === b;
                            }
                        }
                        else {
                            if (a.length <= index && b.length <= index) {
                                return true;
                            }
                            else if (b.length === a.length) {
                                for (var i = index, imax = a.length; i < imax; ++i) {
                                    if (a[i] !== b[i]) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                            return false;
                        }
                    }
                }
                else {
                    if (isString(a)) {
                        if (0 < index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (a.length <= index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
            }
            else {
                if (b != null) {
                    if (isString(b)) {
                        if (0 < index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (b.length <= index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    return true;
                }
            }
        };
        DTable.prototype.toCategoryColumns = function (index, columns, frozen) {
            var result = [];
            var tcolumn = null;
            var ccolumn = null;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                var column = columns[i];
                if (i !== frozen && ccolumn && tcolumn && this.isSameCategory(index, tcolumn.category, column.category)) {
                    if (ccolumn.weight != null && column.weight != null) {
                        ccolumn.weight += column.weight;
                    }
                    else if (ccolumn.width != null && column.width != null) {
                        ccolumn.width += column.width;
                    }
                    else {
                        tcolumn = column;
                        ccolumn = {
                            label: this.toCategoryLabel(index, column.category),
                            weight: column.weight,
                            width: column.width,
                            offset: 0.0
                        };
                        result.push(ccolumn);
                    }
                }
                else {
                    tcolumn = column;
                    ccolumn = {
                        label: this.toCategoryLabel(index, column.category),
                        weight: column.weight,
                        width: column.width,
                        offset: 0.0
                    };
                    result.push(ccolumn);
                }
            }
            return result;
        };
        DTable.prototype.toCategoryOptions = function (index, options, columns, frozen, offset) {
            if (options) {
                if (options.columns === undefined) {
                    options.columns = this.toCategoryColumns(index, columns, frozen);
                }
                if (options.frozen == null) {
                    options.frozen = frozen;
                }
                if (options.offset == null) {
                    options.offset = offset;
                }
                return options;
            }
            return {
                columns: this.toCategoryColumns(index, columns, frozen),
                frozen: frozen,
                offset: offset
            };
        };
        DTable.prototype.newCategories = function (options, columns, frozen) {
            var count = this.getCategoryCount(columns);
            var result = [];
            var offset = 0;
            for (var i = count - 1; 0 <= i; --i) {
                var category = new DTableCategory(this.toCategoryOptions(i, options.category, columns, frozen, offset));
                result.push(category);
                offset += category.height;
            }
            return result;
        };
        DTable.prototype.onDblClick = function (e, interactionManager) {
            var result = this._body.onDblClick(e, interactionManager);
            return _super.prototype.onDblClick.call(this, e, interactionManager) || result;
        };
        DTable.prototype.getScrollBarOffsetVerticalStart = function (size) {
            return size * 0.5 + this._body.position.y;
        };
        DTable.prototype.toContentWidth = function (options) {
            var columnWidthTotal = 0;
            var columns = options.columns;
            if (columns) {
                for (var i = 0, imax = columns.length; i < imax; ++i) {
                    var column = columns[i];
                    var columnWidth = column.width;
                    if (columnWidth != null) {
                        columnWidthTotal += columnWidth;
                    }
                }
            }
            if (0 < columnWidthTotal) {
                return function (p) {
                    return Math.max(p, columnWidthTotal);
                };
            }
            return "100%";
        };
        DTable.prototype.hasHeader = function (options) {
            var columns = options.columns;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                if (columns[i].label != null) {
                    return true;
                }
            }
            return false;
        };
        DTable.prototype.newHeader = function (options, columns, frozen, offset) {
            if (this.hasHeader(options)) {
                return new DTableHeader(this.toHeaderOptions(options.header, columns, frozen, offset));
            }
            return null;
        };
        DTable.prototype.toHeaderOptions = function (options, columns, frozen, offset) {
            if (options) {
                if (options.columns === undefined) {
                    options.columns = columns;
                }
                if (options.frozen == null) {
                    options.frozen = frozen;
                }
                if (options.offset === undefined) {
                    options.offset = offset;
                }
                if (options.table === undefined) {
                    options.table = this;
                }
                return options;
            }
            return {
                columns: columns,
                frozen: frozen,
                offset: offset,
                table: this
            };
        };
        DTable.prototype.newBody = function (options, columns, frozen, offset) {
            return new DTableBody(this.toBodyOptions(options.body, columns, frozen, offset, options.data));
        };
        DTable.prototype.toBodyOptions = function (options, columns, frozen, offset, data) {
            if (options != null) {
                if (options.columns === undefined) {
                    options.columns = columns;
                }
                if (options.frozen == null) {
                    options.frozen = frozen;
                }
                if (options.offset === undefined) {
                    options.offset = offset;
                }
                if (options.data === undefined && data !== undefined) {
                    if (isArray(data)) {
                        options.data = {
                            rows: data
                        };
                    }
                    else {
                        options.data = data;
                    }
                }
                if (options.height === undefined && options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            if (isArray(data)) {
                return {
                    columns: columns,
                    frozen: frozen,
                    offset: offset,
                    data: {
                        rows: data
                    },
                    weight: 1
                };
            }
            else {
                return {
                    columns: columns,
                    frozen: frozen,
                    offset: offset,
                    data: data,
                    weight: 1
                };
            }
        };
        DTable.prototype.getType = function () {
            return "DTable";
        };
        Object.defineProperty(DTable.prototype, "categories", {
            get: function () {
                return this._categories;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTable.prototype, "header", {
            get: function () {
                return this._header;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTable.prototype, "body", {
            get: function () {
                return this._body;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DTable.prototype, "data", {
            get: function () {
                return this._body.data;
            },
            enumerable: true,
            configurable: true
        });
        return DTable;
    }(DPane));

    /**
     * Tree item states.
     */
    var DTreeItemState = {
        /**
         * the parent item is expanded
         */
        EXPANDED: DBaseState.CUSTOM << 0,
        /**
         * the parent item is collapsed
         */
        COLLAPSED: DBaseState.CUSTOM << 1,
        /**
         * the child item is selected
         */
        SELECTED: DBaseState.CUSTOM << 2
    };

    var DTreeItemTextAndImage = /** @class */ (function (_super) {
        __extends(DTreeItemTextAndImage, _super);
        function DTreeItemTextAndImage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTreeItemTextAndImage.prototype.getType = function () {
            return "DTreeItemTextAndImage";
        };
        return DTreeItemTextAndImage;
    }(DImage));

    var DTreeItemToggleIcon = /** @class */ (function (_super) {
        __extends(DTreeItemToggleIcon, _super);
        function DTreeItemToggleIcon() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTreeItemToggleIcon.prototype.getType = function () {
            return "DTreeItemToggleIcon";
        };
        return DTreeItemToggleIcon;
    }(DImage));

    var toText = function (options) {
        if (options) {
            return options.text;
        }
        return "";
    };
    var isParent = function (options) {
        return !!(options && options.isParent);
    };
    var isExpanded = function (options) {
        return !!(options && options.expanded);
    };
    var toImage = function (options) {
        return options && options.image ? options.image : null;
    };
    var toYCoordinate = function (options) {
        return options ? options.y : 0;
    };
    var toRawData = function (options) {
        return options ? options.rawData : {
            text: "",
            children: []
        };
    };
    var toPaddingLeft = function (theme, options) {
        var level = options ? options.level : 0;
        return theme.getPaddingByLevel(level);
    };
    var toTreeItemTextAndImage = function (options) {
        return new DTreeItemTextAndImage({
            text: {
                value: toText(options)
            },
            image: {
                source: toImage(options)
            }
        });
    };
    var DTreeItem = /** @class */ (function (_super) {
        __extends(DTreeItem, _super);
        function DTreeItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTreeItem.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            // get isParent option
            this._isParent = isParent(options);
            // get isExpand option
            this._isExpanded = isExpanded(options);
            // get raw data
            this._rawData = toRawData(options);
            this._icon = new DTreeItemToggleIcon();
            this._textAndImage = toTreeItemTextAndImage(options);
            this.addChild(this._icon);
            this.addChild(this._textAndImage);
            this._icon.on(UtilPointerEvent.down, function () {
                _this.onToggle();
            });
            this._textAndImage.on(UtilPointerEvent.down, function (e) {
                _this.onSelect(e);
            });
            // update states
            this.updateStates(false);
        };
        DTreeItem.prototype.onSelect = function (e) {
            this.emit("select", e);
        };
        DTreeItem.prototype.onToggle = function () {
            this.emit("toggle");
        };
        DTreeItem.prototype.isExpanded = function () {
            return this._isExpanded;
        };
        DTreeItem.prototype.isParent = function () {
            return this._isParent;
        };
        DTreeItem.prototype.getRawData = function () {
            return this._rawData;
        };
        DTreeItem.prototype.update = function (options, isActive) {
            this._textAndImage.text = toText(options);
            this._textAndImage.image = toImage(options);
            this._rawData = toRawData(options);
            this._padding.left = toPaddingLeft(this.theme, options);
            this.position.y = toYCoordinate(options);
            this._isParent = isParent(options);
            this._isExpanded = isExpanded(options);
            this.updateStates(isActive);
            return this;
        };
        DTreeItem.prototype.updateActiveState = function (isActive) {
            this.setActive(isActive);
            this._icon.setState(DTreeItemState.SELECTED, isActive);
            this._textAndImage.setState(DTreeItemState.SELECTED, isActive);
        };
        DTreeItem.prototype.updateStates = function (isActive) {
            this.updateActiveState(isActive);
            this._icon.setState(DTreeItemState.COLLAPSED, !this._isExpanded && this._isParent);
            this._icon.setState(DTreeItemState.EXPANDED, !!this._isExpanded && this._isParent);
        };
        DTreeItem.prototype.getType = function () {
            return "DTreeItem";
        };
        return DTreeItem;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeSelection = /** @class */ (function () {
        function DTreeSelection() {
            this._selection = [];
        }
        /**
         * Select an item.
         * Add item data to this._selection if it not exist in this._selection.
         *
         * @param item Reference data of item want to remove in “value” array.
         */
        DTreeSelection.prototype.add = function (item) {
            if (this._selection.indexOf(item) === -1) {
                this._selection.push(item);
            }
        };
        /**
         * Un-select an item.
         * remove item data to this._selection if it exist in this._selection.
         *
         * @param item Reference data of item want to remove in “value” array.
         */
        DTreeSelection.prototype.remove = function (item) {
            var itemIndex = this._selection.indexOf(item);
            if (itemIndex !== -1) {
                this._selection.splice(itemIndex, 1);
            }
        };
        /**
         * Select/un-select an item.
         * If item data not exist in this._selection, add it to this._selection.
         * If item data exist in this._selection, remove it to this._selection.
         *
         * @param item Reference data of item want to remove in “value” array.
         */
        DTreeSelection.prototype.toggle = function (item) {
            var itemIndex = this._selection.indexOf(item);
            if (itemIndex !== -1) {
                this._selection.splice(itemIndex, 1);
            }
            else {
                this._selection.push(item);
            }
        };
        /**
         * Un-select all item.
         *
         */
        DTreeSelection.prototype.clear = function () {
            this._selection.length = 0;
        };
        /**
         * Get selected item by index.
         *
         * @param index index of item in this._selection
         *
         * @returns  Reference data of selected item in “value” array.
         */
        DTreeSelection.prototype.get = function (index) {
            var selection = this._selection;
            if (0 <= index && index < selection.length) {
                return selection[index];
            }
            return null;
        };
        /**
         * Check item is selected or not.
         *
         * @param item Reference data of item want to remove in “value” array.
         *
         * @returns selected state of checked item.
         */
        DTreeSelection.prototype.contains = function (item) {
            return this._selection.indexOf(item) !== -1;
        };
        /**
         * Get number of selected .
         *
         * @returns number of selected.
         */
        DTreeSelection.prototype.size = function () {
            return this._selection.length;
        };
        /**
         * Iterate over selected items.
         *
         * @param iteratee  boolean function. If the iteratee explicitly returns false, an iteration stops.
         * @param item data of browsed item.
         */
        DTreeSelection.prototype.each = function (iteratee) {
            for (var _i = 0, _a = this._selection; _i < _a.length; _i++) {
                var item = _a[_i];
                if (!iteratee(item)) {
                    return;
                }
            }
        };
        return DTreeSelection;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeAddedItemPosition;
    (function (DTreeAddedItemPosition) {
        DTreeAddedItemPosition[DTreeAddedItemPosition["BEFORE"] = 0] = "BEFORE";
        DTreeAddedItemPosition[DTreeAddedItemPosition["AFTER"] = 1] = "AFTER";
    })(DTreeAddedItemPosition || (DTreeAddedItemPosition = {}));
    var DTree = /** @class */ (function (_super) {
        __extends(DTree, _super);
        function DTree() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTree.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._itemOptions = new WeakMap();
            this._selection = new DTreeSelection();
            this._itemOptionsShowable = [];
            this._itemIndexMappedStart = 0;
            this._itemIndexMappedEnd = 0;
            this._itemY = 0;
            var itemTheme = DThemes.getInstance().get("DTreeItem");
            this._itemHeight = Number(itemTheme.getHeight());
            this._value = options && options.value ? options.value : [];
            this.updateData(null, this._value, 0);
            this._content.on("move", function () {
                _this.update();
            });
            this._content.on("resize", function () {
                _this._content.removeChildren();
                _this.update();
            });
            this.update();
        };
        DTree.prototype.update = function () {
            var _this = this;
            var content = this._content;
            var items = content.children;
            // calculate content height
            content.height = this._itemOptionsShowable.length * this._itemHeight;
            var contentY = content.position.y;
            var height = this.height;
            var itemIndexMappedStart = (0 - contentY) / this._itemHeight - 2 < 0 ?
                0 :
                Math.floor((0 - contentY) / this._itemHeight) - 2;
            var itemIndexMappedEnd = (height - contentY) / this._itemHeight + 2 < this._itemOptionsShowable.length - 1 ?
                Math.floor((height - contentY) / this._itemHeight) + 2 :
                this._itemOptionsShowable.length;
            // get items options are shown in Dpane content frame
            var itemOptionsShown = this._itemOptionsShowable.slice(itemIndexMappedStart, itemIndexMappedEnd);
            if (items.length < itemOptionsShown.length) {
                var _loop_1 = function (i) {
                    var itemOptions = itemOptionsShown[i];
                    var treeItem = new DTreeItem(itemOptions);
                    content.addChild(treeItem);
                    // listen select item event
                    treeItem.on("select", function (e) {
                        if (!_this.isDisabled()) {
                            _this.onSelect(treeItem.getRawData(), e);
                        }
                    });
                    // listen toggle item event
                    treeItem.on("toggle", function () {
                        if (treeItem.isParent()) {
                            if (!_this.isDisabled()) {
                                _this.toggle(treeItem.getRawData());
                            }
                        }
                    });
                };
                for (var i = items.length; i < itemOptionsShown.length; i++) {
                    _loop_1(i);
                }
            }
            else if (items.length > itemOptionsShown.length) {
                for (var i = itemOptionsShown.length; i < items.length; i++) {
                    items[i].hide();
                }
            }
            for (var i = 0; i < itemOptionsShown.length; i++) {
                items[i] = items[i].update(itemOptionsShown[i], this._selection.contains(itemOptionsShown[i].rawData));
                if (items[i].isHidden()) {
                    items[i].show();
                }
            }
        };
        DTree.prototype.reload = function (expandAll) {
            // reset data of tree widget
            this._itemOptionsShowable.length = 0;
            this._itemY = 0;
            // re-render tree
            this.updateData(null, this._value, 0, expandAll);
            this.update();
        };
        Object.defineProperty(DTree.prototype, "value", {
            /**
             * Getter method to access raw data.
             *
             * @returns raw data.
             */
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Toggle an tree parent item,
         * Expand an collapsed tree item or collapse an expanded item.
         *
         * @param item Reference data of item want to toggle in “value” array.
         */
        DTree.prototype.toggle = function (item) {
            var itemOptions = this._itemOptions.get(item);
            if (itemOptions) {
                itemOptions.expanded = !itemOptions.expanded;
                this.reload();
            }
        };
        /**
         * Expand a collapsed tree item.
         *
         * @param item Reference data of item want to expand in “value” array.
         */
        DTree.prototype.expand = function (item) {
            var itemOptions = this._itemOptions.get(item);
            if (itemOptions) {
                itemOptions.expanded = true;
                this.reload();
            }
        };
        /**
         * Collapse an expanded tree item.
         *
         * @param item Reference data of item want to collapse in “value” array.
         */
        DTree.prototype.collapse = function (item) {
            var itemOptions = this._itemOptions.get(item);
            if (itemOptions) {
                itemOptions.expanded = false;
                this.reload();
            }
        };
        /**
         * Expand all tree item.
         */
        DTree.prototype.expandAll = function () {
            this.reload(true);
        };
        /**
         * Collapse all tree item.
         */
        DTree.prototype.collapseAll = function () {
            this.reload(false);
        };
        /**
         * Check if an item is collapsed.
         *
         * @param item Reference data of item want to check in “value” array.
         *
         * @returns collapse status of the item.
         */
        DTree.prototype.isCollapsed = function (item) {
            var itemOptions = this._itemOptions.get(item);
            return itemOptions && !itemOptions.expanded;
        };
        /**
         * Check if an item is expanded.
         *
         * @param item Reference data of item want to check in “value” array.
         *
         * @returns expand status of the item.
         */
        DTree.prototype.isExpanded = function (item) {
            var itemOptions = this._itemOptions.get(item);
            return itemOptions && itemOptions.expanded;
        };
        /**
         * Clear all tree item.
         */
        DTree.prototype.clear = function () {
            this._value = [];
            this.reload();
        };
        /**
         * Remove a tree item
         *
         * @param item Reference data of item want to remove in “value” array.
         */
        DTree.prototype.remove = function (item) {
            this._removeItem = item;
            this.reload();
        };
        /**
         * Add a tree item
         *
         * @param item data of new item want to add to tree.
         * @param parent Reference data of parent item will contain the adding item.
         * If the parent is undefined, the item will be added at the top level.
         * If the parent is not undefined, the item will be inserted as a child of the given parent item.
         */
        DTree.prototype.add = function (item, parent) {
            if (parent) {
                if (parent.children) {
                    parent.children.push(item);
                }
                else {
                    parent.children = [item];
                }
            }
            else {
                this._value.push(item);
            }
            this.reload();
        };
        /**
         * Add the given item will be inserted before the given sibling item.
         *
         * @param item data of new item want to add to tree.
         * @param sibling Reference data of parent item will be using like anchor to add new item.
         */
        DTree.prototype.addBefore = function (item, sibling) {
            this._addItemOptions = {
                item: item,
                sibling: sibling,
                positon: DTreeAddedItemPosition.BEFORE
            };
            this.reload();
        };
        /**
         * Add the given item will be inserted after the given sibling item.
         *
         * @param item data of new item want to add to tree.
         * @param sibling Reference data of parent item will be using like anchor to add new item.
         */
        DTree.prototype.addAfter = function (item, sibling) {
            this._addItemOptions = {
                item: item,
                sibling: sibling,
                positon: DTreeAddedItemPosition.AFTER
            };
            this.reload();
        };
        /**
         * Iterate over all the items.
         *
         * @param iteratee  boolean function. If the iteratee explicitly returns false, an iteration stops.
         * @param item data of browsed item.
         */
        DTree.prototype.each = function (iteratee) {
            this.inOrder(this._value, iteratee);
        };
        /**
         * The recursive function performs item browsing in the tree.
         */
        DTree.prototype.inOrder = function (items, iteratee) {
            for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                var item = items_1[_i];
                if (!iteratee(item)) {
                    return;
                }
                else if (item.children) {
                    this.inOrder(item.children, iteratee);
                }
            }
        };
        Object.defineProperty(DTree.prototype, "selection", {
            /**
             * Get selection object.
             * @returns selection.
             */
            get: function () {
                return this._selection;
            },
            enumerable: true,
            configurable: true
        });
        DTree.prototype.updateData = function (parentItemOptions, items, level, expandAll) {
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                // handle remove item
                if (item === this._removeItem) {
                    // remove item from this._value.
                    items.splice(i, 1);
                    this._removeItem = null;
                    i--;
                    if (parentItemOptions && items.length === 0) {
                        parentItemOptions.isParent = false;
                    }
                    continue;
                }
                // handle add item
                if (this._addItemOptions && item === this._addItemOptions.sibling) {
                    if (this._addItemOptions.positon === DTreeAddedItemPosition.AFTER) {
                        items.splice(i + 1, 0, this._addItemOptions.item);
                        this._addItemOptions = null;
                    }
                    else if (this._addItemOptions.positon === DTreeAddedItemPosition.BEFORE) {
                        items.splice(i, 0, this._addItemOptions.item);
                        i--;
                        this._addItemOptions = null;
                        continue;
                    }
                }
                var isParent = item.children && (item.children.length > 0);
                var text = item.text ? item.text : "";
                var itemImage = item.image ? item.image : null;
                var isItemExisted = false;
                var itemOptions = this._itemOptions.get(item);
                var expanded = false; // set default expand status of item is false
                if (expandAll != null) {
                    expanded = expandAll;
                }
                else if (itemOptions) {
                    expanded = itemOptions.expanded;
                }
                if (itemOptions != null) {
                    itemOptions.rawData = item;
                    itemOptions.text = text;
                    itemOptions.y = this._itemY;
                    itemOptions.isParent = isParent;
                    itemOptions.expanded = expanded;
                    itemOptions.image = itemImage;
                    isItemExisted = true;
                }
                else {
                    itemOptions = {
                        rawData: item,
                        text: text,
                        level: level,
                        y: this._itemY,
                        isParent: isParent,
                        expanded: expanded,
                        image: itemImage
                    };
                }
                /* displayed items need to satisfy 1 of the 2 conditions:
                1. is root item
                2. the parent item is show and expand
                */
                if (parentItemOptions == null ||
                    (parentItemOptions &&
                        parentItemOptions.expanded &&
                        parentItemOptions.showable)) {
                    itemOptions.showable = true;
                    this._itemOptionsShowable.push(itemOptions);
                    this._itemY += this._itemHeight;
                }
                else {
                    itemOptions.showable = false;
                }
                if (!isItemExisted) {
                    this._itemOptions.set(item, itemOptions);
                }
                if (item && item.children) {
                    this.updateData(itemOptions, item.children, level + 1, expandAll);
                }
            }
        };
        DTree.prototype.onSelect = function (item, e) {
            var _this = this;
            var _a, _b;
            // multi select by "ctr" key + click
            if (e.data.originalEvent.ctrlKey) {
                this._selection.toggle(item);
                // multi select by "shift" key + click
            }
            else if (e.data.originalEvent.shiftKey) {
                var lastSelection = this._selection.get(this._selection.size() - 1);
                if (lastSelection) {
                    this._selection.clear();
                    var selectionY = Number((_a = this._itemOptions.get(item)) === null || _a === void 0 ? void 0 : _a.y);
                    var lastSelectionY = Number((_b = this._itemOptions.get(lastSelection)) === null || _b === void 0 ? void 0 : _b.y);
                    var maxY_1 = selectionY < lastSelectionY ?
                        lastSelectionY - this._itemHeight :
                        selectionY;
                    var minY_1 = selectionY < lastSelectionY ?
                        selectionY :
                        lastSelectionY + this._itemHeight;
                    this._itemOptionsShowable.every(function (itemOptions) {
                        if (itemOptions.y >= minY_1 && itemOptions.y <= maxY_1 && itemOptions.showable) {
                            _this._selection.add(itemOptions.rawData);
                        }
                        return itemOptions.y < maxY_1;
                    });
                    this._selection.add(lastSelection);
                }
                // single select
            }
            else {
                this._selection.clear();
                this._selection.add(item);
            }
            this.updateActiveState();
        };
        /* update active state of all shown item.
        *
        **/
        DTree.prototype.updateActiveState = function () {
            var _this = this;
            var items = this._content.children;
            items.forEach(function (item) {
                item.updateActiveState(_this._selection.contains(item.getRawData()));
            });
        };
        DTree.prototype.getType = function () {
            return "DTree";
        };
        return DTree;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */

    var ui = ({
        __proto__: null,
        DInputIntegerAndLabel: DInputIntegerAndLabel,
        loadAll: loadAll,
        loadMenuItemAll: loadMenuItemAll,
        loadMenuItemExpandable: loadMenuItemExpandable,
        loadMenuItem: loadMenuItem,
        loadMenuSidedItemExpandable: loadMenuSidedItemExpandable,
        loadMenuSidedItem: loadMenuSidedItem,
        ESnapperGrid: ESnapperGrid,
        ESnapperResultScale: ESnapperResultScale,
        ESnapperResult: ESnapperResult,
        get ESnapperTargetValueType () { return ESnapperTargetValueType; },
        ESnapperTargetValue: ESnapperTargetValue,
        ESnapperTarget: ESnapperTarget,
        get ESnapperModifierAnchor () { return ESnapperModifierAnchor; },
        ESnapper: ESnapper,
        DThemes: DThemes,
        toString: toString,
        DynamicAtlasItemEmpty: DynamicAtlasItemEmpty,
        DynamicAtlasItemImage: DynamicAtlasItemImage,
        DynamicAtlasItemText: DynamicAtlasItemText,
        DynamicAtlasItemWhite: DynamicAtlasItemWhite,
        DynamicAtlasItem: DynamicAtlasItem,
        DynamicAtlas: DynamicAtlas,
        DynamicFontAtlasCharacterOrigin: DynamicFontAtlasCharacterOrigin,
        DynamicFontAtlasCharacter: DynamicFontAtlasCharacter,
        DynamicFontAtlasFont: DynamicFontAtlasFont,
        DynamicFontAtlas: DynamicFontAtlas,
        DynamicFontAtlases: DynamicFontAtlases,
        DynamicSDFFontAtlas: DynamicSDFFontAtlas,
        DynamicSDFFontAtlases: DynamicSDFFontAtlases,
        DynamicSDFFontGenerator: DynamicSDFFontGenerator,
        isArray: isArray,
        isFunction: isFunction,
        isNaN: isNaN,
        isNumber: isNumber,
        isString: isString,
        Lazy: Lazy,
        NumberFormatterImpl: NumberFormatterImpl,
        NumberFormatters: NumberFormatters,
        toCeilingIndex: toCeilingIndex,
        toIndexOf: toIndexOf,
        toLabel: toLabel,
        toPadded: toPadded,
        DynamicAtlasItemFontAtlas: DynamicAtlasItemFontAtlas,
        toSvgTexture: toSvgTexture,
        toSvgUrl: toSvgUrl,
        UtilAlpha: UtilAlpha,
        UtilSvgAtlasBuilder: UtilSvgAtlasBuilder,
        get UtilAttachAlign () { return UtilAttachAlign; },
        UtilAttach: UtilAttach,
        UtilClickOutside: UtilClickOutside,
        UtilClipboard: UtilClipboard,
        UtilDragEasingHistory: UtilDragEasingHistory,
        UtilDragEasing: UtilDragEasing,
        UtilDrag: UtilDrag,
        UtilExtract: UtilExtract,
        UtilExtractor: UtilExtractor,
        UtilFileDownloader: UtilFileDownloader,
        get UtilFileAs () { return UtilFileAs; },
        UtilFileOpener: UtilFileOpener,
        UtilHsv: UtilHsv,
        UtilKeyboardEvent: UtilKeyboardEvent,
        UtilName: UtilName,
        UtilOverlay: UtilOverlay,
        UtilPointerEvent: UtilPointerEvent,
        UtilPromise: UtilPromise,
        UtilRgb: UtilRgb,
        UtilRgba: UtilRgba,
        UtilTexturePlane: UtilTexturePlane,
        UtilTexture: UtilTexture,
        UtilTransition: UtilTransition,
        UtilWheelEvent: UtilWheelEvent,
        get DAlignHorizontal () { return DAlignHorizontal; },
        get DAlignVertical () { return DAlignVertical; },
        get DAlignWith () { return DAlignWith; },
        DAnimationBase: DAnimationBase,
        DAnimationEmpty: DAnimationEmpty,
        DAnimationFadeIn: DAnimationFadeIn,
        DAnimationTimings: DAnimationTimings,
        DApplicationLayerOptions: DApplicationLayerOptions,
        DApplicationLayer: DApplicationLayer,
        DApplicationPadding: DApplicationPadding,
        DApplication: DApplication,
        DApplications: DApplications,
        DBaseBackground: DBaseBackground,
        DBaseBorder: DBaseBorder,
        DBaseCorner: DBaseCorner,
        get DBaseInteractive () { return DBaseInteractive; },
        DBaseOutline: DBaseOutline,
        DBasePadding: DBasePadding,
        DBasePoint: DBasePoint,
        DBaseReflowable: DBaseReflowable,
        get DBaseState () { return DBaseState; },
        DBaseStates: DBaseStates,
        DBase: DBase,
        DBoard: DBoard,
        get DBorderMask () { return DBorderMask; },
        DButtonAmbient: DButtonAmbient,
        DButtonBase: DButtonBase,
        DButtonCheckRight: DButtonCheckRight,
        DButtonCheck: DButtonCheck,
        DButtonColorGradient: DButtonColorGradient,
        DButtonColor: DButtonColor,
        DButtonDanger: DButtonDanger,
        DButtonDate: DButtonDate,
        DButtonDatetime: DButtonDatetime,
        DButtonFileAs: DButtonFileAs,
        DButtonFile: DButtonFile,
        DButtonGroup: DButtonGroup,
        DButtonLink: DButtonLink,
        DButtonPrimary: DButtonPrimary,
        DButtonRadioRight: DButtonRadioRight,
        DButtonRadio: DButtonRadio,
        DButtonRedo: DButtonRedo,
        DButtonSecondary: DButtonSecondary,
        DButtonSelect: DButtonSelect,
        DButtonTime: DButtonTime,
        DButtonUndo: DButtonUndo,
        DButton: DButton,
        DCanvasContainer: DCanvasContainer,
        DCanvas: DCanvas,
        DChartAxisBase: DChartAxisBase,
        DChartAxisContainerImpl: DChartAxisContainerImpl,
        get DChartAxisPosition () { return DChartAxisPosition; },
        get DChartAxisTickPosition () { return DChartAxisTickPosition; },
        DChartAxisXDatetime: DChartAxisXDatetime,
        DChartAxisX: DChartAxisX,
        DChartAxisY: DChartAxisY,
        DChartColorSet1: DChartColorSet1,
        DChartColorSet2: DChartColorSet2,
        DChartCoordinateContainerImpl: DChartCoordinateContainerImpl,
        DChartCoordinateContainerSubImpl: DChartCoordinateContainerSubImpl,
        DChartCoordinateLinearTick: DChartCoordinateLinearTick,
        DChartCoordinateLinear: DChartCoordinateLinear,
        DChartCoordinateLogTick: DChartCoordinateLogTick,
        DChartCoordinateLog: DChartCoordinateLog,
        DChartCoordinateTransformImpl: DChartCoordinateTransformImpl,
        get DChartCoordinateDirection () { return DChartCoordinateDirection; },
        DChartLegendItem: DChartLegendItem,
        DChartLegend: DChartLegend,
        DChartOverview: DChartOverview,
        DChartPlotArea: DChartPlotArea,
        DChartRegionImplObservable: DChartRegionImplObservable,
        DChartRegionImpl: DChartRegionImpl,
        DChartSeriesBar: DChartSeriesBar,
        DChartSeriesBaseCoordinateContainer: DChartSeriesBaseCoordinateContainer,
        DChartSeriesBase: DChartSeriesBase,
        DChartSeriesContainerImpl: DChartSeriesContainerImpl,
        DChartSeriesFillComputedImpl: DChartSeriesFillComputedImpl,
        DChartSeriesFillImpl: DChartSeriesFillImpl,
        DChartSeriesLineOfCircles: DChartSeriesLineOfCircles,
        DChartSeriesLineOfRectangleRoundeds: DChartSeriesLineOfRectangleRoundeds,
        DChartSeriesLineOfRectangles: DChartSeriesLineOfRectangles,
        DChartSeriesLineOfTriangleRoundeds: DChartSeriesLineOfTriangleRoundeds,
        DChartSeriesLineOfTriangles: DChartSeriesLineOfTriangles,
        DChartSeriesLine: DChartSeriesLine,
        DChartSeriesExpressionParametersImpl: DChartSeriesExpressionParametersImpl,
        DChartSeriesLinear: DChartSeriesLinear,
        DChartSeriesPaddingComputedImpl: DChartSeriesPaddingComputedImpl,
        DChartSeriesPaddingImpl: DChartSeriesPaddingImpl,
        DChartSeriesPointComputedImpl: DChartSeriesPointComputedImpl,
        DChartSeriesPointImpl: DChartSeriesPointImpl,
        DChartSeriesScalars: DChartSeriesScalars,
        DChartSelectionGridlineContainerImpl: DChartSelectionGridlineContainerImpl,
        DChartSelectionGridlineX: DChartSelectionGridlineX,
        DChartSelectionGridlineY: DChartSelectionGridlineY,
        DChartSelectionMarker: DChartSelectionMarker,
        DChartSelectionShapeBase: DChartSelectionShapeBase,
        DChartSelectionSimple: DChartSelectionSimple,
        DChartSelectionSubImpl: DChartSelectionSubImpl,
        get DChartSelectionPoint () { return DChartSelectionPoint; },
        DChartSeriesStrokeImpl: DChartSeriesStrokeImpl,
        DChartSeriesHitResult: DChartSeriesHitResult,
        DChart: DChart,
        DCommandClear: DCommandClear,
        DCommandCreate: DCommandCreate,
        DCommandDelete: DCommandDelete,
        get DCommandFlag () { return DCommandFlag; },
        DCommandRedo: DCommandRedo,
        DCommandSaveAs: DCommandSaveAs,
        DCommandSave: DCommandSave,
        DCommandUndo: DCommandUndo,
        DContent: DContent,
        DControllerDefaultCommand: DControllerDefaultCommand,
        DControllerDefaultFocus: DControllerDefaultFocus,
        DControllerKeyboard: DControllerKeyboard,
        DControllers: DControllers,
        get DCornerMask () { return DCornerMask; },
        DDiagramCanvasBase: DDiagramCanvasBase,
        DDiagramCanvasEditor: DDiagramCanvasEditor,
        DDiagramCanvasTileMappingImpl: DDiagramCanvasTileMappingImpl,
        DDiagramCanvasTileMappingPointImpl: DDiagramCanvasTileMappingPointImpl,
        DDiagramCanvasTile: DDiagramCanvasTile,
        DDiagramCanvas: DDiagramCanvas,
        DDiagramEditor: DDiagramEditor,
        DDiagramLayerContainer: DDiagramLayerContainer,
        DDiagramLayer: DDiagramLayer,
        DDiagramSerializedVersion: DDiagramSerializedVersion,
        DDiagramShape: DDiagramShape,
        DDiagramTag: DDiagramTag,
        DDiagram: DDiagram,
        DDiagrams: DDiagrams,
        get DDialogCloseOn () { return DDialogCloseOn; },
        DDialogColorGradient: DDialogColorGradient,
        DDialogColor: DDialogColor,
        DDialogCommand: DDialogCommand,
        DDialogConfirmDelete: DDialogConfirmDelete,
        DDialogConfirmDiscard: DDialogConfirmDiscard,
        DDialogConfirmMessage: DDialogConfirmMessage,
        DDialogConfirm: DDialogConfirm,
        DDialogDate: DDialogDate,
        DDialogDates: DDialogDates,
        DDialogDatetime: DDialogDatetime,
        DDialogDatetimes: DDialogDatetimes,
        DDialogInputText: DDialogInputText,
        DDialogMessage: DDialogMessage,
        DDialogProcessingMessage: DDialogProcessingMessage,
        DDialogProcessing: DDialogProcessing,
        DDialogSaveAs: DDialogSaveAs,
        DDialogSelectListItem: DDialogSelectListItem,
        DDialogSelectList: DDialogSelectList,
        DDialogSelect: DDialogSelect,
        DDialogTime: DDialogTime,
        DDialogTimes: DDialogTimes,
        DDialog: DDialog,
        DDropdown: DDropdown,
        get DDragMode () { return DDragMode; },
        DDynamicTextGeometry: DDynamicTextGeometry,
        DDynamicTextStyle: DDynamicTextStyle,
        DDynamicTextMeasureResultCharacter: DDynamicTextMeasureResultCharacter,
        DDynamicTextMeasureResult: DDynamicTextMeasureResult,
        DDynamicTextMeasure: DDynamicTextMeasure,
        DDynamicText: DDynamicText,
        DExpandableHeader: DExpandableHeader,
        DExpandable: DExpandable,
        get DHtmlElementWhen () { return DHtmlElementWhen; },
        DHtmlElement: DHtmlElement,
        DImageBase: DImageBase,
        DImage: DImage,
        DInputAndLabel: DInputAndLabel,
        EShapeRenderer: EShapeRenderer,
        EShapeActionRuntimeTransformMoveRelativeX: EShapeActionRuntimeTransformMoveRelativeX,
        EShapeActionBases: EShapeActionBases,
        EShapeActionRuntimeBlinkColorFill: EShapeActionRuntimeBlinkColorFill,
        EShapeActionRuntimeBlinkColorStroke: EShapeActionRuntimeBlinkColorStroke,
        EShapeActionRuntimeBlinkDarken: EShapeActionRuntimeBlinkDarken,
        EShapeActionRuntimeBlinkOpacity: EShapeActionRuntimeBlinkOpacity,
        EShapeActionRuntimeBlinkVisibility: EShapeActionRuntimeBlinkVisibility,
        EShapeActionRuntimeBlink: EShapeActionRuntimeBlink,
        EShapeActionRuntimeChangeColorAll: EShapeActionRuntimeChangeColorAll,
        EShapeActionRuntimeChangeColorBrightnessAll: EShapeActionRuntimeChangeColorBrightnessAll,
        EShapeActionRuntimeChangeColorBrightnessFillAndStroke: EShapeActionRuntimeChangeColorBrightnessFillAndStroke,
        EShapeActionRuntimeChangeColorBrightnessFill: EShapeActionRuntimeChangeColorBrightnessFill,
        EShapeActionRuntimeChangeColorBrightnessStroke: EShapeActionRuntimeChangeColorBrightnessStroke,
        EShapeActionRuntimeChangeColorBrightnessTextOutline: EShapeActionRuntimeChangeColorBrightnessTextOutline,
        EShapeActionRuntimeChangeColorBrightnessText: EShapeActionRuntimeChangeColorBrightnessText,
        EShapeActionRuntimeChangeColorBrightness: EShapeActionRuntimeChangeColorBrightness,
        EShapeActionRuntimeChangeColorCodeAll: EShapeActionRuntimeChangeColorCodeAll,
        EShapeActionRuntimeChangeColorCodeFillAndStroke: EShapeActionRuntimeChangeColorCodeFillAndStroke,
        EShapeActionRuntimeChangeColorCodeFill: EShapeActionRuntimeChangeColorCodeFill,
        EShapeActionRuntimeChangeColorCodeStroke: EShapeActionRuntimeChangeColorCodeStroke,
        EShapeActionRuntimeChangeColorCodeTextOutline: EShapeActionRuntimeChangeColorCodeTextOutline,
        EShapeActionRuntimeChangeColorCodeText: EShapeActionRuntimeChangeColorCodeText,
        EShapeActionRuntimeChangeColorCode: EShapeActionRuntimeChangeColorCode,
        EShapeActionRuntimeChangeColorFillAndStroke: EShapeActionRuntimeChangeColorFillAndStroke,
        EShapeActionRuntimeChangeColorFill: EShapeActionRuntimeChangeColorFill,
        EShapeActionRuntimeChangeColorStroke: EShapeActionRuntimeChangeColorStroke,
        EShapeActionRuntimeChangeColorTextOutline: EShapeActionRuntimeChangeColorTextOutline,
        EShapeActionRuntimeChangeColorText: EShapeActionRuntimeChangeColorText,
        EShapeActionRuntimeChangeColor: EShapeActionRuntimeChangeColor,
        EShapeActionRuntimeChangeCursor: EShapeActionRuntimeChangeCursor,
        EShapeActionRuntimeChangeTextNumber: EShapeActionRuntimeChangeTextNumber,
        EShapeActionRuntimeChangeTextText: EShapeActionRuntimeChangeTextText,
        EShapeActionRuntimeConditional: EShapeActionRuntimeConditional,
        EShapeActionRuntimeEmitEvent: EShapeActionRuntimeEmitEvent,
        EShapeActionRuntimeMiscInputData: EShapeActionRuntimeMiscInputData,
        EShapeActionRuntimeMiscInput: EShapeActionRuntimeMiscInput,
        EShapeActionRuntimeOpenFlow: EShapeActionRuntimeOpenFlow,
        EShapeActionRuntimeOpenPageInplace: EShapeActionRuntimeOpenPageInplace,
        EShapeActionRuntimeOpenPage: EShapeActionRuntimeOpenPage,
        EShapeActionRuntimeOpen: EShapeActionRuntimeOpen,
        EShapeActionRuntimeShowHide: EShapeActionRuntimeShowHide,
        EShapeActionRuntimeTransformMoveAbsoluteX: EShapeActionRuntimeTransformMoveAbsoluteX,
        EShapeActionRuntimeTransformMoveAbsoluteY: EShapeActionRuntimeTransformMoveAbsoluteY,
        EShapeActionRuntimeTransformMoveForwardOrBackward: EShapeActionRuntimeTransformMoveForwardOrBackward,
        EShapeActionRuntimeTransformMoveLeftOrRight: EShapeActionRuntimeTransformMoveLeftOrRight,
        EShapeActionRuntimeBlinkBrighten: EShapeActionRuntimeBlinkBrighten,
        EShapeActionRuntimeTransformMoveRelativeY: EShapeActionRuntimeTransformMoveRelativeY,
        EShapeActionRuntimeTransformMove: EShapeActionRuntimeTransformMove,
        EShapeActionRuntimeTransformResizeHeightAbsolute: EShapeActionRuntimeTransformResizeHeightAbsolute,
        EShapeActionRuntimeTransformResizeHeightRelative: EShapeActionRuntimeTransformResizeHeightRelative,
        EShapeActionRuntimeTransformResizeSizeAbsolute: EShapeActionRuntimeTransformResizeSizeAbsolute,
        EShapeActionRuntimeTransformResizeSizeRelative: EShapeActionRuntimeTransformResizeSizeRelative,
        EShapeActionRuntimeTransformResizeWidthAbsolute: EShapeActionRuntimeTransformResizeWidthAbsolute,
        EShapeActionRuntimeTransformResizeWidthRelative: EShapeActionRuntimeTransformResizeWidthRelative,
        EShapeActionRuntimeTransformResize: EShapeActionRuntimeTransformResize,
        EShapeActionRuntimeTransformRotateAbsolute: EShapeActionRuntimeTransformRotateAbsolute,
        EShapeActionRuntimeTransformRotateRelative: EShapeActionRuntimeTransformRotateRelative,
        EShapeActionRuntimeTransformRotate: EShapeActionRuntimeTransformRotate,
        EShapeActionRuntime: EShapeActionRuntime,
        EShapeActionValueBase: EShapeActionValueBase,
        get EShapeActionValueBlinkType () { return EShapeActionValueBlinkType; },
        EShapeActionValueBlink: EShapeActionValueBlink,
        EShapeActionValueChangeColorBrightness: EShapeActionValueChangeColorBrightness,
        EShapeActionValueChangeColorCode: EShapeActionValueChangeColorCode,
        get EShapeActionValueChangeColorTarget () { return EShapeActionValueChangeColorTarget; },
        get EShapeActionValueChangeColorType () { return EShapeActionValueChangeColorType; },
        EShapeActionValueChangeColor: EShapeActionValueChangeColor,
        EShapeActionValueChangeCursor: EShapeActionValueChangeCursor,
        get EShapeActionValueChangeTextType () { return EShapeActionValueChangeTextType; },
        EShapeActionValueChangeText: EShapeActionValueChangeText,
        EShapeActionValueDeserializer: EShapeActionValueDeserializer,
        EShapeActionValueEmitEvent: EShapeActionValueEmitEvent,
        get EShapeActionValueMiscType () { return EShapeActionValueMiscType; },
        EShapeActionValueMisc: EShapeActionValueMisc,
        get EShapeActionValueOpenType () { return EShapeActionValueOpenType; },
        EShapeActionValueOpen: EShapeActionValueOpen,
        EShapeActionValueOpetyped: EShapeActionValueOpetyped,
        get EShapeActionValueShowHideType () { return EShapeActionValueShowHideType; },
        EShapeActionValueShowHide: EShapeActionValueShowHide,
        EShapeActionValueSubtyped: EShapeActionValueSubtyped,
        get EShapeActionValueTransformMoveType () { return EShapeActionValueTransformMoveType; },
        EShapeActionValueTransformMove: EShapeActionValueTransformMove,
        get EShapeActionValueTransformResizeType () { return EShapeActionValueTransformResizeType; },
        EShapeActionValueTransformResize: EShapeActionValueTransformResize,
        get EShapeActionValueTransformRotateType () { return EShapeActionValueTransformRotateType; },
        EShapeActionValueTransformRotate: EShapeActionValueTransformRotate,
        get EShapeActionValueTransformType () { return EShapeActionValueTransformType; },
        get EShapeActionValueType () { return EShapeActionValueType; },
        EShapeActionValues: EShapeActionValues,
        EShapeAction: EShapeAction,
        EShapeGroupSizeEditor: EShapeGroupSizeEditor,
        CIRCLE_VERTEX_COUNT: CIRCLE_VERTEX_COUNT,
        CIRCLE_INDEX_COUNT: CIRCLE_INDEX_COUNT,
        CIRCLE_WORLD_SIZE: CIRCLE_WORLD_SIZE,
        buildCircleClipping: buildCircleClipping,
        buildCircleIndex: buildCircleIndex,
        buildCircleVertex: buildCircleVertex,
        buildCircleStep: buildCircleStep,
        buildCircleUv: buildCircleUv,
        IMAGE_SDF_VERTEX_COUNT: IMAGE_SDF_VERTEX_COUNT,
        IMAGE_SDF_INDEX_COUNT: IMAGE_SDF_INDEX_COUNT,
        IMAGE_SDF_WORLD_SIZE: IMAGE_SDF_WORLD_SIZE,
        buildImageSdfClipping: buildImageSdfClipping,
        buildImageSdfIndex: buildImageSdfIndex,
        buildImageSdfStep: buildImageSdfStep,
        buildImageSdfVertex: buildImageSdfVertex,
        buildImageSdfUv: buildImageSdfUv,
        toLineOfAnyPointCount: toLineOfAnyPointCount,
        buildLineOfAnyColor: buildLineOfAnyColor,
        toLineVertexCount: toLineVertexCount,
        buildLineClipping: buildLineClipping,
        buildLineIndex: buildLineIndex,
        buildLineUv: buildLineUv,
        buildLineVertexStepAndColorFill: buildLineVertexStepAndColorFill,
        buildNullClipping: buildNullClipping,
        buildNullIndex: buildNullIndex,
        buildNullVertex: buildNullVertex,
        buildNullStep: buildNullStep,
        buildNullUv: buildNullUv,
        RECTANGLE_ROUNDED_VERTEX_COUNT: RECTANGLE_ROUNDED_VERTEX_COUNT,
        RECTANGLE_ROUNDED_INDEX_COUNT: RECTANGLE_ROUNDED_INDEX_COUNT,
        RECTANGLE_ROUNDED_WORLD_SIZE: RECTANGLE_ROUNDED_WORLD_SIZE,
        buildRectangleRoundedIndex: buildRectangleRoundedIndex,
        buildRectangleRoundedVertex: buildRectangleRoundedVertex,
        buildRectangleRoundedClipping: buildRectangleRoundedClipping,
        buildRectangleRoundedStep: buildRectangleRoundedStep,
        buildRectangleRoundedUv: buildRectangleRoundedUv,
        RECTANGLE_VERTEX_COUNT: RECTANGLE_VERTEX_COUNT,
        RECTANGLE_INDEX_COUNT: RECTANGLE_INDEX_COUNT,
        RECTANGLE_WORLD_SIZE: RECTANGLE_WORLD_SIZE,
        buildRectangleClipping: buildRectangleClipping,
        buildRectangleClippingVertical: buildRectangleClippingVertical,
        buildRectangleIndex: buildRectangleIndex,
        buildRectangleVertex: buildRectangleVertex,
        buildRectangleVertexVertical: buildRectangleVertexVertical,
        buildRectangleStep: buildRectangleStep,
        buildRectangleStepVertical: buildRectangleStepVertical,
        buildRectangleStepHorizontal: buildRectangleStepHorizontal,
        buildRectangleUv: buildRectangleUv,
        buildRectangleUvVertical: buildRectangleUvVertical,
        buildStep: buildStep,
        TEXT_VERTEX_COUNT: TEXT_VERTEX_COUNT,
        TEXT_INDEX_COUNT: TEXT_INDEX_COUNT,
        toTextBufferCount: toTextBufferCount,
        buildTextClipping: buildTextClipping,
        buildTextIndex: buildTextIndex,
        buildTextStep: buildTextStep,
        buildTextVertex: buildTextVertex,
        TRIANGLE_ROUNDED_VERTEX_COUNT: TRIANGLE_ROUNDED_VERTEX_COUNT,
        TRIANGLE_ROUNDED_INDEX_COUNT: TRIANGLE_ROUNDED_INDEX_COUNT,
        TRIANGLE_ROUNDED_WORLD_SIZE: TRIANGLE_ROUNDED_WORLD_SIZE,
        buildTriangleRoundedIndex: buildTriangleRoundedIndex,
        buildTriangleRoundedVertex: buildTriangleRoundedVertex,
        buildTriangleRoundedClipping: buildTriangleRoundedClipping,
        buildTriangleRoundedStep: buildTriangleRoundedStep,
        buildTriangleRoundedUv: buildTriangleRoundedUv,
        TRIANGLE_VERTEX_COUNT: TRIANGLE_VERTEX_COUNT,
        TRIANGLE_INDEX_COUNT: TRIANGLE_INDEX_COUNT,
        TRIANGLE_WORLD_SIZE: TRIANGLE_WORLD_SIZE,
        buildTriangleClipping: buildTriangleClipping,
        buildTriangleIndex: buildTriangleIndex,
        buildTriangleVertex: buildTriangleVertex,
        buildTriangleStep: buildTriangleStep,
        buildTriangleUv: buildTriangleUv,
        copyClipping: copyClipping,
        copyIndex: copyIndex,
        copyStep: copyStep,
        copyUvs: copyUvs,
        copyVertex: copyVertex,
        createBarUploaded: createBarUploaded,
        createCircle: createCircle,
        createGroupUploaded: createGroupUploaded,
        createImageSdfUploaded: createImageSdfUploaded,
        createImageSdf: createImageSdf,
        createImage: createImage,
        createLabelUploaded: createLabelUploaded,
        createLineOfAnyUploaded: createLineOfAnyUploaded,
        createLineOfCirclesUploaded: createLineOfCirclesUploaded,
        createLineOfRectangleRoundedsUploaded: createLineOfRectangleRoundedsUploaded,
        createLineOfRectanglesUploaded: createLineOfRectanglesUploaded,
        createLineOfTriangleRoundedsUploaded: createLineOfTriangleRoundedsUploaded,
        createLineOfTrianglesUploaded: createLineOfTrianglesUploaded,
        createLineUploaded: createLineUploaded,
        createLine: createLine,
        toLineStrokeWidth: toLineStrokeWidth,
        createNullUploaded: createNullUploaded,
        createRectangleRoundedUploaded: createRectangleRoundedUploaded,
        createRectangleUploaded: createRectangleUploaded,
        createTriangleRoundedUploaded: createTriangleRoundedUploaded,
        createTriangleUploaded: createTriangleUploaded,
        deserializeBar: deserializeBar,
        deserializeCircle: deserializeCircle,
        deserializeGroupShadowed: deserializeGroupShadowed,
        deserializeGroup: deserializeGroup,
        deserializeImageSdf: deserializeImageSdf,
        deserializeImage: deserializeImage,
        deserializeLabel: deserializeLabel,
        deserializeLineOfCircles: deserializeLineOfCircles,
        deserializeLineOfRectangleRoundeds: deserializeLineOfRectangleRoundeds,
        deserializeLineOfRectangles: deserializeLineOfRectangles,
        deserializeLineOfTriangleRoundeds: deserializeLineOfTriangleRoundeds,
        deserializeLineOfTriangles: deserializeLineOfTriangles,
        deserializeLine: deserializeLine,
        deserializeNull: deserializeNull,
        deserializeRectangleRounded: deserializeRectangleRounded,
        deserializeRectangle: deserializeRectangle,
        deserializeTriangleRounded: deserializeTriangleRounded,
        deserializeTriangle: deserializeTriangle,
        EShapeBarPoints: EShapeBarPoints,
        get EShapeBarPosition () { return EShapeBarPosition; },
        EShapeBarUploaded: EShapeBarUploaded,
        EShapeBar: EShapeBar,
        EShapeBase: EShapeBase,
        EShapeCircleUploaded: EShapeCircleUploaded,
        EShapeCircle: EShapeCircle,
        EShapeFillImpl: EShapeFillImpl,
        EShapeGradients: EShapeGradients,
        EShapeGroupFillEditor: EShapeGroupFillEditor,
        EShapeGroupFillViewer: EShapeGroupFillViewer,
        EShapeGroupPoints: EShapeGroupPoints,
        EShapeGroupShadowed: EShapeGroupShadowed,
        buildColor: buildColor,
        EShapeGroupSizeLayout: EShapeGroupSizeLayout,
        EShapeGroupSizeShadowed: EShapeGroupSizeShadowed,
        EShapeGroupSizeViewer: EShapeGroupSizeViewer,
        EShapeGroupStrokeEditor: EShapeGroupStrokeEditor,
        EShapeGroupStrokeViewer: EShapeGroupStrokeViewer,
        EShapeGroupTextAlignEditor: EShapeGroupTextAlignEditor,
        EShapeGroupTextAlignViewer: EShapeGroupTextAlignViewer,
        EShapeGroupTextEditor: EShapeGroupTextEditor,
        EShapeGroupTextOffsetEditor: EShapeGroupTextOffsetEditor,
        EShapeGroupTextOffsetViewer: EShapeGroupTextOffsetViewer,
        EShapeGroupTextOutlineEditor: EShapeGroupTextOutlineEditor,
        EShapeGroupTextOutlineViewer: EShapeGroupTextOutlineViewer,
        EShapeGroupTextPaddingEditor: EShapeGroupTextPaddingEditor,
        EShapeGroupTextPaddingViewer: EShapeGroupTextPaddingViewer,
        EShapeGroupTextSpacingEditor: EShapeGroupTextSpacingEditor,
        EShapeGroupTextSpacingViewer: EShapeGroupTextSpacingViewer,
        EShapeGroupTextViewer: EShapeGroupTextViewer,
        EShapeGroupUploaded: EShapeGroupUploaded,
        EShapeGroup: EShapeGroup,
        EShapeImageSdfUploaded: EShapeImageSdfUploaded,
        EShapeImageSdf: EShapeImageSdf,
        EShapeImage: EShapeImage,
        EShapeLabelUploaded: EShapeLabelUploaded,
        EShapeLabel: EShapeLabel,
        EShapeLineBase: EShapeLineBase,
        EShapeLineOfAnyPointsFillImpl: EShapeLineOfAnyPointsFillImpl,
        EShapeLineOfAnyPointsImpl: EShapeLineOfAnyPointsImpl,
        EShapeLineOfAnyPointsPointImpl: EShapeLineOfAnyPointsPointImpl,
        EShapeLineOfAnyPointsStrokeImpl: EShapeLineOfAnyPointsStrokeImpl,
        EShapeLineOfAnyUploaded: EShapeLineOfAnyUploaded,
        EShapeLineOfCirclesUploaded: EShapeLineOfCirclesUploaded,
        EShapeLineOfCircles: EShapeLineOfCircles,
        EShapeLineOfRectangleRoundedsUploaded: EShapeLineOfRectangleRoundedsUploaded,
        EShapeLineOfRectangleRoundeds: EShapeLineOfRectangleRoundeds,
        EShapeLineOfRectanglesUploaded: EShapeLineOfRectanglesUploaded,
        EShapeLineOfRectangles: EShapeLineOfRectangles,
        EShapeLineOfTriangleRoundedsUploaded: EShapeLineOfTriangleRoundedsUploaded,
        EShapeLineOfTriangleRoundeds: EShapeLineOfTriangleRoundeds,
        EShapeLineOfTrianglesUploaded: EShapeLineOfTrianglesUploaded,
        EShapeLineOfTriangles: EShapeLineOfTriangles,
        EShapeLinePoints: EShapeLinePoints,
        EShapeLineUploaded: EShapeLineUploaded,
        EShapeLine: EShapeLine,
        EShapeNullUploaded: EShapeNullUploaded,
        EShapeNull: EShapeNull,
        EShapePrimitive: EShapePrimitive,
        EShapeRectangleRoundedUploaded: EShapeRectangleRoundedUploaded,
        EShapeRectangleRounded: EShapeRectangleRounded,
        EShapeRectangleUploaded: EShapeRectangleUploaded,
        EShapeRectangle: EShapeRectangle,
        EShapeStrokeImpl: EShapeStrokeImpl,
        EShapeTagImpl: EShapeTagImpl,
        EShapeTagValueImpl: EShapeTagValueImpl,
        EShapeTagValueRangeImpl: EShapeTagValueRangeImpl,
        EShapeTextAlignImpl: EShapeTextAlignImpl,
        EShapeTextImpl: EShapeTextImpl,
        EShapeTextOffsetImpl: EShapeTextOffsetImpl,
        EShapeTextOutlineImpl: EShapeTextOutlineImpl,
        EShapeTextUploaded: EShapeTextUploaded,
        EShapeTriangleRoundedUploaded: EShapeTriangleRoundedUploaded,
        EShapeTriangleRounded: EShapeTriangleRounded,
        EShapeTriangleUploaded: EShapeTriangleUploaded,
        EShapeTriangle: EShapeTriangle,
        isStatic: isStatic,
        toComputed: toComputed,
        toHitThreshold: toHitThreshold,
        toLength: toLength,
        STEP_VALUES: STEP_VALUES,
        toStep: toStep,
        EShapeBufferUnitBuilder: EShapeBufferUnitBuilder,
        EShapeBufferUnit: EShapeBufferUnit,
        EShapeBuffer: EShapeBuffer,
        EShapeCapabilities: EShapeCapabilities,
        get EShapeCapability () { return EShapeCapability; },
        EShapeContainer: EShapeContainer,
        get EShapeCorner () { return EShapeCorner; },
        EShapeDeleter: EShapeDeleter,
        EShapeDefaults: EShapeDefaults,
        EShapeDeserializer: EShapeDeserializer,
        EShapeDeserializers: EShapeDeserializers,
        EShapeEditor: EShapeEditor,
        EShapeImageElements: EShapeImageElements,
        get EShapePointsStyle () { return EShapePointsStyle; },
        EShapeRendererIteratorDatum: EShapeRendererIteratorDatum,
        EShapeRendererIterator: EShapeRendererIterator,
        loadShapeLineOfRectangles: loadShapeLineOfRectangles,
        loadShapeAll: loadShapeAll,
        loadShapeCircle: loadShapeCircle,
        loadShapeGroupShadowed: loadShapeGroupShadowed,
        loadShapeGroup: loadShapeGroup,
        loadShapeImage: loadShapeImage,
        loadShapeLabel: loadShapeLabel,
        loadShapeLineOfCircles: loadShapeLineOfCircles,
        loadShapeLineOfRectangleRoundeds: loadShapeLineOfRectangleRoundeds,
        loadShapeBar: loadShapeBar,
        loadShapeLineOfTriangleRoundeds: loadShapeLineOfTriangleRoundeds,
        loadShapeLineOfTriangles: loadShapeLineOfTriangles,
        loadShapeLine: loadShapeLine,
        loadShapeNull: loadShapeNull,
        loadShapeRectangleRounded: loadShapeRectangleRounded,
        loadShapeRectangle: loadShapeRectangle,
        loadShapeTriangleRounded: loadShapeTriangleRounded,
        loadShapeTriangle: loadShapeTriangle,
        EShapeResourceManagerDeserialization: EShapeResourceManagerDeserialization,
        EShapeResourceManagerSerialization: EShapeResourceManagerSerialization,
        get EShapeRuntimeReset () { return EShapeRuntimeReset; },
        get EShapeRuntimeState () { return EShapeRuntimeState; },
        EShapeRuntime: EShapeRuntime,
        EShapeRuntimes: EShapeRuntimes,
        EShapeSearch: EShapeSearch,
        EShapeSizes: EShapeSizes,
        get EShapeStrokeSide () { return EShapeStrokeSide; },
        get EShapeTagValueRangeType () { return EShapeTagValueRangeType; },
        get EShapeTagValueOrder () { return EShapeTagValueOrder; },
        get EShapeTextAlignHorizontal () { return EShapeTextAlignHorizontal; },
        get EShapeTextAlignVertical () { return EShapeTextAlignVertical; },
        get EShapeTextDirection () { return EShapeTextDirection; },
        get EShapeTextWeight () { return EShapeTextWeight; },
        get EShapeTextStyle () { return EShapeTextStyle; },
        EShapeTransformImpl: EShapeTransformImpl,
        EShapeTransforms: EShapeTransforms,
        get EShapeType () { return EShapeType; },
        EShapeUploadedBase: EShapeUploadedBase,
        EShapeUploadeds: EShapeUploadeds,
        get EShapeCopyPart () { return EShapeCopyPart; },
        DInputInteger: DInputInteger,
        DInputLabel: DInputLabel,
        DInputNumber: DInputNumber,
        DInputRealAndLabel: DInputRealAndLabel,
        DInputReal: DInputReal,
        DInputTextAndLabel: DInputTextAndLabel,
        DInputText: DInputText,
        DInput: DInput,
        get DLayoutClearType () { return DLayoutClearType; },
        get DLayoutDirection () { return DLayoutDirection; },
        DLayoutHorizontal: DLayoutHorizontal,
        DLayoutSpace: DLayoutSpace,
        DLayoutVertical: DLayoutVertical,
        DLayout: DLayout,
        get DLinkMenuItemId () { return DLinkMenuItemId; },
        get DLinkTarget () { return DLinkTarget; },
        DLink: DLink,
        DListItemSeparatorReflowable: DListItemSeparatorReflowable,
        DListItemSeparator: DListItemSeparator,
        DListItem: DListItem,
        get DListSelectionMode () { return DListSelectionMode; },
        DListSelection: DListSelection,
        DList: DList,
        DMapCoordinateEPSG3857: DMapCoordinateEPSG3857,
        DMapCoordinates: DMapCoordinates,
        DMapTilePlane: DMapTilePlane,
        DMapTilePyramidImpl: DMapTilePyramidImpl,
        DMapTileUrlBuilderKokudo: DMapTileUrlBuilderKokudo,
        DMapTileUrlBuilderOsm: DMapTileUrlBuilderOsm,
        DMapTileUrlBuilderOsmfj: DMapTileUrlBuilderOsmfj,
        DMapTilePyramids: DMapTilePyramids,
        DMapTile: DMapTile,
        DMenuAlign: DMenuAlign,
        DMenuBarBlocker: DMenuBarBlocker,
        DMenuBarItem: DMenuBarItem,
        DMenuBar: DMenuBar,
        DMenuContext: DMenuContext,
        DMenuItemCheck: DMenuItemCheck,
        DMenuItemExpandableBody: DMenuItemExpandableBody,
        DMenuItemExpandableHeader: DMenuItemExpandableHeader,
        DMenuItemExpandableItemCheck: DMenuItemExpandableItemCheck,
        DMenuItemExpandableItemLink: DMenuItemExpandableItemLink,
        DMenuItemExpandableItemMenu: DMenuItemExpandableItemMenu,
        DMenuItemExpandableItemSeparator: DMenuItemExpandableItemSeparator,
        DMenuItemExpandableItemSpace: DMenuItemExpandableItemSpace,
        DMenuItemExpandableItemText: DMenuItemExpandableItemText,
        DMenuItemExpandable: DMenuItemExpandable,
        DMenuItemExpandables: DMenuItemExpandables,
        DMenuItemLinkState: DMenuItemLinkState,
        DMenuItemLink: DMenuItemLink,
        DMenuItemMenu: DMenuItemMenu,
        DMenuItemSeparator: DMenuItemSeparator,
        DMenuItemSpace: DMenuItemSpace,
        DMenuItemText: DMenuItemText,
        DMenuItem: DMenuItem,
        DMenuSidedItemCheck: DMenuSidedItemCheck,
        DMenuSidedItemExpandableItemCheck: DMenuSidedItemExpandableItemCheck,
        DMenuSidedItemExpandableItemLink: DMenuSidedItemExpandableItemLink,
        DMenuSidedItemExpandableItemMenu: DMenuSidedItemExpandableItemMenu,
        DMenuSidedItemExpandableItemSeparator: DMenuSidedItemExpandableItemSeparator,
        DMenuSidedItemExpandableItemSpace: DMenuSidedItemExpandableItemSpace,
        DMenuSidedItemExpandableItemText: DMenuSidedItemExpandableItemText,
        DMenuSidedItemExpandable: DMenuSidedItemExpandable,
        DMenuSidedItemExpandables: DMenuSidedItemExpandables,
        DMenuSidedItemLink: DMenuSidedItemLink,
        DMenuSidedItemMenu: DMenuSidedItemMenu,
        DMenuSidedItemSeparator: DMenuSidedItemSeparator,
        DMenuSidedItemSpace: DMenuSidedItemSpace,
        DMenuSidedItemText: DMenuSidedItemText,
        DMenuSided: DMenuSided,
        DMenuSideds: DMenuSideds,
        DMenu: DMenu,
        DMenus: DMenus,
        get DMouseModifier () { return DMouseModifier; },
        DMouseModifiers: DMouseModifiers,
        DNote: DNote,
        DNotification: DNotification,
        DPagination: DPagination,
        DPaginationNavigationButton: DPaginationNavigationButton,
        DPaginationDynamicButtons: DPaginationDynamicButtons,
        DPaginationDotsButton: DPaginationDotsButton,
        DPane: DPane,
        DPickerColorAndAlpha: DPickerColorAndAlpha,
        DPickerColorGradientDataView: DPickerColorGradientDataView,
        DPickerColorGradientData: DPickerColorGradientData,
        DPickerColorGradientPoint: DPickerColorGradientPoint,
        DPickerColorGradientRecent: DPickerColorGradientRecent,
        DPickerColorGradient: DPickerColorGradient,
        DPickerColorRecent: DPickerColorRecent,
        DPickerColor: DPickerColor,
        DPickerDate: DPickerDate,
        DPickerDates: DPickerDates,
        DPickerDatetimeButtonBack: DPickerDatetimeButtonBack,
        DPickerDatetimeButtonDate: DPickerDatetimeButtonDate,
        DPickerDatetimeButtonNext: DPickerDatetimeButtonNext,
        DPickerDatetimeLabelDate: DPickerDatetimeLabelDate,
        DPickerDatetimeLabel: DPickerDatetimeLabel,
        get DPickerDatetimeMask () { return DPickerDatetimeMask; },
        DPickerDatetimeSpace: DPickerDatetimeSpace,
        DPickerDatetime: DPickerDatetime,
        DPickerDatetimes: DPickerDatetimes,
        DPickerDatetimeRange: DPickerDatetimeRange,
        DPickerTimeRange: DPickerTimeRange,
        DPickerTimeBoundHours: DPickerTimeBoundHours,
        DPickerTimeBoundMinutes: DPickerTimeBoundMinutes,
        DPickerTimeBoundSeconds: DPickerTimeBoundSeconds,
        DPickerTimeBounds: DPickerTimeBounds,
        DPickerTime: DPickerTime,
        DPickerTimes: DPickerTimes,
        DScalarExpression: DScalarExpression,
        DScalarFunctions: DScalarFunctions,
        DScrollBarHorizontal: DScrollBarHorizontal,
        DScrollBarThumbHorizontal: DScrollBarThumbHorizontal,
        DScrollBarThumbReflowableHorizontal: DScrollBarThumbReflowableHorizontal,
        DScrollBarThumbReflowableVertical: DScrollBarThumbReflowableVertical,
        DScrollBarThumbVertocal: DScrollBarThumbVertocal,
        DScrollBarThumb: DScrollBarThumb,
        DScrollBarVertical: DScrollBarVertical,
        DScrollBar: DScrollBar,
        DSelectMultiple: DSelectMultiple,
        DSelect: DSelect,
        DShadowImpl: DShadowImpl,
        DSliderHorizontal: DSliderHorizontal,
        DSliderVertical: DSliderVertical,
        DTableBodyCellActionDialog: DTableBodyCellActionDialog,
        DTableBodyCellActionMenu: DTableBodyCellActionMenu,
        DTableBodyCellActionPromise: DTableBodyCellActionPromise,
        DTableBodyCellButton: DTableBodyCellButton,
        DTableBodyCellCheck: DTableBodyCellCheck,
        DTableBodyCellColor: DTableBodyCellColor,
        DTableBodyCellDate: DTableBodyCellDate,
        DTableBodyCellDatetime: DTableBodyCellDatetime,
        DTableBodyCellIndex: DTableBodyCellIndex,
        DTableBodyCellInputInteger: DTableBodyCellInputInteger,
        DTableBodyCellInputReal: DTableBodyCellInputReal,
        DTableBodyCellInputText: DTableBodyCellInputText,
        DTableBodyCellInputTreeInput: DTableBodyCellInputTreeInput,
        DTableBodyCellInputTreeMarker: DTableBodyCellInputTreeMarker,
        DTableBodyCellInputTree: DTableBodyCellInputTree,
        DTableBodyCellLink: DTableBodyCellLink,
        DTableBodyCellSelectDialog: DTableBodyCellSelectDialog,
        DTableBodyCellSelectMenu: DTableBodyCellSelectMenu,
        DTableBodyCellSelectMultiple: DTableBodyCellSelectMultiple,
        DTableBodyCellSelectPromise: DTableBodyCellSelectPromise,
        DTableBodyCellText: DTableBodyCellText,
        DTableBodyCellTree: DTableBodyCellTree,
        DTableBodyRow: DTableBodyRow,
        DTableBody: DTableBody,
        DTableCategoryCell: DTableCategoryCell,
        DTableCategory: DTableCategory,
        DTableCellState: DTableCellState,
        get DTableColumnType () { return DTableColumnType; },
        DTableDataFilterImpl: DTableDataFilterImpl,
        DTableDataListMapped: DTableDataListMapped,
        DTableDataList: DTableDataList,
        DTableDataSelectionImpl: DTableDataSelectionImpl,
        get DTableDataSelectionType () { return DTableDataSelectionType; },
        DTableDataSorterImpl: DTableDataSorterImpl,
        get DTableDataOrder () { return DTableDataOrder; },
        DTableDataTree: DTableDataTree,
        DTableHeaderCell: DTableHeaderCell,
        DTableHeader: DTableHeader,
        DTableRowState: DTableRowState,
        DTableRow: DTableRow,
        DTable: DTable,
        DTextBase: DTextBase,
        DText: DText,
        get DTreeAddedItemPosition () { return DTreeAddedItemPosition; },
        DTree: DTree,
        DTreeItem: DTreeItem,
        DTreeItemTextAndImage: DTreeItemTextAndImage,
        DTreeItemState: DTreeItemState,
        DViewDragImpl: DViewDragImpl,
        DViewImpl: DViewImpl,
        DViewTransformImpl: DViewTransformImpl
    });

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    loadAll();
    var global = window;
    global.wcardinal = global.wcardinal || {};
    global.wcardinal.ui = ui;

}(PIXI));
