{"version":3,"file":"d-scalar-expression.js","sourceRoot":"","sources":["../../../src/main/typescript/wcardinal/ui/d-scalar-expression.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (C) 2019 Toshiba Corporation\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport { DScalar } from \"./d-scalar\";\r\nimport { isNumber } from \"./util/is-number\";\r\n\r\nconst enum NodeType {\r\n\t// Parensesis\r\n\tOPEN,\r\n\tCLOSE,\r\n\tPARENSESIS,\r\n\r\n\t// Operations\r\n\tADD_OR_PLUS,\r\n\tSUB_OR_MINUS,\r\n\r\n\tPLUS,\r\n\tMINUS,\r\n\r\n\tADD,\r\n\tSUB,\r\n\tMUL,\r\n\tDIV,\r\n\r\n\t// Functions\r\n\tMIN,\r\n\tMAX,\r\n\tCOMMA,\r\n\r\n\t// Literals\r\n\tPARENT,\r\n\tSELF,\r\n\tPADDING,\r\n\tCURRENT,\r\n\tNUMBER\r\n}\r\n\r\ntype NodeTypeOperator = NodeType.SUB_OR_MINUS | NodeType.ADD_OR_PLUS |\r\n\tNodeType.SUB | NodeType.ADD | NodeType.MUL | NodeType.DIV |\r\n\tNodeType.OPEN | NodeType.CLOSE |\r\n\tNodeType.MIN | NodeType.MAX | NodeType.COMMA;\r\ntype NodeTypeLiteral = NodeType.NUMBER | NodeType.PARENT | NodeType.SELF | NodeType.PADDING | NodeType.CURRENT;\r\ntype Token = NodeTypeOperator | [ NodeTypeLiteral, number ];\r\n\r\ninterface NodeOrTokenParensesis {\r\n\t[ 0 ]: NodeType.PARENSESIS;\r\n\t[ 1 ]: NodeOrToken[];\r\n}\r\n\r\ninterface NodeOrTokenUnary {\r\n\t[ 0 ]: NodeType.PLUS | NodeType.MINUS;\r\n\t[ 1 ]: NodeOrToken;\r\n}\r\n\r\ntype NodeArithmeticOperator = NodeType.SUB | NodeType.ADD | NodeType.MUL | NodeType.DIV;\r\n\r\ninterface NodeOrTokenArithmetic {\r\n\t[ 0 ]: NodeArithmeticOperator;\r\n\t[ 1 ]: NodeOrToken;\r\n\t[ 2 ]: NodeOrToken;\r\n}\r\n\r\ninterface NodeOrTokenFunction {\r\n\t[ 0 ]: NodeType.MIN | NodeType.MAX;\r\n\t[ 1 ]: NodeOrToken[];\r\n}\r\n\r\ntype NodeOrToken = Token | NodeOrTokenParensesis | NodeOrTokenUnary | NodeOrTokenArithmetic | NodeOrTokenFunction;\r\n\r\ninterface NodeLiteral {\r\n\t[ 0 ]: NodeTypeLiteral;\r\n\t[ 1 ]: number;\r\n}\r\n\r\ninterface NodeParensesis {\r\n\t[ 0 ]: NodeType.PARENSESIS;\r\n\t[ 1 ]: Node[];\r\n}\r\n\r\ninterface NodeUnary {\r\n\t[ 0 ]: NodeType.PLUS | NodeType.MINUS;\r\n\t[ 1 ]: Node;\r\n}\r\n\r\ninterface NodeArithmetic {\r\n\t[ 0 ]: NodeArithmeticOperator;\r\n\t[ 1 ]: Node;\r\n\t[ 2 ]: Node;\r\n}\r\n\r\ninterface NodeFunction {\r\n\t[ 0 ]: NodeType.MIN | NodeType.MAX;\r\n\t[ 1 ]: Node[];\r\n}\r\n\r\ntype Node = NodeParensesis | NodeUnary | NodeArithmetic | NodeFunction | NodeLiteral;\r\n\r\nconst TOKEN_MAPPING_OPERATOR: { [ token: string ]: NodeTypeOperator | undefined } = {\r\n\t\"+\": NodeType.ADD_OR_PLUS,\r\n\t\"-\": NodeType.SUB_OR_MINUS,\r\n\t\"*\": NodeType.MUL,\r\n\t\"/\": NodeType.DIV,\r\n\t\"(\": NodeType.OPEN,\r\n\t\")\": NodeType.CLOSE,\r\n\t\",\": NodeType.COMMA,\r\n\t\"min\": NodeType.MIN,\r\n\t\"max\": NodeType.MAX\r\n};\r\n\r\nconst TOKEN_MAPPING_LITERAL: { [ token: string ]: NodeTypeLiteral | undefined } = {\r\n\t\"%\": NodeType.PARENT,\r\n\t\"s\": NodeType.SELF,\r\n\t\"p\": NodeType.PADDING,\r\n\t\"c\": NodeType.CURRENT\r\n};\r\n\r\n/**\r\n * Parser and evaluator of the scalar expressions like `100% - 50s`.\r\n *\r\n * Literals\r\n *\r\n * * x%: 0.01 * x * parent value\r\n * * xs: 0.01 * x * self value\r\n * * xp: 0.01 * x * padding value\r\n * * xc: 0.01 * x * current value\r\n *\r\n * Operators\r\n *\r\n * * `+`\r\n * * `-`\r\n * * `*`\r\n * * `/`\r\n * * `(` and `)`\r\n *\r\n * Functions\r\n *\r\n * * min( a, b, ... )\r\n * * max( a, b, ... )\r\n *\r\n * Examples\r\n *\r\n * * `90%`: 0.9 * parent value\r\n * * `50s`: 0.5 * self value\r\n * * `90% - 50s`: 0.9 * parent value - 0.5 * self value\r\n * * `90% - (50s + 100) * 2`: 0.9 * parent value - ( 0.5 * self value + 100 ) * 2\r\n */\r\nexport class DScalarExpression implements DScalar {\r\n\tprotected static TOKEN_REGEX = /(?:\\+|-|\\*|\\/|\\(|\\)|min|max|,|(?:\\d+(?:\\.\\d*)?[%psc]?))/g;\r\n\tprotected _node: Node;\r\n\r\n\tconstructor( expression: string ) {\r\n\t\tconst nodes: NodeOrToken[] = this.toToken( expression );\r\n\t\tlet i = 0;\r\n\t\tdo {\r\n\t\t\ti = this.toParensesis( nodes, i );\r\n\t\t} while( i < nodes.length );\r\n\t\tthis.toUnary( nodes );\r\n\t\tthis.toArithmetic( nodes, NodeType.MUL, NodeType.DIV );\r\n\t\tthis.toArithmetic( nodes, NodeType.ADD, NodeType.SUB );\r\n\t\tif( nodes.length === 1 ) {\r\n\t\t\tconst node = nodes[ 0 ];\r\n\t\t\tif( ! isNumber( node ) ) {\r\n\t\t\t\tthis._node = node as any;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new Error( `Failed to parse '${expression}'` );\r\n\t}\r\n\r\n\ttoParensesis( nodes: NodeOrToken[], ifrom: number ): number {\r\n\t\tlet ito = nodes.length;\r\n\t\tfor( let i = ifrom; i < ito; ++i ) {\r\n\t\t\tconst inode = nodes[ i ];\r\n\t\t\tif( inode === NodeType.OPEN ) {\r\n\t\t\t\tlet istart = i;\r\n\t\t\t\tlet nodeType = NodeType.PARENSESIS;\r\n\t\t\t\tif( 0 < i ) {\r\n\t\t\t\t\tconst nodeTypePrev = nodes[ i - 1 ];\r\n\t\t\t\t\tif( nodeTypePrev === NodeType.MIN || nodeTypePrev === NodeType.MAX ) {\r\n\t\t\t\t\t\tistart -= 1;\r\n\t\t\t\t\t\tnodeType = nodeTypePrev;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor( let j = i + 1; j < ito; ++j ) {\r\n\t\t\t\t\tconst jnode = nodes[ j ];\r\n\t\t\t\t\tif( jnode === NodeType.CLOSE ) {\r\n\t\t\t\t\t\tnodes[ istart ] = [ nodeType, this.toComma( nodes, i + 1, j ) ];\r\n\t\t\t\t\t\tnodes.splice( istart + 1, j - istart );\r\n\t\t\t\t\t\treturn istart + 1;\r\n\t\t\t\t\t} else if( jnode === NodeType.OPEN ) {\r\n\t\t\t\t\t\tj = this.toParensesis( nodes, j ) - 1;\r\n\t\t\t\t\t\tito = nodes.length;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error( `Malformed parensesis` );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ito;\r\n\t}\r\n\r\n\ttoCommaOf( nodes: NodeOrToken[], ifrom: number, ito: number ): NodeOrToken {\r\n\t\tconst l = ito - ifrom;\r\n\t\tif( l <= 0 ) {\r\n\t\t\treturn [ NodeType.NUMBER, 0 ];\r\n\t\t} else if( l <= 1 ) {\r\n\t\t\treturn nodes[ ifrom ];\r\n\t\t} else {\r\n\t\t\tconst operand: NodeOrToken[] = [];\r\n\t\t\tfor( let j = ifrom; j < ito; ++j ) {\r\n\t\t\t\toperand.push( nodes[ j ] );\r\n\t\t\t}\r\n\t\t\treturn [ NodeType.PARENSESIS, operand ];\r\n\t\t}\r\n\t}\r\n\r\n\ttoComma( nodes: NodeOrToken[], ifrom: number, ito: number ): NodeOrToken[] {\r\n\t\tlet result: NodeOrToken[] | null = null;\r\n\t\tlet iprev = ifrom;\r\n\t\tfor( let i = ifrom; i < ito; ++i ) {\r\n\t\t\tconst node = nodes[ i ];\r\n\t\t\tif( node === NodeType.COMMA ) {\r\n\t\t\t\tresult = result || [];\r\n\t\t\t\tresult.push( this.toCommaOf( nodes, iprev, i ) );\r\n\t\t\t\tiprev = i + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif( iprev < ito ) {\r\n\t\t\tif( result == null ) {\r\n\t\t\t\tconst operand: NodeOrToken[] = [];\r\n\t\t\t\tfor( let i = iprev; i < ito; ++i ) {\r\n\t\t\t\t\toperand.push( nodes[ i ] );\r\n\t\t\t\t}\r\n\t\t\t\treturn operand;\r\n\t\t\t} else {\r\n\t\t\t\tresult.push( this.toCommaOf( nodes, iprev, ito ) );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result || [];\r\n\t}\r\n\r\n\ttoUnaryNode( node: NodeOrToken ): void {\r\n\t\tif( ! isNumber( node ) ) {\r\n\t\t\tif( node[ 0 ] === NodeType.PARENSESIS ||\r\n\t\t\t\tnode[ 0 ] === NodeType.MIN ||\r\n\t\t\t\tnode[ 0 ] === NodeType.MAX ) {\r\n\t\t\t\tthis.toUnary( node[ 1 ] );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ttoUnary( nodes: NodeOrToken[] ): void {\r\n\t\tfor( let i = 0, imax = nodes.length; i < imax; ++i ) {\r\n\t\t\tconst node = nodes[ i ];\r\n\t\t\tif( node === NodeType.ADD_OR_PLUS || node === NodeType.SUB_OR_MINUS ) {\r\n\t\t\t\tif( i <= 0 || isNumber( nodes[ i - 1 ] ) ) {\r\n\t\t\t\t\tif( i + 1 < imax && ! isNumber( nodes[ i + 1 ] ) ) {\r\n\t\t\t\t\t\tconst operand = nodes.splice( i + 1, 1 )[ 0 ];\r\n\t\t\t\t\t\tconst type = ( node === NodeType.ADD_OR_PLUS ? NodeType.PLUS : NodeType.MINUS );\r\n\t\t\t\t\t\tnodes[ i ] = [ type, operand ];\r\n\t\t\t\t\t\timax = nodes.length;\r\n\t\t\t\t\t\tthis.toUnaryNode( operand );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error( \"Malformed unary operator\" );\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst type = ( node === NodeType.ADD_OR_PLUS ? NodeType.ADD : NodeType.SUB );\r\n\t\t\t\t\tnodes[ i ] = type;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.toUnaryNode( node );\r\n\t\t\t\timax = nodes.length;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ttoArithmeticNode( node: NodeOrToken, operatorA: NodeArithmeticOperator, operatorB: NodeArithmeticOperator ): void {\r\n\t\tif( ! isNumber( node ) ) {\r\n\t\t\tif( node[ 0 ] === NodeType.PARENSESIS || node[ 0 ] === NodeType.MIN || node[ 0 ] === NodeType.MAX ) {\r\n\t\t\t\tthis.toArithmetic( node[ 1 ], operatorA, operatorB );\r\n\t\t\t} else if( node[ 0 ] === NodeType.PLUS || node[ 0 ] === NodeType.MINUS ) {\r\n\t\t\t\tthis.toArithmeticNode( node[ 1 ], operatorA, operatorB );\r\n\t\t\t} else if( node[ 0 ] === NodeType.ADD || node[ 0 ] === NodeType.SUB ||\r\n\t\t\t\tnode[ 0 ] === NodeType.MUL || node[ 0 ] === NodeType.DIV ) {\r\n\t\t\t\tthis.toArithmeticNode( node[ 1 ], operatorA, operatorB );\r\n\t\t\t\tthis.toArithmeticNode( node[ 2 ], operatorA, operatorB );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ttoArithmetic( nodes: NodeOrToken[], operatorA: NodeArithmeticOperator, operatorB: NodeArithmeticOperator ): void {\r\n\t\tfor( let i = 0, imax = nodes.length; i < imax; ++i ) {\r\n\t\t\tconst node = nodes[ i ];\r\n\t\t\tif( node === operatorA || node === operatorB ) {\r\n\t\t\t\tif( 0 < i && i + 1 < imax ) {\r\n\t\t\t\t\tconst left = nodes[ i - 1 ];\r\n\t\t\t\t\tconst right = nodes[ i + 1 ];\r\n\t\t\t\t\tif( ! isNumber( left ) && ! isNumber( right ) ) {\r\n\t\t\t\t\t\tnodes.splice( i, 2 );\r\n\t\t\t\t\t\tnodes[ i - 1 ] = [ node, left, right ];\r\n\t\t\t\t\t\ti -= 1;\r\n\t\t\t\t\t\timax = nodes.length;\r\n\t\t\t\t\t\tthis.toArithmeticNode( left, operatorA, operatorB );\r\n\t\t\t\t\t\tthis.toArithmeticNode( right, operatorA, operatorB );\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error( `Malformed operands for the operator ${node}` );\r\n\t\t\t} else {\r\n\t\t\t\tthis.toArithmeticNode( node, operatorA, operatorB );\r\n\t\t\t\timax = nodes.length;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ttoToken( expression: string ): Token[] {\r\n\t\tconst tokens: Token[] = [];\r\n\t\twhile( true ) {\r\n\t\t\tconst matched = DScalarExpression.TOKEN_REGEX.exec( expression );\r\n\t\t\tif( matched != null ) {\r\n\t\t\t\tconst token = matched[ 0 ];\r\n\t\t\t\tconst tokenTypeOperator = TOKEN_MAPPING_OPERATOR[ token ];\r\n\t\t\t\tif( tokenTypeOperator != null ) {\r\n\t\t\t\t\ttokens.push( tokenTypeOperator );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst parsedToken = parseFloat( token );\r\n\t\t\t\t\tif( parsedToken !== parsedToken ) {\r\n\t\t\t\t\t\tthrow new Error( `Unexpected token '${token}' at ${matched.index} in '${expression}'` );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst tokenTypeLiteral = TOKEN_MAPPING_LITERAL[ token[ token.length - 1 ] ];\r\n\t\t\t\t\tif( tokenTypeLiteral != null ) {\r\n\t\t\t\t\t\ttokens.push([ tokenTypeLiteral, parsedToken * 0.01 ]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttokens.push([ NodeType.NUMBER, parsedToken ]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\tprotected evaluate( node: Node, parent: number, self: number, padding: number, current: number ): number {\r\n\t\tswitch( node[ 0 ] ) {\r\n\t\tcase NodeType.PARENSESIS:\r\n\t\t\tconst nodes = node[ 1 ];\r\n\t\t\treturn this.evaluate( nodes[ nodes.length - 1 ], parent, self, padding, current );\r\n\r\n\t\t// Unary operators\r\n\t\tcase NodeType.PLUS:\r\n\t\t\treturn + this.evaluate( node[ 1 ], parent, self, padding, current );\r\n\r\n\t\tcase NodeType.MINUS:\r\n\t\t\treturn - this.evaluate( node[ 1 ], parent, self, padding, current );\r\n\r\n\t\t// Four arithmetic operators\r\n\t\tcase NodeType.ADD:\r\n\t\t\treturn this.evaluate( node[ 1 ], parent, self, padding, current ) +\r\n\t\t\t\tthis.evaluate( node[ 2 ], parent, self, padding, current );\r\n\t\tcase NodeType.SUB:\r\n\t\t\treturn this.evaluate( node[ 1 ], parent, self, padding, current ) -\r\n\t\t\t\tthis.evaluate( node[ 2 ], parent, self, padding, current );\r\n\t\tcase NodeType.MUL:\r\n\t\t\treturn this.evaluate( node[ 1 ], parent, self, padding, current ) *\r\n\t\t\t\tthis.evaluate( node[ 2 ], parent, self, padding, current );\r\n\t\tcase NodeType.DIV:\r\n\t\t\treturn this.evaluate( node[ 1 ], parent, self, padding, current ) /\r\n\t\t\t\tthis.evaluate( node[ 2 ], parent, self, padding, current );\r\n\r\n\t\t// Functions\r\n\t\tcase NodeType.MIN:\r\n\t\t\tif( 0 < node[ 1 ].length ) {\r\n\t\t\t\tconst args = node[ 1 ];\r\n\t\t\t\tlet result = this.evaluate( args[ 0 ], parent, self, padding, current );\r\n\t\t\t\tfor( let i = 1, imax = args.length; i < imax; ++i ) {\r\n\t\t\t\t\tresult = Math.min( result, this.evaluate( args[ i ], parent, self, padding, current ) );\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\tcase NodeType.MAX:\r\n\t\t\tif( 0 < node[ 1 ].length ) {\r\n\t\t\t\tconst args = node[ 1 ];\r\n\t\t\t\tlet result = this.evaluate( args[ 0 ], parent, self, padding, current );\r\n\t\t\t\tfor( let i = 1, imax = args.length; i < imax; ++i ) {\r\n\t\t\t\t\tresult = Math.max( result, this.evaluate( args[ i ], parent, self, padding, current ) );\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\r\n\t\t// Literals\r\n\t\tcase NodeType.PARENT:\r\n\t\t\treturn node[ 1 ] * parent;\r\n\t\tcase NodeType.SELF:\r\n\t\t\treturn node[ 1 ] * self;\r\n\t\tcase NodeType.PADDING:\r\n\t\t\treturn node[ 1 ] * padding;\r\n\t\tcase NodeType.CURRENT:\r\n\t\t\treturn node[ 1 ] * current;\r\n\t\tcase NodeType.NUMBER:\r\n\t\t\treturn node[ 1 ];\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tcalculate( parent: number, self: number, padding: number, current: number ): number {\r\n\t\treturn this.evaluate( this._node, parent, self, padding, current );\r\n\t}\r\n}\r\n"]}