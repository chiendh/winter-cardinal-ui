{"version":3,"file":"d-chart-coordinate.js","sourceRoot":"","sources":["../../../src/main/typescript/wcardinal/ui/d-chart-coordinate.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAKH,MAAM,CAAN,IAAY,yBAGX;AAHD,WAAY,yBAAyB;IACpC,mEAAC,CAAA;IACD,mEAAC,CAAA;AACF,CAAC,EAHW,yBAAyB,KAAzB,yBAAyB,QAGpC","sourcesContent":["/*\r\n * Copyright (C) 2019 Toshiba Corporation\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport { DChartCoordinateContainerSub } from \"./d-chart-coordinate-container-sub\";\r\nimport { DChartCoordinateTransform } from \"./d-chart-coordinate-transform\";\r\n\r\nexport enum DChartCoordinateDirection {\r\n\tX,\r\n\tY\r\n}\r\n\r\nexport interface DChartCoordinate {\r\n\t/**\r\n\t * Monotonic increasing ID for change detection.\r\n\t */\r\n\treadonly id: number;\r\n\treadonly transform: DChartCoordinateTransform;\r\n\r\n\tbind( container: DChartCoordinateContainerSub, direction: DChartCoordinateDirection ): void;\r\n\tunbind(): void;\r\n\r\n\t/**\r\n\t * Adjusts the transform so that mapped points of the given range fit into the plot area\r\n\t * if the plot area container's localTransform is an identity matrix.\r\n\t *\r\n\t * @param from a lower end of the range\r\n\t * @param to an upper end of the range\r\n\t */\r\n\tfit( from?: number, to?: number ): void;\r\n\r\n\tmark( from?: number, to?: number ): void;\r\n\r\n\tblend( ratio: number ): void;\r\n\r\n\t/**\r\n\t * Transforms the given raw value to the untransformed value.\r\n\t *\r\n\t * @param value a raw value\r\n\t */\r\n\tmap( value: number ): number;\r\n\r\n\t/**\r\n\t * Transforms the given raw values to untransformed values.\r\n\t * Numbers whose indices are ifrom + i * stride + offset and less than iend will be transformed.\r\n\t * Here, i is a non-negative integer.\r\n\t *\r\n\t * @param values raw values to be transformed\r\n\t * @param ifrom an index on raw values at which to begin a transformation\r\n\t * @param iend an index on raw values before which to end a transformation\r\n\t * @param stride a stride of indices\r\n\t * @param offset an offset of indices\r\n\t */\r\n\tmapAll( values: number[], ifrom: number, iend: number, stride: number, offset: number ): void;\r\n\r\n\t/**\r\n\t * Transforms the given untransformed value to the raw value.\r\n\t *\r\n\t * @param value an untransformed value\r\n\t */\r\n\tunmap( value: number ): number;\r\n\r\n\t/**\r\n\t * Transforms the given untransformed values to raw values.\r\n\t * Numbers whose indices are ifrom + i * stride + offset and less than iend will be transformed.\r\n\t * Here, i is a non-negative integer.\r\n\t *\r\n\t * @param values untrasformed values to be transformed\r\n\t * @param ifrom an index on raw values at which to begin a transformation\r\n\t * @param iend an index on raw values at which to begin a transformation\r\n\t * @param stride a stride of indices\r\n\t * @param offset an offset of indices\r\n\t */\r\n\tunmapAll( values: number[], ifrom: number, iend: number, stride: number, offset: number ): void;\r\n\r\n\t/**\r\n\t * Returns major / minor tick positions.\r\n\t *\r\n\t * @param domainMin minimum domain\r\n\t * @param domainMax maximum domain\r\n\t * @param majorCount Expected major tick count\r\n\t * @param minorCountPerMajor Expected minor tick count per major ticks\r\n\t * @param minorCount Expected total minor tick count\r\n\t * @param majorResult `majorResult.length` must be larger than `majorCount * 3`.\r\n\t * @param minorResult `minorResult.length` must be larger than `minorCount * 3`.\r\n\t */\r\n\tticks(\r\n\t\tdomainMin: number,\r\n\t\tdomainMax: number,\r\n\t\tmajorCount: number,\r\n\t\tminorCountPerMajor: number,\r\n\t\tminorCount: number,\r\n\t\tmajorResult: Float64Array,\r\n\t\tminorResult: Float64Array\r\n\t): void;\r\n}\r\n"]}