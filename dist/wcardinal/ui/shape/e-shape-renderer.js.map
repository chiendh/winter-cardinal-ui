{"version":3,"file":"e-shape-renderer.js","sourceRoot":"","sources":["../../../../src/main/typescript/wcardinal/ui/shape/e-shape-renderer.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (C) 2019 Toshiba Corporation\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport { BaseTexture, BLEND_MODES, ObjectRenderer, Renderer, Shader, Texture, utils } from \"pixi.js\";\r\nimport { DynamicAtlas } from \"../util/dynamic-atlas\";\r\nimport { DynamicAtlasItemImage } from \"../util/dynamic-atlas-item-image\";\r\nimport { DynamicSDFFontAtlases } from \"../util/dynamic-sdf-font-atlases\";\r\nimport { EShape } from \"./e-shape\";\r\nimport { EShapeBuffer } from \"./e-shape-buffer\";\r\nimport { EShapeContainer } from \"./e-shape-container\";\r\nimport { EShapeRendererIterator } from \"./e-shape-renderer-iterator\";\r\n\r\nconst VERTEX_SHADER = `\r\nattribute vec2 aPosition;\r\nattribute vec3 aClipping;\r\nattribute vec2 aStep;\r\nattribute vec4 aAntialias;\r\nattribute vec4 aColorFill;\r\nattribute vec4 aColorStroke;\r\nattribute vec2 aUv;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mediump float pixelScale;\r\nuniform mediump float antialiasWeight;\r\n\r\nvarying mediump vec3 vClipping;\r\nvarying mediump vec2 vStep;\r\nvarying mediump vec4 vAntialias;\r\nvarying mediump vec4 vColorFill;\r\nvarying mediump vec4 vColorStroke;\r\nvarying mediump vec2 vUv;\r\n\r\nvec2 toInverse( in vec2 v ) {\r\n\treturn vec2( -v.y, v.x );\r\n}\r\n\r\nvec2 toTransformedPosition( in vec2 v ) {\r\n\treturn (projectionMatrix * translationMatrix * vec3(v, 1.0)).xy;\r\n}\r\n\r\nvec4 toAntialias01( in vec4 antialias, in float scale ) {\r\n\t// Taylor series of 1 / ( 1 - a ) = 1 + a + a^2 + ....\r\n\treturn 1.0 + min( vec4( 1.0 ), antialias * scale );\r\n}\r\n\r\nvec4 toAntialias2( in vec2 step, in vec4 antialias, in float scale ) {\r\n\tfloat x = min( 0.4, step.x * scale );\r\n\tfloat y = 0.5 - antialias.x;\r\n\tfloat z = 0.5 - antialias.x - step.y;\r\n\treturn vec4( y, z, y - max( 0.01, y - x ), z - max( 0.01, z - x ) );\r\n}\r\n\r\nvec2 toPosition3456( in float type, in vec2 p, in vec2 pprev, in vec2 pnext, in float strokeWidth, out float shift ) {\r\n\tvec2 d0 = p - pprev;\r\n\tvec2 d1 = pnext - p;\r\n\tfloat l0 = dot( d0, d0 );\r\n\tfloat l1 = dot( d1, d1 );\r\n\tvec2 nd0 = normalize( toInverse( d0 ) );\r\n\tvec2 nd1 = normalize( toInverse( d1 ) );\r\n\tvec2 n0 = 0.00001 < l0 ? nd0 : nd1;\r\n\tvec2 n1 = 0.00001 < l1 ? nd1 : nd0;\r\n\tvec2 n0i = toInverse( n0 );\r\n\tvec2 n1i = toInverse( n1 );\r\n\tfloat direction = sign( 4.5 - type );\r\n\r\n\t// Offset\r\n\tfloat cross = dot( n0i, n1 );\r\n\tfloat crossInverse = ( 0.00001 < abs( cross ) ? 1.0 / cross : 0.0 );\r\n\tfloat b = dot(n1 - n0, n0) * crossInverse;\r\n\tfloat offsetSize = direction * strokeWidth * 0.5;\r\n\tvec2 offset = n1 + n1i * b;\r\n\r\n\t// Miter\r\n\tvec2 pmiter = p + offsetSize * offset;\r\n\tfloat miterAngle0 = dot( n0i, pmiter - pprev );\r\n\tfloat miterAngle1 = dot( n1i, pmiter - pnext );\r\n\tfloat miterLength = dot( offset, offset );\r\n\tfloat miterSide = direction * cross;\r\n\r\n\t// Bevel\r\n\tvec2 n = ( type == 4.0 || type == 6.0 ? n1 : n0 );\r\n\tvec2 pbevel = p + offsetSize * n;\r\n\r\n\t//\r\n\tvec2 presult = (\r\n\t\t0.0 <= miterAngle0 || miterAngle1 < 0.0 || miterSide < 0.0 ?\r\n\t\tpbevel : pmiter\r\n\t);\r\n\t/*\r\n\tvec2 presult = (\r\n\t\tmiterAngle0 < 0.0 && 0.0 <= miterAngle1 && miterLength < 50.0 ?\r\n\t\tpmiter : pbevel\r\n\t);\r\n\t*/\r\n\tvec2 ni = ( type == 4.0 || type == 6.0 ? n1i : n0i );\r\n\tshift = dot( ni, p - presult );\r\n\treturn toTransformedPosition( presult );\r\n}\r\n\r\nvec2 toStep3456( in float type ) {\r\n\treturn ( type < 4.5 ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 ) );\r\n}\r\n\r\nvec4 toAntialias3456( in float strokeWidth, in float scale ) {\r\n\tfloat a = antialiasWeight / max( 0.0001, strokeWidth );\r\n\treturn toAntialias01( vec4( a, a, a, a ), scale );\r\n}\r\n\r\nfloat toDotAndDashScale( in float scale, in float strokeWidthScale ) {\r\n\treturn (\r\n\t\tscale == 4.0 || scale == 5.0 || scale == 6.0 || scale == 7.0 ?\r\n\t\tstrokeWidthScale : 1.0\r\n\t);\r\n}\r\n\r\nvec4 toColorStroke3456( in float shift, in float scale ) {\r\n\tfloat x = aColorFill.x + shift;\r\n\tfloat y = scale * aColorFill.y;\r\n\tfloat z = scale * aColorFill.z;\r\n\tfloat w = aColorFill.w;\r\n\treturn vec4( x, y, z, w );\r\n}\r\n\r\nfloat toStrokeWidthScale( in float scale ) {\r\n\treturn (\r\n\t\tscale == 3.0 || scale == 7.0 ?\r\n\t\tpixelScale : (\r\n\t\t\tscale == 1.0 || scale == 5.0 ?\r\n\t\t\tmin( 1.0, pixelScale ) : (\r\n\t\t\t\tscale == 2.0 || scale == 6.0 ?\r\n\t\t\t\tmax( 1.0, pixelScale ) : 1.0\r\n\t\t\t)\r\n\t\t)\r\n\t);\r\n}\r\n\r\nvoid main(void) {\r\n\tvec2 p012 = toTransformedPosition( aPosition );\r\n\r\n\tfloat type = aClipping.z;\r\n\r\n\t// type === 0 or 1\r\n\tvec4 a01 = toAntialias01( aAntialias, pixelScale );\r\n\r\n\t// type === 2\r\n\tvec4 a2 = toAntialias2( aStep, aAntialias, pixelScale );\r\n\r\n\t// type === 3, 4, 5 or 6\r\n\tfloat shift3456 = 0.0;\r\n\tfloat strokeWidthScale = toStrokeWidthScale( aStep.y );\r\n\tfloat strokeWidth = strokeWidthScale * aStep.x;\r\n\tvec2 p3456 = toPosition3456( type, aPosition, aAntialias.xy, aAntialias.zw, strokeWidth, shift3456 );\r\n\tvec2 step3456 = toStep3456( type );\r\n\tvec4 a3456 = toAntialias3456( strokeWidth, pixelScale );\r\n\tvec4 colorStroke3456 = toColorStroke3456( shift3456, toDotAndDashScale( aStep.y, strokeWidthScale ) );\r\n\r\n\t//\r\n\tgl_Position = vec4( ( 2.5 < type ? p3456 : p012 ), 0.0, 1.0 );\r\n\tvAntialias = ( 1.5 < type ? ( 2.5 < type ? a3456 : a2 ) : a01 );\r\n\tvClipping = aClipping;\r\n\tvStep = ( 2.5 < type ? step3456 : aStep );\r\n\tvColorFill = ( 2.5 < type ? aColorStroke : aColorFill );\r\n\tvColorStroke = ( 2.5 < type ? colorStroke3456 : aColorStroke );\r\n\tvUv = aUv;\r\n}`;\r\n\r\nconst FRAGMENT_SHADER_NO_AA = `\r\nvarying mediump vec3 vClipping;\r\nvarying mediump vec2 vStep;\r\nvarying mediump vec4 vAntialias;\r\nvarying mediump vec4 vColorFill;\r\nvarying mediump vec4 vColorStroke;\r\nvarying mediump vec2 vUv;\r\n\r\nuniform sampler2D sampler;\r\nuniform mediump float pixelScale;\r\n\r\nvoid main(void) {\r\n\tvec4 texture = texture2D(sampler, vUv);\r\n\tfloat type = vClipping.z;\r\n\tvec2 v0 = vStep;\r\n\tvec2 v1 = vClipping.xy;\r\n\tvec2 v2 = v0 * vAntialias.xy;\r\n\tvec2 v3 = v1 * vAntialias.zw;\r\n\tvec2 d01 = ( v0.x < v0.y ? vec2( v0.y, v2.y ) : vec2( v0.x, v2.x ) );\r\n\tvec2 d02 = ( v1.x < v1.y ? vec2( v1.y, v3.y ) : vec2( v1.x, v3.x ) );\r\n\tvec4 d0 = vec4( d01.x, d02.x, d01.y, d02.y );\r\n\tvec4 d1 = vec4( dot( v0, v0 ), dot( v1, v1 ), dot( v2, v2 ), dot( v3, v3 ) );\r\n\tvec4 d = ( type == 1.0 ? d1 : d0 );\r\n\tvec2 s = step( vec2( 1.0 ), d.xy );\r\n\tvec4 color01 = texture * (vColorStroke * (s.x - s.y) + vColorFill * (1.0 - s.x));\r\n\r\n\tfloat l = vColorStroke.x;\r\n\tfloat lp0 = vColorStroke.y;\r\n\tfloat lp1 = vColorStroke.z;\r\n\tfloat lt = vColorStroke.w;\r\n\tfloat lm = mod( l, lp0 + lp1 );\r\n\tfloat ls0 = step( 0.0, lm );\r\n\tfloat ls1 = step( lp0, lm );\r\n\tfloat ls2 = ( 0.0 <= lt ? 1.0 - step( lt, l ) : 1.0 );\r\n\tvec4 color3456 = color01 * ( ls0 - ls1 ) * ls2;\r\n\r\n\tvec2 a0 = vAntialias.xy;\r\n\tvec2 a1 = vAntialias.zw;\r\n\tvec2 a2 = vec2( texture.a );\r\n\tvec2 a = smoothstep( a0 - a1, a0 + a1, a2 );\r\n\tvec4 color2 = a.x * vColorFill + ( a.y - a.x ) * vColorStroke;\r\n\tgl_FragColor = ( type == 2.0 ? color2 : (2.5 < type ? color3456 : color01) );\r\n}`;\r\n\r\nconst FRAGMENT_SHADER = `\r\nvarying mediump vec3 vClipping;\r\nvarying mediump vec2 vStep;\r\nvarying mediump vec4 vAntialias;\r\nvarying mediump vec4 vColorFill;\r\nvarying mediump vec4 vColorStroke;\r\nvarying mediump vec2 vUv;\r\n\r\nuniform sampler2D sampler;\r\nuniform mediump float pixelScale;\r\n\r\nvoid main(void) {\r\n\tvec4 texture = texture2D(sampler, vUv);\r\n\tfloat type = vClipping.z;\r\n\tvec2 v0 = vStep;\r\n\tvec2 v1 = vClipping.xy;\r\n\tvec2 v2 = v0 * vAntialias.xy;\r\n\tvec2 v3 = v1 * vAntialias.zw;\r\n\tvec2 d01 = ( v0.x < v0.y ? vec2( v0.y, v2.y ) : vec2( v0.x, v2.x ) );\r\n\tvec2 d02 = ( v1.x < v1.y ? vec2( v1.y, v3.y ) : vec2( v1.x, v3.x ) );\r\n\tvec4 d0 = vec4( d01.x, d02.x, d01.y, d02.y );\r\n\tvec4 d1 = vec4( dot( v0, v0 ), dot( v1, v1 ), dot( v2, v2 ), dot( v3, v3 ) );\r\n\tvec4 d = ( type == 1.0 ? d1 : d0 );\r\n\tvec2 s = smoothstep( 1.0 - (d.zw - d.xy), vec2( 1.0 ), d.xy );\r\n\tvec4 color01 = texture * (vColorStroke * (s.x - s.y) + vColorFill * (1.0 - s.x));\r\n\r\n\tfloat l = vColorStroke.x;\r\n\tfloat lp0 = vColorStroke.y;\r\n\tfloat lp1 = vColorStroke.z;\r\n\tfloat lt = vColorStroke.w;\r\n\tfloat ld = 0.5 * pixelScale;\r\n\tfloat lm = mod( l, lp0 + lp1 );\r\n\tfloat ls0 = smoothstep( 0.0, 0.0 + ld, lm );\r\n\tfloat ls1 = smoothstep( lp0, lp0 + ld, lm );\r\n\tfloat ls2 = ( 0.0 <= lt ? 1.0 - smoothstep( lt - ld, lt, l ) : 1.0 );\r\n\tvec4 color3456 = color01 * ( ls0 - ls1 ) * ls2;\r\n\r\n\tvec2 a0 = vAntialias.xy;\r\n\tvec2 a1 = vAntialias.zw;\r\n\tvec2 a2 = vec2( texture.a );\r\n\tvec2 a = smoothstep( a0 - a1, a0 + a1, a2 );\r\n\tvec4 color2 = a.x * vColorFill + ( a.y - a.x ) * vColorStroke;\r\n\tgl_FragColor = ( type == 2.0 ? color2 : (2.5 < type ? color3456 : color01) );\r\n}`;\r\n\r\nexport class EShapeRenderer extends ObjectRenderer {\r\n\tstatic SHADER: Shader | null = null;\r\n\r\n\tprotected _shader: Shader | null;\r\n\tprotected _iterator: EShapeRendererIterator;\r\n\tprotected _bufferSizeMax: number;\r\n\r\n\tconstructor( renderer: Renderer ) {\r\n\t\tsuper( renderer );\r\n\t\tEShapeRenderer.SHADER = EShapeRenderer.SHADER || Shader.from( VERTEX_SHADER, FRAGMENT_SHADER );\r\n\t\tthis._shader = EShapeRenderer.SHADER;\r\n\t\tthis._iterator = new EShapeRendererIterator();\r\n\t\tthis._bufferSizeMax = this.getBufferSizeMax( renderer );\r\n\t}\r\n\r\n\tprotected getBufferSizeMax( renderer: Renderer ): number {\r\n\t\tconst context = renderer.context;\r\n\t\tconst extensions = context.extensions as any;\r\n\t\tif( 1 < context.webGLVersion || !! extensions.uint32ElementIndex ) {\r\n\t\t\treturn 1431655765; // 2^32 / 3\r\n\t\t}\r\n\t\treturn 21845; // 2^16 / 3\r\n\t}\r\n\r\n\tupdateAtlas(\r\n\t\tshape: EShape,\r\n\t\tatlas: DynamicAtlas, fontAtlases: DynamicSDFFontAtlases,\r\n\t\tdefaultTexture: Texture, baseTexture: BaseTexture\r\n\t): void {\r\n\t\t// Texture\r\n\t\t// Do not access the shape.image.src here.\r\n\t\t// It slows down the rendering speed significantly.\r\n\t\tconst imageSrc = shape.imageSrc;\r\n\t\tif( imageSrc != null ) {\r\n\t\t\tconst textureItem = atlas.get( imageSrc );\r\n\t\t\tif( textureItem != null ) {\r\n\t\t\t\tshape.texture = textureItem.texture;\r\n\t\t\t} else {\r\n\t\t\t\tconst newTextureItem = new DynamicAtlasItemImage( shape.image!, baseTexture );\r\n\t\t\t\tshape.texture = newTextureItem.texture;\r\n\t\t\t\tatlas.set( newTextureItem.id, newTextureItem );\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tshape.texture = defaultTexture;\r\n\t\t}\r\n\r\n\t\t// Font texture atlas\r\n\t\tconst text = shape.text;\r\n\t\tconst textValue = text.value;\r\n\t\tif( 0 < textValue.length ) {\r\n\t\t\tfontAtlases.add( text.family, textValue );\r\n\t\t}\r\n\t}\r\n\r\n\tupdateAtlases(\r\n\t\tshapes: EShape[],\r\n\t\tatlas: DynamicAtlas, fontAtlases: DynamicSDFFontAtlases,\r\n\t\tdefaultTexture: Texture, baseTexture: BaseTexture\r\n\t): void {\r\n\t\tfor( let i = 0, imax = shapes.length; i < imax; ++i ) {\r\n\t\t\tconst shape = shapes[ i ];\r\n\t\t\tthis.updateAtlas( shape, atlas, fontAtlases, defaultTexture, baseTexture );\r\n\t\t\tconst children = shape.children;\r\n\t\t\tfor( let j = 0, jmax = children.length; j < jmax; ++j ) {\r\n\t\t\t\tconst child = children[ j ];\r\n\t\t\t\tthis.updateAtlas( child, atlas, fontAtlases, defaultTexture, baseTexture );\r\n\t\t\t\tthis.updateAtlases( child.children, atlas, fontAtlases, defaultTexture, baseTexture );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tupdateFontAtlas(\r\n\t\tshape: EShape,\r\n\t\tatlas: DynamicAtlas, fontAtlases: DynamicSDFFontAtlases,\r\n\t\tdefaultTexture: Texture\r\n\t): void {\r\n\t\tconst text = shape.text;\r\n\t\tconst fontAtlas = fontAtlases.get( text.family );\r\n\t\tif( fontAtlas != null ) {\r\n\t\t\tconst textureItem = atlas.get( fontAtlas.id );\r\n\t\t\tif( textureItem != null ) {\r\n\t\t\t\ttext.atlas = fontAtlas;\r\n\t\t\t\ttext.texture = textureItem.texture;\r\n\t\t\t} else {\r\n\t\t\t\ttext.atlas = undefined;\r\n\t\t\t\ttext.texture = defaultTexture;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttext.atlas = undefined;\r\n\t\t\ttext.texture = defaultTexture;\r\n\t\t}\r\n\t}\r\n\r\n\tupdateFontAtlases(\r\n\t\tshapes: EShape[],\r\n\t\tatlas: DynamicAtlas, fontAtlases: DynamicSDFFontAtlases,\r\n\t\tdefaultTexture: Texture\r\n\t): void {\r\n\t\tfor( let i = 0, imax = shapes.length; i < imax; ++i ) {\r\n\t\t\tconst shape = shapes[ i ];\r\n\t\t\tthis.updateFontAtlas( shape, atlas, fontAtlases, defaultTexture );\r\n\t\t\tconst children = shape.children;\r\n\t\t\tfor( let j = 0, jmax = children.length; j < jmax; ++j ) {\r\n\t\t\t\tconst child = children[ j ];\r\n\t\t\t\tthis.updateFontAtlas( child, atlas, fontAtlases, defaultTexture );\r\n\t\t\t\tthis.updateFontAtlases( child.children, atlas, fontAtlases, defaultTexture );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\trender_( container: EShapeContainer, shapes: EShape[], isDirty: boolean ): void {\r\n\t\tconst renderer = this.renderer;\r\n\t\tconst shader = this._shader;\r\n\r\n\t\tif( shader != null && 0 < shapes.length ) {\r\n\t\t\tconst resolution = renderer.resolution;\r\n\t\t\tconst buffers = container.getBuffers();\r\n\t\t\tconst antialiasWeight = container.getAntialiasWeight( resolution );\r\n\r\n\t\t\t// Update textures\r\n\t\t\tif( isDirty ) {\r\n\t\t\t\t// Atlases\r\n\t\t\t\tconst atlas = container.getAtlas( resolution );\r\n\t\t\t\tconst fontAtlases = container.getFontAtlases();\r\n\t\t\t\tatlas.begin();\r\n\t\t\t\tfontAtlases.begin();\r\n\t\t\t\tconst defaultTexture = atlas.getDefaultTexture();\r\n\t\t\t\tconst baseTexture: BaseTexture = atlas.getBaseTexture();\r\n\t\t\t\tthis.updateAtlases( shapes, atlas, fontAtlases, defaultTexture, baseTexture );\r\n\t\t\t\tfontAtlases.end();\r\n\t\t\t\tfontAtlases.update( atlas );\r\n\t\t\t\tthis.updateFontAtlases( shapes, atlas, fontAtlases, defaultTexture );\r\n\t\t\t\tatlas.end();\r\n\t\t\t\tatlas.repack();\r\n\r\n\t\t\t\t// Update buffers\r\n\t\t\t\tthis.updateBuffers( shapes, buffers, renderer, antialiasWeight );\r\n\t\t\t}\r\n\r\n\t\t\t// Render buffers\r\n\t\t\tshader.uniforms.pixelScale = container.toPixelScale( resolution );\r\n\t\t\tshader.uniforms.antialiasWeight = antialiasWeight;\r\n\t\t\tshader.uniforms.translationMatrix = container.worldTransform.toArray( true );\r\n\t\t\trenderer.shader.bind( shader, false );\r\n\t\t\trenderer.state!.setBlendMode(utils.correctBlendMode(BLEND_MODES.NORMAL, true));\r\n\t\t\tconst buffersLength = buffers.length;\r\n\t\t\tif( 1 < buffersLength ) {\r\n\t\t\t\tfor( let i = 0; i < buffersLength; ++i ) {\r\n\t\t\t\t\tbuffers[ i ].upload();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor( let i = 0; i < buffersLength; ++i ) {\r\n\t\t\t\tbuffers[ i ].render( shader );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tupdateBuffers(\r\n\t\tshapes: EShape[], buffers: EShapeBuffer[],\r\n\t\trenderer: Renderer, antialiasWeight: number\r\n\t): void {\r\n\t\tconst iterator = this._iterator;\r\n\t\titerator.reset( shapes );\r\n\r\n\t\tlet ib = 0;\r\n\t\tlet bufferSize = 0;\r\n\t\tconst bufferSizeBase = 5000;\r\n\t\tconst bufferSizeMax = this._bufferSizeMax;\r\n\t\twhile( iterator.get() != null ) {\r\n\t\t\tlet buffer: EShapeBuffer | null = null;\r\n\t\t\tlet noMoreThanOne = false;\r\n\t\t\tif( 0 < bufferSize ) {\r\n\t\t\t\tbuffer = new EShapeBuffer( bufferSize, renderer );\r\n\t\t\t\tbuffers.splice( ib, 0, buffer );\r\n\t\t\t\tnoMoreThanOne = true;\r\n\t\t\t} else if( ib < buffers.length ) {\r\n\t\t\t\tbuffer = buffers[ ib ];\r\n\t\t\t\tnoMoreThanOne = false;\r\n\t\t\t} else {\r\n\t\t\t\tbuffer = new EShapeBuffer( bufferSizeBase, renderer );\r\n\t\t\t\tbuffers.push( buffer );\r\n\t\t\t\tnoMoreThanOne = false;\r\n\t\t\t}\r\n\t\t\tif( buffer.update( iterator, antialiasWeight, noMoreThanOne ) ) {\r\n\t\t\t\tbufferSize = 0;\r\n\t\t\t\tib += 1;\r\n\t\t\t} else {\r\n\t\t\t\tbufferSize = buffer.indexCountRequested;\r\n\t\t\t\tif( bufferSize <= bufferSizeMax ) {\r\n\t\t\t\t\tbufferSize = Math.ceil( bufferSize / bufferSizeBase ) * bufferSizeBase;\r\n\t\t\t\t\tbufferSize = Math.min( bufferSize, bufferSizeMax );\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// No way to render\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif( ib < buffers.length ) {\r\n\t\t\tfor( let jb = ib, ibmax = buffers.length; jb < ibmax; ++jb ) {\r\n\t\t\t\tbuffers[ jb ].destroy();\r\n\t\t\t}\r\n\t\t\tbuffers.length = ib;\r\n\t\t}\r\n\t}\r\n}\r\n"]}